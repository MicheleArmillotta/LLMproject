[
  {
    "function_name": "dump_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2516-2690",
    "snippet": "void\ndump_config(ServerOptions *o)\n{\n\tchar *s;\n\tu_int i;\n\n\t/* these are usually at the top of the config */\n\tfor (i = 0; i < o->num_ports; i++)\n\t\tprintf(\"port %d\\n\", o->ports[i]);\n\tdump_cfg_fmtint(sAddressFamily, o->address_family);\n\n\tfor (i = 0; i < o->num_listen_addrs; i++) {\n\t\ts = format_listen_addrs(&o->listen_addrs[i]);\n\t\tprintf(\"%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* integer arguments */\n#ifdef USE_PAM\n\tdump_cfg_fmtint(sUsePAM, o->use_pam);\n#endif\n\tdump_cfg_int(sLoginGraceTime, o->login_grace_time);\n\tdump_cfg_int(sX11DisplayOffset, o->x11_display_offset);\n\tdump_cfg_int(sMaxAuthTries, o->max_authtries);\n\tdump_cfg_int(sMaxSessions, o->max_sessions);\n\tdump_cfg_int(sClientAliveInterval, o->client_alive_interval);\n\tdump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);\n\tdump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);\n\n\t/* formatted integer arguments */\n\tdump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);\n\tdump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);\n\tdump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);\n\tdump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,\n\t    o->hostbased_uses_name_from_packet_only);\n\tdump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);\n#ifdef KRB5\n\tdump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);\n\tdump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);\n\tdump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);\n# ifdef USE_AFS\n\tdump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);\n# endif\n#endif\n#ifdef GSSAPI\n\tdump_cfg_fmtint(sGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);\n#endif\n\tdump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(sKbdInteractiveAuthentication,\n\t    o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(sChallengeResponseAuthentication,\n\t    o->challenge_response_authentication);\n\tdump_cfg_fmtint(sPrintMotd, o->print_motd);\n#ifndef DISABLE_LASTLOG\n\tdump_cfg_fmtint(sPrintLastLog, o->print_lastlog);\n#endif\n\tdump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);\n\tdump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);\n\tdump_cfg_fmtint(sPermitTTY, o->permit_tty);\n\tdump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);\n\tdump_cfg_fmtint(sStrictModes, o->strict_modes);\n\tdump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);\n\tdump_cfg_fmtint(sCompression, o->compression);\n\tdump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);\n\tdump_cfg_fmtint(sUseDNS, o->use_dns);\n\tdump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);\n\tdump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);\n\tdump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);\n\tdump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);\n\tdump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);\n\n\t/* string arguments */\n\tdump_cfg_string(sPidFile, o->pid_file);\n\tdump_cfg_string(sXAuthLocation, o->xauth_location);\n\tdump_cfg_string(sCiphers, o->ciphers ? o->ciphers : KEX_SERVER_ENCRYPT);\n\tdump_cfg_string(sMacs, o->macs ? o->macs : KEX_SERVER_MAC);\n\tdump_cfg_string(sBanner, o->banner);\n\tdump_cfg_string(sForceCommand, o->adm_forced_command);\n\tdump_cfg_string(sChrootDirectory, o->chroot_directory);\n\tdump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);\n\tdump_cfg_string(sRevokedKeys, o->revoked_keys_file);\n\tdump_cfg_string(sAuthorizedPrincipalsFile,\n\t    o->authorized_principals_file);\n\tdump_cfg_string(sVersionAddendum, *o->version_addendum == '\\0'\n\t    ? \"none\" : o->version_addendum);\n\tdump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);\n\tdump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);\n\tdump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);\n\tdump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);\n\tdump_cfg_string(sHostKeyAgent, o->host_key_agent);\n\tdump_cfg_string(sKexAlgorithms,\n\t    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);\n\tdump_cfg_string(sCASignatureAlgorithms, o->ca_sign_algorithms ?\n\t    o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(sHostbasedAcceptedKeyTypes, o->hostbased_key_types ?\n\t    o->hostbased_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms ?\n\t    o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sPubkeyAcceptedKeyTypes, o->pubkey_key_types ?\n\t    o->pubkey_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sRDomain, o->routing_domain);\n\n\t/* string arguments requiring a lookup */\n\tdump_cfg_string(sLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(sLogFacility, log_facility_name(o->log_facility));\n\n\t/* string array arguments */\n\tdump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,\n\t    o->authorized_keys_files);\n\tdump_cfg_strarray(sHostKeyFile, o->num_host_key_files,\n\t     o->host_key_files);\n\tdump_cfg_strarray(sHostCertificate, o->num_host_cert_files,\n\t     o->host_cert_files);\n\tdump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);\n\tdump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);\n\tdump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);\n\tdump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);\n\tdump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);\n\tdump_cfg_strarray(sSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(sAuthenticationMethods,\n\t    o->num_auth_methods, o->auth_methods);\n\n\t/* other arguments */\n\tfor (i = 0; i < o->num_subsystems; i++)\n\t\tprintf(\"subsystem %s %s\\n\", o->subsystem_name[i],\n\t\t    o->subsystem_args[i]);\n\n\tprintf(\"maxstartups %d:%d:%d\\n\", o->max_startups_begin,\n\t    o->max_startups_rate, o->max_startups);\n\n\ts = NULL;\n\tfor (i = 0; tunmode_desc[i].val != -1; i++) {\n\t\tif (tunmode_desc[i].val == o->permit_tun) {\n\t\t\ts = tunmode_desc[i].text;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdump_cfg_string(sPermitTunnel, s);\n\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\tprintf(\"rekeylimit %llu %d\\n\", (unsigned long long)o->rekey_limit,\n\t    o->rekey_interval);\n\n\tprintf(\"permitopen\");\n\tif (o->num_permitted_opens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_opens; i++)\n\t\t\tprintf(\" %s\", o->permitted_opens[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"permitlisten\");\n\tif (o->num_permitted_listens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_listens; i++)\n\t\t\tprintf(\" %s\", o->permitted_listens[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (o->permit_user_env_whitelist == NULL) {\n\t\tdump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);\n\t} else {\n\t\tprintf(\"permituserenvironment %s\\n\",\n\t\t    o->permit_user_env_whitelist);\n\t}\n\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"permituserenvironment %s\\n\"",
            "o->permit_user_env_whitelist"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_fmtint",
          "args": [
            "sPermitUserEnvironment",
            "o->permit_user_env"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_fmtint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2440-2444",
          "snippet": "static void\ndump_cfg_fmtint(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_fmtint(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptos2str",
          "args": [
            "o->ip_qos_bulk"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "iptos2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1466-1478",
          "snippet": "const char *\niptos2str(int iptos)\n{\n\tint i;\n\tstatic char iptos_str[sizeof \"0xff\"];\n\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (ipqos[i].value == iptos)\n\t\t\treturn ipqos[i].name;\n\t}\n\tsnprintf(iptos_str, sizeof iptos_str, \"0x%02x\", iptos);\n\treturn iptos_str;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};\n\nconst char *\niptos2str(int iptos)\n{\n\tint i;\n\tstatic char iptos_str[sizeof \"0xff\"];\n\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (ipqos[i].value == iptos)\n\t\t\treturn ipqos[i].name;\n\t}\n\tsnprintf(iptos_str, sizeof iptos_str, \"0x%02x\", iptos);\n\treturn iptos_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_string",
          "args": [
            "sPermitTunnel",
            "s"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2446-2451",
          "snippet": "static void\ndump_cfg_string(ServerOpCodes code, const char *val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code),\n\t    val == NULL ? \"none\" : val);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_string(ServerOpCodes code, const char *val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code),\n\t    val == NULL ? \"none\" : val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_strarray_oneline",
          "args": [
            "sAuthenticationMethods",
            "o->num_auth_methods",
            "o->auth_methods"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_strarray_oneline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2462-2475",
          "snippet": "static void\ndump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tif (count <= 0 && code != sAuthenticationMethods)\n\t\treturn;\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tif (code == sAuthenticationMethods && count == 0)\n\t\tprintf(\" any\");\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tif (count <= 0 && code != sAuthenticationMethods)\n\t\treturn;\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tif (code == sAuthenticationMethods && count == 0)\n\t\tprintf(\" any\");\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_facility_name",
          "args": [
            "o->log_facility"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "log_facility_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "126-135",
          "snippet": "const char *\nlog_facility_name(SyslogFacility facility)\n{\n\tu_int i;\n\n\tfor (i = 0;  log_facilities[i].name; i++)\n\t\tif (log_facilities[i].val == facility)\n\t\t\treturn log_facilities[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};\n\nconst char *\nlog_facility_name(SyslogFacility facility)\n{\n\tu_int i;\n\n\tfor (i = 0;  log_facilities[i].name; i++)\n\t\tif (log_facilities[i].val == facility)\n\t\t\treturn log_facilities[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_name",
          "args": [
            "o->log_level"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "149-158",
          "snippet": "const char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nconst char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_oct",
          "args": [
            "sStreamLocalBindMask",
            "o->fwd_opts.streamlocal_bind_mask"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_oct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2434-2438",
          "snippet": "static void\ndump_cfg_oct(ServerOpCodes code, int val)\n{\n\tprintf(\"%s 0%o\\n\", lookup_opcode_name(code), val);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_oct(ServerOpCodes code, int val)\n{\n\tprintf(\"%s 0%o\\n\", lookup_opcode_name(code), val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_int",
          "args": [
            "sClientAliveCountMax",
            "o->client_alive_count_max"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2428-2432",
          "snippet": "static void\ndump_cfg_int(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_int(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_listen_addrs",
          "args": [
            "&o->listen_addrs[i]"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "format_listen_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2477-2514",
          "snippet": "static char *\nformat_listen_addrs(struct listenaddr *la)\n{\n\tint r;\n\tstruct addrinfo *ai;\n\tchar addr[NI_MAXHOST], port[NI_MAXSERV];\n\tchar *laddr1 = xstrdup(\"\"), *laddr2 = NULL;\n\n\t/*\n\t * ListenAddress must be after Port.  add_one_listen_addr pushes\n\t * addresses onto a stack, so to maintain ordering we need to\n\t * print these in reverse order.\n\t */\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif ((r = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,\n\t\t    sizeof(addr), port, sizeof(port),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo: %.100s\", ssh_gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tladdr2 = laddr1;\n\t\tif (ai->ai_family == AF_INET6) {\n\t\t\txasprintf(&laddr1, \"listenaddress [%s]:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t} else {\n\t\t\txasprintf(&laddr1, \"listenaddress %s:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t}\n\t\tfree(laddr2);\n\t}\n\treturn laddr1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nformat_listen_addrs(struct listenaddr *la)\n{\n\tint r;\n\tstruct addrinfo *ai;\n\tchar addr[NI_MAXHOST], port[NI_MAXSERV];\n\tchar *laddr1 = xstrdup(\"\"), *laddr2 = NULL;\n\n\t/*\n\t * ListenAddress must be after Port.  add_one_listen_addr pushes\n\t * addresses onto a stack, so to maintain ordering we need to\n\t * print these in reverse order.\n\t */\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif ((r = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,\n\t\t    sizeof(addr), port, sizeof(port),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo: %.100s\", ssh_gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tladdr2 = laddr1;\n\t\tif (ai->ai_family == AF_INET6) {\n\t\t\txasprintf(&laddr1, \"listenaddress [%s]:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t} else {\n\t\t\txasprintf(&laddr1, \"listenaddress %s:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t}\n\t\tfree(laddr2);\n\t}\n\treturn laddr1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\n\nvoid\ndump_config(ServerOptions *o)\n{\n\tchar *s;\n\tu_int i;\n\n\t/* these are usually at the top of the config */\n\tfor (i = 0; i < o->num_ports; i++)\n\t\tprintf(\"port %d\\n\", o->ports[i]);\n\tdump_cfg_fmtint(sAddressFamily, o->address_family);\n\n\tfor (i = 0; i < o->num_listen_addrs; i++) {\n\t\ts = format_listen_addrs(&o->listen_addrs[i]);\n\t\tprintf(\"%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* integer arguments */\n#ifdef USE_PAM\n\tdump_cfg_fmtint(sUsePAM, o->use_pam);\n#endif\n\tdump_cfg_int(sLoginGraceTime, o->login_grace_time);\n\tdump_cfg_int(sX11DisplayOffset, o->x11_display_offset);\n\tdump_cfg_int(sMaxAuthTries, o->max_authtries);\n\tdump_cfg_int(sMaxSessions, o->max_sessions);\n\tdump_cfg_int(sClientAliveInterval, o->client_alive_interval);\n\tdump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);\n\tdump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);\n\n\t/* formatted integer arguments */\n\tdump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);\n\tdump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);\n\tdump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);\n\tdump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,\n\t    o->hostbased_uses_name_from_packet_only);\n\tdump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);\n#ifdef KRB5\n\tdump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);\n\tdump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);\n\tdump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);\n# ifdef USE_AFS\n\tdump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);\n# endif\n#endif\n#ifdef GSSAPI\n\tdump_cfg_fmtint(sGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);\n#endif\n\tdump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(sKbdInteractiveAuthentication,\n\t    o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(sChallengeResponseAuthentication,\n\t    o->challenge_response_authentication);\n\tdump_cfg_fmtint(sPrintMotd, o->print_motd);\n#ifndef DISABLE_LASTLOG\n\tdump_cfg_fmtint(sPrintLastLog, o->print_lastlog);\n#endif\n\tdump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);\n\tdump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);\n\tdump_cfg_fmtint(sPermitTTY, o->permit_tty);\n\tdump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);\n\tdump_cfg_fmtint(sStrictModes, o->strict_modes);\n\tdump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);\n\tdump_cfg_fmtint(sCompression, o->compression);\n\tdump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);\n\tdump_cfg_fmtint(sUseDNS, o->use_dns);\n\tdump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);\n\tdump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);\n\tdump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);\n\tdump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);\n\tdump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);\n\n\t/* string arguments */\n\tdump_cfg_string(sPidFile, o->pid_file);\n\tdump_cfg_string(sXAuthLocation, o->xauth_location);\n\tdump_cfg_string(sCiphers, o->ciphers ? o->ciphers : KEX_SERVER_ENCRYPT);\n\tdump_cfg_string(sMacs, o->macs ? o->macs : KEX_SERVER_MAC);\n\tdump_cfg_string(sBanner, o->banner);\n\tdump_cfg_string(sForceCommand, o->adm_forced_command);\n\tdump_cfg_string(sChrootDirectory, o->chroot_directory);\n\tdump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);\n\tdump_cfg_string(sRevokedKeys, o->revoked_keys_file);\n\tdump_cfg_string(sAuthorizedPrincipalsFile,\n\t    o->authorized_principals_file);\n\tdump_cfg_string(sVersionAddendum, *o->version_addendum == '\\0'\n\t    ? \"none\" : o->version_addendum);\n\tdump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);\n\tdump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);\n\tdump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);\n\tdump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);\n\tdump_cfg_string(sHostKeyAgent, o->host_key_agent);\n\tdump_cfg_string(sKexAlgorithms,\n\t    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);\n\tdump_cfg_string(sCASignatureAlgorithms, o->ca_sign_algorithms ?\n\t    o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(sHostbasedAcceptedKeyTypes, o->hostbased_key_types ?\n\t    o->hostbased_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms ?\n\t    o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sPubkeyAcceptedKeyTypes, o->pubkey_key_types ?\n\t    o->pubkey_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sRDomain, o->routing_domain);\n\n\t/* string arguments requiring a lookup */\n\tdump_cfg_string(sLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(sLogFacility, log_facility_name(o->log_facility));\n\n\t/* string array arguments */\n\tdump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,\n\t    o->authorized_keys_files);\n\tdump_cfg_strarray(sHostKeyFile, o->num_host_key_files,\n\t     o->host_key_files);\n\tdump_cfg_strarray(sHostCertificate, o->num_host_cert_files,\n\t     o->host_cert_files);\n\tdump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);\n\tdump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);\n\tdump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);\n\tdump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);\n\tdump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);\n\tdump_cfg_strarray(sSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(sAuthenticationMethods,\n\t    o->num_auth_methods, o->auth_methods);\n\n\t/* other arguments */\n\tfor (i = 0; i < o->num_subsystems; i++)\n\t\tprintf(\"subsystem %s %s\\n\", o->subsystem_name[i],\n\t\t    o->subsystem_args[i]);\n\n\tprintf(\"maxstartups %d:%d:%d\\n\", o->max_startups_begin,\n\t    o->max_startups_rate, o->max_startups);\n\n\ts = NULL;\n\tfor (i = 0; tunmode_desc[i].val != -1; i++) {\n\t\tif (tunmode_desc[i].val == o->permit_tun) {\n\t\t\ts = tunmode_desc[i].text;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdump_cfg_string(sPermitTunnel, s);\n\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\tprintf(\"rekeylimit %llu %d\\n\", (unsigned long long)o->rekey_limit,\n\t    o->rekey_interval);\n\n\tprintf(\"permitopen\");\n\tif (o->num_permitted_opens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_opens; i++)\n\t\t\tprintf(\" %s\", o->permitted_opens[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"permitlisten\");\n\tif (o->num_permitted_listens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_listens; i++)\n\t\t\tprintf(\" %s\", o->permitted_listens[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (o->permit_user_env_whitelist == NULL) {\n\t\tdump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);\n\t} else {\n\t\tprintf(\"permituserenvironment %s\\n\",\n\t\t    o->permit_user_env_whitelist);\n\t}\n\n}"
  },
  {
    "function_name": "format_listen_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2477-2514",
    "snippet": "static char *\nformat_listen_addrs(struct listenaddr *la)\n{\n\tint r;\n\tstruct addrinfo *ai;\n\tchar addr[NI_MAXHOST], port[NI_MAXSERV];\n\tchar *laddr1 = xstrdup(\"\"), *laddr2 = NULL;\n\n\t/*\n\t * ListenAddress must be after Port.  add_one_listen_addr pushes\n\t * addresses onto a stack, so to maintain ordering we need to\n\t * print these in reverse order.\n\t */\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif ((r = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,\n\t\t    sizeof(addr), port, sizeof(port),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo: %.100s\", ssh_gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tladdr2 = laddr1;\n\t\tif (ai->ai_family == AF_INET6) {\n\t\t\txasprintf(&laddr1, \"listenaddress [%s]:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t} else {\n\t\t\txasprintf(&laddr1, \"listenaddress %s:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t}\n\t\tfree(laddr2);\n\t}\n\treturn laddr1;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "laddr2"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&laddr1",
            "\"listenaddress %s:%s%s%s\\n%s\"",
            "addr",
            "port",
            "la->rdomain == NULL ? \"\" : \" rdomain \"",
            "la->rdomain == NULL ? \"\" : la->rdomain",
            "laddr2"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"getnameinfo: %.100s\"",
            "ssh_gai_strerror(r)"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "r"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "addr",
            "sizeof(addr)",
            "port",
            "sizeof(port)",
            "NI_NUMERICHOST|NI_NUMERICSERV"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"\""
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nformat_listen_addrs(struct listenaddr *la)\n{\n\tint r;\n\tstruct addrinfo *ai;\n\tchar addr[NI_MAXHOST], port[NI_MAXSERV];\n\tchar *laddr1 = xstrdup(\"\"), *laddr2 = NULL;\n\n\t/*\n\t * ListenAddress must be after Port.  add_one_listen_addr pushes\n\t * addresses onto a stack, so to maintain ordering we need to\n\t * print these in reverse order.\n\t */\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif ((r = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,\n\t\t    sizeof(addr), port, sizeof(port),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo: %.100s\", ssh_gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tladdr2 = laddr1;\n\t\tif (ai->ai_family == AF_INET6) {\n\t\t\txasprintf(&laddr1, \"listenaddress [%s]:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t} else {\n\t\t\txasprintf(&laddr1, \"listenaddress %s:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t}\n\t\tfree(laddr2);\n\t}\n\treturn laddr1;\n}"
  },
  {
    "function_name": "dump_cfg_strarray_oneline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2462-2475",
    "snippet": "static void\ndump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tif (count <= 0 && code != sAuthenticationMethods)\n\t\treturn;\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tif (code == sAuthenticationMethods && count == 0)\n\t\tprintf(\" any\");\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %s\"",
            "vals[i]"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tif (count <= 0 && code != sAuthenticationMethods)\n\t\treturn;\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tif (code == sAuthenticationMethods && count == 0)\n\t\tprintf(\" any\");\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "dump_cfg_strarray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2453-2460",
    "snippet": "static void\ndump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "vals[i]"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}"
  },
  {
    "function_name": "dump_cfg_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2446-2451",
    "snippet": "static void\ndump_cfg_string(ServerOpCodes code, const char *val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code),\n\t    val == NULL ? \"none\" : val);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "val == NULL ? \"none\" : val"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_string(ServerOpCodes code, const char *val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code),\n\t    val == NULL ? \"none\" : val);\n}"
  },
  {
    "function_name": "dump_cfg_fmtint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2440-2444",
    "snippet": "static void\ndump_cfg_fmtint(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "fmt_intarg(code, val)"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_intarg",
          "args": [
            "code",
            "val"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_intarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2396-2426",
          "snippet": "static const char *\nfmt_intarg(ServerOpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase sAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase sPermitRootLogin:\n\t\treturn fmt_multistate_int(val, multistate_permitrootlogin);\n\tcase sGatewayPorts:\n\t\treturn fmt_multistate_int(val, multistate_gatewayports);\n\tcase sCompression:\n\t\treturn fmt_multistate_int(val, multistate_compression);\n\tcase sAllowTcpForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sAllowStreamLocalForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nstatic const char *\nfmt_intarg(ServerOpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase sAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase sPermitRootLogin:\n\t\treturn fmt_multistate_int(val, multistate_permitrootlogin);\n\tcase sGatewayPorts:\n\t\treturn fmt_multistate_int(val, multistate_gatewayports);\n\tcase sCompression:\n\t\treturn fmt_multistate_int(val, multistate_compression);\n\tcase sAllowTcpForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sAllowStreamLocalForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_fmtint(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}"
  },
  {
    "function_name": "dump_cfg_oct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2434-2438",
    "snippet": "static void\ndump_cfg_oct(ServerOpCodes code, int val)\n{\n\tprintf(\"%s 0%o\\n\", lookup_opcode_name(code), val);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s 0%o\\n\"",
            "lookup_opcode_name(code)",
            "val"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_oct(ServerOpCodes code, int val)\n{\n\tprintf(\"%s 0%o\\n\", lookup_opcode_name(code), val);\n}"
  },
  {
    "function_name": "dump_cfg_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2428-2432",
    "snippet": "static void\ndump_cfg_int(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d\\n\"",
            "lookup_opcode_name(code)",
            "val"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_int(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}"
  },
  {
    "function_name": "fmt_intarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2396-2426",
    "snippet": "static const char *\nfmt_intarg(ServerOpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase sAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase sPermitRootLogin:\n\t\treturn fmt_multistate_int(val, multistate_permitrootlogin);\n\tcase sGatewayPorts:\n\t\treturn fmt_multistate_int(val, multistate_gatewayports);\n\tcase sCompression:\n\t\treturn fmt_multistate_int(val, multistate_compression);\n\tcase sAllowTcpForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sAllowStreamLocalForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_digest_alg_name",
          "args": [
            "val"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "135-141",
          "snippet": "const char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_multistate_int",
          "args": [
            "val",
            "multistate_tcpfwd"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nstatic const char *\nfmt_intarg(ServerOpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase sAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase sPermitRootLogin:\n\t\treturn fmt_multistate_int(val, multistate_permitrootlogin);\n\tcase sGatewayPorts:\n\t\treturn fmt_multistate_int(val, multistate_gatewayports);\n\tcase sCompression:\n\t\treturn fmt_multistate_int(val, multistate_compression);\n\tcase sAllowTcpForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sAllowStreamLocalForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fmt_multistate_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2384-2394",
    "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
  },
  {
    "function_name": "parse_server_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2359-2382",
    "snippet": "void\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_queued_listen_addrs",
          "args": [
            "options"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "process_queued_listen_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "835-855",
          "snippet": "static void\nprocess_queued_listen_addrs(ServerOptions *options)\n{\n\tu_int i;\n\tstruct queued_listenaddr *qla;\n\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\n\tfor (i = 0; i < options->num_queued_listens; i++) {\n\t\tqla = &options->queued_listen_addrs[i];\n\t\tadd_listen_addr(options, qla->addr, qla->rdomain, qla->port);\n\t\tfree(qla->addr);\n\t\tfree(qla->rdomain);\n\t}\n\tfree(options->queued_listen_addrs);\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nprocess_queued_listen_addrs(ServerOptions *options)\n{\n\tu_int i;\n\tstruct queued_listenaddr *qla;\n\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\n\tfor (i = 0; i < options->num_queued_listens; i++) {\n\t\tqla = &options->queued_listen_addrs[i];\n\t\tadd_listen_addr(options, qla->addr, qla->rdomain, qla->port);\n\t\tfree(qla->addr);\n\t\tfree(qla->rdomain);\n\t}\n\tfree(options->queued_listen_addrs);\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: terminating, %d bad configuration options\"",
            "filename",
            "bad_options"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "obuf"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_server_config_line",
          "args": [
            "options",
            "cp",
            "filename",
            "linenum++",
            "&active",
            "connectinfo"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "process_server_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "1199-2171",
          "snippet": "int\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\r\\n\"",
            "#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */"
          ],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};",
            "static const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\nstatic const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nint\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&cbuf",
            "\"\\n\""
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_dup_string failed\"",
            "__func__"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dup_string",
          "args": [
            "conf"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dup_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "139-160",
          "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: config %s len %zu\"",
            "__func__",
            "filename",
            "sshbuf_len(conf)"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "conf"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}"
  },
  {
    "function_name": "copy_set_server_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2258-2353",
    "snippet": "void\ncopy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)\n{\n#define M_CP_INTOPT(n) do {\\\n\tif (src->n != -1) \\\n\t\tdst->n = src->n; \\\n} while (0)\n\n\tM_CP_INTOPT(password_authentication);\n\tM_CP_INTOPT(gss_authentication);\n\tM_CP_INTOPT(pubkey_authentication);\n\tM_CP_INTOPT(kerberos_authentication);\n\tM_CP_INTOPT(hostbased_authentication);\n\tM_CP_INTOPT(hostbased_uses_name_from_packet_only);\n\tM_CP_INTOPT(kbd_interactive_authentication);\n\tM_CP_INTOPT(permit_root_login);\n\tM_CP_INTOPT(permit_empty_passwd);\n\n\tM_CP_INTOPT(allow_tcp_forwarding);\n\tM_CP_INTOPT(allow_streamlocal_forwarding);\n\tM_CP_INTOPT(allow_agent_forwarding);\n\tM_CP_INTOPT(disable_forwarding);\n\tM_CP_INTOPT(expose_userauth_info);\n\tM_CP_INTOPT(permit_tun);\n\tM_CP_INTOPT(fwd_opts.gateway_ports);\n\tM_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);\n\tM_CP_INTOPT(x11_display_offset);\n\tM_CP_INTOPT(x11_forwarding);\n\tM_CP_INTOPT(x11_use_localhost);\n\tM_CP_INTOPT(permit_tty);\n\tM_CP_INTOPT(permit_user_rc);\n\tM_CP_INTOPT(max_sessions);\n\tM_CP_INTOPT(max_authtries);\n\tM_CP_INTOPT(client_alive_count_max);\n\tM_CP_INTOPT(client_alive_interval);\n\tM_CP_INTOPT(ip_qos_interactive);\n\tM_CP_INTOPT(ip_qos_bulk);\n\tM_CP_INTOPT(rekey_limit);\n\tM_CP_INTOPT(rekey_interval);\n\tM_CP_INTOPT(log_level);\n\n\t/*\n\t * The bind_mask is a mode_t that may be unsigned, so we can't use\n\t * M_CP_INTOPT - it does a signed comparison that causes compiler\n\t * warnings.\n\t */\n\tif (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {\n\t\tdst->fwd_opts.streamlocal_bind_mask =\n\t\t    src->fwd_opts.streamlocal_bind_mask;\n\t}\n\n\t/* M_CP_STROPT and M_CP_STRARRAYOPT should not appear before here */\n#define M_CP_STROPT(n) do {\\\n\tif (src->n != NULL && dst->n != src->n) { \\\n\t\tfree(dst->n); \\\n\t\tdst->n = src->n; \\\n\t} \\\n} while(0)\n#define M_CP_STRARRAYOPT(s, num_s) do {\\\n\tu_int i; \\\n\tif (src->num_s != 0) { \\\n\t\tfor (i = 0; i < dst->num_s; i++) \\\n\t\t\tfree(dst->s[i]); \\\n\t\tfree(dst->s); \\\n\t\tdst->s = xcalloc(src->num_s, sizeof(*dst->s)); \\\n\t\tfor (i = 0; i < src->num_s; i++) \\\n\t\t\tdst->s[i] = xstrdup(src->s[i]); \\\n\t\tdst->num_s = src->num_s; \\\n\t} \\\n} while(0)\n\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n\n\t/* Arguments that accept '+...' need to be expanded */\n\tassemble_algorithms(dst);\n\n\t/*\n\t * The only things that should be below this point are string options\n\t * which are only used after authentication.\n\t */\n\tif (preauth)\n\t\treturn;\n\n\t/* These options may be \"none\" to clear a global setting */\n\tM_CP_STROPT(adm_forced_command);\n\tif (option_clear_or_none(dst->adm_forced_command)) {\n\t\tfree(dst->adm_forced_command);\n\t\tdst->adm_forced_command = NULL;\n\t}\n\tM_CP_STROPT(chroot_directory);\n\tif (option_clear_or_none(dst->chroot_directory)) {\n\t\tfree(dst->chroot_directory);\n\t\tdst->chroot_directory = NULL;\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dst->chroot_directory"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "option_clear_or_none",
          "args": [
            "dst->chroot_directory"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "option_clear_or_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "186-190",
          "snippet": "static int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_CP_STROPT",
          "args": [
            "chroot_directory"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_STROPT",
          "args": [
            "adm_forced_command"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assemble_algorithms",
          "args": [
            "dst"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "assemble_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "192-221",
          "snippet": "static void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPY_MATCH_STRING_OPTS",
          "args": [],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "log_level"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "rekey_interval"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "rekey_limit"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "ip_qos_bulk"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "ip_qos_interactive"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "client_alive_interval"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "client_alive_count_max"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "max_authtries"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "max_sessions"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "permit_user_rc"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "permit_tty"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "x11_use_localhost"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "x11_forwarding"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "x11_display_offset"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "fwd_opts.streamlocal_bind_unlink"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "fwd_opts.gateway_ports"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "permit_tun"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "expose_userauth_info"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "disable_forwarding"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "allow_agent_forwarding"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "allow_streamlocal_forwarding"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "allow_tcp_forwarding"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "permit_empty_passwd"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "permit_root_login"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "kbd_interactive_authentication"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "hostbased_uses_name_from_packet_only"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "hostbased_authentication"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "kerberos_authentication"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "pubkey_authentication"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "gss_authentication"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_CP_INTOPT",
          "args": [
            "password_authentication"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\ncopy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)\n{\n#define M_CP_INTOPT(n) do {\\\n\tif (src->n != -1) \\\n\t\tdst->n = src->n; \\\n} while (0)\n\n\tM_CP_INTOPT(password_authentication);\n\tM_CP_INTOPT(gss_authentication);\n\tM_CP_INTOPT(pubkey_authentication);\n\tM_CP_INTOPT(kerberos_authentication);\n\tM_CP_INTOPT(hostbased_authentication);\n\tM_CP_INTOPT(hostbased_uses_name_from_packet_only);\n\tM_CP_INTOPT(kbd_interactive_authentication);\n\tM_CP_INTOPT(permit_root_login);\n\tM_CP_INTOPT(permit_empty_passwd);\n\n\tM_CP_INTOPT(allow_tcp_forwarding);\n\tM_CP_INTOPT(allow_streamlocal_forwarding);\n\tM_CP_INTOPT(allow_agent_forwarding);\n\tM_CP_INTOPT(disable_forwarding);\n\tM_CP_INTOPT(expose_userauth_info);\n\tM_CP_INTOPT(permit_tun);\n\tM_CP_INTOPT(fwd_opts.gateway_ports);\n\tM_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);\n\tM_CP_INTOPT(x11_display_offset);\n\tM_CP_INTOPT(x11_forwarding);\n\tM_CP_INTOPT(x11_use_localhost);\n\tM_CP_INTOPT(permit_tty);\n\tM_CP_INTOPT(permit_user_rc);\n\tM_CP_INTOPT(max_sessions);\n\tM_CP_INTOPT(max_authtries);\n\tM_CP_INTOPT(client_alive_count_max);\n\tM_CP_INTOPT(client_alive_interval);\n\tM_CP_INTOPT(ip_qos_interactive);\n\tM_CP_INTOPT(ip_qos_bulk);\n\tM_CP_INTOPT(rekey_limit);\n\tM_CP_INTOPT(rekey_interval);\n\tM_CP_INTOPT(log_level);\n\n\t/*\n\t * The bind_mask is a mode_t that may be unsigned, so we can't use\n\t * M_CP_INTOPT - it does a signed comparison that causes compiler\n\t * warnings.\n\t */\n\tif (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {\n\t\tdst->fwd_opts.streamlocal_bind_mask =\n\t\t    src->fwd_opts.streamlocal_bind_mask;\n\t}\n\n\t/* M_CP_STROPT and M_CP_STRARRAYOPT should not appear before here */\n#define M_CP_STROPT(n) do {\\\n\tif (src->n != NULL && dst->n != src->n) { \\\n\t\tfree(dst->n); \\\n\t\tdst->n = src->n; \\\n\t} \\\n} while(0)\n#define M_CP_STRARRAYOPT(s, num_s) do {\\\n\tu_int i; \\\n\tif (src->num_s != 0) { \\\n\t\tfor (i = 0; i < dst->num_s; i++) \\\n\t\t\tfree(dst->s[i]); \\\n\t\tfree(dst->s); \\\n\t\tdst->s = xcalloc(src->num_s, sizeof(*dst->s)); \\\n\t\tfor (i = 0; i < src->num_s; i++) \\\n\t\t\tdst->s[i] = xstrdup(src->s[i]); \\\n\t\tdst->num_s = src->num_s; \\\n\t} \\\n} while(0)\n\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n\n\t/* Arguments that accept '+...' need to be expanded */\n\tassemble_algorithms(dst);\n\n\t/*\n\t * The only things that should be below this point are string options\n\t * which are only used after authentication.\n\t */\n\tif (preauth)\n\t\treturn;\n\n\t/* These options may be \"none\" to clear a global setting */\n\tM_CP_STROPT(adm_forced_command);\n\tif (option_clear_or_none(dst->adm_forced_command)) {\n\t\tfree(dst->adm_forced_command);\n\t\tdst->adm_forced_command = NULL;\n\t}\n\tM_CP_STROPT(chroot_directory);\n\tif (option_clear_or_none(dst->chroot_directory)) {\n\t\tfree(dst->chroot_directory);\n\t\tdst->chroot_directory = NULL;\n\t}\n}"
  },
  {
    "function_name": "parse_server_match_testspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2220-2249",
    "snippet": "int parse_server_match_testspec(struct connection_info *ci, char *spec)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&spec, \",\")) && *p != '\\0') {\n\t\tif (strncmp(p, \"addr=\", 5) == 0) {\n\t\t\tci->address = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"host=\", 5) == 0) {\n\t\t\tci->host = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"user=\", 5) == 0) {\n\t\t\tci->user = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"laddr=\", 6) == 0) {\n\t\t\tci->laddress = xstrdup(p + 6);\n\t\t} else if (strncmp(p, \"rdomain=\", 8) == 0) {\n\t\t\tci->rdomain = xstrdup(p + 8);\n\t\t} else if (strncmp(p, \"lport=\", 6) == 0) {\n\t\t\tci->lport = a2port(p + 6);\n\t\t\tif (ci->lport == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid port '%s' in test mode\"\n\t\t\t\t   \" specification %s\\n\", p+6, p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid test mode specification %s\\n\",\n\t\t\t   p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid test mode specification %s\\n\"",
            "p"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid port '%s' in test mode\"\n\t\t\t\t   \" specification %s\\n\"",
            "p+6",
            "p"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "p + 6"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"lport=\"",
            "6"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "p + 8"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&spec",
            "\",\""
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint parse_server_match_testspec(struct connection_info *ci, char *spec)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&spec, \",\")) && *p != '\\0') {\n\t\tif (strncmp(p, \"addr=\", 5) == 0) {\n\t\t\tci->address = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"host=\", 5) == 0) {\n\t\t\tci->host = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"user=\", 5) == 0) {\n\t\t\tci->user = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"laddr=\", 6) == 0) {\n\t\t\tci->laddress = xstrdup(p + 6);\n\t\t} else if (strncmp(p, \"rdomain=\", 8) == 0) {\n\t\t\tci->rdomain = xstrdup(p + 8);\n\t\t} else if (strncmp(p, \"lport=\", 6) == 0) {\n\t\t\tci->lport = a2port(p + 6);\n\t\t\tif (ci->lport == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid port '%s' in test mode\"\n\t\t\t\t   \" specification %s\\n\", p+6, p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid test mode specification %s\\n\",\n\t\t\t   p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_server_match_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2209-2218",
    "snippet": "void\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "extern struct sshbuf *cfg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_set_server_options",
          "args": [
            "options",
            "&mo",
            "0"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "copy_set_server_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2258-2353",
          "snippet": "void\ncopy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)\n{\n#define M_CP_INTOPT(n) do {\\\n\tif (src->n != -1) \\\n\t\tdst->n = src->n; \\\n} while (0)\n\n\tM_CP_INTOPT(password_authentication);\n\tM_CP_INTOPT(gss_authentication);\n\tM_CP_INTOPT(pubkey_authentication);\n\tM_CP_INTOPT(kerberos_authentication);\n\tM_CP_INTOPT(hostbased_authentication);\n\tM_CP_INTOPT(hostbased_uses_name_from_packet_only);\n\tM_CP_INTOPT(kbd_interactive_authentication);\n\tM_CP_INTOPT(permit_root_login);\n\tM_CP_INTOPT(permit_empty_passwd);\n\n\tM_CP_INTOPT(allow_tcp_forwarding);\n\tM_CP_INTOPT(allow_streamlocal_forwarding);\n\tM_CP_INTOPT(allow_agent_forwarding);\n\tM_CP_INTOPT(disable_forwarding);\n\tM_CP_INTOPT(expose_userauth_info);\n\tM_CP_INTOPT(permit_tun);\n\tM_CP_INTOPT(fwd_opts.gateway_ports);\n\tM_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);\n\tM_CP_INTOPT(x11_display_offset);\n\tM_CP_INTOPT(x11_forwarding);\n\tM_CP_INTOPT(x11_use_localhost);\n\tM_CP_INTOPT(permit_tty);\n\tM_CP_INTOPT(permit_user_rc);\n\tM_CP_INTOPT(max_sessions);\n\tM_CP_INTOPT(max_authtries);\n\tM_CP_INTOPT(client_alive_count_max);\n\tM_CP_INTOPT(client_alive_interval);\n\tM_CP_INTOPT(ip_qos_interactive);\n\tM_CP_INTOPT(ip_qos_bulk);\n\tM_CP_INTOPT(rekey_limit);\n\tM_CP_INTOPT(rekey_interval);\n\tM_CP_INTOPT(log_level);\n\n\t/*\n\t * The bind_mask is a mode_t that may be unsigned, so we can't use\n\t * M_CP_INTOPT - it does a signed comparison that causes compiler\n\t * warnings.\n\t */\n\tif (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {\n\t\tdst->fwd_opts.streamlocal_bind_mask =\n\t\t    src->fwd_opts.streamlocal_bind_mask;\n\t}\n\n\t/* M_CP_STROPT and M_CP_STRARRAYOPT should not appear before here */\n#define M_CP_STROPT(n) do {\\\n\tif (src->n != NULL && dst->n != src->n) { \\\n\t\tfree(dst->n); \\\n\t\tdst->n = src->n; \\\n\t} \\\n} while(0)\n#define M_CP_STRARRAYOPT(s, num_s) do {\\\n\tu_int i; \\\n\tif (src->num_s != 0) { \\\n\t\tfor (i = 0; i < dst->num_s; i++) \\\n\t\t\tfree(dst->s[i]); \\\n\t\tfree(dst->s); \\\n\t\tdst->s = xcalloc(src->num_s, sizeof(*dst->s)); \\\n\t\tfor (i = 0; i < src->num_s; i++) \\\n\t\t\tdst->s[i] = xstrdup(src->s[i]); \\\n\t\tdst->num_s = src->num_s; \\\n\t} \\\n} while(0)\n\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n\n\t/* Arguments that accept '+...' need to be expanded */\n\tassemble_algorithms(dst);\n\n\t/*\n\t * The only things that should be below this point are string options\n\t * which are only used after authentication.\n\t */\n\tif (preauth)\n\t\treturn;\n\n\t/* These options may be \"none\" to clear a global setting */\n\tM_CP_STROPT(adm_forced_command);\n\tif (option_clear_or_none(dst->adm_forced_command)) {\n\t\tfree(dst->adm_forced_command);\n\t\tdst->adm_forced_command = NULL;\n\t}\n\tM_CP_STROPT(chroot_directory);\n\tif (option_clear_or_none(dst->chroot_directory)) {\n\t\tfree(dst->chroot_directory);\n\t\tdst->chroot_directory = NULL;\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\ncopy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)\n{\n#define M_CP_INTOPT(n) do {\\\n\tif (src->n != -1) \\\n\t\tdst->n = src->n; \\\n} while (0)\n\n\tM_CP_INTOPT(password_authentication);\n\tM_CP_INTOPT(gss_authentication);\n\tM_CP_INTOPT(pubkey_authentication);\n\tM_CP_INTOPT(kerberos_authentication);\n\tM_CP_INTOPT(hostbased_authentication);\n\tM_CP_INTOPT(hostbased_uses_name_from_packet_only);\n\tM_CP_INTOPT(kbd_interactive_authentication);\n\tM_CP_INTOPT(permit_root_login);\n\tM_CP_INTOPT(permit_empty_passwd);\n\n\tM_CP_INTOPT(allow_tcp_forwarding);\n\tM_CP_INTOPT(allow_streamlocal_forwarding);\n\tM_CP_INTOPT(allow_agent_forwarding);\n\tM_CP_INTOPT(disable_forwarding);\n\tM_CP_INTOPT(expose_userauth_info);\n\tM_CP_INTOPT(permit_tun);\n\tM_CP_INTOPT(fwd_opts.gateway_ports);\n\tM_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);\n\tM_CP_INTOPT(x11_display_offset);\n\tM_CP_INTOPT(x11_forwarding);\n\tM_CP_INTOPT(x11_use_localhost);\n\tM_CP_INTOPT(permit_tty);\n\tM_CP_INTOPT(permit_user_rc);\n\tM_CP_INTOPT(max_sessions);\n\tM_CP_INTOPT(max_authtries);\n\tM_CP_INTOPT(client_alive_count_max);\n\tM_CP_INTOPT(client_alive_interval);\n\tM_CP_INTOPT(ip_qos_interactive);\n\tM_CP_INTOPT(ip_qos_bulk);\n\tM_CP_INTOPT(rekey_limit);\n\tM_CP_INTOPT(rekey_interval);\n\tM_CP_INTOPT(log_level);\n\n\t/*\n\t * The bind_mask is a mode_t that may be unsigned, so we can't use\n\t * M_CP_INTOPT - it does a signed comparison that causes compiler\n\t * warnings.\n\t */\n\tif (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {\n\t\tdst->fwd_opts.streamlocal_bind_mask =\n\t\t    src->fwd_opts.streamlocal_bind_mask;\n\t}\n\n\t/* M_CP_STROPT and M_CP_STRARRAYOPT should not appear before here */\n#define M_CP_STROPT(n) do {\\\n\tif (src->n != NULL && dst->n != src->n) { \\\n\t\tfree(dst->n); \\\n\t\tdst->n = src->n; \\\n\t} \\\n} while(0)\n#define M_CP_STRARRAYOPT(s, num_s) do {\\\n\tu_int i; \\\n\tif (src->num_s != 0) { \\\n\t\tfor (i = 0; i < dst->num_s; i++) \\\n\t\t\tfree(dst->s[i]); \\\n\t\tfree(dst->s); \\\n\t\tdst->s = xcalloc(src->num_s, sizeof(*dst->s)); \\\n\t\tfor (i = 0; i < src->num_s; i++) \\\n\t\t\tdst->s[i] = xstrdup(src->s[i]); \\\n\t\tdst->num_s = src->num_s; \\\n\t} \\\n} while(0)\n\n\t/* See comment in servconf.h */\n\tCOPY_MATCH_STRING_OPTS();\n\n\t/* Arguments that accept '+...' need to be expanded */\n\tassemble_algorithms(dst);\n\n\t/*\n\t * The only things that should be below this point are string options\n\t * which are only used after authentication.\n\t */\n\tif (preauth)\n\t\treturn;\n\n\t/* These options may be \"none\" to clear a global setting */\n\tM_CP_STROPT(adm_forced_command);\n\tif (option_clear_or_none(dst->adm_forced_command)) {\n\t\tfree(dst->adm_forced_command);\n\t\tdst->adm_forced_command = NULL;\n\t}\n\tM_CP_STROPT(chroot_directory);\n\tif (option_clear_or_none(dst->chroot_directory)) {\n\t\tfree(dst->chroot_directory);\n\t\tdst->chroot_directory = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_config",
          "args": [
            "&mo",
            "\"reprocess config\"",
            "cfg",
            "connectinfo"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2359-2382",
          "snippet": "void\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_server_options",
          "args": [
            "&mo"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_server_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "79-183",
          "snippet": "void\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nextern struct sshbuf *cfg;\n\nvoid\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}"
  },
  {
    "function_name": "load_server_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "2175-2207",
    "snippet": "void\nload_server_config(const char *filename, struct sshbuf *conf)\n{\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tFILE *f;\n\tint r, lineno = 0;\n\n\tdebug2(\"%s: filename %s\", __func__, filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tsshbuf_reset(conf);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlineno++;\n\t\t/*\n\t\t * Trim out comments and strip whitespace\n\t\t * NB - preserve newlines, they are needed to reproduce\n\t\t * line numbers later for error messages\n\t\t */\n\t\tif ((cp = strchr(line, '#')) != NULL)\n\t\t\tmemcpy(cp, \"\\n\", 2);\n\t\tcp = line + strspn(line, \" \\t\\r\");\n\t\tif ((r = sshbuf_put(conf, cp, strlen(cp))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tfree(line);\n\tif ((r = sshbuf_put_u8(conf, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfclose(f);\n\tdebug2(\"%s: done config len = %zu\", __func__, sshbuf_len(conf));\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: done config len = %zu\"",
            "__func__",
            "sshbuf_len(conf)"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "conf"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "conf",
            "0"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "conf",
            "cp",
            "strlen(cp)"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "line",
            "\" \\t\\r\""
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp",
            "\"\\n\"",
            "2"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'#'"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "conf"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "filename"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nload_server_config(const char *filename, struct sshbuf *conf)\n{\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tFILE *f;\n\tint r, lineno = 0;\n\n\tdebug2(\"%s: filename %s\", __func__, filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tsshbuf_reset(conf);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlineno++;\n\t\t/*\n\t\t * Trim out comments and strip whitespace\n\t\t * NB - preserve newlines, they are needed to reproduce\n\t\t * line numbers later for error messages\n\t\t */\n\t\tif ((cp = strchr(line, '#')) != NULL)\n\t\t\tmemcpy(cp, \"\\n\", 2);\n\t\tcp = line + strspn(line, \" \\t\\r\");\n\t\tif ((r = sshbuf_put(conf, cp, strlen(cp))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tfree(line);\n\tif ((r = sshbuf_put_u8(conf, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfclose(f);\n\tdebug2(\"%s: done config len = %zu\", __func__, sshbuf_len(conf));\n}"
  },
  {
    "function_name": "process_server_config_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "1199-2171",
    "snippet": "int\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define WHITESPACE \" \\t\\r\\n\"",
      "#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */"
    ],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};",
      "static const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s line %d: garbage at end of line; \\\"%.200s\\\".\"",
            "filename",
            "linenum",
            "arg"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdelim",
          "args": [
            "&cp"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "strdelimw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "296-300",
          "snippet": "char *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO",
            "\"%s line %d: %s option %s\"",
            "filename",
            "linenum",
            "opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\"",
            "arg"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "arg"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_rdomain",
          "args": [
            "arg"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "valid_rdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "777-810",
          "snippet": "static int\nvalid_rdomain(const char *name)\n{\n#if defined(HAVE_SYS_VALID_RDOMAIN)\n\treturn sys_valid_rdomain(name);\n#elif defined(__OpenBSD__)\n\tconst char *errstr;\n\tlong long num;\n\tstruct rt_tableinfo info;\n\tint mib[6];\n\tsize_t miblen = sizeof(mib);\n\n\tif (name == NULL)\n\t\treturn 1;\n\n\tnum = strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)\n\t\treturn 0;\n\n\t/* Check whether the table actually exists */\n\tmemset(mib, 0, sizeof(mib));\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_ROUTE;\n\tmib[4] = NET_RT_TABLE;\n\tmib[5] = (int)num;\n\tif (sysctl(mib, 6, &info, &miblen, NULL, 0) == -1)\n\t\treturn 0;\n\n\treturn 1;\n#else /* defined(__OpenBSD__) */\n\terror(\"Routing domains are not supported on this platform\");\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nvalid_rdomain(const char *name)\n{\n#if defined(HAVE_SYS_VALID_RDOMAIN)\n\treturn sys_valid_rdomain(name);\n#elif defined(__OpenBSD__)\n\tconst char *errstr;\n\tlong long num;\n\tstruct rt_tableinfo info;\n\tint mib[6];\n\tsize_t miblen = sizeof(mib);\n\n\tif (name == NULL)\n\t\treturn 1;\n\n\tnum = strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)\n\t\treturn 0;\n\n\t/* Check whether the table actually exists */\n\tmemset(mib, 0, sizeof(mib));\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_ROUTE;\n\tmib[4] = NET_RT_TABLE;\n\tmib[5] = (int)num;\n\tif (sysctl(mib, 6, &info, &miblen, NULL, 0) == -1)\n\t\treturn 0;\n\n\treturn 1;\n#else /* defined(__OpenBSD__) */\n\terror(\"Routing domains are not supported on this platform\");\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"%D\""
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "arg",
            "\"none\""
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_digest_alg_by_name",
          "args": [
            "arg"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "123-133",
          "snippet": "int\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "arg",
            "&p",
            "8"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_append",
          "args": [
            "filename",
            "linenum",
            "\"AuthenticationMethods\"",
            "&options->auth_methods",
            "&options->num_auth_methods",
            "arg"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "array_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "223-234",
          "snippet": "static void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_methods_valid",
          "args": [
            "arg",
            "0"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_methods_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "507-547",
          "snippet": "int\nauth2_methods_valid(const char *_methods, int need_enable)\n{\n\tchar *methods, *omethods, *method, *p;\n\tu_int i, found;\n\tint ret = -1;\n\n\tif (*_methods == '\\0') {\n\t\terror(\"empty authentication method list\");\n\t\treturn -1;\n\t}\n\tomethods = methods = xstrdup(_methods);\n\twhile ((method = strsep(&methods, \",\")) != NULL) {\n\t\tfor (found = i = 0; !found && authmethods[i] != NULL; i++) {\n\t\t\tif ((p = strchr(method, ':')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t\tif (strcmp(method, authmethods[i]->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (need_enable) {\n\t\t\t\tif (authmethods[i]->enabled == NULL ||\n\t\t\t\t    *(authmethods[i]->enabled) == 0) {\n\t\t\t\t\terror(\"Disabled method \\\"%s\\\" in \"\n\t\t\t\t\t    \"AuthenticationMethods list \\\"%s\\\"\",\n\t\t\t\t\t    method, _methods);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\terror(\"Unknown authentication method \\\"%s\\\" in list\",\n\t\t\t    method);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(omethods);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Authmethod *authmethods[] = {\n\t&method_none,\n\t&method_pubkey,\n#ifdef GSSAPI\n\t&method_gssapi,\n#endif\n\t&method_passwd,\n\t&method_kbdint,\n\t&method_hostbased,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAuthmethod *authmethods[] = {\n\t&method_none,\n\t&method_pubkey,\n#ifdef GSSAPI\n\t&method_gssapi,\n#endif\n\t&method_passwd,\n\t&method_kbdint,\n\t&method_hostbased,\n\tNULL\n};\n\nint\nauth2_methods_valid(const char *_methods, int need_enable)\n{\n\tchar *methods, *omethods, *method, *p;\n\tu_int i, found;\n\tint ret = -1;\n\n\tif (*_methods == '\\0') {\n\t\terror(\"empty authentication method list\");\n\t\treturn -1;\n\t}\n\tomethods = methods = xstrdup(_methods);\n\twhile ((method = strsep(&methods, \",\")) != NULL) {\n\t\tfor (found = i = 0; !found && authmethods[i] != NULL; i++) {\n\t\t\tif ((p = strchr(method, ':')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t\tif (strcmp(method, authmethods[i]->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (need_enable) {\n\t\t\t\tif (authmethods[i]->enabled == NULL ||\n\t\t\t\t    *(authmethods[i]->enabled) == 0) {\n\t\t\t\t\terror(\"Disabled method \\\"%s\\\" in \"\n\t\t\t\t\t    \"AuthenticationMethods list \\\"%s\\\"\",\n\t\t\t\t\t    method, _methods);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\terror(\"Unknown authentication method \\\"%s\\\" in list\",\n\t\t\t    method);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(omethods);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "cp + len",
            "\"none\""
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "cp + len",
            "\"none\""
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp + len",
            "'\\r'"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "cp + len",
            "\"none\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_ipqos",
          "args": [
            "arg"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ipqos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1446-1464",
          "snippet": "int\nparse_ipqos(const char *cp)\n{\n\tu_int i;\n\tchar *ep;\n\tlong val;\n\n\tif (cp == NULL)\n\t\treturn -1;\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (strcasecmp(cp, ipqos[i].name) == 0)\n\t\t\treturn ipqos[i].value;\n\t}\n\t/* Try parsing as an integer */\n\tval = strtol(cp, &ep, 0);\n\tif (*cp == '\\0' || *ep != '\\0' || val < 0 || val > 255)\n\t\treturn -1;\n\treturn val;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};\n\nint\nparse_ipqos(const char *cp)\n{\n\tu_int i;\n\tchar *ep;\n\tlong val;\n\n\tif (cp == NULL)\n\t\treturn -1;\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (strcasecmp(cp, ipqos[i].name) == 0)\n\t\t\treturn ipqos[i].value;\n\t}\n\t/* Try parsing as an integer */\n\tval = strtol(cp, &ep, 0);\n\tif (*cp == '\\0' || *ep != '\\0' || val < 0 || val > 255)\n\t\treturn -1;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "WHITESPACE"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arg2"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "opcode"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "permitopen_port",
          "args": [
            "arg"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "permitopen_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4124-4134",
          "snippet": "int\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nint\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanhostname",
          "args": [
            "p"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "cleanhostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "535-543",
          "snippet": "char *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpdelim",
          "args": [
            "&arg"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "hpdelim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "529-533",
          "snippet": "char *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&arg2",
            "\"*:%s\"",
            "arg"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(**chararrayptr)"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_cfg_line",
          "args": [
            "&cp",
            "linenum",
            "connectinfo"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "match_cfg_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "1000-1150",
          "snippet": "static int\nmatch_cfg_line(char **condition, int line, struct connection_info *ci)\n{\n\tint result = 1, attributes = 0, port;\n\tchar *arg, *attrib, *cp = *condition;\n\n\tif (ci == NULL)\n\t\tdebug3(\"checking syntax for 'Match %s'\", cp);\n\telse\n\t\tdebug3(\"checking match for '%s' user %s host %s addr %s \"\n\t\t    \"laddr %s lport %d\", cp, ci->user ? ci->user : \"(null)\",\n\t\t    ci->host ? ci->host : \"(null)\",\n\t\t    ci->address ? ci->address : \"(null)\",\n\t\t    ci->laddress ? ci->laddress : \"(null)\", ci->lport);\n\n\twhile ((attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes != 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"'all' cannot be combined with other \"\n\t\t\t\t    \"Match attributes\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*condition = cp;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"User\", \"user\");\n\t\t\tif (match_pattern_list(ci->user, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'User %.100s' at \"\n\t\t\t\t    \"line %d\", ci->user, arg, line);\n\t\t} else if (strcasecmp(attrib, \"group\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Group\", \"user\");\n\t\t\tswitch (match_cfg_line_group(arg, line, ci->user)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->host == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Host\", \"host\");\n\t\t\tif (match_hostname(ci->host, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"connection from %.100s matched 'Host \"\n\t\t\t\t    \"%.100s' at line %d\", ci->host, arg, line);\n\t\t} else if (strcasecmp(attrib, \"address\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->address == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Address\", \"addr\");\n\t\t\tswitch (addr_match_list(ci->address, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched 'Address \"\n\t\t\t\t    \"%.100s' at line %d\", ci->address, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localaddress\") == 0){\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->laddress == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"LocalAddress\",\n\t\t\t\t    \"laddr\");\n\t\t\tswitch (addr_match_list(ci->laddress, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalAddress %.100s' at line %d\",\n\t\t\t\t    ci->laddress, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localport\") == 0) {\n\t\t\tif ((port = a2port(arg)) == -1) {\n\t\t\t\terror(\"Invalid LocalPort '%s' on Match line\",\n\t\t\t\t    arg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->lport == 0)\n\t\t\t\tmatch_test_missing_fatal(\"LocalPort\", \"lport\");\n\t\t\t/* TODO support port lists */\n\t\t\tif (port == ci->lport)\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalPort %d' at line %d\",\n\t\t\t\t    ci->laddress, port, line);\n\t\t\telse\n\t\t\t\tresult = 0;\n\t\t} else if (strcasecmp(attrib, \"rdomain\") == 0) {\n\t\t\tif (ci == NULL || ci->rdomain == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match_pattern_list(ci->rdomain, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'RDomain %.100s' at \"\n\t\t\t\t    \"line %d\", ci->rdomain, arg, line);\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\treturn -1;\n\t}\n\tif (ci != NULL)\n\t\tdebug3(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\treturn result;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line(char **condition, int line, struct connection_info *ci)\n{\n\tint result = 1, attributes = 0, port;\n\tchar *arg, *attrib, *cp = *condition;\n\n\tif (ci == NULL)\n\t\tdebug3(\"checking syntax for 'Match %s'\", cp);\n\telse\n\t\tdebug3(\"checking match for '%s' user %s host %s addr %s \"\n\t\t    \"laddr %s lport %d\", cp, ci->user ? ci->user : \"(null)\",\n\t\t    ci->host ? ci->host : \"(null)\",\n\t\t    ci->address ? ci->address : \"(null)\",\n\t\t    ci->laddress ? ci->laddress : \"(null)\", ci->lport);\n\n\twhile ((attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes != 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"'all' cannot be combined with other \"\n\t\t\t\t    \"Match attributes\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*condition = cp;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"User\", \"user\");\n\t\t\tif (match_pattern_list(ci->user, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'User %.100s' at \"\n\t\t\t\t    \"line %d\", ci->user, arg, line);\n\t\t} else if (strcasecmp(attrib, \"group\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Group\", \"user\");\n\t\t\tswitch (match_cfg_line_group(arg, line, ci->user)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->host == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Host\", \"host\");\n\t\t\tif (match_hostname(ci->host, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"connection from %.100s matched 'Host \"\n\t\t\t\t    \"%.100s' at line %d\", ci->host, arg, line);\n\t\t} else if (strcasecmp(attrib, \"address\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->address == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Address\", \"addr\");\n\t\t\tswitch (addr_match_list(ci->address, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched 'Address \"\n\t\t\t\t    \"%.100s' at line %d\", ci->address, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localaddress\") == 0){\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->laddress == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"LocalAddress\",\n\t\t\t\t    \"laddr\");\n\t\t\tswitch (addr_match_list(ci->laddress, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalAddress %.100s' at line %d\",\n\t\t\t\t    ci->laddress, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localport\") == 0) {\n\t\t\tif ((port = a2port(arg)) == -1) {\n\t\t\t\terror(\"Invalid LocalPort '%s' on Match line\",\n\t\t\t\t    arg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->lport == 0)\n\t\t\t\tmatch_test_missing_fatal(\"LocalPort\", \"lport\");\n\t\t\t/* TODO support port lists */\n\t\t\tif (port == ci->lport)\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalPort %d' at line %d\",\n\t\t\t\t    ci->laddress, port, line);\n\t\t\telse\n\t\t\t\tresult = 0;\n\t\t} else if (strcasecmp(attrib, \"rdomain\") == 0) {\n\t\t\tif (ci == NULL || ci->rdomain == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match_pattern_list(ci->rdomain, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'RDomain %.100s' at \"\n\t\t\t\t    \"line %d\", ci->rdomain, arg, line);\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\treturn -1;\n\t}\n\tif (ci != NULL)\n\t\tdebug3(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "arg",
            "getuid()"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "arg",
            "\"%d:%d:%d\"",
            "&options->max_startups_begin",
            "&options->max_startups_rate",
            "&options->max_startups"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "p",
            "arg",
            "len"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "p",
            "1",
            "len"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kex_names_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "kex_names_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "144-164",
          "snippet": "int\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "mac_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "247-265",
          "snippet": "int\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tMAC_SEP\t\",\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tMAC_SEP\t\",\"\n\nint\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ciphers_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "ciphers_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "203-224",
          "snippet": "int\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tCIPHER_SEP\t\",\"",
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tCIPHER_SEP\t\",\"\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nint\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_user",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "arg"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "match_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "221-248",
          "snippet": "int\nmatch_user(const char *user, const char *host, const char *ipaddr,\n    const char *pattern)\n{\n\tchar *p, *pat;\n\tint ret;\n\n\t/* test mode */\n\tif (user == NULL && host == NULL && ipaddr == NULL) {\n\t\tif ((p = strchr(pattern, '@')) != NULL &&\n\t\t    match_host_and_ip(NULL, NULL, p + 1) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif ((p = strchr(pattern,'@')) == NULL)\n\t\treturn match_pattern(user, pattern);\n\n\tpat = xstrdup(pattern);\n\tp = strchr(pat, '@');\n\t*p++ = '\\0';\n\n\tif ((ret = match_pattern(user, pat)) == 1)\n\t\tret = match_host_and_ip(host, ipaddr, p);\n\tfree(pat);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_user(const char *user, const char *host, const char *ipaddr,\n    const char *pattern)\n{\n\tchar *p, *pat;\n\tint ret;\n\n\t/* test mode */\n\tif (user == NULL && host == NULL && ipaddr == NULL) {\n\t\tif ((p = strchr(pattern, '@')) != NULL &&\n\t\t    match_host_and_ip(NULL, NULL, p + 1) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif ((p = strchr(pattern,'@')) == NULL)\n\t\treturn match_pattern(user, pattern);\n\n\tpat = xstrdup(pattern);\n\tp = strchr(pat, '@');\n\t*p++ = '\\0';\n\n\tif ((ret = match_pattern(user, pat)) == 1)\n\t\tret = match_host_and_ip(host, ipaddr, p);\n\tfree(pat);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_number",
          "args": [
            "arg"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "137-147",
          "snippet": "LogLevel\nlog_level_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_levels[i].name; i++)\n\t\t\tif (strcasecmp(log_levels[i].name, name) == 0)\n\t\t\t\treturn log_levels[i].val;\n\treturn SYSLOG_LEVEL_NOT_SET;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nLogLevel\nlog_level_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_levels[i].name; i++)\n\t\t\tif (strcasecmp(log_levels[i].name, name) == 0)\n\t\t\t\treturn log_levels[i].val;\n\treturn SYSLOG_LEVEL_NOT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_facility_number",
          "args": [
            "arg"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "log_facility_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "114-124",
          "snippet": "SyslogFacility\nlog_facility_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_facilities[i].name; i++)\n\t\t\tif (strcasecmp(log_facilities[i].name, name) == 0)\n\t\t\t\treturn log_facilities[i].val;\n\treturn SYSLOG_FACILITY_NOT_SET;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};\n\nSyslogFacility\nlog_facility_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_facilities[i].name; i++)\n\t\t\tif (strcasecmp(log_facilities[i].name, name) == 0)\n\t\t\t\treturn log_facilities[i].val;\n\treturn SYSLOG_FACILITY_NOT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_scaled",
          "args": [
            "arg",
            "&val64"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "scan_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
          "lines": "75-212",
          "snippet": "int\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */",
            "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi_err",
          "args": [
            "arg",
            "&value"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "atoi_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1974-1986",
          "snippet": "const char *\natoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\natoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_names_valid2",
          "args": [
            "*arg == '+' ? arg + 1 : arg",
            "1"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_names_valid2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "246-281",
          "snippet": "int\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "derelativise_path",
          "args": [
            "arg"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "derelativise_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "697-712",
          "snippet": "char *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "servconf_add_hostcert",
          "args": [
            "filename",
            "linenum",
            "options",
            "arg"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "servconf_add_hostcert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "247-256",
          "snippet": "void\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "servconf_add_hostkey",
          "args": [
            "filename",
            "linenum",
            "options",
            "arg"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "servconf_add_hostkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "236-245",
          "snippet": "void\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "arg",
            "multistate_ptr[i].key"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_listen_addr",
          "args": [
            "options",
            "p",
            "arg2",
            "port"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "queue_listen_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "816-830",
          "snippet": "static void\nqueue_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct queued_listenaddr *qla;\n\n\toptions->queued_listen_addrs = xrecallocarray(\n\t    options->queued_listen_addrs,\n\t    options->num_queued_listens, options->num_queued_listens + 1,\n\t    sizeof(*options->queued_listen_addrs));\n\tqla = &options->queued_listen_addrs[options->num_queued_listens++];\n\tqla->addr = xstrdup(addr);\n\tqla->port = port;\n\tqla->rdomain = rdomain == NULL ? NULL : xstrdup(rdomain);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nqueue_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct queued_listenaddr *qla;\n\n\toptions->queued_listen_addrs = xrecallocarray(\n\t    options->queued_listen_addrs,\n\t    options->num_queued_listens, options->num_queued_listens + 1,\n\t    sizeof(*options->queued_listen_addrs));\n\tqla = &options->queued_listen_addrs[options->num_queued_listens++];\n\tqla->addr = xstrdup(addr);\n\tqla->port = port;\n\tqla->rdomain = rdomain == NULL ? NULL : xstrdup(rdomain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "arg"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "arg"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s:%d setting %s %s\"",
            "filename",
            "linenum",
            "arg",
            "cp"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_token",
          "args": [
            "arg",
            "filename",
            "linenum",
            "&flags"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "parse_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "680-695",
          "snippet": "static ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\nstatic const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nint\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}"
  },
  {
    "function_name": "match_cfg_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "1000-1150",
    "snippet": "static int\nmatch_cfg_line(char **condition, int line, struct connection_info *ci)\n{\n\tint result = 1, attributes = 0, port;\n\tchar *arg, *attrib, *cp = *condition;\n\n\tif (ci == NULL)\n\t\tdebug3(\"checking syntax for 'Match %s'\", cp);\n\telse\n\t\tdebug3(\"checking match for '%s' user %s host %s addr %s \"\n\t\t    \"laddr %s lport %d\", cp, ci->user ? ci->user : \"(null)\",\n\t\t    ci->host ? ci->host : \"(null)\",\n\t\t    ci->address ? ci->address : \"(null)\",\n\t\t    ci->laddress ? ci->laddress : \"(null)\", ci->lport);\n\n\twhile ((attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes != 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"'all' cannot be combined with other \"\n\t\t\t\t    \"Match attributes\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*condition = cp;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"User\", \"user\");\n\t\t\tif (match_pattern_list(ci->user, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'User %.100s' at \"\n\t\t\t\t    \"line %d\", ci->user, arg, line);\n\t\t} else if (strcasecmp(attrib, \"group\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Group\", \"user\");\n\t\t\tswitch (match_cfg_line_group(arg, line, ci->user)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->host == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Host\", \"host\");\n\t\t\tif (match_hostname(ci->host, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"connection from %.100s matched 'Host \"\n\t\t\t\t    \"%.100s' at line %d\", ci->host, arg, line);\n\t\t} else if (strcasecmp(attrib, \"address\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->address == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Address\", \"addr\");\n\t\t\tswitch (addr_match_list(ci->address, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched 'Address \"\n\t\t\t\t    \"%.100s' at line %d\", ci->address, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localaddress\") == 0){\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->laddress == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"LocalAddress\",\n\t\t\t\t    \"laddr\");\n\t\t\tswitch (addr_match_list(ci->laddress, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalAddress %.100s' at line %d\",\n\t\t\t\t    ci->laddress, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localport\") == 0) {\n\t\t\tif ((port = a2port(arg)) == -1) {\n\t\t\t\terror(\"Invalid LocalPort '%s' on Match line\",\n\t\t\t\t    arg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->lport == 0)\n\t\t\t\tmatch_test_missing_fatal(\"LocalPort\", \"lport\");\n\t\t\t/* TODO support port lists */\n\t\t\tif (port == ci->lport)\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalPort %d' at line %d\",\n\t\t\t\t    ci->laddress, port, line);\n\t\t\telse\n\t\t\t\tresult = 0;\n\t\t} else if (strcasecmp(attrib, \"rdomain\") == 0) {\n\t\t\tif (ci == NULL || ci->rdomain == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match_pattern_list(ci->rdomain, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'RDomain %.100s' at \"\n\t\t\t\t    \"line %d\", ci->rdomain, arg, line);\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\treturn -1;\n\t}\n\tif (ci != NULL)\n\t\tdebug3(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\treturn result;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"match %sfound\"",
            "result ? \"\" : \"not \""
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"One or more attributes required for Match\""
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "ci->rdomain",
            "arg",
            "0"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"rdomain\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_test_missing_fatal",
          "args": [
            "\"LocalPort\"",
            "\"lport\""
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "arg"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"localport\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_match_list",
          "args": [
            "ci->laddress",
            "arg"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "addr_match_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "375-424",
          "snippet": "int\naddr_match_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen, neg;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tneg = *cp == '!';\n\t\tif (neg)\n\t\t\tcp++;\n\t\tif (*cp == '\\0') {\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t}\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -2) {\n\t\t\tdebug2(\"%s: inconsistent mask length for \"\n\t\t\t    \"match network \\\"%.100s\\\"\", __func__, cp);\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t} else if (r == 0) {\n\t\t\tif (addr != NULL && addr_netmatch(&try_addr,\n                           &match_addr, masklen) == 0) {\n foundit:\n\t\t\t\tif (neg) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* If CIDR parse failed, try wildcard string match */\n\t\t\tif (addr != NULL && match_pattern(addr, cp) == 1)\n\t\t\t\tgoto foundit;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\naddr_match_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen, neg;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tneg = *cp == '!';\n\t\tif (neg)\n\t\t\tcp++;\n\t\tif (*cp == '\\0') {\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t}\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -2) {\n\t\t\tdebug2(\"%s: inconsistent mask length for \"\n\t\t\t    \"match network \\\"%.100s\\\"\", __func__, cp);\n\t\t\tret = -2;\n\t\t\tbreak;\n\t\t} else if (r == 0) {\n\t\t\tif (addr != NULL && addr_netmatch(&try_addr,\n                           &match_addr, masklen) == 0) {\n foundit:\n\t\t\t\tif (neg) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* If CIDR parse failed, try wildcard string match */\n\t\t\tif (addr != NULL && match_pattern(addr, cp) == 1)\n\t\t\t\tgoto foundit;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"localaddress\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"address\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_hostname",
          "args": [
            "ci->host",
            "arg"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "match_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "179-189",
          "snippet": "int\nmatch_hostname(const char *host, const char *pattern)\n{\n\tchar *hostcopy = xstrdup(host);\n\tint r;\n\n\tlowercase(hostcopy);\n\tr = match_pattern_list(hostcopy, pattern, 1);\n\tfree(hostcopy);\n\treturn r;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_hostname(const char *host, const char *pattern)\n{\n\tchar *hostcopy = xstrdup(host);\n\tint r;\n\n\tlowercase(hostcopy);\n\tr = match_pattern_list(hostcopy, pattern, 1);\n\tfree(hostcopy);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"host\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_cfg_line_group",
          "args": [
            "arg",
            "line",
            "ci->user"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "match_cfg_line_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "960-986",
          "snippet": "static int\nmatch_cfg_line_group(const char *grps, int line, const char *user)\n{\n\tint result = 0;\n\tstruct passwd *pw;\n\n\tif (user == NULL)\n\t\tgoto out;\n\n\tif ((pw = getpwnam(user)) == NULL) {\n\t\tdebug(\"Can't match group at line %d because user %.100s does \"\n\t\t    \"not exist\", line, user);\n\t} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\tdebug(\"Can't Match group because user %.100s not in any group \"\n\t\t    \"at line %d\", user, line);\n\t} else if (ga_match_pattern_list(grps) != 1) {\n\t\tdebug(\"user %.100s does not match group list %.100s at line %d\",\n\t\t    user, grps, line);\n\t} else {\n\t\tdebug(\"user %.100s matched group list %.100s at line %d\", user,\n\t\t    grps, line);\n\t\tresult = 1;\n\t}\nout:\n\tga_free();\n\treturn result;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line_group(const char *grps, int line, const char *user)\n{\n\tint result = 0;\n\tstruct passwd *pw;\n\n\tif (user == NULL)\n\t\tgoto out;\n\n\tif ((pw = getpwnam(user)) == NULL) {\n\t\tdebug(\"Can't match group at line %d because user %.100s does \"\n\t\t    \"not exist\", line, user);\n\t} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\tdebug(\"Can't Match group because user %.100s not in any group \"\n\t\t    \"at line %d\", user, line);\n\t} else if (ga_match_pattern_list(grps) != 1) {\n\t\tdebug(\"user %.100s does not match group list %.100s at line %d\",\n\t\t    user, grps, line);\n\t} else {\n\t\tdebug(\"user %.100s matched group list %.100s at line %d\", user,\n\t\t    grps, line);\n\t\tresult = 1;\n\t}\nout:\n\tga_free();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"group\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"user\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdelim",
          "args": [
            "&cp"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "strdelimw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "296-300",
          "snippet": "char *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"all\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line(char **condition, int line, struct connection_info *ci)\n{\n\tint result = 1, attributes = 0, port;\n\tchar *arg, *attrib, *cp = *condition;\n\n\tif (ci == NULL)\n\t\tdebug3(\"checking syntax for 'Match %s'\", cp);\n\telse\n\t\tdebug3(\"checking match for '%s' user %s host %s addr %s \"\n\t\t    \"laddr %s lport %d\", cp, ci->user ? ci->user : \"(null)\",\n\t\t    ci->host ? ci->host : \"(null)\",\n\t\t    ci->address ? ci->address : \"(null)\",\n\t\t    ci->laddress ? ci->laddress : \"(null)\", ci->lport);\n\n\twhile ((attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes != 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"'all' cannot be combined with other \"\n\t\t\t\t    \"Match attributes\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*condition = cp;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"User\", \"user\");\n\t\t\tif (match_pattern_list(ci->user, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'User %.100s' at \"\n\t\t\t\t    \"line %d\", ci->user, arg, line);\n\t\t} else if (strcasecmp(attrib, \"group\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Group\", \"user\");\n\t\t\tswitch (match_cfg_line_group(arg, line, ci->user)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->host == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Host\", \"host\");\n\t\t\tif (match_hostname(ci->host, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"connection from %.100s matched 'Host \"\n\t\t\t\t    \"%.100s' at line %d\", ci->host, arg, line);\n\t\t} else if (strcasecmp(attrib, \"address\") == 0) {\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->address == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Address\", \"addr\");\n\t\t\tswitch (addr_match_list(ci->address, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched 'Address \"\n\t\t\t\t    \"%.100s' at line %d\", ci->address, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localaddress\") == 0){\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->laddress == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"LocalAddress\",\n\t\t\t\t    \"laddr\");\n\t\t\tswitch (addr_match_list(ci->laddress, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalAddress %.100s' at line %d\",\n\t\t\t\t    ci->laddress, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localport\") == 0) {\n\t\t\tif ((port = a2port(arg)) == -1) {\n\t\t\t\terror(\"Invalid LocalPort '%s' on Match line\",\n\t\t\t\t    arg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ci == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->lport == 0)\n\t\t\t\tmatch_test_missing_fatal(\"LocalPort\", \"lport\");\n\t\t\t/* TODO support port lists */\n\t\t\tif (port == ci->lport)\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalPort %d' at line %d\",\n\t\t\t\t    ci->laddress, port, line);\n\t\t\telse\n\t\t\t\tresult = 0;\n\t\t} else if (strcasecmp(attrib, \"rdomain\") == 0) {\n\t\t\tif (ci == NULL || ci->rdomain == NULL) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match_pattern_list(ci->rdomain, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'RDomain %.100s' at \"\n\t\t\t\t    \"line %d\", ci->rdomain, arg, line);\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\treturn -1;\n\t}\n\tif (ci != NULL)\n\t\tdebug3(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\treturn result;\n}"
  },
  {
    "function_name": "match_test_missing_fatal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "988-993",
    "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\"",
            "criteria",
            "attrib"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
  },
  {
    "function_name": "match_cfg_line_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "960-986",
    "snippet": "static int\nmatch_cfg_line_group(const char *grps, int line, const char *user)\n{\n\tint result = 0;\n\tstruct passwd *pw;\n\n\tif (user == NULL)\n\t\tgoto out;\n\n\tif ((pw = getpwnam(user)) == NULL) {\n\t\tdebug(\"Can't match group at line %d because user %.100s does \"\n\t\t    \"not exist\", line, user);\n\t} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\tdebug(\"Can't Match group because user %.100s not in any group \"\n\t\t    \"at line %d\", user, line);\n\t} else if (ga_match_pattern_list(grps) != 1) {\n\t\tdebug(\"user %.100s does not match group list %.100s at line %d\",\n\t\t    user, grps, line);\n\t} else {\n\t\tdebug(\"user %.100s matched group list %.100s at line %d\", user,\n\t\t    grps, line);\n\t\tresult = 1;\n\t}\nout:\n\tga_free();\n\treturn result;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ga_free",
          "args": [],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ga_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "121-133",
          "snippet": "void\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nvoid\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"user %.100s matched group list %.100s at line %d\"",
            "user",
            "grps",
            "line"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ga_match_pattern_list",
          "args": [
            "grps"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ga_match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "100-116",
          "snippet": "int\nga_match_pattern_list(const char *group_pattern)\n{\n\tint i, found = 0;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tswitch (match_pattern_list(groups_byname[i], group_pattern, 0)) {\n\t\tcase -1:\n\t\t\treturn 0;\t/* Negated match wins */\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tfound = 1;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_match_pattern_list(const char *group_pattern)\n{\n\tint i, found = 0;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tswitch (match_pattern_list(groups_byname[i], group_pattern, 0)) {\n\t\tcase -1:\n\t\t\treturn 0;\t/* Negated match wins */\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tfound = 1;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ga_init",
          "args": [
            "pw->pw_name",
            "pw->pw_gid"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ga_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "49-78",
          "snippet": "int\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line_group(const char *grps, int line, const char *user)\n{\n\tint result = 0;\n\tstruct passwd *pw;\n\n\tif (user == NULL)\n\t\tgoto out;\n\n\tif ((pw = getpwnam(user)) == NULL) {\n\t\tdebug(\"Can't match group at line %d because user %.100s does \"\n\t\t    \"not exist\", line, user);\n\t} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\tdebug(\"Can't Match group because user %.100s not in any group \"\n\t\t    \"at line %d\", user, line);\n\t} else if (ga_match_pattern_list(grps) != 1) {\n\t\tdebug(\"user %.100s does not match group list %.100s at line %d\",\n\t\t    user, grps, line);\n\t} else {\n\t\tdebug(\"user %.100s matched group list %.100s at line %d\", user,\n\t\t    grps, line);\n\t\tresult = 1;\n\t}\nout:\n\tga_free();\n\treturn result;\n}"
  },
  {
    "function_name": "get_connection_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "911-925",
    "snippet": "struct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_rdomain_in",
          "args": [
            "ssh"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_rdomain_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "568-577",
          "snippet": "const char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_local_port",
          "args": [
            "ssh"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "560-565",
          "snippet": "int\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_local_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "551-556",
          "snippet": "const char *\nssh_local_ipaddr(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_local_ipaddr(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "use_dns"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}"
  },
  {
    "function_name": "process_permitopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "901-909",
    "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_permitopen_list",
          "args": [
            "ssh",
            "sPermitListen",
            "options->permitted_listens",
            "options->num_permitted_listens"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "861-896",
          "snippet": "static void\nprocess_permitopen_list(struct ssh *ssh, ServerOpCodes opcode,\n    char **opens, u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *host, *arg, *oarg;\n\tint where = opcode == sPermitOpen ? FORWARD_LOCAL : FORWARD_REMOTE;\n\tconst char *what = lookup_opcode_name(opcode);\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn; /* permit any */\n\n\t/* handle keywords: \"any\" / \"none\" */\n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t/* Otherwise treat it as a list of permitted host:port */\n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\thost = hpdelim(&arg);\n\t\tif (host == NULL)\n\t\t\tfatal(\"%s: missing host in %s\", __func__, what);\n\t\thost = cleanhostname(host);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal(\"%s: bad port number in %s\", __func__, what);\n\t\t/* Send it to channels layer */\n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, host, port);\n\t\tfree(oarg);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic void\nprocess_permitopen_list(struct ssh *ssh, ServerOpCodes opcode,\n    char **opens, u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *host, *arg, *oarg;\n\tint where = opcode == sPermitOpen ? FORWARD_LOCAL : FORWARD_REMOTE;\n\tconst char *what = lookup_opcode_name(opcode);\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn; /* permit any */\n\n\t/* handle keywords: \"any\" / \"none\" */\n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t/* Otherwise treat it as a list of permitted host:port */\n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\thost = hpdelim(&arg);\n\t\tif (host == NULL)\n\t\t\tfatal(\"%s: missing host in %s\", __func__, what);\n\t\thost = cleanhostname(host);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal(\"%s: bad port number in %s\", __func__, what);\n\t\t/* Send it to channels layer */\n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, host, port);\n\t\tfree(oarg);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
  },
  {
    "function_name": "process_permitopen_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "861-896",
    "snippet": "static void\nprocess_permitopen_list(struct ssh *ssh, ServerOpCodes opcode,\n    char **opens, u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *host, *arg, *oarg;\n\tint where = opcode == sPermitOpen ? FORWARD_LOCAL : FORWARD_REMOTE;\n\tconst char *what = lookup_opcode_name(opcode);\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn; /* permit any */\n\n\t/* handle keywords: \"any\" / \"none\" */\n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t/* Otherwise treat it as a list of permitted host:port */\n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\thost = hpdelim(&arg);\n\t\tif (host == NULL)\n\t\t\tfatal(\"%s: missing host in %s\", __func__, what);\n\t\thost = cleanhostname(host);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal(\"%s: bad port number in %s\", __func__, what);\n\t\t/* Send it to channels layer */\n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, host, port);\n\t\tfree(oarg);\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oarg"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_add_permission",
          "args": [
            "ssh",
            "FORWARD_ADM",
            "where",
            "host",
            "port"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "channel_add_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4051-4068",
          "snippet": "void\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad port number in %s\"",
            "__func__",
            "what"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permitopen_port",
          "args": [
            "arg"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "permitopen_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4124-4134",
          "snippet": "int\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nint\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanhostname",
          "args": [
            "host"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "cleanhostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "535-543",
          "snippet": "char *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpdelim",
          "args": [
            "&arg"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "hpdelim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "529-533",
          "snippet": "char *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "opens[i]"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_disable_admin",
          "args": [
            "ssh",
            "where"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "channel_disable_admin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4073-4079",
          "snippet": "void\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opens[0]",
            "\"none\""
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_clear_permission",
          "args": [
            "ssh",
            "FORWARD_ADM",
            "where"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "channel_clear_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4084-4093",
          "snippet": "void\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "opcode"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "664-673",
          "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic void\nprocess_permitopen_list(struct ssh *ssh, ServerOpCodes opcode,\n    char **opens, u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *host, *arg, *oarg;\n\tint where = opcode == sPermitOpen ? FORWARD_LOCAL : FORWARD_REMOTE;\n\tconst char *what = lookup_opcode_name(opcode);\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn; /* permit any */\n\n\t/* handle keywords: \"any\" / \"none\" */\n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t/* Otherwise treat it as a list of permitted host:port */\n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\thost = hpdelim(&arg);\n\t\tif (host == NULL)\n\t\t\tfatal(\"%s: missing host in %s\", __func__, what);\n\t\thost = cleanhostname(host);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal(\"%s: bad port number in %s\", __func__, what);\n\t\t/* Send it to channels layer */\n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, host, port);\n\t\tfree(oarg);\n\t}\n}"
  },
  {
    "function_name": "process_queued_listen_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "835-855",
    "snippet": "static void\nprocess_queued_listen_addrs(ServerOptions *options)\n{\n\tu_int i;\n\tstruct queued_listenaddr *qla;\n\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\n\tfor (i = 0; i < options->num_queued_listens; i++) {\n\t\tqla = &options->queued_listen_addrs[i];\n\t\tadd_listen_addr(options, qla->addr, qla->rdomain, qla->port);\n\t\tfree(qla->addr);\n\t\tfree(qla->rdomain);\n\t}\n\tfree(options->queued_listen_addrs);\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options->queued_listen_addrs"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_listen_addr",
          "args": [
            "options",
            "qla->addr",
            "qla->rdomain",
            "qla->port"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "add_listen_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "714-728",
          "snippet": "static void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nprocess_queued_listen_addrs(ServerOptions *options)\n{\n\tu_int i;\n\tstruct queued_listenaddr *qla;\n\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\n\tfor (i = 0; i < options->num_queued_listens; i++) {\n\t\tqla = &options->queued_listen_addrs[i];\n\t\tadd_listen_addr(options, qla->addr, qla->rdomain, qla->port);\n\t\tfree(qla->addr);\n\t\tfree(qla->rdomain);\n\t}\n\tfree(options->queued_listen_addrs);\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n}"
  },
  {
    "function_name": "queue_listen_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "816-830",
    "snippet": "static void\nqueue_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct queued_listenaddr *qla;\n\n\toptions->queued_listen_addrs = xrecallocarray(\n\t    options->queued_listen_addrs,\n\t    options->num_queued_listens, options->num_queued_listens + 1,\n\t    sizeof(*options->queued_listen_addrs));\n\tqla = &options->queued_listen_addrs[options->num_queued_listens++];\n\tqla->addr = xstrdup(addr);\n\tqla->port = port;\n\tqla->rdomain = rdomain == NULL ? NULL : xstrdup(rdomain);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "rdomain"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "options->queued_listen_addrs",
            "options->num_queued_listens",
            "options->num_queued_listens + 1",
            "sizeof(*options->queued_listen_addrs)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nqueue_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct queued_listenaddr *qla;\n\n\toptions->queued_listen_addrs = xrecallocarray(\n\t    options->queued_listen_addrs,\n\t    options->num_queued_listens, options->num_queued_listens + 1,\n\t    sizeof(*options->queued_listen_addrs));\n\tqla = &options->queued_listen_addrs[options->num_queued_listens++];\n\tqla->addr = xstrdup(addr);\n\tqla->port = port;\n\tqla->rdomain = rdomain == NULL ? NULL : xstrdup(rdomain);\n}"
  },
  {
    "function_name": "valid_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "777-810",
    "snippet": "static int\nvalid_rdomain(const char *name)\n{\n#if defined(HAVE_SYS_VALID_RDOMAIN)\n\treturn sys_valid_rdomain(name);\n#elif defined(__OpenBSD__)\n\tconst char *errstr;\n\tlong long num;\n\tstruct rt_tableinfo info;\n\tint mib[6];\n\tsize_t miblen = sizeof(mib);\n\n\tif (name == NULL)\n\t\treturn 1;\n\n\tnum = strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)\n\t\treturn 0;\n\n\t/* Check whether the table actually exists */\n\tmemset(mib, 0, sizeof(mib));\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_ROUTE;\n\tmib[4] = NET_RT_TABLE;\n\tmib[5] = (int)num;\n\tif (sysctl(mib, 6, &info, &miblen, NULL, 0) == -1)\n\t\treturn 0;\n\n\treturn 1;\n#else /* defined(__OpenBSD__) */\n\terror(\"Routing domains are not supported on this platform\");\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Routing domains are not supported on this platform\""
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl",
          "args": [
            "mib",
            "6",
            "&info",
            "&miblen",
            "NULL",
            "0"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mib",
            "0",
            "sizeof(mib)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "name",
            "0",
            "255",
            "&errstr"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sys_valid_rdomain",
          "args": [
            "name"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "sys_valid_rdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
          "lines": "76-95",
          "snippet": "int\nsys_valid_rdomain(const char *name)\n{\n\tint fd;\n\n\t/*\n\t * This is a pretty crappy way to test. It would be better to\n\t * check whether \"name\" represents a VRF device, but apparently\n\t * that requires an rtnetlink transaction.\n\t */\n\tif ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n\t\treturn 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n}",
          "includes": [
            "#include <net/if_tun.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <linux/if_tun.h>",
            "#include <linux/if.h>",
            "#include \"ssherr.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_valid_rdomain(const char *name)\n{\n\tint fd;\n\n\t/*\n\t * This is a pretty crappy way to test. It would be better to\n\t * check whether \"name\" represents a VRF device, but apparently\n\t * that requires an rtnetlink transaction.\n\t */\n\tif ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n\t\treturn 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nvalid_rdomain(const char *name)\n{\n#if defined(HAVE_SYS_VALID_RDOMAIN)\n\treturn sys_valid_rdomain(name);\n#elif defined(__OpenBSD__)\n\tconst char *errstr;\n\tlong long num;\n\tstruct rt_tableinfo info;\n\tint mib[6];\n\tsize_t miblen = sizeof(mib);\n\n\tif (name == NULL)\n\t\treturn 1;\n\n\tnum = strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)\n\t\treturn 0;\n\n\t/* Check whether the table actually exists */\n\tmemset(mib, 0, sizeof(mib));\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_ROUTE;\n\tmib[4] = NET_RT_TABLE;\n\tmib[5] = (int)num;\n\tif (sysctl(mib, 6, &info, &miblen, NULL, 0) == -1)\n\t\treturn 0;\n\n\treturn 1;\n#else /* defined(__OpenBSD__) */\n\terror(\"Routing domains are not supported on this platform\");\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "add_one_listen_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "730-774",
    "snippet": "static void\nadd_one_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr;\n\tu_int i;\n\n\t/* Find listen_addrs entry for this rdomain */\n\tfor (i = 0; i < options->num_listen_addrs; i++) {\n\t\tif (rdomain == NULL && options->listen_addrs[i].rdomain == NULL)\n\t\t\tbreak;\n\t\tif (rdomain == NULL || options->listen_addrs[i].rdomain == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(rdomain, options->listen_addrs[i].rdomain) == 0)\n\t\t\tbreak;\n\t}\n\tif (i >= options->num_listen_addrs) {\n\t\t/* No entry for this rdomain; allocate one */\n\t\tif (i >= INT_MAX)\n\t\t\tfatal(\"%s: too many listen addresses\", __func__);\n\t\toptions->listen_addrs = xrecallocarray(options->listen_addrs,\n\t\t    options->num_listen_addrs, options->num_listen_addrs + 1,\n\t\t    sizeof(*options->listen_addrs));\n\t\ti = options->num_listen_addrs++;\n\t\tif (rdomain != NULL)\n\t\t\toptions->listen_addrs[i].rdomain = xstrdup(rdomain);\n\t}\n\t/* options->listen_addrs[i] points to the addresses for this rdomain */\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options->address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tif ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)\n\t\tfatal(\"bad addr or host: %s (%s)\",\n\t\t    addr ? addr : \"<NULL>\",\n\t\t    ssh_gai_strerror(gaierr));\n\tfor (ai = aitop; ai->ai_next; ai = ai->ai_next)\n\t\t;\n\tai->ai_next = options->listen_addrs[i].addrs;\n\toptions->listen_addrs[i].addrs = aitop;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"bad addr or host: %s (%s)\"",
            "addr ? addr : \"<NULL>\"",
            "ssh_gai_strerror(gaierr)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "gaierr"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "addr",
            "strport",
            "&hints",
            "&aitop"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "port"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "rdomain"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "options->listen_addrs",
            "options->num_listen_addrs",
            "options->num_listen_addrs + 1",
            "sizeof(*options->listen_addrs)"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: too many listen addresses\"",
            "__func__"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rdomain",
            "options->listen_addrs[i].rdomain"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nadd_one_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr;\n\tu_int i;\n\n\t/* Find listen_addrs entry for this rdomain */\n\tfor (i = 0; i < options->num_listen_addrs; i++) {\n\t\tif (rdomain == NULL && options->listen_addrs[i].rdomain == NULL)\n\t\t\tbreak;\n\t\tif (rdomain == NULL || options->listen_addrs[i].rdomain == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(rdomain, options->listen_addrs[i].rdomain) == 0)\n\t\t\tbreak;\n\t}\n\tif (i >= options->num_listen_addrs) {\n\t\t/* No entry for this rdomain; allocate one */\n\t\tif (i >= INT_MAX)\n\t\t\tfatal(\"%s: too many listen addresses\", __func__);\n\t\toptions->listen_addrs = xrecallocarray(options->listen_addrs,\n\t\t    options->num_listen_addrs, options->num_listen_addrs + 1,\n\t\t    sizeof(*options->listen_addrs));\n\t\ti = options->num_listen_addrs++;\n\t\tif (rdomain != NULL)\n\t\t\toptions->listen_addrs[i].rdomain = xstrdup(rdomain);\n\t}\n\t/* options->listen_addrs[i] points to the addresses for this rdomain */\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options->address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tif ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)\n\t\tfatal(\"bad addr or host: %s (%s)\",\n\t\t    addr ? addr : \"<NULL>\",\n\t\t    ssh_gai_strerror(gaierr));\n\tfor (ai = aitop; ai->ai_next; ai = ai->ai_next)\n\t\t;\n\tai->ai_next = options->listen_addrs[i].addrs;\n\toptions->listen_addrs[i].addrs = aitop;\n}"
  },
  {
    "function_name": "add_listen_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "714-728",
    "snippet": "static void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_one_listen_addr",
          "args": [
            "options",
            "addr",
            "rdomain",
            "options->ports[i]"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "add_one_listen_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "730-774",
          "snippet": "static void\nadd_one_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr;\n\tu_int i;\n\n\t/* Find listen_addrs entry for this rdomain */\n\tfor (i = 0; i < options->num_listen_addrs; i++) {\n\t\tif (rdomain == NULL && options->listen_addrs[i].rdomain == NULL)\n\t\t\tbreak;\n\t\tif (rdomain == NULL || options->listen_addrs[i].rdomain == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(rdomain, options->listen_addrs[i].rdomain) == 0)\n\t\t\tbreak;\n\t}\n\tif (i >= options->num_listen_addrs) {\n\t\t/* No entry for this rdomain; allocate one */\n\t\tif (i >= INT_MAX)\n\t\t\tfatal(\"%s: too many listen addresses\", __func__);\n\t\toptions->listen_addrs = xrecallocarray(options->listen_addrs,\n\t\t    options->num_listen_addrs, options->num_listen_addrs + 1,\n\t\t    sizeof(*options->listen_addrs));\n\t\ti = options->num_listen_addrs++;\n\t\tif (rdomain != NULL)\n\t\t\toptions->listen_addrs[i].rdomain = xstrdup(rdomain);\n\t}\n\t/* options->listen_addrs[i] points to the addresses for this rdomain */\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options->address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tif ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)\n\t\tfatal(\"bad addr or host: %s (%s)\",\n\t\t    addr ? addr : \"<NULL>\",\n\t\t    ssh_gai_strerror(gaierr));\n\tfor (ai = aitop; ai->ai_next; ai = ai->ai_next)\n\t\t;\n\tai->ai_next = options->listen_addrs[i].addrs;\n\toptions->listen_addrs[i].addrs = aitop;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nadd_one_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr;\n\tu_int i;\n\n\t/* Find listen_addrs entry for this rdomain */\n\tfor (i = 0; i < options->num_listen_addrs; i++) {\n\t\tif (rdomain == NULL && options->listen_addrs[i].rdomain == NULL)\n\t\t\tbreak;\n\t\tif (rdomain == NULL || options->listen_addrs[i].rdomain == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(rdomain, options->listen_addrs[i].rdomain) == 0)\n\t\t\tbreak;\n\t}\n\tif (i >= options->num_listen_addrs) {\n\t\t/* No entry for this rdomain; allocate one */\n\t\tif (i >= INT_MAX)\n\t\t\tfatal(\"%s: too many listen addresses\", __func__);\n\t\toptions->listen_addrs = xrecallocarray(options->listen_addrs,\n\t\t    options->num_listen_addrs, options->num_listen_addrs + 1,\n\t\t    sizeof(*options->listen_addrs));\n\t\ti = options->num_listen_addrs++;\n\t\tif (rdomain != NULL)\n\t\t\toptions->listen_addrs[i].rdomain = xstrdup(rdomain);\n\t}\n\t/* options->listen_addrs[i] points to the addresses for this rdomain */\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options->address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tif ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)\n\t\tfatal(\"bad addr or host: %s (%s)\",\n\t\t    addr ? addr : \"<NULL>\",\n\t\t    ssh_gai_strerror(gaierr));\n\tfor (ai = aitop; ai->ai_next; ai = ai->ai_next)\n\t\t;\n\tai->ai_next = options->listen_addrs[i].addrs;\n\toptions->listen_addrs[i].addrs = aitop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "derelativise_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "697-712",
    "snippet": "char *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "expanded"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"%s/%s\"",
            "cwd",
            "expanded"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: getcwd: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "cwd",
            "sizeof(cwd)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "getcwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getcwd.c",
          "lines": "51-238",
          "snippet": "char *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}",
          "includes": [
            "#include \"includes.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/dir.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/dir.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nchar *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "path",
            "getuid()"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"none\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"none\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "680-695",
    "snippet": "static ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: line %d: Bad configuration option: %s\"",
            "filename",
            "linenum",
            "cp"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "cp",
            "keywords[i].name"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}"
  },
  {
    "function_name": "lookup_opcode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "664-673",
    "snippet": "static const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t/* Portable-specific options */\n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t/* Standard Options */\n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t/* alias */\n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */\n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sChallengeResponseAuthentication, SSHCFG_GLOBAL },\n\t{ \"skeyauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_GLOBAL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t/* obsolete alias */\n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_GLOBAL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
  },
  {
    "function_name": "fill_default_server_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "258-460",
    "snippet": "void\nfill_default_server_options(ServerOptions *options)\n{\n\tu_int i;\n\n\t/* Portable-specific options */\n\tif (options->use_pam == -1)\n\t\toptions->use_pam = 0;\n\n\t/* Standard Options */\n\tif (options->num_host_key_files == 0) {\n\t\t/* fill default hostkeys for protocols */\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_RSA_KEY_FILE);\n#ifdef OPENSSL_HAS_ECC\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ECDSA_KEY_FILE);\n#endif\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ED25519_KEY_FILE);\n#ifdef WITH_XMSS\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_XMSS_KEY_FILE);\n#endif /* WITH_XMSS */\n\t}\n\t/* No certificates by default */\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->listen_addrs == NULL)\n\t\tadd_listen_addr(options, NULL, NULL, 0);\n\tif (options->pid_file == NULL)\n\t\toptions->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);\n\tif (options->login_grace_time == -1)\n\t\toptions->login_grace_time = 120;\n\tif (options->permit_root_login == PERMIT_NOT_SET)\n\t\toptions->permit_root_login = PERMIT_NO_PASSWD;\n\tif (options->ignore_rhosts == -1)\n\t\toptions->ignore_rhosts = 1;\n\tif (options->ignore_user_known_hosts == -1)\n\t\toptions->ignore_user_known_hosts = 0;\n\tif (options->print_motd == -1)\n\t\toptions->print_motd = 1;\n\tif (options->print_lastlog == -1)\n\t\toptions->print_lastlog = 1;\n\tif (options->x11_forwarding == -1)\n\t\toptions->x11_forwarding = 0;\n\tif (options->x11_display_offset == -1)\n\t\toptions->x11_display_offset = 10;\n\tif (options->x11_use_localhost == -1)\n\t\toptions->x11_use_localhost = 1;\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->permit_tty == -1)\n\t\toptions->permit_tty = 1;\n\tif (options->permit_user_rc == -1)\n\t\toptions->permit_user_rc = 1;\n\tif (options->strict_modes == -1)\n\t\toptions->strict_modes = 1;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_AUTH;\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->hostbased_uses_name_from_packet_only == -1)\n\t\toptions->hostbased_uses_name_from_packet_only = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->kerberos_authentication == -1)\n\t\toptions->kerberos_authentication = 0;\n\tif (options->kerberos_or_local_passwd == -1)\n\t\toptions->kerberos_or_local_passwd = 1;\n\tif (options->kerberos_ticket_cleanup == -1)\n\t\toptions->kerberos_ticket_cleanup = 1;\n\tif (options->kerberos_get_afs_token == -1)\n\t\toptions->kerberos_get_afs_token = 0;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_cleanup_creds == -1)\n\t\toptions->gss_cleanup_creds = 1;\n\tif (options->gss_strict_acceptor == -1)\n\t\toptions->gss_strict_acceptor = 1;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 0;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->permit_empty_passwd == -1)\n\t\toptions->permit_empty_passwd = 0;\n\tif (options->permit_user_env == -1) {\n\t\toptions->permit_user_env = 0;\n\t\toptions->permit_user_env_whitelist = NULL;\n\t}\n\tif (options->compression == -1)\n\t\toptions->compression = COMP_DELAYED;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->allow_tcp_forwarding == -1)\n\t\toptions->allow_tcp_forwarding = FORWARD_ALLOW;\n\tif (options->allow_streamlocal_forwarding == -1)\n\t\toptions->allow_streamlocal_forwarding = FORWARD_ALLOW;\n\tif (options->allow_agent_forwarding == -1)\n\t\toptions->allow_agent_forwarding = 1;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->max_startups == -1)\n\t\toptions->max_startups = 100;\n\tif (options->max_startups_rate == -1)\n\t\toptions->max_startups_rate = 30;\t\t/* 30% */\n\tif (options->max_startups_begin == -1)\n\t\toptions->max_startups_begin = 10;\n\tif (options->max_authtries == -1)\n\t\toptions->max_authtries = DEFAULT_AUTH_FAIL_MAX;\n\tif (options->max_sessions == -1)\n\t\toptions->max_sessions = DEFAULT_SESSIONS_MAX;\n\tif (options->use_dns == -1)\n\t\toptions->use_dns = 0;\n\tif (options->client_alive_interval == -1)\n\t\toptions->client_alive_interval = 0;\n\tif (options->client_alive_count_max == -1)\n\t\toptions->client_alive_count_max = 3;\n\tif (options->num_authkeys_files == 0) {\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS);\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS2);\n\t}\n\tif (options->permit_tun == -1)\n\t\toptions->permit_tun = SSH_TUNMODE_NO;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->version_addendum == NULL)\n\t\toptions->version_addendum = xstrdup(\"\");\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->disable_forwarding == -1)\n\t\toptions->disable_forwarding = 0;\n\tif (options->expose_userauth_info == -1)\n\t\toptions->expose_userauth_info = 0;\n\n\tassemble_algorithms(options);\n\n\t/* Turn privilege separation and sandboxing on by default */\n\tif (use_privsep == -1)\n\t\tuse_privsep = PRIVSEP_ON;\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->pid_file);\n\tCLEAR_ON_NONE(options->xauth_location);\n\tCLEAR_ON_NONE(options->banner);\n\tCLEAR_ON_NONE(options->trusted_user_ca_keys);\n\tCLEAR_ON_NONE(options->revoked_keys_file);\n\tCLEAR_ON_NONE(options->authorized_principals_file);\n\tCLEAR_ON_NONE(options->adm_forced_command);\n\tCLEAR_ON_NONE(options->chroot_directory);\n\tCLEAR_ON_NONE(options->routing_domain);\n\tfor (i = 0; i < options->num_host_key_files; i++)\n\t\tCLEAR_ON_NONE(options->host_key_files[i]);\n\tfor (i = 0; i < options->num_host_cert_files; i++)\n\t\tCLEAR_ON_NONE(options->host_cert_files[i]);\n#undef CLEAR_ON_NONE\n\n\t/* Similar handling for AuthenticationMethods=any */\n\tif (options->num_auth_methods == 1 &&\n\t    strcmp(options->auth_methods[0], \"any\") == 0) {\n\t\tfree(options->auth_methods[0]);\n\t\toptions->auth_methods[0] = NULL;\n\t\toptions->num_auth_methods = 0;\n\t}\n\n#ifndef HAVE_MMAP\n\tif (use_privsep && options->compression == 1) {\n\t\terror(\"This platform does not support both privilege \"\n\t\t    \"separation and compression\");\n\t\terror(\"Compression disabled\");\n\t\toptions->compression = 0;\n\t}\n#endif\n\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "extern int use_privsep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Compression disabled\""
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options->auth_methods[0]"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options->auth_methods[0]",
            "\"any\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->host_cert_files[i]"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->host_key_files[i]"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->routing_domain"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->chroot_directory"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->adm_forced_command"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->authorized_principals_file"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->revoked_keys_file"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->trusted_user_ca_keys"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->banner"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->xauth_location"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->pid_file"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assemble_algorithms",
          "args": [
            "options"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "assemble_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "192-221",
          "snippet": "static void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_append",
          "args": [
            "\"[default]\"",
            "0",
            "\"AuthorizedKeysFiles\"",
            "&options->authorized_keys_files",
            "&options->num_authkeys_files",
            "_PATH_SSH_USER_PERMITTED_KEYS2"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "array_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "223-234",
          "snippet": "static void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_listen_addr",
          "args": [
            "options",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "add_listen_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "714-728",
          "snippet": "static void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "servconf_add_hostkey",
          "args": [
            "\"[default]\"",
            "0",
            "options",
            "_PATH_HOST_XMSS_KEY_FILE"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "servconf_add_hostkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "236-245",
          "snippet": "void\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nextern int use_privsep;\n\nvoid\nfill_default_server_options(ServerOptions *options)\n{\n\tu_int i;\n\n\t/* Portable-specific options */\n\tif (options->use_pam == -1)\n\t\toptions->use_pam = 0;\n\n\t/* Standard Options */\n\tif (options->num_host_key_files == 0) {\n\t\t/* fill default hostkeys for protocols */\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_RSA_KEY_FILE);\n#ifdef OPENSSL_HAS_ECC\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ECDSA_KEY_FILE);\n#endif\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ED25519_KEY_FILE);\n#ifdef WITH_XMSS\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_XMSS_KEY_FILE);\n#endif /* WITH_XMSS */\n\t}\n\t/* No certificates by default */\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->listen_addrs == NULL)\n\t\tadd_listen_addr(options, NULL, NULL, 0);\n\tif (options->pid_file == NULL)\n\t\toptions->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);\n\tif (options->login_grace_time == -1)\n\t\toptions->login_grace_time = 120;\n\tif (options->permit_root_login == PERMIT_NOT_SET)\n\t\toptions->permit_root_login = PERMIT_NO_PASSWD;\n\tif (options->ignore_rhosts == -1)\n\t\toptions->ignore_rhosts = 1;\n\tif (options->ignore_user_known_hosts == -1)\n\t\toptions->ignore_user_known_hosts = 0;\n\tif (options->print_motd == -1)\n\t\toptions->print_motd = 1;\n\tif (options->print_lastlog == -1)\n\t\toptions->print_lastlog = 1;\n\tif (options->x11_forwarding == -1)\n\t\toptions->x11_forwarding = 0;\n\tif (options->x11_display_offset == -1)\n\t\toptions->x11_display_offset = 10;\n\tif (options->x11_use_localhost == -1)\n\t\toptions->x11_use_localhost = 1;\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->permit_tty == -1)\n\t\toptions->permit_tty = 1;\n\tif (options->permit_user_rc == -1)\n\t\toptions->permit_user_rc = 1;\n\tif (options->strict_modes == -1)\n\t\toptions->strict_modes = 1;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_AUTH;\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->hostbased_uses_name_from_packet_only == -1)\n\t\toptions->hostbased_uses_name_from_packet_only = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->kerberos_authentication == -1)\n\t\toptions->kerberos_authentication = 0;\n\tif (options->kerberos_or_local_passwd == -1)\n\t\toptions->kerberos_or_local_passwd = 1;\n\tif (options->kerberos_ticket_cleanup == -1)\n\t\toptions->kerberos_ticket_cleanup = 1;\n\tif (options->kerberos_get_afs_token == -1)\n\t\toptions->kerberos_get_afs_token = 0;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_cleanup_creds == -1)\n\t\toptions->gss_cleanup_creds = 1;\n\tif (options->gss_strict_acceptor == -1)\n\t\toptions->gss_strict_acceptor = 1;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 0;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->permit_empty_passwd == -1)\n\t\toptions->permit_empty_passwd = 0;\n\tif (options->permit_user_env == -1) {\n\t\toptions->permit_user_env = 0;\n\t\toptions->permit_user_env_whitelist = NULL;\n\t}\n\tif (options->compression == -1)\n\t\toptions->compression = COMP_DELAYED;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->allow_tcp_forwarding == -1)\n\t\toptions->allow_tcp_forwarding = FORWARD_ALLOW;\n\tif (options->allow_streamlocal_forwarding == -1)\n\t\toptions->allow_streamlocal_forwarding = FORWARD_ALLOW;\n\tif (options->allow_agent_forwarding == -1)\n\t\toptions->allow_agent_forwarding = 1;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->max_startups == -1)\n\t\toptions->max_startups = 100;\n\tif (options->max_startups_rate == -1)\n\t\toptions->max_startups_rate = 30;\t\t/* 30% */\n\tif (options->max_startups_begin == -1)\n\t\toptions->max_startups_begin = 10;\n\tif (options->max_authtries == -1)\n\t\toptions->max_authtries = DEFAULT_AUTH_FAIL_MAX;\n\tif (options->max_sessions == -1)\n\t\toptions->max_sessions = DEFAULT_SESSIONS_MAX;\n\tif (options->use_dns == -1)\n\t\toptions->use_dns = 0;\n\tif (options->client_alive_interval == -1)\n\t\toptions->client_alive_interval = 0;\n\tif (options->client_alive_count_max == -1)\n\t\toptions->client_alive_count_max = 3;\n\tif (options->num_authkeys_files == 0) {\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS);\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS2);\n\t}\n\tif (options->permit_tun == -1)\n\t\toptions->permit_tun = SSH_TUNMODE_NO;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->version_addendum == NULL)\n\t\toptions->version_addendum = xstrdup(\"\");\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->disable_forwarding == -1)\n\t\toptions->disable_forwarding = 0;\n\tif (options->expose_userauth_info == -1)\n\t\toptions->expose_userauth_info = 0;\n\n\tassemble_algorithms(options);\n\n\t/* Turn privilege separation and sandboxing on by default */\n\tif (use_privsep == -1)\n\t\tuse_privsep = PRIVSEP_ON;\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->pid_file);\n\tCLEAR_ON_NONE(options->xauth_location);\n\tCLEAR_ON_NONE(options->banner);\n\tCLEAR_ON_NONE(options->trusted_user_ca_keys);\n\tCLEAR_ON_NONE(options->revoked_keys_file);\n\tCLEAR_ON_NONE(options->authorized_principals_file);\n\tCLEAR_ON_NONE(options->adm_forced_command);\n\tCLEAR_ON_NONE(options->chroot_directory);\n\tCLEAR_ON_NONE(options->routing_domain);\n\tfor (i = 0; i < options->num_host_key_files; i++)\n\t\tCLEAR_ON_NONE(options->host_key_files[i]);\n\tfor (i = 0; i < options->num_host_cert_files; i++)\n\t\tCLEAR_ON_NONE(options->host_cert_files[i]);\n#undef CLEAR_ON_NONE\n\n\t/* Similar handling for AuthenticationMethods=any */\n\tif (options->num_auth_methods == 1 &&\n\t    strcmp(options->auth_methods[0], \"any\") == 0) {\n\t\tfree(options->auth_methods[0]);\n\t\toptions->auth_methods[0] = NULL;\n\t\toptions->num_auth_methods = 0;\n\t}\n\n#ifndef HAVE_MMAP\n\tif (use_privsep && options->compression == 1) {\n\t\terror(\"This platform does not support both privilege \"\n\t\t    \"separation and compression\");\n\t\terror(\"Compression disabled\");\n\t\toptions->compression = 0;\n\t}\n#endif\n\n}"
  },
  {
    "function_name": "servconf_add_hostcert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "247-256",
    "snippet": "void\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "apath"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_append",
          "args": [
            "file",
            "line",
            "\"HostCertificate\"",
            "&options->host_cert_files",
            "&options->num_host_cert_files",
            "apath"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "array_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "223-234",
          "snippet": "static void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "derelativise_path",
          "args": [
            "path"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "derelativise_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "697-712",
          "snippet": "char *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}"
  },
  {
    "function_name": "servconf_add_hostkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "236-245",
    "snippet": "void\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "apath"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_append",
          "args": [
            "file",
            "line",
            "\"HostKey\"",
            "&options->host_key_files",
            "&options->num_host_key_files",
            "apath"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "array_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "223-234",
          "snippet": "static void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "derelativise_path",
          "args": [
            "path"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "derelativise_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "697-712",
          "snippet": "char *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (*expanded == '/')\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal(\"%s: getcwd: %s\", __func__, strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}"
  },
  {
    "function_name": "array_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "223-234",
    "snippet": "static void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "s"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "*array",
            "*lp",
            "*lp + 1",
            "sizeof(**array)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s line %d: Too many %s entries\"",
            "file",
            "line",
            "directive"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\narray_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}"
  },
  {
    "function_name": "assemble_algorithms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "192-221",
    "snippet": "static void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "all_sig"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "ca_sign_algorithms",
            "SSH_ALLOWED_CA_SIGALGS",
            "all_sig"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "pubkey_key_types",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "hostbased_key_types",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "hostkeyalgorithms",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "kex_algorithms",
            "KEX_SERVER_KEX",
            "all_kex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "macs",
            "KEX_SERVER_MAC",
            "all_mac"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "ciphers",
            "KEX_SERVER_ENCRYPT",
            "all_cipher"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_alg_list",
          "args": [
            "0",
            "1",
            "1",
            "','"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "218-244",
          "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_alg_list",
          "args": [
            "','"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "kex_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "109-129",
          "snippet": "char *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_alg_list",
          "args": [
            "','"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "mac_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "86-106",
          "snippet": "char *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};\n\nchar *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_alg_list",
          "args": [
            "','",
            "0"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "117-141",
          "snippet": "char *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nchar *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nstatic void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostkeyalgorithms, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n}"
  },
  {
    "function_name": "option_clear_or_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "186-190",
    "snippet": "static int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "o",
            "\"none\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
  },
  {
    "function_name": "initialize_server_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
    "lines": "79-183",
    "snippet": "void\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"packet.h\"",
      "#include \"canohost.h\"",
      "#include \"groupaccess.h\"",
      "#include \"channels.h\"",
      "#include \"match.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"pathnames.h\"",
      "#include \"compat.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <util.h>",
      "#include <errno.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <ctype.h>",
      "#include <net/route.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
      "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "options",
            "0",
            "sizeof(*options)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}"
  }
]