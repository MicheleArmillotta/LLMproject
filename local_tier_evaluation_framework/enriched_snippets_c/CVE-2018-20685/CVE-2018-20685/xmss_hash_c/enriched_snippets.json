[
  {
    "function_name": "hash_f",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "119-139",
    "snippet": "int hash_f(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n  unsigned char buf[n];\n  unsigned char key[n];\n  unsigned char bitmask[n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);  \n  addr_to_byte(byte_addr, addr);  \n  prf(key, byte_addr, pub_seed, n);\n  \n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  \n  for (i = 0; i < n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 0, key, n, buf, n, n);\n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "core_hash_SHA2",
          "args": [
            "out",
            "0",
            "key",
            "n",
            "buf",
            "n",
            "n"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "core_hash_SHA2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "41-69",
          "snippet": "int core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prf",
          "args": [
            "bitmask",
            "byte_addr",
            "pub_seed",
            "n"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "prf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "74-77",
          "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_to_byte",
          "args": [
            "byte_addr",
            "addr"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "29-39",
          "snippet": "unsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nunsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}"
        }
      },
      {
        "call_info": {
          "callee": "setKeyAndMask",
          "args": [
            "addr",
            "1"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "setKeyAndMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "33-35",
          "snippet": "void setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_f(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n  unsigned char buf[n];\n  unsigned char key[n];\n  unsigned char bitmask[n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);  \n  addr_to_byte(byte_addr, addr);  \n  prf(key, byte_addr, pub_seed, n);\n  \n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  \n  for (i = 0; i < n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 0, key, n, buf, n, n);\n}"
  },
  {
    "function_name": "hash_h",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "94-117",
    "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "core_hash_SHA2",
          "args": [
            "out",
            "1",
            "key",
            "n",
            "buf",
            "2*n",
            "n"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "core_hash_SHA2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "41-69",
          "snippet": "int core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prf",
          "args": [
            "bitmask+n",
            "byte_addr",
            "pub_seed",
            "n"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "prf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "74-77",
          "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_to_byte",
          "args": [
            "byte_addr",
            "addr"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "29-39",
          "snippet": "unsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nunsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}"
        }
      },
      {
        "call_info": {
          "callee": "setKeyAndMask",
          "args": [
            "addr",
            "2"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "setKeyAndMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "33-35",
          "snippet": "void setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
  },
  {
    "function_name": "h_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "82-89",
    "snippet": "int h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "core_hash_SHA2",
          "args": [
            "out",
            "2",
            "key",
            "keylen",
            "in",
            "inlen",
            "n"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "core_hash_SHA2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "41-69",
          "snippet": "int core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}"
  },
  {
    "function_name": "prf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "74-77",
    "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "core_hash_SHA2",
          "args": [
            "out",
            "3",
            "key",
            "keylen",
            "in",
            "32",
            "keylen"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "core_hash_SHA2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "41-69",
          "snippet": "int core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
  },
  {
    "function_name": "core_hash_SHA2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "41-69",
    "snippet": "int core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA512",
          "args": [
            "buf",
            "inlen + keylen + n",
            "out"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "736-780",
          "snippet": "void\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHA256",
          "args": [
            "buf",
            "inlen + keylen + n",
            "out"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "SHA256_Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "455-499",
          "snippet": "void\nSHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA256_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tcontext->bitcount += freespace << 3;\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tcontext->bitcount += len << 3;\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA256_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA256_Transform(context->state, data);\n\t\tcontext->bitcount += SHA256_BLOCK_LENGTH << 3;\n\t\tlen -= SHA256_BLOCK_LENGTH;\n\t\tdata += SHA256_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tcontext->bitcount += len << 3;\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA256_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tcontext->bitcount += freespace << 3;\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tcontext->bitcount += len << 3;\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA256_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA256_Transform(context->state, data);\n\t\tcontext->bitcount += SHA256_BLOCK_LENGTH << 3;\n\t\tlen -= SHA256_BLOCK_LENGTH;\n\t\tdata += SHA256_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tcontext->bitcount += len << 3;\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "buf",
            "type",
            "n"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  // Input is (toByte(X, 32) || KEY || M) \n  \n  // set toByte\n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}"
  },
  {
    "function_name": "addr_to_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
    "lines": "29-39",
    "snippet": "unsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}",
    "includes": [
      "#include <openssl/evp.h>",
      "#include <openssl/hmac.h>",
      "#include <openssl/sha.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bytes",
            "addr",
            "32"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "bytes+i*4",
            "addr[i]",
            "4"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nunsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}"
  }
]