[
  {
    "function_name": "muxclient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "2284-2391",
    "snippet": "int\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "u_int muxclient_command = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"unrecognised muxclient_command %d\"",
            "muxclient_command"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_proxy",
          "args": [
            "sock"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "2082-2121",
          "snippet": "static int\nmux_client_proxy(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif (type != MUX_S_PROXY) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n\tmuxclient_request_id++;\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_PROXY\t\t0x8000000f",
            "#define MUX_C_PROXY\t\t0x1000000f"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_PROXY\t\t0x8000000f\n#define MUX_C_PROXY\t\t0x1000000f\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_proxy(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif (type != MUX_S_PROXY) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n\tmuxclient_request_id++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: master cancel forward request failed\"",
            "__func__"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_forwards",
          "args": [
            "sock",
            "1"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1862-1885",
          "snippet": "static int\nmux_client_forwards(int fd, int cancel_flag)\n{\n\tint i, ret = 0;\n\n\tdebug3(\"%s: %s forwardings: %d local, %d remote\", __func__,\n\t    cancel_flag ? \"cancel\" : \"request\",\n\t    options.num_local_forwards, options.num_remote_forwards);\n\n\t/* XXX ExitOnForwardingFailure */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag,\n\t\t    options.local_forwards[i].connect_port == 0 ?\n\t\t    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,\n\t\t    options.local_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,\n\t\t    options.remote_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_FWD_DYNAMIC 3",
            "#define MUX_FWD_REMOTE  2",
            "#define MUX_FWD_LOCAL   1"
          ],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic int\nmux_client_forwards(int fd, int cancel_flag)\n{\n\tint i, ret = 0;\n\n\tdebug3(\"%s: %s forwardings: %d local, %d remote\", __func__,\n\t    cancel_flag ? \"cancel\" : \"request\",\n\t    options.num_local_forwards, options.num_remote_forwards);\n\n\t/* XXX ExitOnForwardingFailure */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag,\n\t\t    options.local_forwards[i].connect_port == 0 ?\n\t\t    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,\n\t\t    options.local_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,\n\t\t    options.remote_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Stop listening request sent.\\r\\n\""
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mux_client_request_stop_listening",
          "args": [
            "sock"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_stop_listening",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "2231-2281",
          "snippet": "static void\nmux_client_request_stop_listening(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_STOP_LISTENING)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0)\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused stop listening request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: stop listening request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_S_PERMISSION_DENIED\t0x80000002",
            "#define MUX_S_OK\t\t0x80000001",
            "#define MUX_C_STOP_LISTENING\t0x10000009"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_STOP_LISTENING\t0x10000009\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_client_request_stop_listening(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_STOP_LISTENING)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0)\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused stop listening request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: stop listening request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_request_stdio_fwd",
          "args": [
            "sock"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_stdio_fwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "2123-2229",
          "snippet": "static int\nmux_client_request_stdio_fwd(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid, sid;\n\tint r, devnull;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_STDIO_FWD)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_cstring(m, options.stdio_forward_host)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.stdio_forward_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tdebug3(\"%s: stdio forward request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tdebug(\"%s: master session id: %u\", __func__, sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Master refused stdio forwarding request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Stdio forwarding request failed: %s\", e);\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tif (errno == EPIPE ||\n\t\t    (errno == EINTR && muxclient_terminate != 0))\n\t\t\treturn 0;\n\t\tfatal(\"%s: mux_client_read_packet: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\tfatal(\"%s: master returned unexpected message %u\", __func__, type);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_SESSION_OPENED\t0x80000006",
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_S_PERMISSION_DENIED\t0x80000002",
            "#define MUX_C_NEW_STDIO_FWD\t0x10000008"
          ],
          "globals_used": [
            "extern Options options;",
            "extern int stdin_null_flag;",
            "u_int muxclient_request_id = 0;",
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static u_int muxserver_pid = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_C_NEW_STDIO_FWD\t0x10000008\n\nextern Options options;\nextern int stdin_null_flag;\nu_int muxclient_request_id = 0;\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic u_int muxserver_pid = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_request_stdio_fwd(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid, sid;\n\tint r, devnull;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_STDIO_FWD)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_cstring(m, options.stdio_forward_host)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.stdio_forward_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tdebug3(\"%s: stdio forward request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tdebug(\"%s: master session id: %u\", __func__, sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Master refused stdio forwarding request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Stdio forwarding request failed: %s\", e);\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tif (errno == EPIPE ||\n\t\t    (errno == EINTR && muxclient_terminate != 0))\n\t\t\treturn 0;\n\t\tfatal(\"%s: mux_client_read_packet: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\tfatal(\"%s: master returned unexpected message %u\", __func__, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_request_session",
          "args": [
            "sock"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1887-2080",
          "snippet": "static int\nmux_client_request_session(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tconst char *term;\n\tu_int echar, rid, sid, esid, exitval, type, exitval_seen;\n\textern char **environ;\n\tint r, i, devnull, rawmode;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((term = getenv(\"TERM\")) == NULL)\n\t\tterm = \"\";\n\techar = 0xffffffff;\n\tif (options.escape_char != SSH_ESCAPECHAR_NONE)\n\t    echar = (u_int)options.escape_char;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_SESSION)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_u32(m, tty_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_x11)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_agent)) != 0 ||\n\t    (r = sshbuf_put_u32(m, subsystem_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, echar)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, term)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, command)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\t/* Pass environment */\n\tif (options.num_send_env > 0 && environ != NULL) {\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tif (!env_permitted(environ[i]))\n\t\t\t\tcontinue;\n\t\t\tif ((r = sshbuf_put_cstring(m, environ[i])) != 0)\n\t\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tif ((r = sshbuf_put_cstring(m, options.setenv[i])) != 0)\n\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDERR_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tdebug3(\"%s: session request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"Master refused session request: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"%s: session request failed: %s\", __func__, e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\trawmode = tty_flag;\n\tif (tty_flag)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t * Before it does, it is expected to write an exit message.\n\t * This process must read the value and wait for the closure of\n\t * the client_fd; if this one closes early, the multiplex master will\n\t * terminate early too (possibly losing data).\n\t */\n\tfor (exitval = 255, exitval_seen = 0;;) {\n\t\tsshbuf_reset(m);\n\t\tif (mux_client_read_packet(fd, m) != 0)\n\t\t\tbreak;\n\t\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase MUX_S_TTY_ALLOC_FAIL:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: tty alloc fail on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tleave_raw_mode(options.request_tty ==\n\t\t\t    REQUEST_TTY_FORCE);\n\t\t\trawmode = 0;\n\t\t\tcontinue;\n\t\tcase MUX_S_EXIT_MESSAGE:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: exit on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tif (exitval_seen)\n\t\t\t\tfatal(\"%s: exitval sent twice\", __func__);\n\t\t\tif ((r = sshbuf_get_u32(m, &exitval)) != 0)\n\t\t\t\tfatal(\"%s: decode exit value: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\texitval_seen = 1;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\t\tfatal(\"%s: decode error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t\t}\n\t}\n\n\tclose(fd);\n\tif (rawmode)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (muxclient_terminate) {\n\t\tdebug2(\"Exiting on signal: %s\", strsignal(muxclient_terminate));\n\t\texitval = 255;\n\t} else if (!exitval_seen) {\n\t\tdebug2(\"Control master terminated unexpectedly\");\n\t\texitval = 255;\n\t} else\n\t\tdebug2(\"Received exit status from master %d\", exitval);\n\n\tif (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)\n\t\tfprintf(stderr, \"Shared connection to %s closed.\\r\\n\", host);\n\n\texit(exitval);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_TTY_ALLOC_FAIL\t0x80000008",
            "#define MUX_S_SESSION_OPENED\t0x80000006",
            "#define MUX_S_EXIT_MESSAGE\t0x80000004",
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_S_PERMISSION_DENIED\t0x80000002",
            "#define MUX_C_NEW_SESSION\t0x10000002"
          ],
          "globals_used": [
            "extern int tty_flag;",
            "extern Options options;",
            "extern int stdin_null_flag;",
            "extern char *host;",
            "extern int subsystem_flag;",
            "extern struct sshbuf *command;",
            "u_int muxclient_request_id = 0;",
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static u_int muxserver_pid = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_C_NEW_SESSION\t0x10000002\n\nextern int tty_flag;\nextern Options options;\nextern int stdin_null_flag;\nextern char *host;\nextern int subsystem_flag;\nextern struct sshbuf *command;\nu_int muxclient_request_id = 0;\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic u_int muxserver_pid = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_request_session(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tconst char *term;\n\tu_int echar, rid, sid, esid, exitval, type, exitval_seen;\n\textern char **environ;\n\tint r, i, devnull, rawmode;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((term = getenv(\"TERM\")) == NULL)\n\t\tterm = \"\";\n\techar = 0xffffffff;\n\tif (options.escape_char != SSH_ESCAPECHAR_NONE)\n\t    echar = (u_int)options.escape_char;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_SESSION)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_u32(m, tty_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_x11)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_agent)) != 0 ||\n\t    (r = sshbuf_put_u32(m, subsystem_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, echar)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, term)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, command)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\t/* Pass environment */\n\tif (options.num_send_env > 0 && environ != NULL) {\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tif (!env_permitted(environ[i]))\n\t\t\t\tcontinue;\n\t\t\tif ((r = sshbuf_put_cstring(m, environ[i])) != 0)\n\t\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tif ((r = sshbuf_put_cstring(m, options.setenv[i])) != 0)\n\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDERR_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tdebug3(\"%s: session request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"Master refused session request: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"%s: session request failed: %s\", __func__, e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\trawmode = tty_flag;\n\tif (tty_flag)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t * Before it does, it is expected to write an exit message.\n\t * This process must read the value and wait for the closure of\n\t * the client_fd; if this one closes early, the multiplex master will\n\t * terminate early too (possibly losing data).\n\t */\n\tfor (exitval = 255, exitval_seen = 0;;) {\n\t\tsshbuf_reset(m);\n\t\tif (mux_client_read_packet(fd, m) != 0)\n\t\t\tbreak;\n\t\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase MUX_S_TTY_ALLOC_FAIL:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: tty alloc fail on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tleave_raw_mode(options.request_tty ==\n\t\t\t    REQUEST_TTY_FORCE);\n\t\t\trawmode = 0;\n\t\t\tcontinue;\n\t\tcase MUX_S_EXIT_MESSAGE:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: exit on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tif (exitval_seen)\n\t\t\t\tfatal(\"%s: exitval sent twice\", __func__);\n\t\t\tif ((r = sshbuf_get_u32(m, &exitval)) != 0)\n\t\t\t\tfatal(\"%s: decode exit value: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\texitval_seen = 1;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\t\tfatal(\"%s: decode error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t\t}\n\t}\n\n\tclose(fd);\n\tif (rawmode)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (muxclient_terminate) {\n\t\tdebug2(\"Exiting on signal: %s\", strsignal(muxclient_terminate));\n\t\texitval = 255;\n\t} else if (!exitval_seen) {\n\t\tdebug2(\"Control master terminated unexpectedly\");\n\t\texitval = 255;\n\t} else\n\t\tdebug2(\"Received exit status from master %d\", exitval);\n\n\tif (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)\n\t\tfprintf(stderr, \"Shared connection to %s closed.\\r\\n\", host);\n\n\texit(exitval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Exit request sent.\\r\\n\""
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mux_client_request_terminate",
          "args": [
            "sock"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1708-1763",
          "snippet": "static void\nmux_client_request_terminate(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_TERMINATE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\t/* Remote end exited already */\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(m);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused termination request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: termination request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_S_PERMISSION_DENIED\t0x80000002",
            "#define MUX_S_OK\t\t0x80000001",
            "#define MUX_C_TERMINATE\t\t0x10000005"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_TERMINATE\t\t0x10000005\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_client_request_terminate(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_TERMINATE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\t/* Remote end exited already */\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(m);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused termination request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: termination request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Master running (pid=%u)\\r\\n\"",
            "pid"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mux_client_request_alive",
          "args": [
            "sock"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1657-1706",
          "snippet": "static u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_ALIVE\t\t0x80000005",
            "#define MUX_C_ALIVE_CHECK\t0x10000004"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_C_ALIVE_CHECK\t0x10000004\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_hello_exchange",
          "args": [
            "sock"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_hello_exchange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1595-1655",
          "snippet": "static int\nmux_client_hello_exchange(int fd)\n{\n\tstruct sshbuf *m;\n\tu_int type, ver;\n\tint r, ret = -1;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_MSG_HELLO)) != 0 ||\n\t    (r = sshbuf_put_u32(m, SSHMUX_VER)) != 0)\n\t\tfatal(\"%s: hello: %s\", __func__, ssh_err(r));\n\t/* no extensions */\n\n\tif (mux_client_write_packet(fd, m) != 0) {\n\t\tdebug(\"%s: write packet: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(m);\n\n\t/* Read their HELLO */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tdebug(\"%s: read packet failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_MSG_HELLO) {\n\t\terror(\"%s: expected HELLO (%u) received %u\",\n\t\t    __func__, MUX_MSG_HELLO, type);\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0)\n\t\tfatal(\"%s: decode version: %s\", __func__, ssh_err(r));\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"Unsupported multiplexing protocol version %d \"\n\t\t    \"(expected %d)\", ver, SSHMUX_VER);\n\t\tgoto out;\n\t}\n\tdebug2(\"%s: master version %u\", __func__, ver);\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_skip_string(m)) != 0) { /* value */\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"Unrecognised master extension \\\"%s\\\"\", name);\n\t\tfree(name);\n\t}\n\t/* success */\n\tret = 0;\n out:\n\tsshbuf_free(m);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_MSG_HELLO\t\t0x00000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_MSG_HELLO\t\t0x00000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_hello_exchange(int fd)\n{\n\tstruct sshbuf *m;\n\tu_int type, ver;\n\tint r, ret = -1;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_MSG_HELLO)) != 0 ||\n\t    (r = sshbuf_put_u32(m, SSHMUX_VER)) != 0)\n\t\tfatal(\"%s: hello: %s\", __func__, ssh_err(r));\n\t/* no extensions */\n\n\tif (mux_client_write_packet(fd, m) != 0) {\n\t\tdebug(\"%s: write packet: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(m);\n\n\t/* Read their HELLO */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tdebug(\"%s: read packet failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_MSG_HELLO) {\n\t\terror(\"%s: expected HELLO (%u) received %u\",\n\t\t    __func__, MUX_MSG_HELLO, type);\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0)\n\t\tfatal(\"%s: decode version: %s\", __func__, ssh_err(r));\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"Unsupported multiplexing protocol version %d \"\n\t\t    \"(expected %d)\", ver, SSHMUX_VER);\n\t\tgoto out;\n\t}\n\tdebug2(\"%s: master version %u\", __func__, ver);\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_skip_string(m)) != 0) { /* value */\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"Unrecognised master extension \\\"%s\\\"\", name);\n\t\tfree(name);\n\t}\n\t/* success */\n\tret = 0;\n out:\n\tsshbuf_free(m);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "sock"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Control socket \\\"%.100s\\\" does not exist\"",
            "path"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Control socket connect(%.100s): %s\"",
            "path",
            "strerror(errno)"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "(struct sockaddr *)&addr",
            "sizeof(addr)"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "addr.sun_path",
            "path",
            "sizeof(addr.sun_path)"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "'\\0'",
            "sizeof(addr)"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_int muxclient_command = 0;\n\nint\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}"
  },
  {
    "function_name": "mux_client_request_stop_listening",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "2231-2281",
    "snippet": "static void\nmux_client_request_stop_listening(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_STOP_LISTENING)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0)\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused stop listening request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: stop listening request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002",
      "#define MUX_S_OK\t\t0x80000001",
      "#define MUX_C_STOP_LISTENING\t0x10000009"
    ],
    "globals_used": [
      "u_int muxclient_request_id = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unexpected response from master 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Master refused stop listening request: %s\"",
            "e"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&rid"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "muxclient_request_id"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: entering\"",
            "__func__"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_STOP_LISTENING\t0x10000009\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_client_request_stop_listening(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_STOP_LISTENING)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0)\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused stop listening request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: stop listening request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}"
  },
  {
    "function_name": "mux_client_request_stdio_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "2123-2229",
    "snippet": "static int\nmux_client_request_stdio_fwd(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid, sid;\n\tint r, devnull;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_STDIO_FWD)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_cstring(m, options.stdio_forward_host)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.stdio_forward_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tdebug3(\"%s: stdio forward request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tdebug(\"%s: master session id: %u\", __func__, sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Master refused stdio forwarding request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Stdio forwarding request failed: %s\", e);\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tif (errno == EPIPE ||\n\t\t    (errno == EINTR && muxclient_terminate != 0))\n\t\t\treturn 0;\n\t\tfatal(\"%s: mux_client_read_packet: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\tfatal(\"%s: master returned unexpected message %u\", __func__, type);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_SESSION_OPENED\t0x80000006",
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002",
      "#define MUX_C_NEW_STDIO_FWD\t0x10000008"
    ],
    "globals_used": [
      "extern Options options;",
      "extern int stdin_null_flag;",
      "u_int muxclient_request_id = 0;",
      "static volatile sig_atomic_t muxclient_terminate = 0;",
      "static u_int muxserver_pid = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: master returned unexpected message %u\"",
            "__func__",
            "type"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGWINCH",
            "control_client_sigrelay"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: unexpected response from master 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Stdio forwarding request failed: %s\"",
            "e"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: master session id: %u\"",
            "__func__",
            "sid"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&sid"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pledge_mux",
          "args": [],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pledge_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform-pledge.c",
          "lines": "65-71",
          "snippet": "void\nplatform_pledge_mux(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\tsolaris_drop_privs_root_pinfo_net_exec();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nplatform_pledge_mux(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\tsolaris_drop_privs_root_pinfo_net_exec();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio proc tty\"",
            "NULL"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_send_fd",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "mm_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "51-110",
          "snippet": "int\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "options.stdio_forward_port"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "options.stdio_forward_host"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "m",
            "NULL",
            "0"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devnull"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDIN_FILENO"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDONLY"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_request_alive",
          "args": [
            "fd"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1657-1706",
          "snippet": "static u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_ALIVE\t\t0x80000005",
            "#define MUX_C_ALIVE_CHECK\t0x10000004"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_C_ALIVE_CHECK\t0x10000004\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_C_NEW_STDIO_FWD\t0x10000008\n\nextern Options options;\nextern int stdin_null_flag;\nu_int muxclient_request_id = 0;\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic u_int muxserver_pid = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_request_stdio_fwd(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid, sid;\n\tint r, devnull;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_STDIO_FWD)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_cstring(m, options.stdio_forward_host)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.stdio_forward_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tdebug3(\"%s: stdio forward request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tdebug(\"%s: master session id: %u\", __func__, sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Master refused stdio forwarding request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\tfatal(\"Stdio forwarding request failed: %s\", e);\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tif (errno == EPIPE ||\n\t\t    (errno == EINTR && muxclient_terminate != 0))\n\t\t\treturn 0;\n\t\tfatal(\"%s: mux_client_read_packet: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\tfatal(\"%s: master returned unexpected message %u\", __func__, type);\n}"
  },
  {
    "function_name": "mux_client_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "2082-2121",
    "snippet": "static int\nmux_client_proxy(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif (type != MUX_S_PROXY) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n\tmuxclient_request_id++;\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_PROXY\t\t0x8000000f",
      "#define MUX_C_PROXY\t\t0x1000000f"
    ],
    "globals_used": [
      "u_int muxclient_request_id = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: done\"",
            "__func__"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: master returned error: %s\"",
            "__func__",
            "e"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&rid"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "muxclient_request_id"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_PROXY\t\t0x8000000f\n#define MUX_C_PROXY\t\t0x1000000f\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_proxy(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif (type != MUX_S_PROXY) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n\tmuxclient_request_id++;\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_client_request_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1887-2080",
    "snippet": "static int\nmux_client_request_session(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tconst char *term;\n\tu_int echar, rid, sid, esid, exitval, type, exitval_seen;\n\textern char **environ;\n\tint r, i, devnull, rawmode;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((term = getenv(\"TERM\")) == NULL)\n\t\tterm = \"\";\n\techar = 0xffffffff;\n\tif (options.escape_char != SSH_ESCAPECHAR_NONE)\n\t    echar = (u_int)options.escape_char;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_SESSION)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_u32(m, tty_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_x11)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_agent)) != 0 ||\n\t    (r = sshbuf_put_u32(m, subsystem_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, echar)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, term)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, command)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\t/* Pass environment */\n\tif (options.num_send_env > 0 && environ != NULL) {\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tif (!env_permitted(environ[i]))\n\t\t\t\tcontinue;\n\t\t\tif ((r = sshbuf_put_cstring(m, environ[i])) != 0)\n\t\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tif ((r = sshbuf_put_cstring(m, options.setenv[i])) != 0)\n\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDERR_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tdebug3(\"%s: session request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"Master refused session request: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"%s: session request failed: %s\", __func__, e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\trawmode = tty_flag;\n\tif (tty_flag)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t * Before it does, it is expected to write an exit message.\n\t * This process must read the value and wait for the closure of\n\t * the client_fd; if this one closes early, the multiplex master will\n\t * terminate early too (possibly losing data).\n\t */\n\tfor (exitval = 255, exitval_seen = 0;;) {\n\t\tsshbuf_reset(m);\n\t\tif (mux_client_read_packet(fd, m) != 0)\n\t\t\tbreak;\n\t\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase MUX_S_TTY_ALLOC_FAIL:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: tty alloc fail on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tleave_raw_mode(options.request_tty ==\n\t\t\t    REQUEST_TTY_FORCE);\n\t\t\trawmode = 0;\n\t\t\tcontinue;\n\t\tcase MUX_S_EXIT_MESSAGE:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: exit on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tif (exitval_seen)\n\t\t\t\tfatal(\"%s: exitval sent twice\", __func__);\n\t\t\tif ((r = sshbuf_get_u32(m, &exitval)) != 0)\n\t\t\t\tfatal(\"%s: decode exit value: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\texitval_seen = 1;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\t\tfatal(\"%s: decode error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t\t}\n\t}\n\n\tclose(fd);\n\tif (rawmode)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (muxclient_terminate) {\n\t\tdebug2(\"Exiting on signal: %s\", strsignal(muxclient_terminate));\n\t\texitval = 255;\n\t} else if (!exitval_seen) {\n\t\tdebug2(\"Control master terminated unexpectedly\");\n\t\texitval = 255;\n\t} else\n\t\tdebug2(\"Received exit status from master %d\", exitval);\n\n\tif (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)\n\t\tfprintf(stderr, \"Shared connection to %s closed.\\r\\n\", host);\n\n\texit(exitval);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_TTY_ALLOC_FAIL\t0x80000008",
      "#define MUX_S_SESSION_OPENED\t0x80000006",
      "#define MUX_S_EXIT_MESSAGE\t0x80000004",
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002",
      "#define MUX_C_NEW_SESSION\t0x10000002"
    ],
    "globals_used": [
      "extern int tty_flag;",
      "extern Options options;",
      "extern int stdin_null_flag;",
      "extern char *host;",
      "extern int subsystem_flag;",
      "extern struct sshbuf *command;",
      "u_int muxclient_request_id = 0;",
      "static volatile sig_atomic_t muxclient_terminate = 0;",
      "static u_int muxserver_pid = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "exitval"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Shared connection to %s closed.\\r\\n\"",
            "host"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Received exit status from master %d\"",
            "exitval"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "muxclient_terminate"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "strsignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-signal.c",
          "lines": "54-60",
          "snippet": "char *strsignal(int sig)\n{\n\tstatic char buf[16];\n\n\t(void)snprintf(buf, sizeof(buf), \"%d\", sig);\n\treturn buf;\n}",
          "includes": [
            "#include \"openbsd-compat/bsd-signal.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/bsd-signal.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include \"includes.h\"\n\nchar *strsignal(int sig)\n{\n\tstatic char buf[16];\n\n\t(void)snprintf(buf, sizeof(buf), \"%d\", sig);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: master returned error: %s\"",
            "__func__",
            "e"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&exitval"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: exitval sent twice\"",
            "__func__"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "enter_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "68-96",
          "snippet": "void\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGWINCH",
            "control_client_sigrelay"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pledge_mux",
          "args": [],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pledge_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform-pledge.c",
          "lines": "65-71",
          "snippet": "void\nplatform_pledge_mux(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\tsolaris_drop_privs_root_pinfo_net_exec();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nplatform_pledge_mux(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\tsolaris_drop_privs_root_pinfo_net_exec();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio proc tty\"",
            "NULL"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: unexpected response from master 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: session request sent\"",
            "__func__"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_send_fd",
          "args": [
            "fd",
            "STDERR_FILENO"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "mm_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "51-110",
          "snippet": "int\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: sendmsg(%d): %s\", __func__, fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: sendmsg(%d): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: sendmsg: expected sent 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "options.setenv[i]"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_permitted",
          "args": [
            "environ[i]"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "env_permitted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "244-263",
          "snippet": "static int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "m",
            "command"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "echar"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "m",
            "NULL",
            "0"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TERM\""
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDIN_FILENO"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDONLY"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_request_alive",
          "args": [
            "fd"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_request_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1657-1706",
          "snippet": "static u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_ALIVE\t\t0x80000005",
            "#define MUX_C_ALIVE_CHECK\t0x10000004"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_C_ALIVE_CHECK\t0x10000004\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_C_NEW_SESSION\t0x10000002\n\nextern int tty_flag;\nextern Options options;\nextern int stdin_null_flag;\nextern char *host;\nextern int subsystem_flag;\nextern struct sshbuf *command;\nu_int muxclient_request_id = 0;\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic u_int muxserver_pid = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_request_session(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tconst char *term;\n\tu_int echar, rid, sid, esid, exitval, type, exitval_seen;\n\textern char **environ;\n\tint r, i, devnull, rawmode;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror(\"%s: master alive request failed\", __func__);\n\t\treturn -1;\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tif (stdin_null_flag) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\tif ((term = getenv(\"TERM\")) == NULL)\n\t\tterm = \"\";\n\techar = 0xffffffff;\n\tif (options.escape_char != SSH_ESCAPECHAR_NONE)\n\t    echar = (u_int)options.escape_char;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_SESSION)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 || /* reserved */\n\t    (r = sshbuf_put_u32(m, tty_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_x11)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_agent)) != 0 ||\n\t    (r = sshbuf_put_u32(m, subsystem_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, echar)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, term)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, command)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\t/* Pass environment */\n\tif (options.num_send_env > 0 && environ != NULL) {\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tif (!env_permitted(environ[i]))\n\t\t\t\tcontinue;\n\t\t\tif ((r = sshbuf_put_cstring(m, environ[i])) != 0)\n\t\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tif ((r = sshbuf_put_cstring(m, options.setenv[i])) != 0)\n\t\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\t/* Send the stdio file descriptors */\n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDERR_FILENO) == -1)\n\t\tfatal(\"%s: send fds failed\", __func__);\n\n\tdebug3(\"%s: session request sent\", __func__);\n\n\t/* Read their reply */\n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal(\"%s: decode ID: %s\", __func__, ssh_err(r));\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"Master refused session request: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\terror(\"%s: session request failed: %s\", __func__, e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\tplatform_pledge_mux();\n\n\tsignal(SIGHUP, control_client_sighandler);\n\tsignal(SIGINT, control_client_sighandler);\n\tsignal(SIGTERM, control_client_sighandler);\n\tsignal(SIGWINCH, control_client_sigrelay);\n\n\trawmode = tty_flag;\n\tif (tty_flag)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/*\n\t * Stick around until the controlee closes the client_fd.\n\t * Before it does, it is expected to write an exit message.\n\t * This process must read the value and wait for the closure of\n\t * the client_fd; if this one closes early, the multiplex master will\n\t * terminate early too (possibly losing data).\n\t */\n\tfor (exitval = 255, exitval_seen = 0;;) {\n\t\tsshbuf_reset(m);\n\t\tif (mux_client_read_packet(fd, m) != 0)\n\t\t\tbreak;\n\t\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase MUX_S_TTY_ALLOC_FAIL:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: tty alloc fail on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tleave_raw_mode(options.request_tty ==\n\t\t\t    REQUEST_TTY_FORCE);\n\t\t\trawmode = 0;\n\t\t\tcontinue;\n\t\tcase MUX_S_EXIT_MESSAGE:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal(\"%s: decode ID: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (esid != sid)\n\t\t\t\tfatal(\"%s: exit on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\",\n\t\t\t\t    __func__, sid, esid);\n\t\t\tif (exitval_seen)\n\t\t\t\tfatal(\"%s: exitval sent twice\", __func__);\n\t\t\tif ((r = sshbuf_get_u32(m, &exitval)) != 0)\n\t\t\t\tfatal(\"%s: decode exit value: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\texitval_seen = 1;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\t\tfatal(\"%s: decode error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t\t}\n\t}\n\n\tclose(fd);\n\tif (rawmode)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (muxclient_terminate) {\n\t\tdebug2(\"Exiting on signal: %s\", strsignal(muxclient_terminate));\n\t\texitval = 255;\n\t} else if (!exitval_seen) {\n\t\tdebug2(\"Control master terminated unexpectedly\");\n\t\texitval = 255;\n\t} else\n\t\tdebug2(\"Received exit status from master %d\", exitval);\n\n\tif (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)\n\t\tfprintf(stderr, \"Shared connection to %s closed.\\r\\n\", host);\n\n\texit(exitval);\n}"
  },
  {
    "function_name": "mux_client_forwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1862-1885",
    "snippet": "static int\nmux_client_forwards(int fd, int cancel_flag)\n{\n\tint i, ret = 0;\n\n\tdebug3(\"%s: %s forwardings: %d local, %d remote\", __func__,\n\t    cancel_flag ? \"cancel\" : \"request\",\n\t    options.num_local_forwards, options.num_remote_forwards);\n\n\t/* XXX ExitOnForwardingFailure */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag,\n\t\t    options.local_forwards[i].connect_port == 0 ?\n\t\t    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,\n\t\t    options.local_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,\n\t\t    options.remote_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_FWD_DYNAMIC 3",
      "#define MUX_FWD_REMOTE  2",
      "#define MUX_FWD_LOCAL   1"
    ],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mux_client_forward",
          "args": [
            "fd",
            "cancel_flag",
            "MUX_FWD_REMOTE",
            "options.remote_forwards + i"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1765-1860",
          "snippet": "static int\nmux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)\n{\n\tstruct sshbuf *m;\n\tchar *e, *fwd_desc;\n\tconst char *lhost, *chost;\n\tu_int type, rid;\n\tint r;\n\n\tfwd_desc = format_forward(ftype, fwd);\n\tdebug(\"Requesting %s %s\",\n\t    cancel_flag ? \"cancellation of\" : \"forwarding of\", fwd_desc);\n\tfree(fwd_desc);\n\n\ttype = cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD;\n\tif (fwd->listen_path != NULL)\n\t\tlhost = fwd->listen_path;\n\telse if (fwd->listen_host == NULL)\n\t\tlhost = \"\";\n\telse if (*fwd->listen_host == '\\0')\n\t\tlhost = \"*\";\n\telse\n\t\tlhost = fwd->listen_host;\n\n\tif (fwd->connect_path != NULL)\n\t\tchost = fwd->connect_path;\n\telse if (fwd->connect_host == NULL)\n\t\tchost = \"\";\n\telse\n\t\tchost = fwd->connect_host;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, ftype)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, lhost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->listen_port)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, chost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->connect_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_REMOTE_PORT:\n\t\tif (cancel_flag)\n\t\t\tfatal(\"%s: got MUX_S_REMOTE_PORT for cancel\", __func__);\n\t\tif ((r = sshbuf_get_u32(m, &fwd->allocated_port)) != 0)\n\t\t\tfatal(\"%s: decode port: %s\", __func__, ssh_err(r));\n\t\tverbose(\"Allocated port %u for remote forward to %s:%d\",\n\t\t    fwd->allocated_port,\n\t\t    fwd->connect_host ? fwd->connect_host : \"\",\n\t\t    fwd->connect_port);\n\t\tif (muxclient_command == SSHMUX_COMMAND_FORWARD)\n\t\t\tfprintf(stdout, \"%i\\n\", fwd->allocated_port);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"Master refused forwarding request: %s\", e);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"%s: forwarding request failed: %s\", __func__, e);\n\t\treturn -1;\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\n\tmuxclient_request_id++;\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_REMOTE_PORT\t0x80000007",
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_S_PERMISSION_DENIED\t0x80000002",
            "#define MUX_S_OK\t\t0x80000001",
            "#define MUX_C_CLOSE_FWD\t\t0x10000007",
            "#define MUX_C_OPEN_FWD\t\t0x10000006"
          ],
          "globals_used": [
            "u_int muxclient_request_id = 0;",
            "u_int muxclient_command = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_CLOSE_FWD\t\t0x10000007\n#define MUX_C_OPEN_FWD\t\t0x10000006\n\nu_int muxclient_request_id = 0;\nu_int muxclient_command = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)\n{\n\tstruct sshbuf *m;\n\tchar *e, *fwd_desc;\n\tconst char *lhost, *chost;\n\tu_int type, rid;\n\tint r;\n\n\tfwd_desc = format_forward(ftype, fwd);\n\tdebug(\"Requesting %s %s\",\n\t    cancel_flag ? \"cancellation of\" : \"forwarding of\", fwd_desc);\n\tfree(fwd_desc);\n\n\ttype = cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD;\n\tif (fwd->listen_path != NULL)\n\t\tlhost = fwd->listen_path;\n\telse if (fwd->listen_host == NULL)\n\t\tlhost = \"\";\n\telse if (*fwd->listen_host == '\\0')\n\t\tlhost = \"*\";\n\telse\n\t\tlhost = fwd->listen_host;\n\n\tif (fwd->connect_path != NULL)\n\t\tchost = fwd->connect_path;\n\telse if (fwd->connect_host == NULL)\n\t\tchost = \"\";\n\telse\n\t\tchost = fwd->connect_host;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, ftype)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, lhost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->listen_port)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, chost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->connect_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_REMOTE_PORT:\n\t\tif (cancel_flag)\n\t\t\tfatal(\"%s: got MUX_S_REMOTE_PORT for cancel\", __func__);\n\t\tif ((r = sshbuf_get_u32(m, &fwd->allocated_port)) != 0)\n\t\t\tfatal(\"%s: decode port: %s\", __func__, ssh_err(r));\n\t\tverbose(\"Allocated port %u for remote forward to %s:%d\",\n\t\t    fwd->allocated_port,\n\t\t    fwd->connect_host ? fwd->connect_host : \"\",\n\t\t    fwd->connect_port);\n\t\tif (muxclient_command == SSHMUX_COMMAND_FORWARD)\n\t\t\tfprintf(stdout, \"%i\\n\", fwd->allocated_port);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"Master refused forwarding request: %s\", e);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"%s: forwarding request failed: %s\", __func__, e);\n\t\treturn -1;\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\n\tmuxclient_request_id++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s forwardings: %d local, %d remote\"",
            "__func__",
            "cancel_flag ? \"cancel\" : \"request\"",
            "options.num_local_forwards",
            "options.num_remote_forwards"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic int\nmux_client_forwards(int fd, int cancel_flag)\n{\n\tint i, ret = 0;\n\n\tdebug3(\"%s: %s forwardings: %d local, %d remote\", __func__,\n\t    cancel_flag ? \"cancel\" : \"request\",\n\t    options.num_local_forwards, options.num_remote_forwards);\n\n\t/* XXX ExitOnForwardingFailure */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag,\n\t\t    options.local_forwards[i].connect_port == 0 ?\n\t\t    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,\n\t\t    options.local_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,\n\t\t    options.remote_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_client_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1765-1860",
    "snippet": "static int\nmux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)\n{\n\tstruct sshbuf *m;\n\tchar *e, *fwd_desc;\n\tconst char *lhost, *chost;\n\tu_int type, rid;\n\tint r;\n\n\tfwd_desc = format_forward(ftype, fwd);\n\tdebug(\"Requesting %s %s\",\n\t    cancel_flag ? \"cancellation of\" : \"forwarding of\", fwd_desc);\n\tfree(fwd_desc);\n\n\ttype = cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD;\n\tif (fwd->listen_path != NULL)\n\t\tlhost = fwd->listen_path;\n\telse if (fwd->listen_host == NULL)\n\t\tlhost = \"\";\n\telse if (*fwd->listen_host == '\\0')\n\t\tlhost = \"*\";\n\telse\n\t\tlhost = fwd->listen_host;\n\n\tif (fwd->connect_path != NULL)\n\t\tchost = fwd->connect_path;\n\telse if (fwd->connect_host == NULL)\n\t\tchost = \"\";\n\telse\n\t\tchost = fwd->connect_host;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, ftype)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, lhost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->listen_port)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, chost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->connect_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_REMOTE_PORT:\n\t\tif (cancel_flag)\n\t\t\tfatal(\"%s: got MUX_S_REMOTE_PORT for cancel\", __func__);\n\t\tif ((r = sshbuf_get_u32(m, &fwd->allocated_port)) != 0)\n\t\t\tfatal(\"%s: decode port: %s\", __func__, ssh_err(r));\n\t\tverbose(\"Allocated port %u for remote forward to %s:%d\",\n\t\t    fwd->allocated_port,\n\t\t    fwd->connect_host ? fwd->connect_host : \"\",\n\t\t    fwd->connect_port);\n\t\tif (muxclient_command == SSHMUX_COMMAND_FORWARD)\n\t\t\tfprintf(stdout, \"%i\\n\", fwd->allocated_port);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"Master refused forwarding request: %s\", e);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"%s: forwarding request failed: %s\", __func__, e);\n\t\treturn -1;\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\n\tmuxclient_request_id++;\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_REMOTE_PORT\t0x80000007",
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002",
      "#define MUX_S_OK\t\t0x80000001",
      "#define MUX_C_CLOSE_FWD\t\t0x10000007",
      "#define MUX_C_OPEN_FWD\t\t0x10000006"
    ],
    "globals_used": [
      "u_int muxclient_request_id = 0;",
      "u_int muxclient_command = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unexpected response from master 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: forwarding request failed: %s\"",
            "__func__",
            "e"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%i\\n\"",
            "fwd->allocated_port"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Allocated port %u for remote forward to %s:%d\"",
            "fwd->allocated_port",
            "fwd->connect_host ? fwd->connect_host : \"\"",
            "fwd->connect_port"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&fwd->allocated_port"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: got MUX_S_REMOTE_PORT for cancel\"",
            "__func__"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "fwd->connect_port"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "chost"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fwd_desc"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Requesting %s %s\"",
            "cancel_flag ? \"cancellation of\" : \"forwarding of\"",
            "fwd_desc"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_forward",
          "args": [
            "ftype",
            "fwd"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "format_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "540-574",
          "snippet": "static char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_FWD_DYNAMIC 3",
            "#define MUX_FWD_REMOTE  2",
            "#define MUX_FWD_LOCAL   1"
          ],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_CLOSE_FWD\t\t0x10000007\n#define MUX_C_OPEN_FWD\t\t0x10000006\n\nu_int muxclient_request_id = 0;\nu_int muxclient_command = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)\n{\n\tstruct sshbuf *m;\n\tchar *e, *fwd_desc;\n\tconst char *lhost, *chost;\n\tu_int type, rid;\n\tint r;\n\n\tfwd_desc = format_forward(ftype, fwd);\n\tdebug(\"Requesting %s %s\",\n\t    cancel_flag ? \"cancellation of\" : \"forwarding of\", fwd_desc);\n\tfree(fwd_desc);\n\n\ttype = cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD;\n\tif (fwd->listen_path != NULL)\n\t\tlhost = fwd->listen_path;\n\telse if (fwd->listen_host == NULL)\n\t\tlhost = \"\";\n\telse if (*fwd->listen_host == '\\0')\n\t\tlhost = \"*\";\n\telse\n\t\tlhost = fwd->listen_host;\n\n\tif (fwd->connect_path != NULL)\n\t\tchost = fwd->connect_path;\n\telse if (fwd->connect_host == NULL)\n\t\tchost = \"\";\n\telse\n\t\tchost = fwd->connect_host;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, ftype)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, lhost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->listen_port)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, chost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->connect_port)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_REMOTE_PORT:\n\t\tif (cancel_flag)\n\t\t\tfatal(\"%s: got MUX_S_REMOTE_PORT for cancel\", __func__);\n\t\tif ((r = sshbuf_get_u32(m, &fwd->allocated_port)) != 0)\n\t\t\tfatal(\"%s: decode port: %s\", __func__, ssh_err(r));\n\t\tverbose(\"Allocated port %u for remote forward to %s:%d\",\n\t\t    fwd->allocated_port,\n\t\t    fwd->connect_host ? fwd->connect_host : \"\",\n\t\t    fwd->connect_port);\n\t\tif (muxclient_command == SSHMUX_COMMAND_FORWARD)\n\t\t\tfprintf(stdout, \"%i\\n\", fwd->allocated_port);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"Master refused forwarding request: %s\", e);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(m);\n\t\terror(\"%s: forwarding request failed: %s\", __func__, e);\n\t\treturn -1;\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\n\tmuxclient_request_id++;\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_client_request_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1708-1763",
    "snippet": "static void\nmux_client_request_terminate(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_TERMINATE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\t/* Remote end exited already */\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(m);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused termination request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: termination request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002",
      "#define MUX_S_OK\t\t0x80000001",
      "#define MUX_C_TERMINATE\t\t0x10000005"
    ],
    "globals_used": [
      "u_int muxclient_request_id = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unexpected response from master 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Master refused termination request: %s\"",
            "e"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&rid"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "muxclient_request_id"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: entering\"",
            "__func__"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_OK\t\t0x80000001\n#define MUX_C_TERMINATE\t\t0x10000005\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_client_request_terminate(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_TERMINATE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\t/* Remote end exited already */\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(m);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"%s: read from master failed: %s\",\n\t\t    __func__, strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"Master refused termination request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: termination request failed: %s\", __func__, e);\n\tdefault:\n\t\tfatal(\"%s: unexpected response from master 0x%08x\",\n\t\t    __func__, type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}"
  },
  {
    "function_name": "mux_client_request_alive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1657-1706",
    "snippet": "static u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_ALIVE\t\t0x80000005",
      "#define MUX_C_ALIVE_CHECK\t0x10000004"
    ],
    "globals_used": [
      "u_int muxclient_request_id = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: done pid = %u\"",
            "__func__",
            "pid"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: decode PID: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&pid"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&e",
            "NULL"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "muxclient_request_id"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_C_ALIVE_CHECK\t0x10000004\n\nu_int muxclient_request_id = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3(\"%s: entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal(\"%s: request: %s\", __func__, ssh_err(r));\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal(\"%s: write packet: %s\", __func__, strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t/* Read their reply */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal(\"%s: decode error: %s\", __func__, ssh_err(r));\n\t\tfatal(\"%s: master returned error: %s\", __func__, e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal(\"%s: decode remote ID: %s\", __func__, ssh_err(r));\n\tif (rid != muxclient_request_id)\n\t\tfatal(\"%s: out of sequence reply: my id %u theirs %u\",\n\t\t    __func__, muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal(\"%s: decode PID: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done pid = %u\", __func__, pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}"
  },
  {
    "function_name": "mux_client_hello_exchange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1595-1655",
    "snippet": "static int\nmux_client_hello_exchange(int fd)\n{\n\tstruct sshbuf *m;\n\tu_int type, ver;\n\tint r, ret = -1;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_MSG_HELLO)) != 0 ||\n\t    (r = sshbuf_put_u32(m, SSHMUX_VER)) != 0)\n\t\tfatal(\"%s: hello: %s\", __func__, ssh_err(r));\n\t/* no extensions */\n\n\tif (mux_client_write_packet(fd, m) != 0) {\n\t\tdebug(\"%s: write packet: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(m);\n\n\t/* Read their HELLO */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tdebug(\"%s: read packet failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_MSG_HELLO) {\n\t\terror(\"%s: expected HELLO (%u) received %u\",\n\t\t    __func__, MUX_MSG_HELLO, type);\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0)\n\t\tfatal(\"%s: decode version: %s\", __func__, ssh_err(r));\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"Unsupported multiplexing protocol version %d \"\n\t\t    \"(expected %d)\", ver, SSHMUX_VER);\n\t\tgoto out;\n\t}\n\tdebug2(\"%s: master version %u\", __func__, ver);\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_skip_string(m)) != 0) { /* value */\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"Unrecognised master extension \\\"%s\\\"\", name);\n\t\tfree(name);\n\t}\n\t/* success */\n\tret = 0;\n out:\n\tsshbuf_free(m);\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_MSG_HELLO\t\t0x00000001"
    ],
    "globals_used": [
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Unrecognised master extension \\\"%s\\\"\"",
            "name"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: malformed extension: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "m"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&name",
            "NULL"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "m"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: decode version: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&ver"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: expected HELLO (%u) received %u\"",
            "__func__",
            "MUX_MSG_HELLO",
            "type"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: read packet failed\"",
            "__func__"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1562-1593",
          "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_write_packet",
          "args": [
            "fd",
            "m"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_write_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1508-1560",
          "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "SSHMUX_VER"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_MSG_HELLO\t\t0x00000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_hello_exchange(int fd)\n{\n\tstruct sshbuf *m;\n\tu_int type, ver;\n\tint r, ret = -1;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_MSG_HELLO)) != 0 ||\n\t    (r = sshbuf_put_u32(m, SSHMUX_VER)) != 0)\n\t\tfatal(\"%s: hello: %s\", __func__, ssh_err(r));\n\t/* no extensions */\n\n\tif (mux_client_write_packet(fd, m) != 0) {\n\t\tdebug(\"%s: write packet: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(m);\n\n\t/* Read their HELLO */\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tdebug(\"%s: read packet failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal(\"%s: decode type: %s\", __func__, ssh_err(r));\n\tif (type != MUX_MSG_HELLO) {\n\t\terror(\"%s: expected HELLO (%u) received %u\",\n\t\t    __func__, MUX_MSG_HELLO, type);\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0)\n\t\tfatal(\"%s: decode version: %s\", __func__, ssh_err(r));\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"Unsupported multiplexing protocol version %d \"\n\t\t    \"(expected %d)\", ver, SSHMUX_VER);\n\t\tgoto out;\n\t}\n\tdebug2(\"%s: master version %u\", __func__, ver);\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_skip_string(m)) != 0) { /* value */\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"Unrecognised master extension \\\"%s\\\"\", name);\n\t\tfree(name);\n\t}\n\t/* success */\n\tret = 0;\n out:\n\tsshbuf_free(m);\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_client_read_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1562-1593",
    "snippet": "static int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "queue"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "m",
            "ptr",
            "have"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "queue",
            "&ptr",
            "&have"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: read body failed: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_client_read",
          "args": [
            "fd",
            "queue",
            "need"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1466-1506",
          "snippet": "static int\nmux_client_read(int fd, struct sshbuf *b, size_t need)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tstruct pollfd pfd;\n\tint r;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t muxclient_terminate = 0;",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read(int fd, struct sshbuf *b, size_t need)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tstruct pollfd pfd;\n\tint r;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "sshbuf_ptr(queue)"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "queue"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (mux_client_read(fd, queue, 4) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3(\"%s: read header failed: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need) != 0) {\n\t\toerrno = errno;\n\t\tdebug3(\"%s: read body failed: %s\", __func__, strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(queue);\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_client_write_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1508-1560",
    "snippet": "static int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t muxclient_terminate = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "queue"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "-1"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "ptr + have",
            "need - have"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "queue"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "queue"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_put_stringb: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "queue",
            "m"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_client_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1466-1506",
    "snippet": "static int\nmux_client_read(int fd, struct sshbuf *b, size_t need)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tstruct pollfd pfd;\n\tint r;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t muxclient_terminate = 0;",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "-1"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "p + have",
            "need - have"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "mux_client_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1466-1506",
          "snippet": "static int\nmux_client_read(int fd, struct sshbuf *b, size_t need)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tstruct pollfd pfd;\n\tint r;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reserve: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "b",
            "need",
            "&p"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_client_read(int fd, struct sshbuf *b, size_t need)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tstruct pollfd pfd;\n\tint r;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLIN;\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal(\"%s: reserve: %s\", __func__, ssh_err(r));\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len < 0) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "control_client_sigrelay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1455-1464",
    "snippet": "static void\ncontrol_client_sigrelay(int signo)\n{\n\tint save_errno = errno;\n\n\tif (muxserver_pid > 1)\n\t\tkill(muxserver_pid, signo);\n\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int muxserver_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "muxserver_pid",
            "signo"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int muxserver_pid = 0;\n\nstatic void\ncontrol_client_sigrelay(int signo)\n{\n\tint save_errno = errno;\n\n\tif (muxserver_pid > 1)\n\t\tkill(muxserver_pid, signo);\n\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "control_client_sighandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1445-1449",
    "snippet": "static void\ncontrol_client_sighandler(int signo)\n{\n\tmuxclient_terminate = signo;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t muxclient_terminate = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t muxclient_terminate = 0;\n\nstatic void\ncontrol_client_sighandler(int signo)\n{\n\tmuxclient_terminate = signo;\n}"
  },
  {
    "function_name": "mux_session_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1361-1440",
    "snippet": "static void\nmux_session_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_session_confirm_ctx *cctx = arg;\n\tconst char *display;\n\tChannel *c, *cc;\n\tint i, r;\n\tstruct sshbuf *reply;\n\n\tif (cctx == NULL)\n\t\tfatal(\"%s: cctx == NULL\", __func__);\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal(\"%s: no channel for id %d\", __func__, id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d lacks control channel %d\", __func__,\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tif (!success) {\n\t\tdebug3(\"%s: sending failure reply\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\tgoto done;\n\t}\n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (cctx->want_x_fwd && options.forward_x11 && display != NULL) {\n\t\tchar *proto, *data;\n\n\t\t/* Get reasonable local authentication information. */\n\t\tif (client_x11_get_proto(ssh, display, options.xauth_location,\n\t\t    options.forward_x11_trusted, options.forward_x11_timeout,\n\t\t    &proto, &data) == 0) {\n\t\t\t/* Request forwarding with authentication spoofing. */\n\t\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t\t    \"spoofing.\");\n\t\t\tx11_request_forwarding_with_spoofing(ssh, id,\n\t\t\t    display, proto, data, 1);\n\t\t\t/* XXX exit_on_forward_failure */\n\t\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\",\n\t\t\t    CONFIRM_WARN);\n\t\t}\n\t}\n\n\tif (cctx->want_agent_fwd && options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tpacket_send();\n\t}\n\n\tclient_session2_setup(ssh, id, cctx->want_tty, cctx->want_subsys,\n\t    cctx->term, &cctx->tio, c->rfd, cctx->cmd, cctx->env);\n\n\tdebug3(\"%s: sending success reply\", __func__);\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n done:\n\t/* Send reply */\n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, cc->mux_pause);\n\tcc->mux_pause = 0; /* start processing messages again */\n\tc->open_confirm_ctx = NULL;\n\tsshbuf_free(cctx->cmd);\n\tfree(cctx->term);\n\tif (cctx->env != NULL) {\n\t\tfor (i = 0; cctx->env[i] != NULL; i++)\n\t\t\tfree(cctx->env[i]);\n\t\tfree(cctx->env);\n\t}\n\tfree(cctx);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_SESSION_OPENED\t0x80000006",
      "#define MUX_S_FAILURE\t\t0x80000003"
    ],
    "globals_used": [
      "extern Options options;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cctx"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "cctx->cmd"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: mux_pause %d\"",
            "__func__",
            "cc->mux_pause"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "cc->output",
            "reply"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "c->self"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending success reply\"",
            "__func__"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_session2_setup",
          "args": [
            "ssh",
            "id",
            "cctx->want_tty",
            "cctx->want_subsys",
            "cctx->term",
            "&cctx->tio",
            "c->rfd",
            "cctx->cmd",
            "cctx->env"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "client_session2_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2193-2305",
          "snippet": "void\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nvoid\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "id",
            "\"auth-agent-req@openssh.com\"",
            "0"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_expect_confirm",
          "args": [
            "ssh",
            "id",
            "\"X11 forwarding\"",
            "CONFIRM_WARN"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "client_expect_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "734-745",
          "snippet": "void\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_request_forwarding_with_spoofing",
          "args": [
            "ssh",
            "id",
            "display",
            "proto",
            "data",
            "1"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "x11_request_forwarding_with_spoofing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4816-4876",
          "snippet": "void\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_x11_get_proto",
          "args": [
            "ssh",
            "display",
            "options.xauth_location",
            "options.forward_x11_trusted",
            "options.forward_x11_timeout",
            "&proto",
            "&data"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "client_x11_get_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "277-441",
          "snippet": "int\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define X11_TIMEOUT_SLACK\t60",
            "#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\""
          ],
          "globals_used": [
            "static u_int x11_refuse_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define X11_TIMEOUT_SLACK\t60\n#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\"\n\nstatic u_int x11_refuse_time;\n\nint\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_FAILURE",
            "cctx->rid",
            "\"Session open refused by peer\""
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->ctl_chan"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_FAILURE\t\t0x80000003\n\nextern Options options;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_session_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_session_confirm_ctx *cctx = arg;\n\tconst char *display;\n\tChannel *c, *cc;\n\tint i, r;\n\tstruct sshbuf *reply;\n\n\tif (cctx == NULL)\n\t\tfatal(\"%s: cctx == NULL\", __func__);\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal(\"%s: no channel for id %d\", __func__, id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d lacks control channel %d\", __func__,\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tif (!success) {\n\t\tdebug3(\"%s: sending failure reply\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\tgoto done;\n\t}\n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (cctx->want_x_fwd && options.forward_x11 && display != NULL) {\n\t\tchar *proto, *data;\n\n\t\t/* Get reasonable local authentication information. */\n\t\tif (client_x11_get_proto(ssh, display, options.xauth_location,\n\t\t    options.forward_x11_trusted, options.forward_x11_timeout,\n\t\t    &proto, &data) == 0) {\n\t\t\t/* Request forwarding with authentication spoofing. */\n\t\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t\t    \"spoofing.\");\n\t\t\tx11_request_forwarding_with_spoofing(ssh, id,\n\t\t\t    display, proto, data, 1);\n\t\t\t/* XXX exit_on_forward_failure */\n\t\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\",\n\t\t\t    CONFIRM_WARN);\n\t\t}\n\t}\n\n\tif (cctx->want_agent_fwd && options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tpacket_send();\n\t}\n\n\tclient_session2_setup(ssh, id, cctx->want_tty, cctx->want_subsys,\n\t    cctx->term, &cctx->tio, c->rfd, cctx->cmd, cctx->env);\n\n\tdebug3(\"%s: sending success reply\", __func__);\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n done:\n\t/* Send reply */\n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, cc->mux_pause);\n\tcc->mux_pause = 0; /* start processing messages again */\n\tc->open_confirm_ctx = NULL;\n\tsshbuf_free(cctx->cmd);\n\tfree(cctx->term);\n\tif (cctx->env != NULL) {\n\t\tfor (i = 0; cctx->env[i] != NULL; i++)\n\t\t\tfree(cctx->env[i]);\n\t\tfree(cctx->env);\n\t}\n\tfree(cctx);\n}"
  },
  {
    "function_name": "muxserver_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1277-1358",
    "snippet": "void\nmuxserver_listen(struct ssh *ssh)\n{\n\tmode_t old_umask;\n\tchar *orig_control_path = options.control_path;\n\tchar rbuf[16+1];\n\tu_int i, r;\n\tint oerrno;\n\n\tif (options.control_path == NULL ||\n\t    options.control_master == SSHCTL_MASTER_NO)\n\t\treturn;\n\n\tdebug(\"setting up multiplex master socket\");\n\n\t/*\n\t * Use a temporary path before listen so we can pseudo-atomically\n\t * establish the listening socket in its final location to avoid\n\t * other processes racing in between bind() and listen() and hitting\n\t * an unready socket.\n\t */\n\tfor (i = 0; i < sizeof(rbuf) - 1; i++) {\n\t\tr = arc4random_uniform(26+26+10);\n\t\trbuf[i] = (r < 26) ? 'a' + r :\n\t\t    (r < 26*2) ? 'A' + r - 26 :\n\t\t    '0' + r - 26 - 26;\n\t}\n\trbuf[sizeof(rbuf) - 1] = '\\0';\n\toptions.control_path = NULL;\n\txasprintf(&options.control_path, \"%s.%s\", orig_control_path, rbuf);\n\tdebug3(\"%s: temporary control path %s\", __func__, options.control_path);\n\n\told_umask = umask(0177);\n\tmuxserver_sock = unix_listener(options.control_path, 64, 0);\n\toerrno = errno;\n\tumask(old_umask);\n\tif (muxserver_sock < 0) {\n\t\tif (oerrno == EINVAL || oerrno == EADDRINUSE) {\n\t\t\terror(\"ControlSocket %s already exists, \"\n\t\t\t    \"disabling multiplexing\", options.control_path);\n disable_mux_master:\n\t\t\tif (muxserver_sock != -1) {\n\t\t\t\tclose(muxserver_sock);\n\t\t\t\tmuxserver_sock = -1;\n\t\t\t}\n\t\t\tfree(orig_control_path);\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = NULL;\n\t\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* unix_listener() logs the error */\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Now atomically \"move\" the mux socket into position */\n\tif (link(options.control_path, orig_control_path) != 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tfatal(\"%s: link mux listener %s => %s: %s\", __func__,\n\t\t\t    options.control_path, orig_control_path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\terror(\"ControlSocket %s already exists, disabling multiplexing\",\n\t\t    orig_control_path);\n\t\tunlink(options.control_path);\n\t\tgoto disable_mux_master;\n\t}\n\tunlink(options.control_path);\n\tfree(options.control_path);\n\toptions.control_path = orig_control_path;\n\n\tset_nonblock(muxserver_sock);\n\n\tmux_listener_channel = channel_new(ssh, \"mux listener\",\n\t    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, options.control_path, 1);\n\tmux_listener_channel->mux_rcb = mux_master_read_cb;\n\tdebug3(\"%s: mux listener channel %d fd %d\", __func__,\n\t    mux_listener_channel->self, mux_listener_channel->sock);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int muxserver_sock = -1;",
      "static Channel *mux_listener_channel = NULL;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: mux listener channel %d fd %d\"",
            "__func__",
            "mux_listener_channel->self",
            "mux_listener_channel->sock"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"mux listener\"",
            "SSH_CHANNEL_MUX_LISTENER",
            "muxserver_sock",
            "muxserver_sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "options.control_path",
            "1"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "muxserver_sock"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.control_path"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.control_path"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.control_path"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ControlSocket %s already exists, disabling multiplexing\"",
            "orig_control_path"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: link mux listener %s => %s: %s\"",
            "__func__",
            "options.control_path",
            "orig_control_path",
            "strerror(errno)"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link",
          "args": [
            "options.control_path",
            "orig_control_path"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "do_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1026-1079",
          "snippet": "char *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "muxserver_sock"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_listener",
          "args": [
            "options.control_path",
            "64",
            "0"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "unix_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1487-1532",
          "snippet": "int\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0177"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&options.control_path",
            "\"%s.%s\"",
            "orig_control_path",
            "rbuf"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_uniform",
          "args": [
            "26+26+10"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_uniform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "291-315",
          "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint muxserver_sock = -1;\nstatic Channel *mux_listener_channel = NULL;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\n\nvoid\nmuxserver_listen(struct ssh *ssh)\n{\n\tmode_t old_umask;\n\tchar *orig_control_path = options.control_path;\n\tchar rbuf[16+1];\n\tu_int i, r;\n\tint oerrno;\n\n\tif (options.control_path == NULL ||\n\t    options.control_master == SSHCTL_MASTER_NO)\n\t\treturn;\n\n\tdebug(\"setting up multiplex master socket\");\n\n\t/*\n\t * Use a temporary path before listen so we can pseudo-atomically\n\t * establish the listening socket in its final location to avoid\n\t * other processes racing in between bind() and listen() and hitting\n\t * an unready socket.\n\t */\n\tfor (i = 0; i < sizeof(rbuf) - 1; i++) {\n\t\tr = arc4random_uniform(26+26+10);\n\t\trbuf[i] = (r < 26) ? 'a' + r :\n\t\t    (r < 26*2) ? 'A' + r - 26 :\n\t\t    '0' + r - 26 - 26;\n\t}\n\trbuf[sizeof(rbuf) - 1] = '\\0';\n\toptions.control_path = NULL;\n\txasprintf(&options.control_path, \"%s.%s\", orig_control_path, rbuf);\n\tdebug3(\"%s: temporary control path %s\", __func__, options.control_path);\n\n\told_umask = umask(0177);\n\tmuxserver_sock = unix_listener(options.control_path, 64, 0);\n\toerrno = errno;\n\tumask(old_umask);\n\tif (muxserver_sock < 0) {\n\t\tif (oerrno == EINVAL || oerrno == EADDRINUSE) {\n\t\t\terror(\"ControlSocket %s already exists, \"\n\t\t\t    \"disabling multiplexing\", options.control_path);\n disable_mux_master:\n\t\t\tif (muxserver_sock != -1) {\n\t\t\t\tclose(muxserver_sock);\n\t\t\t\tmuxserver_sock = -1;\n\t\t\t}\n\t\t\tfree(orig_control_path);\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = NULL;\n\t\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* unix_listener() logs the error */\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Now atomically \"move\" the mux socket into position */\n\tif (link(options.control_path, orig_control_path) != 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tfatal(\"%s: link mux listener %s => %s: %s\", __func__,\n\t\t\t    options.control_path, orig_control_path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\terror(\"ControlSocket %s already exists, disabling multiplexing\",\n\t\t    orig_control_path);\n\t\tunlink(options.control_path);\n\t\tgoto disable_mux_master;\n\t}\n\tunlink(options.control_path);\n\tfree(options.control_path);\n\toptions.control_path = orig_control_path;\n\n\tset_nonblock(muxserver_sock);\n\n\tmux_listener_channel = channel_new(ssh, \"mux listener\",\n\t    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, options.control_path, 1);\n\tmux_listener_channel->mux_rcb = mux_master_read_cb;\n\tdebug3(\"%s: mux listener channel %d fd %d\", __func__,\n\t    mux_listener_channel->self, mux_listener_channel->sock);\n}"
  },
  {
    "function_name": "mux_tty_alloc_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1253-1274",
    "snippet": "void\nmux_tty_alloc_failed(struct ssh *ssh, Channel *c)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: TTY alloc failed\", __func__, c->self);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_TTY_ALLOC_FAIL)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_TTY_ALLOC_FAIL\t0x80000008"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "mux_chan->output",
            "m"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "c->self"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->ctl_chan"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel %d: TTY alloc failed\"",
            "__func__",
            "c->self"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nvoid\nmux_tty_alloc_failed(struct ssh *ssh, Channel *c)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: TTY alloc failed\", __func__, c->self);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_TTY_ALLOC_FAIL)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}"
  },
  {
    "function_name": "mux_exit_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1228-1251",
    "snippet": "void\nmux_exit_message(struct ssh *ssh, Channel *c, int exitval)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: exit message, exitval %d\", __func__, c->self,\n\t    exitval);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_EXIT_MESSAGE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_u32(m, exitval)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_EXIT_MESSAGE\t0x80000004"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "mux_chan->output",
            "m"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "exitval"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->ctl_chan"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel %d: exit message, exitval %d\"",
            "__func__",
            "c->self",
            "exitval"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nvoid\nmux_exit_message(struct ssh *ssh, Channel *c, int exitval)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: exit message, exitval %d\", __func__, c->self,\n\t    exitval);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_EXIT_MESSAGE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_u32(m, exitval)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}"
  },
  {
    "function_name": "mux_master_read_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1149-1226",
    "snippet": "static int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_MSG_HELLO\t\t0x00000001"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "out"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_put_stringb: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "c->output",
            "out"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "out"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "out",
            "MUX_S_FAILURE",
            "rid",
            "\"unsupported request\""
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: unsupported mux message 0x%08x\"",
            "__func__",
            "type"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_master_handlers[i].handler",
          "args": [
            "ssh",
            "rid",
            "c",
            "in",
            "out"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "in",
            "&rid"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel %d packet type 0x%08x len %zu\"",
            "__func__",
            "c->self",
            "type",
            "sshbuf_len(in)"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "c->input",
            "&in"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "out",
            "SSHMUX_VER"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "c->self",
            "mux_master_control_cleanup_cb",
            "0"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*state)"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_MSG_HELLO\t\t0x00000001\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};\n\nstatic int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_master_process_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1132-1146",
    "snippet": "static int\nmux_master_process_proxy(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug(\"%s: channel %d: proxy request\", __func__, c->self);\n\n\tc->mux_rcb = channel_proxy_downstream;\n\tif ((r = sshbuf_put_u32(reply, MUX_S_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_PROXY\t\t0x8000000f"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "rid"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: channel %d: proxy request\"",
            "__func__",
            "c->self"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_PROXY\t\t0x8000000f\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_proxy(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug(\"%s: channel %d: proxy request\", __func__, c->self);\n\n\tc->mux_rcb = channel_proxy_downstream;\n\tif ((r = sshbuf_put_u32(reply, MUX_S_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_master_process_stop_listening",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1102-1130",
    "snippet": "static int\nmux_master_process_stop_listening(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug(\"%s: channel %d: stop listening\", __func__, c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Disable further multiplexing on shared \"\n\t\t    \"connection to %s? \", host)) {\n\t\t\tdebug2(\"%s: stop listen refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (mux_listener_channel != NULL) {\n\t\tchannel_free(ssh, mux_listener_channel);\n\t\tclient_stop_mux();\n\t\tfree(options.control_path);\n\t\toptions.control_path = NULL;\n\t\tmux_listener_channel = NULL;\n\t\tmuxserver_sock = -1;\n\t}\n\n\treply_ok(reply, rid);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_PERMISSION_DENIED\t0x80000002"
    ],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "int muxserver_sock = -1;",
      "static Channel *mux_listener_channel = NULL;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reply_ok",
          "args": [
            "reply",
            "rid"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "reply_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "312-320",
          "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_OK\t\t0x80000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.control_path"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_stop_mux",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "client_stop_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2333-2346",
          "snippet": "void\nclient_stop_mux(void)\n{\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\t/*\n\t * If we are in persist mode, or don't have a shell, signal that we\n\t * should close when all active channels are closed.\n\t */\n\tif (options.control_persist || no_shell_flag) {\n\t\tsession_closed = 1;\n\t\tsetproctitle(\"[stopped mux]\");\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int no_shell_flag;",
            "extern int muxserver_sock;",
            "static int session_closed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int no_shell_flag;\nextern int muxserver_sock;\nstatic int session_closed;\n\nvoid\nclient_stop_mux(void)\n{\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\t/*\n\t * If we are in persist mode, or don't have a shell, signal that we\n\t * should close when all active channels are closed.\n\t */\n\tif (options.control_persist || no_shell_flag) {\n\t\tsession_closed = 1;\n\t\tsetproctitle(\"[stopped mux]\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "mux_listener_channel"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_PERMISSION_DENIED",
            "rid",
            "\"Permission denied\""
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: stop listen refused by user\"",
            "__func__"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Disable further multiplexing on shared \"\n\t\t    \"connection to %s? \"",
            "host"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: channel %d: stop listening\"",
            "__func__",
            "c->self"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n\nextern Options options;\nextern char *host;\nint muxserver_sock = -1;\nstatic Channel *mux_listener_channel = NULL;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_stop_listening(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug(\"%s: channel %d: stop listening\", __func__, c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Disable further multiplexing on shared \"\n\t\t    \"connection to %s? \", host)) {\n\t\t\tdebug2(\"%s: stop listen refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (mux_listener_channel != NULL) {\n\t\tchannel_free(ssh, mux_listener_channel);\n\t\tclient_stop_mux();\n\t\tfree(options.control_path);\n\t\toptions.control_path = NULL;\n\t\tmux_listener_channel = NULL;\n\t\tmuxserver_sock = -1;\n\t}\n\n\treply_ok(reply, rid);\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_stdio_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "1056-1100",
    "snippet": "static void\nmux_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_stdio_confirm_ctx *cctx = arg;\n\tChannel *c, *cc;\n\tstruct sshbuf *reply;\n\tint r;\n\n\tif (cctx == NULL)\n\t\tfatal(\"%s: cctx == NULL\", __func__);\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal(\"%s: no channel for id %d\", __func__, id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d lacks control channel %d\", __func__,\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tif (!success) {\n\t\tdebug3(\"%s: sending failure reply\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\t/* prepare reply */\n\t\tgoto done;\n\t}\n\n\tdebug3(\"%s: sending success reply\", __func__);\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n done:\n\t/* Send reply */\n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, cc->mux_pause);\n\tcc->mux_pause = 0; /* start processing messages again */\n\tc->open_confirm_ctx = NULL;\n\tfree(cctx);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_SESSION_OPENED\t0x80000006",
      "#define MUX_S_FAILURE\t\t0x80000003"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cctx"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: mux_pause %d\"",
            "__func__",
            "cc->mux_pause"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "reply"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "cc->output",
            "reply"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "c->self"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sending success reply\"",
            "__func__"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_FAILURE",
            "cctx->rid",
            "\"Session open refused by peer\""
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->ctl_chan"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_FAILURE\t\t0x80000003\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_stdio_confirm_ctx *cctx = arg;\n\tChannel *c, *cc;\n\tstruct sshbuf *reply;\n\tint r;\n\n\tif (cctx == NULL)\n\t\tfatal(\"%s: cctx == NULL\", __func__);\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal(\"%s: no channel for id %d\", __func__, id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d lacks control channel %d\", __func__,\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tif (!success) {\n\t\tdebug3(\"%s: sending failure reply\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\t/* prepare reply */\n\t\tgoto done;\n\t}\n\n\tdebug3(\"%s: sending success reply\", __func__);\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n done:\n\t/* Send reply */\n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, cc->mux_pause);\n\tcc->mux_pause = 0; /* start processing messages again */\n\tc->open_confirm_ctx = NULL;\n\tfree(cctx);\n}"
  },
  {
    "function_name": "mux_master_process_stdio_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "964-1053",
    "snippet": "static int\nmux_master_process_stdio_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tchar *chost = NULL;\n\tu_int cport, i, j;\n\tint r, new_fd[2];\n\tstruct mux_stdio_confirm_ctx *cctx;\n\n\tif ((r = sshbuf_skip_string(m)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0) {\n\t\tfree(chost);\n\t\terror(\"%s: malformed message\", __func__);\n\t\treturn -1;\n\t}\n\n\tdebug2(\"%s: channel %d: request stdio fwd to %s:%u\",\n\t    __func__, c->self, chost, cport);\n\n\t/* Gather fds from client */\n\tfor(i = 0; i < 2; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror(\"%s: failed to receive fd %d from slave\",\n\t\t\t    __func__, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfree(chost);\n\n\t\t\t/* prepare reply */\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3(\"%s: got fds stdin %d, stdout %d\", __func__,\n\t    new_fd[0], new_fd[1]);\n\n\t/* XXX support multiple child sessions in future */\n\tif (c->have_remote_id) {\n\t\tdebug2(\"%s: session already open\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tfree(chost);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Allow forward to %s:%u? \",\n\t\t    chost, cport)) {\n\t\t\tdebug2(\"%s: stdio fwd refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(new_fd[0]))\n\t\tset_nonblock(new_fd[0]);\n\tif (!isatty(new_fd[1]))\n\t\tset_nonblock(new_fd[1]);\n\n\tnc = channel_connect_stdio_fwd(ssh, chost, cport, new_fd[0], new_fd[1]);\n\tfree(chost);\n\n\tnc->ctl_chan = c->self;\t\t/* link session -> control channel */\n\tc->remote_id = nc->self; \t/* link control -> session channel */\n\tc->have_remote_id = 1;\n\n\tdebug2(\"%s: channel_new: %d linked to control channel %d\",\n\t    __func__, nc->self, nc->ctl_chan);\n\n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->rid = rid;\n\tchannel_register_open_confirm(ssh, nc->self, mux_stdio_confirm, cctx);\n\tc->mux_pause = 1; /* stop handling messages until open_confirm done */\n\n\t/* reply is deferred, sent by mux_session_confirm */\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002"
    ],
    "globals_used": [
      "extern Options options;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_open_confirm",
          "args": [
            "ssh",
            "nc->self",
            "mux_stdio_confirm",
            "cctx"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_open_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "971-983",
          "snippet": "void\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*cctx)"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "nc->self",
            "mux_master_session_cleanup_cb",
            "1"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel_new: %d linked to control channel %d\"",
            "__func__",
            "nc->self",
            "nc->ctl_chan"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "chost"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_stdio_fwd",
          "args": [
            "ssh",
            "chost",
            "cport",
            "new_fd[0]",
            "new_fd[1]"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_stdio_fwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1489-1510",
          "snippet": "Channel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "new_fd[1]"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "new_fd[1]"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "new_fd[0]"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_PERMISSION_DENIED",
            "rid",
            "\"Permission denied\""
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Allow forward to %s:%u? \"",
            "chost",
            "cport"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "new_fd[1]"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: got fds stdin %d, stdout %d\"",
            "__func__",
            "new_fd[0]",
            "new_fd[1]"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: failed to receive fd %d from slave\"",
            "__func__",
            "i"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_receive_fd",
          "args": [
            "c->sock"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "mm_receive_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "112-187",
          "snippet": "int\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&cport"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&chost",
            "NULL"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "m"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n\nextern Options options;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_stdio_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tchar *chost = NULL;\n\tu_int cport, i, j;\n\tint r, new_fd[2];\n\tstruct mux_stdio_confirm_ctx *cctx;\n\n\tif ((r = sshbuf_skip_string(m)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0) {\n\t\tfree(chost);\n\t\terror(\"%s: malformed message\", __func__);\n\t\treturn -1;\n\t}\n\n\tdebug2(\"%s: channel %d: request stdio fwd to %s:%u\",\n\t    __func__, c->self, chost, cport);\n\n\t/* Gather fds from client */\n\tfor(i = 0; i < 2; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror(\"%s: failed to receive fd %d from slave\",\n\t\t\t    __func__, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfree(chost);\n\n\t\t\t/* prepare reply */\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3(\"%s: got fds stdin %d, stdout %d\", __func__,\n\t    new_fd[0], new_fd[1]);\n\n\t/* XXX support multiple child sessions in future */\n\tif (c->have_remote_id) {\n\t\tdebug2(\"%s: session already open\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tfree(chost);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Allow forward to %s:%u? \",\n\t\t    chost, cport)) {\n\t\t\tdebug2(\"%s: stdio fwd refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(new_fd[0]))\n\t\tset_nonblock(new_fd[0]);\n\tif (!isatty(new_fd[1]))\n\t\tset_nonblock(new_fd[1]);\n\n\tnc = channel_connect_stdio_fwd(ssh, chost, cport, new_fd[0], new_fd[1]);\n\tfree(chost);\n\n\tnc->ctl_chan = c->self;\t\t/* link session -> control channel */\n\tc->remote_id = nc->self; \t/* link control -> session channel */\n\tc->have_remote_id = 1;\n\n\tdebug2(\"%s: channel_new: %d linked to control channel %d\",\n\t    __func__, nc->self, nc->ctl_chan);\n\n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->rid = rid;\n\tchannel_register_open_confirm(ssh, nc->self, mux_stdio_confirm, cctx);\n\tc->mux_pause = 1; /* stop handling messages until open_confirm done */\n\n\t/* reply is deferred, sent by mux_session_confirm */\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_master_process_close_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "852-962",
    "snippet": "static int\nmux_master_process_close_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd, *found_fwd;\n\tchar *fwd_desc = NULL;\n\tconst char *error_reason = NULL;\n\tchar *listen_addr = NULL, *connect_addr = NULL;\n\tu_int ftype;\n\tint r, i, ret = 0;\n\tu_int lport, cport;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror(\"%s: malformed message\", __func__);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2(\"%s: channel %d: request cancel %s\", __func__, c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\t/* make sure this has been requested */\n\tfound_fwd = NULL;\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n\t\t\t\tfound_fwd = options.local_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.remote_forwards + i)) {\n\t\t\t\tfound_fwd = options.remote_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (found_fwd == NULL)\n\t\terror_reason = \"port not forwarded\";\n\telse if (ftype == MUX_FWD_REMOTE) {\n\t\t/*\n\t\t * This shouldn't fail unless we confused the host/port\n\t\t * between options.remote_forwards and permitted_opens.\n\t\t * However, for dynamic allocated listen ports we need\n\t\t * to use the actual listen port.\n\t\t */\n\t\tif (channel_request_rforward_cancel(ssh, found_fwd) == -1)\n\t\t\terror_reason = \"port not in permitted opens\";\n\t} else {\t/* local and dynamic forwards */\n\t\t/* Ditto */\n\t\tif (channel_cancel_lport_listener(ssh, &fwd, fwd.connect_port,\n\t\t    &options.fwd_opts) == -1)\n\t\t\terror_reason = \"port not found\";\n\t}\n\n\tif (error_reason != NULL)\n\t\treply_error(reply, MUX_S_FAILURE, rid, error_reason);\n\telse {\n\t\treply_ok(reply, rid);\n\t\tfree(found_fwd->listen_host);\n\t\tfree(found_fwd->listen_path);\n\t\tfree(found_fwd->connect_host);\n\t\tfree(found_fwd->connect_path);\n\t\tfound_fwd->listen_host = found_fwd->connect_host = NULL;\n\t\tfound_fwd->listen_path = found_fwd->connect_path = NULL;\n\t\tfound_fwd->listen_port = found_fwd->connect_port = 0;\n\t}\n out:\n\tfree(fwd_desc);\n\tfree(listen_addr);\n\tfree(connect_addr);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_FWD_DYNAMIC 3",
      "#define MUX_FWD_REMOTE  2",
      "#define MUX_FWD_LOCAL   1",
      "#define MUX_S_FAILURE\t\t0x80000003"
    ],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "connect_addr"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_ok",
          "args": [
            "reply",
            "rid"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "reply_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "312-320",
          "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_OK\t\t0x80000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_FAILURE",
            "rid",
            "error_reason"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_lport_listener",
          "args": [
            "ssh",
            "&fwd",
            "fwd.connect_port",
            "&options.fwd_opts"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_lport_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3700-3711",
          "snippet": "int\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_rforward_cancel",
          "args": [
            "ssh",
            "found_fwd"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_rforward_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4021-4032",
          "snippet": "int\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_forward",
          "args": [
            "&fwd",
            "options.remote_forwards + i"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "compare_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "586-603",
          "snippet": "static int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel %d: request cancel %s\"",
            "__func__",
            "c->self",
            "(fwd_desc = format_forward(ftype, &fwd))"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_forward",
          "args": [
            "ftype",
            "&fwd"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "format_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "540-574",
          "snippet": "static char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_FWD_DYNAMIC 3",
            "#define MUX_FWD_REMOTE  2",
            "#define MUX_FWD_LOCAL   1"
          ],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: malformed message\"",
            "__func__"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&cport"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&connect_addr",
            "NULL"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n#define MUX_S_FAILURE\t\t0x80000003\n\nextern Options options;\nextern char *host;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_close_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd, *found_fwd;\n\tchar *fwd_desc = NULL;\n\tconst char *error_reason = NULL;\n\tchar *listen_addr = NULL, *connect_addr = NULL;\n\tu_int ftype;\n\tint r, i, ret = 0;\n\tu_int lport, cport;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror(\"%s: malformed message\", __func__);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2(\"%s: channel %d: request cancel %s\", __func__, c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\t/* make sure this has been requested */\n\tfound_fwd = NULL;\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n\t\t\t\tfound_fwd = options.local_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.remote_forwards + i)) {\n\t\t\t\tfound_fwd = options.remote_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (found_fwd == NULL)\n\t\terror_reason = \"port not forwarded\";\n\telse if (ftype == MUX_FWD_REMOTE) {\n\t\t/*\n\t\t * This shouldn't fail unless we confused the host/port\n\t\t * between options.remote_forwards and permitted_opens.\n\t\t * However, for dynamic allocated listen ports we need\n\t\t * to use the actual listen port.\n\t\t */\n\t\tif (channel_request_rforward_cancel(ssh, found_fwd) == -1)\n\t\t\terror_reason = \"port not in permitted opens\";\n\t} else {\t/* local and dynamic forwards */\n\t\t/* Ditto */\n\t\tif (channel_cancel_lport_listener(ssh, &fwd, fwd.connect_port,\n\t\t    &options.fwd_opts) == -1)\n\t\t\terror_reason = \"port not found\";\n\t}\n\n\tif (error_reason != NULL)\n\t\treply_error(reply, MUX_S_FAILURE, rid, error_reason);\n\telse {\n\t\treply_ok(reply, rid);\n\t\tfree(found_fwd->listen_host);\n\t\tfree(found_fwd->listen_path);\n\t\tfree(found_fwd->connect_host);\n\t\tfree(found_fwd->connect_path);\n\t\tfound_fwd->listen_host = found_fwd->connect_host = NULL;\n\t\tfound_fwd->listen_path = found_fwd->connect_path = NULL;\n\t\tfound_fwd->listen_port = found_fwd->connect_port = 0;\n\t}\n out:\n\tfree(fwd_desc);\n\tfree(listen_addr);\n\tfree(connect_addr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_master_process_open_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "685-850",
    "snippet": "static int\nmux_master_process_open_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd;\n\tchar *fwd_desc = NULL;\n\tchar *listen_addr, *connect_addr;\n\tu_int ftype;\n\tu_int lport, cport;\n\tint r, i, ret = 0, freefwd = 1;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\t/* XXX - lport/cport check redundant */\n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror(\"%s: malformed message\", __func__);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2(\"%s: channel %d: request %s\", __func__, c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\tif (ftype != MUX_FWD_LOCAL && ftype != MUX_FWD_REMOTE &&\n\t    ftype != MUX_FWD_DYNAMIC) {\n\t\tlogit(\"%s: invalid forwarding type %u\", __func__, ftype);\n invalid:\n\t\tfree(listen_addr);\n\t\tfree(connect_addr);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Invalid forwarding request\");\n\t\treturn 0;\n\t}\n\tif (ftype == MUX_FWD_DYNAMIC && fwd.listen_path) {\n\t\tlogit(\"%s: streamlocal and dynamic forwards \"\n\t\t    \"are mutually exclusive\", __func__);\n\t\tgoto invalid;\n\t}\n\tif (fwd.listen_port != PORT_STREAMLOCAL && fwd.listen_port >= 65536) {\n\t\tlogit(\"%s: invalid listen port %u\", __func__,\n\t\t    fwd.listen_port);\n\t\tgoto invalid;\n\t}\n\tif ((fwd.connect_port != PORT_STREAMLOCAL &&\n\t    fwd.connect_port >= 65536) ||\n\t    (ftype != MUX_FWD_DYNAMIC && ftype != MUX_FWD_REMOTE &&\n\t    fwd.connect_port == 0)) {\n\t\tlogit(\"%s: invalid connect port %u\", __func__,\n\t\t    fwd.connect_port);\n\t\tgoto invalid;\n\t}\n\tif (ftype != MUX_FWD_DYNAMIC && fwd.connect_host == NULL &&\n\t    fwd.connect_path == NULL) {\n\t\tlogit(\"%s: missing connect host\", __func__);\n\t\tgoto invalid;\n\t}\n\n\t/* Skip forwards that have already been requested */\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n exists:\n\t\t\t\tdebug2(\"%s: found existing forwarding\",\n\t\t\t\t    __func__);\n\t\t\t\treply_ok(reply, rid);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (!compare_forward(&fwd, options.remote_forwards + i))\n\t\t\t\tcontinue;\n\t\t\tif (fwd.listen_port != 0)\n\t\t\t\tgoto exists;\n\t\t\tdebug2(\"%s: found allocated port\", __func__);\n\t\t\tif ((r = sshbuf_put_u32(reply,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply,\n\t\t\t    options.remote_forwards[i].allocated_port)) != 0)\n\t\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Open %s on %s?\", fwd_desc, host)) {\n\t\t\tdebug2(\"%s: forwarding refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ftype == MUX_FWD_LOCAL || ftype == MUX_FWD_DYNAMIC) {\n\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t    &options.fwd_opts)) {\n fail:\n\t\t\tlogit(\"%s: requested %s failed\", __func__, fwd_desc);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"Port forwarding failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tadd_local_forward(&options, &fwd);\n\t\tfreefwd = 0;\n\t} else {\n\t\tstruct mux_channel_confirm_ctx *fctx;\n\n\t\tfwd.handle = channel_request_remote_forwarding(ssh, &fwd);\n\t\tif (fwd.handle < 0)\n\t\t\tgoto fail;\n\t\tadd_remote_forward(&options, &fwd);\n\t\tfctx = xcalloc(1, sizeof(*fctx));\n\t\tfctx->cid = c->self;\n\t\tfctx->rid = rid;\n\t\tfctx->fid = options.num_remote_forwards - 1;\n\t\tclient_register_global_confirm(mux_confirm_remote_forward,\n\t\t    fctx);\n\t\tfreefwd = 0;\n\t\tc->mux_pause = 1; /* wait for mux_confirm_remote_forward */\n\t\t/* delayed reply in mux_confirm_remote_forward */\n\t\tgoto out;\n\t}\n\treply_ok(reply, rid);\n out:\n\tfree(fwd_desc);\n\tif (freefwd) {\n\t\tfree(fwd.listen_host);\n\t\tfree(fwd.listen_path);\n\t\tfree(fwd.connect_host);\n\t\tfree(fwd.connect_path);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_FWD_DYNAMIC 3",
      "#define MUX_FWD_REMOTE  2",
      "#define MUX_FWD_LOCAL   1",
      "#define MUX_S_REMOTE_PORT\t0x80000007",
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002"
    ],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fwd.connect_path"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_ok",
          "args": [
            "reply",
            "rid"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "reply_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "312-320",
          "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_OK\t\t0x80000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_register_global_confirm",
          "args": [
            "mux_confirm_remote_forward",
            "fctx"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "client_register_global_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "747-766",
          "snippet": "void\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*fctx)"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_remote_forward",
          "args": [
            "&options",
            "&fwd"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "add_remote_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "350-374",
          "snippet": "void\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_remote_forwarding",
          "args": [
            "ssh",
            "&fwd"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_remote_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3830-3886",
          "snippet": "int\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_local_forward",
          "args": [
            "&options",
            "&fwd"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "add_local_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "321-343",
          "snippet": "void\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_FAILURE",
            "rid",
            "\"Port forwarding failed\""
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: requested %s failed\"",
            "__func__",
            "fwd_desc"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_setup_local_fwd_listener",
          "args": [
            "ssh",
            "&fwd",
            "&options.fwd_opts"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_local_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3714-3725",
          "snippet": "int\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: forwarding refused by user\"",
            "__func__"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Open %s on %s?\"",
            "fwd_desc",
            "host"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "options.remote_forwards[i].allocated_port"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_forward",
          "args": [
            "&fwd",
            "options.remote_forwards + i"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "compare_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "586-603",
          "snippet": "static int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_forward",
          "args": [
            "ftype",
            "&fwd"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "format_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "540-574",
          "snippet": "static char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_FWD_DYNAMIC 3",
            "#define MUX_FWD_REMOTE  2",
            "#define MUX_FWD_LOCAL   1"
          ],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: malformed message\"",
            "__func__"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&cport"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&connect_addr",
            "NULL"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n\nextern Options options;\nextern char *host;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_open_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd;\n\tchar *fwd_desc = NULL;\n\tchar *listen_addr, *connect_addr;\n\tu_int ftype;\n\tu_int lport, cport;\n\tint r, i, ret = 0, freefwd = 1;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\t/* XXX - lport/cport check redundant */\n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror(\"%s: malformed message\", __func__);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2(\"%s: channel %d: request %s\", __func__, c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\tif (ftype != MUX_FWD_LOCAL && ftype != MUX_FWD_REMOTE &&\n\t    ftype != MUX_FWD_DYNAMIC) {\n\t\tlogit(\"%s: invalid forwarding type %u\", __func__, ftype);\n invalid:\n\t\tfree(listen_addr);\n\t\tfree(connect_addr);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Invalid forwarding request\");\n\t\treturn 0;\n\t}\n\tif (ftype == MUX_FWD_DYNAMIC && fwd.listen_path) {\n\t\tlogit(\"%s: streamlocal and dynamic forwards \"\n\t\t    \"are mutually exclusive\", __func__);\n\t\tgoto invalid;\n\t}\n\tif (fwd.listen_port != PORT_STREAMLOCAL && fwd.listen_port >= 65536) {\n\t\tlogit(\"%s: invalid listen port %u\", __func__,\n\t\t    fwd.listen_port);\n\t\tgoto invalid;\n\t}\n\tif ((fwd.connect_port != PORT_STREAMLOCAL &&\n\t    fwd.connect_port >= 65536) ||\n\t    (ftype != MUX_FWD_DYNAMIC && ftype != MUX_FWD_REMOTE &&\n\t    fwd.connect_port == 0)) {\n\t\tlogit(\"%s: invalid connect port %u\", __func__,\n\t\t    fwd.connect_port);\n\t\tgoto invalid;\n\t}\n\tif (ftype != MUX_FWD_DYNAMIC && fwd.connect_host == NULL &&\n\t    fwd.connect_path == NULL) {\n\t\tlogit(\"%s: missing connect host\", __func__);\n\t\tgoto invalid;\n\t}\n\n\t/* Skip forwards that have already been requested */\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n exists:\n\t\t\t\tdebug2(\"%s: found existing forwarding\",\n\t\t\t\t    __func__);\n\t\t\t\treply_ok(reply, rid);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (!compare_forward(&fwd, options.remote_forwards + i))\n\t\t\t\tcontinue;\n\t\t\tif (fwd.listen_port != 0)\n\t\t\t\tgoto exists;\n\t\t\tdebug2(\"%s: found allocated port\", __func__);\n\t\t\tif ((r = sshbuf_put_u32(reply,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply,\n\t\t\t    options.remote_forwards[i].allocated_port)) != 0)\n\t\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Open %s on %s?\", fwd_desc, host)) {\n\t\t\tdebug2(\"%s: forwarding refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ftype == MUX_FWD_LOCAL || ftype == MUX_FWD_DYNAMIC) {\n\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t    &options.fwd_opts)) {\n fail:\n\t\t\tlogit(\"%s: requested %s failed\", __func__, fwd_desc);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"Port forwarding failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tadd_local_forward(&options, &fwd);\n\t\tfreefwd = 0;\n\t} else {\n\t\tstruct mux_channel_confirm_ctx *fctx;\n\n\t\tfwd.handle = channel_request_remote_forwarding(ssh, &fwd);\n\t\tif (fwd.handle < 0)\n\t\t\tgoto fail;\n\t\tadd_remote_forward(&options, &fwd);\n\t\tfctx = xcalloc(1, sizeof(*fctx));\n\t\tfctx->cid = c->self;\n\t\tfctx->rid = rid;\n\t\tfctx->fid = options.num_remote_forwards - 1;\n\t\tclient_register_global_confirm(mux_confirm_remote_forward,\n\t\t    fctx);\n\t\tfreefwd = 0;\n\t\tc->mux_pause = 1; /* wait for mux_confirm_remote_forward */\n\t\t/* delayed reply in mux_confirm_remote_forward */\n\t\tgoto out;\n\t}\n\treply_ok(reply, rid);\n out:\n\tfree(fwd_desc);\n\tif (freefwd) {\n\t\tfree(fwd.listen_host);\n\t\tfree(fwd.listen_path);\n\t\tfree(fwd.connect_host);\n\t\tfree(fwd.connect_path);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_confirm_remote_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "605-683",
    "snippet": "static void\nmux_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct mux_channel_confirm_ctx *fctx = ctxt;\n\tchar *failmsg = NULL;\n\tstruct Forward *rfwd;\n\tChannel *c;\n\tstruct sshbuf *out;\n\tint r;\n\n\tif ((c = channel_by_id(ssh, fctx->cid)) == NULL) {\n\t\t/* no channel for reply */\n\t\terror(\"%s: unknown channel\", __func__);\n\t\treturn;\n\t}\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (fctx->fid >= options.num_remote_forwards ||\n\t    (options.remote_forwards[fctx->fid].connect_path == NULL &&\n\t    options.remote_forwards[fctx->fid].connect_host == NULL)) {\n\t\txasprintf(&failmsg, \"unknown forwarding id %d\", fctx->fid);\n\t\tgoto fail;\n\t}\n\trfwd = &options.remote_forwards[fctx->fid];\n\tdebug(\"%s: %s for: listen %d, connect %s:%d\", __func__,\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\tif (rfwd->listen_port == 0) {\n\t\t\trfwd->allocated_port = packet_get_int();\n\t\t\tdebug(\"Allocated port %u for mux remote forward\"\n\t\t\t    \" to %s:%d\", rfwd->allocated_port,\n\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\tif ((r = sshbuf_put_u32(out,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out, fctx->rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out,\n\t\t\t    rfwd->allocated_port)) != 0)\n\t\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t\tchannel_update_permission(ssh, rfwd->handle,\n\t\t\t   rfwd->allocated_port);\n\t\t} else {\n\t\t\treply_ok(out, fctx->rid);\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\tif (rfwd->listen_port == 0)\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\tif (rfwd->listen_path != NULL)\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen path %s\", rfwd->listen_path);\n\t\telse\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen port %d\", rfwd->listen_port);\n\n                debug2(\"%s: clearing registered forwarding for listen %d, \"\n\t\t    \"connect %s:%d\", __func__, rfwd->listen_port,\n\t\t    rfwd->connect_path ? rfwd->connect_path :\n\t\t    rfwd->connect_host, rfwd->connect_port);\n\n\t\tfree(rfwd->listen_host);\n\t\tfree(rfwd->listen_path);\n\t\tfree(rfwd->connect_host);\n\t\tfree(rfwd->connect_path);\n\t\tmemset(rfwd, 0, sizeof(*rfwd));\n\t}\n fail:\n\terror(\"%s: %s\", __func__, failmsg);\n\treply_error(out, MUX_S_FAILURE, fctx->rid, failmsg);\n\tfree(failmsg);\n out:\n\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(out);\n\tif (c->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, c->mux_pause);\n\tc->mux_pause = 0; /* start processing messages again */\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_REMOTE_PORT\t0x80000007",
      "#define MUX_S_FAILURE\t\t0x80000003"
    ],
    "globals_used": [
      "extern Options options;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: mux_pause %d\"",
            "__func__",
            "c->mux_pause"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "out"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "c->output",
            "out"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "failmsg"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "out",
            "MUX_S_FAILURE",
            "fctx->rid",
            "failmsg"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "failmsg"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rfwd",
            "0",
            "sizeof(*rfwd)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: clearing registered forwarding for listen %d, \"\n\t\t    \"connect %s:%d\"",
            "__func__",
            "rfwd->listen_port",
            "rfwd->connect_path ? rfwd->connect_path :\n\t\t    rfwd->connect_host",
            "rfwd->connect_port"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&failmsg",
            "\"remote port forwarding failed for \"\n\t\t\t    \"listen port %d\"",
            "rfwd->listen_port"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_update_permission",
          "args": [
            "ssh",
            "rfwd->handle",
            "-1"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "channel_update_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4100-4121",
          "snippet": "void\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_ok",
          "args": [
            "out",
            "fctx->rid"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "reply_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "312-320",
          "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_OK\t\t0x80000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "out",
            "rfwd->allocated_port"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Allocated port %u for mux remote forward\"\n\t\t\t    \" to %s:%d\"",
            "rfwd->allocated_port",
            "rfwd->connect_host",
            "rfwd->connect_port"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "fctx->cid"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_FAILURE\t\t0x80000003\n\nextern Options options;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nmux_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct mux_channel_confirm_ctx *fctx = ctxt;\n\tchar *failmsg = NULL;\n\tstruct Forward *rfwd;\n\tChannel *c;\n\tstruct sshbuf *out;\n\tint r;\n\n\tif ((c = channel_by_id(ssh, fctx->cid)) == NULL) {\n\t\t/* no channel for reply */\n\t\terror(\"%s: unknown channel\", __func__);\n\t\treturn;\n\t}\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif (fctx->fid >= options.num_remote_forwards ||\n\t    (options.remote_forwards[fctx->fid].connect_path == NULL &&\n\t    options.remote_forwards[fctx->fid].connect_host == NULL)) {\n\t\txasprintf(&failmsg, \"unknown forwarding id %d\", fctx->fid);\n\t\tgoto fail;\n\t}\n\trfwd = &options.remote_forwards[fctx->fid];\n\tdebug(\"%s: %s for: listen %d, connect %s:%d\", __func__,\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\tif (rfwd->listen_port == 0) {\n\t\t\trfwd->allocated_port = packet_get_int();\n\t\t\tdebug(\"Allocated port %u for mux remote forward\"\n\t\t\t    \" to %s:%d\", rfwd->allocated_port,\n\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\tif ((r = sshbuf_put_u32(out,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out, fctx->rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out,\n\t\t\t    rfwd->allocated_port)) != 0)\n\t\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t\tchannel_update_permission(ssh, rfwd->handle,\n\t\t\t   rfwd->allocated_port);\n\t\t} else {\n\t\t\treply_ok(out, fctx->rid);\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\tif (rfwd->listen_port == 0)\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\tif (rfwd->listen_path != NULL)\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen path %s\", rfwd->listen_path);\n\t\telse\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen port %d\", rfwd->listen_port);\n\n                debug2(\"%s: clearing registered forwarding for listen %d, \"\n\t\t    \"connect %s:%d\", __func__, rfwd->listen_port,\n\t\t    rfwd->connect_path ? rfwd->connect_path :\n\t\t    rfwd->connect_host, rfwd->connect_port);\n\n\t\tfree(rfwd->listen_host);\n\t\tfree(rfwd->listen_path);\n\t\tfree(rfwd->connect_host);\n\t\tfree(rfwd->connect_path);\n\t\tmemset(rfwd, 0, sizeof(*rfwd));\n\t}\n fail:\n\terror(\"%s: %s\", __func__, failmsg);\n\treply_error(out, MUX_S_FAILURE, fctx->rid, failmsg);\n\tfree(failmsg);\n out:\n\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\tfatal(\"%s: sshbuf_put_stringb: %s\", __func__, ssh_err(r));\n\tsshbuf_free(out);\n\tif (c->mux_pause <= 0)\n\t\tfatal(\"%s: mux_pause %d\", __func__, c->mux_pause);\n\tc->mux_pause = 0; /* start processing messages again */\n}"
  },
  {
    "function_name": "compare_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "586-603",
    "snippet": "static int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_host",
          "args": [
            "a->connect_path",
            "b->connect_path"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "compare_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "576-584",
          "snippet": "static int\ncompare_host(const char *a, const char *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\treturn strcmp(a, b) == 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncompare_host(const char *a, const char *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\treturn strcmp(a, b) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "compare_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "576-584",
    "snippet": "static int\ncompare_host(const char *a, const char *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\treturn strcmp(a, b) == 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a",
            "b"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncompare_host(const char *a, const char *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\treturn strcmp(a, b) == 0;\n}"
  },
  {
    "function_name": "format_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "540-574",
    "snippet": "static char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_FWD_DYNAMIC 3",
      "#define MUX_FWD_REMOTE  2",
      "#define MUX_FWD_LOCAL   1"
    ],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unknown forward type %u\"",
            "__func__",
            "ftype"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"remote forward %.200s:%d -> %.200s:%d\"",
            "(fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host",
            "fwd->listen_port",
            "(fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host",
            "fwd->connect_port"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_FWD_DYNAMIC 3\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_LOCAL   1\n\nextern Options options;\n\nstatic char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t     fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown forward type %u\", __func__, ftype);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mux_master_process_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "517-538",
    "snippet": "static int\nmux_master_process_terminate(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug2(\"%s: channel %d: terminate request\", __func__, c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Terminate shared connection to %s? \",\n\t\t    host)) {\n\t\t\tdebug2(\"%s: termination refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tquit_pending = 1;\n\treply_ok(reply, rid);\n\t/* XXX exit happens too soon - message never makes it to client */\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_PERMISSION_DENIED\t0x80000002"
    ],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "extern volatile sig_atomic_t quit_pending;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reply_ok",
          "args": [
            "reply",
            "rid"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "reply_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "312-320",
          "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_OK\t\t0x80000001"
          ],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_PERMISSION_DENIED",
            "rid",
            "\"Permission denied\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: termination refused by user\"",
            "__func__"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Terminate shared connection to %s? \"",
            "host"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n\nextern Options options;\nextern char *host;\nextern volatile sig_atomic_t quit_pending;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_terminate(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug2(\"%s: channel %d: terminate request\", __func__, c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Terminate shared connection to %s? \",\n\t\t    host)) {\n\t\t\tdebug2(\"%s: termination refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tquit_pending = 1;\n\treply_ok(reply, rid);\n\t/* XXX exit happens too soon - message never makes it to client */\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_master_process_alive_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "500-515",
    "snippet": "static int\nmux_master_process_alive_check(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug2(\"%s: channel %d: alive check\", __func__, c->self);\n\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_ALIVE)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, (u_int)getpid())) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_ALIVE\t\t0x80000005"
    ],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "(u_int)getpid()"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel %d: alive check\"",
            "__func__",
            "c->self"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_ALIVE\t\t0x80000005\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_alive_check(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug2(\"%s: channel %d: alive check\", __func__, c->self);\n\n\t/* prepare reply */\n\tif ((r = sshbuf_put_u32(reply, MUX_S_ALIVE)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, (u_int)getpid())) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_master_process_new_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "334-498",
    "snippet": "static int\nmux_master_process_new_session(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tstruct mux_session_confirm_ctx *cctx;\n\tchar *cmd, *cp;\n\tu_int i, j, env_len, escape_char, window, packetmax;\n\tint r, new_fd[3];\n\n\t/* Reply for SSHMUX_COMMAND_OPEN */\n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->term = NULL;\n\tcctx->rid = rid;\n\tcmd = NULL;\n\tcctx->env = NULL;\n\tenv_len = 0;\n\tif ((r = sshbuf_skip_string(m)) != 0 || /* reserved */\n\t    (r = sshbuf_get_u32(m, &cctx->want_tty)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_x_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_agent_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_subsys)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &escape_char)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cctx->term, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cmd, NULL)) != 0) {\n malf:\n\t\tfree(cmd);\n\t\tfor (j = 0; j < env_len; j++)\n\t\t\tfree(cctx->env[j]);\n\t\tfree(cctx->env);\n\t\tfree(cctx->term);\n\t\tfree(cctx);\n\t\terror(\"%s: malformed message\", __func__);\n\t\treturn -1;\n\t}\n\n#define MUX_MAX_ENV_VARS\t4096\n\twhile (sshbuf_len(m) > 0) {\n\t\tif ((r = sshbuf_get_cstring(m, &cp, NULL)) != 0)\n\t\t\tgoto malf;\n\t\tif (!env_permitted(cp)) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tcctx->env = xreallocarray(cctx->env, env_len + 2,\n\t\t    sizeof(*cctx->env));\n\t\tcctx->env[env_len++] = cp;\n\t\tcctx->env[env_len] = NULL;\n\t\tif (env_len > MUX_MAX_ENV_VARS) {\n\t\t\terror(\"%s: >%d environment variables received, \"\n\t\t\t    \"ignoring additional\", __func__, MUX_MAX_ENV_VARS);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug2(\"%s: channel %d: request tty %d, X %d, agent %d, subsys %d, \"\n\t    \"term \\\"%s\\\", cmd \\\"%s\\\", env %u\", __func__, c->self,\n\t    cctx->want_tty, cctx->want_x_fwd, cctx->want_agent_fwd,\n\t    cctx->want_subsys, cctx->term, cmd, env_len);\n\n\tif ((cctx->cmd = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(cctx->cmd, cmd, strlen(cmd))) != 0)\n\t\tfatal(\"%s: sshbuf_put: %s\", __func__, ssh_err(r));\n\tfree(cmd);\n\tcmd = NULL;\n\n\t/* Gather fds from client */\n\tfor(i = 0; i < 3; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror(\"%s: failed to receive fd %d from slave\",\n\t\t\t    __func__, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfor (j = 0; j < env_len; j++)\n\t\t\t\tfree(cctx->env[j]);\n\t\t\tfree(cctx->env);\n\t\t\tfree(cctx->term);\n\t\t\tsshbuf_free(cctx->cmd);\n\t\t\tfree(cctx);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3(\"%s: got fds stdin %d, stdout %d, stderr %d\", __func__,\n\t    new_fd[0], new_fd[1], new_fd[2]);\n\n\t/* XXX support multiple child sessions in future */\n\tif (c->have_remote_id) {\n\t\tdebug2(\"%s: session already open\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tclose(new_fd[2]);\n\t\tfree(cctx->term);\n\t\tif (env_len != 0) {\n\t\t\tfor (i = 0; i < env_len; i++)\n\t\t\t\tfree(cctx->env[i]);\n\t\t\tfree(cctx->env);\n\t\t}\n\t\tsshbuf_free(cctx->cmd);\n\t\tfree(cctx);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Allow shared connection to %s? \", host)) {\n\t\t\tdebug2(\"%s: session refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Try to pick up ttymodes from client before it goes raw */\n\tif (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)\n\t\terror(\"%s: tcgetattr: %s\", __func__, strerror(errno));\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(new_fd[0]))\n\t\tset_nonblock(new_fd[0]);\n\tif (!isatty(new_fd[1]))\n\t\tset_nonblock(new_fd[1]);\n\tif (!isatty(new_fd[2]))\n\t\tset_nonblock(new_fd[2]);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (cctx->want_tty) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\n\tnc = channel_new(ssh, \"session\", SSH_CHANNEL_OPENING,\n\t    new_fd[0], new_fd[1], new_fd[2], window, packetmax,\n\t    CHAN_EXTENDED_WRITE, \"client-session\", /*nonblock*/0);\n\n\tnc->ctl_chan = c->self;\t\t/* link session -> control channel */\n\tc->remote_id = nc->self; \t/* link control -> session channel */\n\tc->have_remote_id = 1;\n\n\tif (cctx->want_tty && escape_char != 0xffffffff) {\n\t\tchannel_register_filter(ssh, nc->self,\n\t\t    client_simple_escape_filter, NULL,\n\t\t    client_filter_cleanup,\n\t\t    client_new_escape_filter_ctx((int)escape_char));\n\t}\n\n\tdebug2(\"%s: channel_new: %d linked to control channel %d\",\n\t    __func__, nc->self, nc->ctl_chan);\n\n\tchannel_send_open(ssh, nc->self);\n\tchannel_register_open_confirm(ssh, nc->self, mux_session_confirm, cctx);\n\tc->mux_pause = 1; /* stop handling messages until open_confirm done */\n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\t/* reply is deferred, sent by mux_session_confirm */\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_MAX_ENV_VARS\t4096",
      "#define MUX_S_FAILURE\t\t0x80000003",
      "#define MUX_S_PERMISSION_DENIED\t0x80000002"
    ],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "nc->self",
            "mux_master_session_cleanup_cb",
            "1"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_open_confirm",
          "args": [
            "ssh",
            "nc->self",
            "mux_session_confirm",
            "cctx"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_open_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "971-983",
          "snippet": "void\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_send_open",
          "args": [
            "ssh",
            "nc->self"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "channel_send_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "916-930",
          "snippet": "void\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel_new: %d linked to control channel %d\"",
            "__func__",
            "nc->self",
            "nc->ctl_chan"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_filter",
          "args": [
            "ssh",
            "nc->self",
            "client_simple_escape_filter",
            "NULL",
            "client_filter_cleanup",
            "client_new_escape_filter_ctx((int)escape_char)"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1012-1026",
          "snippet": "void\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_new_escape_filter_ctx",
          "args": [
            "(int)escape_char"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "client_new_escape_filter_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1193-1202",
          "snippet": "void *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"session\"",
            "SSH_CHANNEL_OPENING",
            "new_fd[0]",
            "new_fd[1]",
            "new_fd[2]",
            "window",
            "packetmax",
            "CHAN_EXTENDED_WRITE",
            "\"client-session\"",
            "/*nonblock*/0"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "new_fd[2]"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "new_fd[2]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "new_fd[1]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "new_fd[0]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: tcgetattr: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "new_fd[0]",
            "&cctx->tio"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "tcgetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "46-50",
          "snippet": "int\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reply_error",
          "args": [
            "reply",
            "MUX_S_PERMISSION_DENIED",
            "rid",
            "\"Permission denied\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Allow shared connection to %s? \"",
            "host"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cctx"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "cctx->cmd"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "new_fd[2]"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: got fds stdin %d, stdout %d, stderr %d\"",
            "__func__",
            "new_fd[0]",
            "new_fd[1]",
            "new_fd[2]"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_receive_fd",
          "args": [
            "c->sock"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "mm_receive_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_fdpass.c",
          "lines": "112-187",
          "snippet": "int\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"monitor_fdpass.h\"",
            "#include \"log.h\"",
            "#  include <sys/poll.h>",
            "# include <poll.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"monitor_fdpass.h\"\n#include \"log.h\"\n#  include <sys/poll.h>\n# include <poll.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror(\"%s: recvmsg: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror(\"%s: recvmsg: expected received 1 got %zd\", __func__, n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror(\"%s: no fd\", __func__);\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror(\"%s: no message header\", __func__);\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror(\"%s: expected type %d got %d\", __func__,\n\t\t    SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_put: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "cctx->cmd",
            "cmd",
            "strlen(cmd)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "cctx->env",
            "env_len + 2",
            "sizeof(*cctx->env)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_permitted",
          "args": [
            "cp"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "env_permitted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "244-263",
          "snippet": "static int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&cp",
            "NULL"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "m"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&escape_char"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "m"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*cctx)"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_MAX_ENV_VARS\t4096\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n\nextern Options options;\nextern char *host;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_new_session(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tstruct mux_session_confirm_ctx *cctx;\n\tchar *cmd, *cp;\n\tu_int i, j, env_len, escape_char, window, packetmax;\n\tint r, new_fd[3];\n\n\t/* Reply for SSHMUX_COMMAND_OPEN */\n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->term = NULL;\n\tcctx->rid = rid;\n\tcmd = NULL;\n\tcctx->env = NULL;\n\tenv_len = 0;\n\tif ((r = sshbuf_skip_string(m)) != 0 || /* reserved */\n\t    (r = sshbuf_get_u32(m, &cctx->want_tty)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_x_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_agent_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_subsys)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &escape_char)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cctx->term, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cmd, NULL)) != 0) {\n malf:\n\t\tfree(cmd);\n\t\tfor (j = 0; j < env_len; j++)\n\t\t\tfree(cctx->env[j]);\n\t\tfree(cctx->env);\n\t\tfree(cctx->term);\n\t\tfree(cctx);\n\t\terror(\"%s: malformed message\", __func__);\n\t\treturn -1;\n\t}\n\n#define MUX_MAX_ENV_VARS\t4096\n\twhile (sshbuf_len(m) > 0) {\n\t\tif ((r = sshbuf_get_cstring(m, &cp, NULL)) != 0)\n\t\t\tgoto malf;\n\t\tif (!env_permitted(cp)) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tcctx->env = xreallocarray(cctx->env, env_len + 2,\n\t\t    sizeof(*cctx->env));\n\t\tcctx->env[env_len++] = cp;\n\t\tcctx->env[env_len] = NULL;\n\t\tif (env_len > MUX_MAX_ENV_VARS) {\n\t\t\terror(\"%s: >%d environment variables received, \"\n\t\t\t    \"ignoring additional\", __func__, MUX_MAX_ENV_VARS);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug2(\"%s: channel %d: request tty %d, X %d, agent %d, subsys %d, \"\n\t    \"term \\\"%s\\\", cmd \\\"%s\\\", env %u\", __func__, c->self,\n\t    cctx->want_tty, cctx->want_x_fwd, cctx->want_agent_fwd,\n\t    cctx->want_subsys, cctx->term, cmd, env_len);\n\n\tif ((cctx->cmd = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put(cctx->cmd, cmd, strlen(cmd))) != 0)\n\t\tfatal(\"%s: sshbuf_put: %s\", __func__, ssh_err(r));\n\tfree(cmd);\n\tcmd = NULL;\n\n\t/* Gather fds from client */\n\tfor(i = 0; i < 3; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror(\"%s: failed to receive fd %d from slave\",\n\t\t\t    __func__, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfor (j = 0; j < env_len; j++)\n\t\t\t\tfree(cctx->env[j]);\n\t\t\tfree(cctx->env);\n\t\t\tfree(cctx->term);\n\t\t\tsshbuf_free(cctx->cmd);\n\t\t\tfree(cctx);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3(\"%s: got fds stdin %d, stdout %d, stderr %d\", __func__,\n\t    new_fd[0], new_fd[1], new_fd[2]);\n\n\t/* XXX support multiple child sessions in future */\n\tif (c->have_remote_id) {\n\t\tdebug2(\"%s: session already open\", __func__);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tclose(new_fd[2]);\n\t\tfree(cctx->term);\n\t\tif (env_len != 0) {\n\t\t\tfor (i = 0; i < env_len; i++)\n\t\t\t\tfree(cctx->env[i]);\n\t\t\tfree(cctx->env);\n\t\t}\n\t\tsshbuf_free(cctx->cmd);\n\t\tfree(cctx);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Allow shared connection to %s? \", host)) {\n\t\t\tdebug2(\"%s: session refused by user\", __func__);\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Try to pick up ttymodes from client before it goes raw */\n\tif (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)\n\t\terror(\"%s: tcgetattr: %s\", __func__, strerror(errno));\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(new_fd[0]))\n\t\tset_nonblock(new_fd[0]);\n\tif (!isatty(new_fd[1]))\n\t\tset_nonblock(new_fd[1]);\n\tif (!isatty(new_fd[2]))\n\t\tset_nonblock(new_fd[2]);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (cctx->want_tty) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\n\tnc = channel_new(ssh, \"session\", SSH_CHANNEL_OPENING,\n\t    new_fd[0], new_fd[1], new_fd[2], window, packetmax,\n\t    CHAN_EXTENDED_WRITE, \"client-session\", /*nonblock*/0);\n\n\tnc->ctl_chan = c->self;\t\t/* link session -> control channel */\n\tc->remote_id = nc->self; \t/* link control -> session channel */\n\tc->have_remote_id = 1;\n\n\tif (cctx->want_tty && escape_char != 0xffffffff) {\n\t\tchannel_register_filter(ssh, nc->self,\n\t\t    client_simple_escape_filter, NULL,\n\t\t    client_filter_cleanup,\n\t\t    client_new_escape_filter_ctx((int)escape_char));\n\t}\n\n\tdebug2(\"%s: channel_new: %d linked to control channel %d\",\n\t    __func__, nc->self, nc->ctl_chan);\n\n\tchannel_send_open(ssh, nc->self);\n\tchannel_register_open_confirm(ssh, nc->self, mux_session_confirm, cctx);\n\tc->mux_pause = 1; /* stop handling messages until open_confirm done */\n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\t/* reply is deferred, sent by mux_session_confirm */\n\treturn 0;\n}"
  },
  {
    "function_name": "reply_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "323-332",
    "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "reply",
            "msg"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "rid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "reply_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "312-320",
    "snippet": "static void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MUX_S_OK\t\t0x80000001"
    ],
    "globals_used": [
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: reply: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "reply",
            "rid"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_OK\t\t0x80000001\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "mux_master_process_hello",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "267-309",
    "snippet": "static int\nmux_master_process_hello(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tu_int ver;\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tint r;\n\n\tif (state == NULL)\n\t\tfatal(\"%s: channel %d: c->mux_ctx == NULL\", __func__, c->self);\n\tif (state->hello_rcvd) {\n\t\terror(\"%s: HELLO received twice\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0) {\n\t\terror(\"%s: malformed message: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"%s: unsupported multiplexing protocol version %u \"\n\t\t    \"(expected %u)\", __func__, ver, SSHMUX_VER);\n\t\treturn -1;\n\t}\n\tdebug2(\"%s: channel %d slave version %u\", __func__, c->self, ver);\n\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\t\tsize_t value_len = 0;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, NULL, &value_len)) != 0) {\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tdebug2(\"%s: Unrecognised extension \\\"%s\\\" length %zu\",\n\t\t    __func__, name, value_len);\n\t\tfree(name);\n\t}\n\tstate->hello_rcvd = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
      "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
      "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: Unrecognised extension \\\"%s\\\" length %zu\"",
            "__func__",
            "name",
            "value_len"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: malformed extension: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "m",
            "NULL",
            "&value_len"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "&name",
            "NULL"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "m"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: unsupported multiplexing protocol version %u \"\n\t\t    \"(expected %u)\"",
            "__func__",
            "ver",
            "SSHMUX_VER"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "reply_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "323-332",
          "snippet": "static void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&ver"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: c->mux_ctx == NULL\"",
            "__func__",
            "c->self"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic int\nmux_master_process_hello(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tu_int ver;\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tint r;\n\n\tif (state == NULL)\n\t\tfatal(\"%s: channel %d: c->mux_ctx == NULL\", __func__, c->self);\n\tif (state->hello_rcvd) {\n\t\terror(\"%s: HELLO received twice\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0) {\n\t\terror(\"%s: malformed message: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"%s: unsupported multiplexing protocol version %u \"\n\t\t    \"(expected %u)\", __func__, ver, SSHMUX_VER);\n\t\treturn -1;\n\t}\n\tdebug2(\"%s: channel %d slave version %u\", __func__, c->self, ver);\n\n\t/* No extensions are presently defined */\n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\t\tsize_t value_len = 0;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, NULL, &value_len)) != 0) {\n\t\t\terror(\"%s: malformed extension: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tdebug2(\"%s: Unrecognised extension \\\"%s\\\" length %zu\",\n\t\t    __func__, name, value_len);\n\t\tfree(name);\n\t}\n\tstate->hello_rcvd = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "env_permitted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "244-263",
    "snippet": "static int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "name",
            "options.send_env[i]"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: name '%.100s...' too long\"",
            "__func__",
            "env"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"%.*s\"",
            "(int)(cp - env)",
            "env"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "env",
            "'='"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nenv_permitted(char *env)\n{\n\tint i, ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror(\"%s: name '%.100s...' too long\", __func__, env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mux_master_control_cleanup_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "214-241",
    "snippet": "static void\nmux_master_control_cleanup_cb(struct ssh *ssh, int cid, void *unused)\n{\n\tChannel *sc, *c = channel_by_id(ssh, cid);\n\n\tdebug3(\"%s: entering for channel %d\", __func__, cid);\n\tif (c == NULL)\n\t\tfatal(\"%s: channel_by_id(%i) == NULL\", __func__, cid);\n\tif (c->have_remote_id) {\n\t\tif ((sc = channel_by_id(ssh, c->remote_id)) == NULL)\n\t\t\tfatal(\"%s: channel %d missing session channel %u\",\n\t\t\t    __func__, c->self, c->remote_id);\n\t\tc->remote_id = 0;\n\t\tc->have_remote_id = 0;\n\t\tsc->ctl_chan = -1;\n\t\tif (sc->type != SSH_CHANNEL_OPEN &&\n\t\t    sc->type != SSH_CHANNEL_OPENING) {\n\t\t\tdebug2(\"%s: channel %d: not open\", __func__, sc->self);\n\t\t\tchan_mark_dead(ssh, sc);\n\t\t} else {\n\t\t\tif (sc->istate == CHAN_INPUT_OPEN)\n\t\t\t\tchan_read_failed(ssh, sc);\n\t\t\tif (sc->ostate == CHAN_OUTPUT_OPEN)\n\t\t\t\tchan_write_failed(ssh, sc);\n\t\t}\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "c->self"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "sc"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "sc"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "sc"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel %d: not open\"",
            "__func__",
            "sc->self"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d missing session channel %u\"",
            "__func__",
            "c->self",
            "c->remote_id"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->remote_id"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: entering for channel %d\"",
            "__func__",
            "cid"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\n\nstatic void\nmux_master_control_cleanup_cb(struct ssh *ssh, int cid, void *unused)\n{\n\tChannel *sc, *c = channel_by_id(ssh, cid);\n\n\tdebug3(\"%s: entering for channel %d\", __func__, cid);\n\tif (c == NULL)\n\t\tfatal(\"%s: channel_by_id(%i) == NULL\", __func__, cid);\n\tif (c->have_remote_id) {\n\t\tif ((sc = channel_by_id(ssh, c->remote_id)) == NULL)\n\t\t\tfatal(\"%s: channel %d missing session channel %u\",\n\t\t\t    __func__, c->self, c->remote_id);\n\t\tc->remote_id = 0;\n\t\tc->have_remote_id = 0;\n\t\tsc->ctl_chan = -1;\n\t\tif (sc->type != SSH_CHANNEL_OPEN &&\n\t\t    sc->type != SSH_CHANNEL_OPENING) {\n\t\t\tdebug2(\"%s: channel %d: not open\", __func__, sc->self);\n\t\t\tchan_mark_dead(ssh, sc);\n\t\t} else {\n\t\t\tif (sc->istate == CHAN_INPUT_OPEN)\n\t\t\t\tchan_read_failed(ssh, sc);\n\t\t\tif (sc->ostate == CHAN_OUTPUT_OPEN)\n\t\t\t\tchan_write_failed(ssh, sc);\n\t\t}\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}"
  },
  {
    "function_name": "mux_master_session_cleanup_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
    "lines": "192-210",
    "snippet": "static void\nmux_master_session_cleanup_cb(struct ssh *ssh, int cid, void *unused)\n{\n\tChannel *cc, *c = channel_by_id(ssh, cid);\n\n\tdebug3(\"%s: entering for channel %d\", __func__, cid);\n\tif (c == NULL)\n\t\tfatal(\"%s: channel_by_id(%i) == NULL\", __func__, cid);\n\tif (c->ctl_chan != -1) {\n\t\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\t\tfatal(\"%s: channel %d missing control channel %d\",\n\t\t\t    __func__, c->self, c->ctl_chan);\n\t\tc->ctl_chan = -1;\n\t\tcc->remote_id = 0;\n\t\tcc->have_remote_id = 0;\n\t\tchan_rcvd_oclose(ssh, cc);\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshpty.h\"",
      "#include \"monitor_fdpass.h\"",
      "#include \"packet.h\"",
      "#include \"msg.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"pathnames.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <util.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <paths.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mux_session_confirm(struct ssh *, int, int, void *);",
      "static void mux_stdio_confirm(struct ssh *, int, int, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "c->self"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_oclose",
          "args": [
            "ssh",
            "cc"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_oclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "265-303",
          "snippet": "void\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d missing control channel %d\"",
            "__func__",
            "c->self",
            "c->ctl_chan"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "c->ctl_chan"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: entering for channel %d\"",
            "__func__",
            "cid"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\n\nstatic void\nmux_master_session_cleanup_cb(struct ssh *ssh, int cid, void *unused)\n{\n\tChannel *cc, *c = channel_by_id(ssh, cid);\n\n\tdebug3(\"%s: entering for channel %d\", __func__, cid);\n\tif (c == NULL)\n\t\tfatal(\"%s: channel_by_id(%i) == NULL\", __func__, cid);\n\tif (c->ctl_chan != -1) {\n\t\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\t\tfatal(\"%s: channel %d missing control channel %d\",\n\t\t\t    __func__, c->self, c->ctl_chan);\n\t\tc->ctl_chan = -1;\n\t\tcc->remote_id = 0;\n\t\tcc->have_remote_id = 0;\n\t\tchan_rcvd_oclose(ssh, cc);\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}"
  }
]