[
  {
    "function_name": "handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/readpassphrase.c",
    "lines": "206-210",
    "snippet": "static void handler(int s)\n{\n\n\tsigno[s] = 1;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <readpassphrase.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <readpassphrase.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <signal.h>\n#include <termios.h>\n#include \"includes.h\"\n\nstatic void handler(int s)\n{\n\n\tsigno[s] = 1;\n}"
  },
  {
    "function_name": "getpass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/readpassphrase.c",
    "lines": "197-203",
    "snippet": "char *\ngetpass(const char *prompt)\n{\n\tstatic char buf[_PASSWORD_LEN + 1];\n\n\treturn(readpassphrase(prompt, buf, sizeof(buf), RPP_ECHO_OFF));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <readpassphrase.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readpassphrase",
          "args": [
            "prompt",
            "buf",
            "sizeof(buf)",
            "RPP_ECHO_OFF"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "readpassphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/readpassphrase.c",
          "lines": "53-193",
          "snippet": "char *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <readpassphrase.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <readpassphrase.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <signal.h>\n#include <termios.h>\n#include \"includes.h\"\n\nchar *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <readpassphrase.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <signal.h>\n#include <termios.h>\n#include \"includes.h\"\n\nchar *\ngetpass(const char *prompt)\n{\n\tstatic char buf[_PASSWORD_LEN + 1];\n\n\treturn(readpassphrase(prompt, buf, sizeof(buf), RPP_ECHO_OFF));\n}"
  },
  {
    "function_name": "readpassphrase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/readpassphrase.c",
    "lines": "53-193",
    "snippet": "char *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <readpassphrase.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "i"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "input"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTTOU",
            "&savettou",
            "NULL"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sigaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sigact.c",
          "lines": "48-53",
          "snippet": "int\nsigaction(int sig, struct sigaction *sigact, struct sigaction *osigact)\n{\n\treturn sigvec(sig, sigact ? &sigact->sv : NULL,\n\t    osigact ? &osigact->sv : NULL);\n}",
          "includes": [
            "#include \"sigact.h\"",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sigact.h\"\n#include <signal.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsigaction(int sig, struct sigaction *sigact, struct sigaction *osigact)\n{\n\treturn sigvec(sig, sigact ? &sigact->sv : NULL,\n\t    osigact ? &osigact->sv : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "input",
            "TCSAFLUSH|TCSASOFT",
            "&oterm"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "tcsetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "52-73",
          "snippet": "int\ntcsetattr(int fd, int opt, const struct termios *t)\n{\n\tstruct termios localterm;\n\n\tif (opt & TCSASOFT) {\n\t\tlocalterm = *t;\n\t\tlocalterm.c_cflag |= CIGNORE;\n\t\tt = &localterm;\n\t}\n\tswitch (opt & ~TCSASOFT) {\n\tcase TCSANOW:\n\t\treturn (ioctl(fd, TIOCSETA, t));\n\tcase TCSADRAIN:\n\t\treturn (ioctl(fd, TIOCSETAW, t));\n\tcase TCSAFLUSH:\n\t\treturn (ioctl(fd, TIOCSETAF, t));\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcsetattr(int fd, int opt, const struct termios *t)\n{\n\tstruct termios localterm;\n\n\tif (opt & TCSASOFT) {\n\t\tlocalterm = *t;\n\t\tlocalterm.c_cflag |= CIGNORE;\n\t\tt = &localterm;\n\t}\n\tswitch (opt & ~TCSASOFT) {\n\tcase TCSANOW:\n\t\treturn (ioctl(fd, TIOCSETA, t));\n\tcase TCSADRAIN:\n\t\treturn (ioctl(fd, TIOCSETAW, t));\n\tcase TCSAFLUSH:\n\t\treturn (ioctl(fd, TIOCSETAF, t));\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&term",
            "&oterm",
            "sizeof(term)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "output",
            "\"\\n\"",
            "1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "(unsigned char)ch"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "(unsigned char)ch"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char)ch"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "input",
            "&ch",
            "1"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "output",
            "prompt",
            "strlen(prompt)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prompt"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sa.sa_mask"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "sigemptyset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sigact.c",
          "lines": "55-64",
          "snippet": "int\nsigemptyset (sigset_t *mask)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"sigact.h\"",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sigact.h\"\n#include <signal.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsigemptyset (sigset_t *mask)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&oterm",
            "0",
            "sizeof(oterm)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&term",
            "0",
            "sizeof(term)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&term",
            "&oterm",
            "sizeof(term)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "input",
            "&oterm"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "tcgetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "46-50",
          "snippet": "int\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_TTY",
            "O_RDWR"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <readpassphrase.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <signal.h>\n#include <termios.h>\n#include \"includes.h\"\n\nchar *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}"
  }
]