[
  {
    "function_name": "platform_krb5_get_principal_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "190-198",
    "snippet": "char *\nplatform_krb5_get_principal_name(const char *pw_name)\n{\n#ifdef USE_AIX_KRB_NAME\n\treturn aix_krb5_get_principal_name(pw_name);\n#else\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aix_krb5_get_principal_name",
          "args": [
            "pw_name"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "aix_krb5_get_principal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "388-405",
          "snippet": "char *\naix_krb5_get_principal_name(char *pw_name)\n{\n\tchar *authname = NULL, *authdomain = NULL, *principal = NULL;\n\n\tsetuserdb(S_READ);\n\tif (getuserattr(pw_name, S_AUTHDOMAIN, &authdomain, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHDOMAIN: %s\", strerror(errno));\n\tif (getuserattr(pw_name, S_AUTHNAME, &authname, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHNAME: %s\", strerror(errno));\n\n\tif (authdomain != NULL)\n\t\txasprintf(&principal, \"%s@%s\", authname ? authname : pw_name, authdomain);\n\telse if (authname != NULL)\n\t\tprincipal = xstrdup(authname);\n\tenduserdb();\n\treturn principal;\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nchar *\naix_krb5_get_principal_name(char *pw_name)\n{\n\tchar *authname = NULL, *authdomain = NULL, *principal = NULL;\n\n\tsetuserdb(S_READ);\n\tif (getuserattr(pw_name, S_AUTHDOMAIN, &authdomain, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHDOMAIN: %s\", strerror(errno));\n\tif (getuserattr(pw_name, S_AUTHNAME, &authname, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHNAME: %s\", strerror(errno));\n\n\tif (authdomain != NULL)\n\t\txasprintf(&principal, \"%s@%s\", authname ? authname : pw_name, authdomain);\n\telse if (authname != NULL)\n\t\tprincipal = xstrdup(authname);\n\tenduserdb();\n\treturn principal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nplatform_krb5_get_principal_name(const char *pw_name)\n{\n#ifdef USE_AIX_KRB_NAME\n\treturn aix_krb5_get_principal_name(pw_name);\n#else\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "platform_setusercontext_post_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "144-188",
    "snippet": "void\nplatform_setusercontext_post_groups(struct passwd *pw)\n{\n#if !defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * PAM credentials may take the form of supplementary groups.\n\t * These will have been wiped by the above initgroups() call.\n\t * Reestablish them here.\n\t */\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(use_privsep);\n\t}\n#endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && (defined(WITH_IRIX_PROJECT) || \\\n    defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY))\n\tirix_setusercontext(pw);\n#endif /* defined(WITH_IRIX_PROJECT) || defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY) */\n\n#ifdef _AIX\n\taix_usrinfo(pw);\n#endif /* _AIX */\n\n#ifdef HAVE_SETPCRED\n\t/*\n\t * If we have a chroot directory, we set all creds except real\n\t * uid which we will need for chroot.  If we don't have a\n\t * chroot directory, we don't override anything.\n\t */\n\t{\n\t\tchar **creds = NULL, *chroot_creds[] =\n\t\t    { \"REAL_USER=root\", NULL };\n\n\t\tif (options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0)\n\t\t\tcreds = chroot_creds;\n\n\t\tif (setpcred(pw->pw_name, creds) == -1)\n\t\t\tfatal(\"Failed to set process credentials\");\n\t}\n#endif /* HAVE_SETPCRED */\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_exec_context(pw->pw_name);\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int use_privsep;",
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_selinux_setup_exec_context",
          "args": [
            "pw->pw_name"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_selinux_setup_exec_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "105-133",
          "snippet": "void\nssh_selinux_setup_exec_context(char *pwname)\n{\n\tsecurity_context_t user_ctx = NULL;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting execution context\", __func__);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\tif (setexeccon(user_ctx) != 0) {\n\t\tswitch (security_getenforce()) {\n\t\tcase -1:\n\t\t\tfatal(\"%s: security_getenforce() failed\", __func__);\n\t\tcase 0:\n\t\t\terror(\"%s: Failed to set SELinux execution \"\n\t\t\t    \"context for %s\", __func__, pwname);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: Failed to set SELinux execution context \"\n\t\t\t    \"for %s (in enforcing mode)\", __func__, pwname);\n\t\t}\n\t}\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\n\tdebug3(\"%s: done\", __func__);\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nssh_selinux_setup_exec_context(char *pwname)\n{\n\tsecurity_context_t user_ctx = NULL;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting execution context\", __func__);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\tif (setexeccon(user_ctx) != 0) {\n\t\tswitch (security_getenforce()) {\n\t\tcase -1:\n\t\t\tfatal(\"%s: security_getenforce() failed\", __func__);\n\t\tcase 0:\n\t\t\terror(\"%s: Failed to set SELinux execution \"\n\t\t\t    \"context for %s\", __func__, pwname);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: Failed to set SELinux execution context \"\n\t\t\t    \"for %s (in enforcing mode)\", __func__, pwname);\n\t\t}\n\t}\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\n\tdebug3(\"%s: done\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to set process credentials\""
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setpcred",
          "args": [
            "pw->pw_name",
            "creds"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.chroot_directory",
            "\"none\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aix_usrinfo",
          "args": [
            "pw"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "aix_usrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "75-92",
          "snippet": "void\naix_usrinfo(struct passwd *pw)\n{\n\tu_int i;\n\tsize_t len;\n\tchar *cp;\n\n\tlen = sizeof(\"LOGNAME= NAME= \") + (2 * strlen(pw->pw_name));\n\tcp = xmalloc(len);\n\n\ti = snprintf(cp, len, \"LOGNAME=%s%cNAME=%s%c\", pw->pw_name, '\\0',\n\t    pw->pw_name, '\\0');\n\tif (usrinfo(SETUINFO, cp, i) == -1)\n\t\tfatal(\"Couldn't set usrinfo: %s\", strerror(errno));\n\tdebug3(\"AIX/UsrInfo: set len %d\", i);\n\n\tfree(cp);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_usrinfo(struct passwd *pw)\n{\n\tu_int i;\n\tsize_t len;\n\tchar *cp;\n\n\tlen = sizeof(\"LOGNAME= NAME= \") + (2 * strlen(pw->pw_name));\n\tcp = xmalloc(len);\n\n\ti = snprintf(cp, len, \"LOGNAME=%s%cNAME=%s%c\", pw->pw_name, '\\0',\n\t    pw->pw_name, '\\0');\n\tif (usrinfo(SETUINFO, cp, i) == -1)\n\t\tfatal(\"Couldn't set usrinfo: %s\", strerror(errno));\n\tdebug3(\"AIX/UsrInfo: set len %d\", i);\n\n\tfree(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irix_setusercontext",
          "args": [
            "pw"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "irix_setusercontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-irix.c",
          "lines": "46-87",
          "snippet": "void\nirix_setusercontext(struct passwd *pw)\n{\n#ifdef WITH_IRIX_PROJECT\n\tprid_t projid;\n#endif\n#ifdef WITH_IRIX_JOBS\n\tjid_t jid = 0;\n#elif defined(WITH_IRIX_ARRAY)\n\tint jid = 0;\n#endif\n\n#ifdef WITH_IRIX_JOBS\n\tjid = jlimit_startjob(pw->pw_name, pw->pw_uid, \"interactive\");\n\tif (jid == -1)\n\t\tfatal(\"Failed to create job container: %.100s\",\n\t\t    strerror(errno));\n#endif /* WITH_IRIX_JOBS */\n#ifdef WITH_IRIX_ARRAY\n\t/* initialize array session */\n\tif (jid == 0  && newarraysess() != 0)\n\t\tfatal(\"Failed to set up new array session: %.100s\",\n\t\t    strerror(errno));\n#endif /* WITH_IRIX_ARRAY */\n#ifdef WITH_IRIX_PROJECT\n\t/* initialize irix project info */\n\tif ((projid = getdfltprojuser(pw->pw_name)) == -1) {\n\t\tdebug(\"Failed to get project id, using projid 0\");\n\t\tprojid = 0;\n\t}\n\tif (setprid(projid))\n\t\tfatal(\"Failed to initialize project %d for %s: %.100s\",\n\t\t    (int)projid, pw->pw_name, strerror(errno));\n#endif /* WITH_IRIX_PROJECT */\n#ifdef WITH_IRIX_AUDIT\n\tif (sysconf(_SC_AUDIT)) {\n\t\tdebug(\"Setting sat id to %d\", (int) pw->pw_uid);\n\t\tif (satsetid(pw->pw_uid))\n\t\t\tdebug(\"error setting satid: %.100s\", strerror(errno));\n\t}\n#endif /* WITH_IRIX_AUDIT */\n}",
          "includes": [
            "# include <sat.h>",
            "# include <sys/resource.h>",
            "# include <proj.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sat.h>\n# include <sys/resource.h>\n# include <proj.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nirix_setusercontext(struct passwd *pw)\n{\n#ifdef WITH_IRIX_PROJECT\n\tprid_t projid;\n#endif\n#ifdef WITH_IRIX_JOBS\n\tjid_t jid = 0;\n#elif defined(WITH_IRIX_ARRAY)\n\tint jid = 0;\n#endif\n\n#ifdef WITH_IRIX_JOBS\n\tjid = jlimit_startjob(pw->pw_name, pw->pw_uid, \"interactive\");\n\tif (jid == -1)\n\t\tfatal(\"Failed to create job container: %.100s\",\n\t\t    strerror(errno));\n#endif /* WITH_IRIX_JOBS */\n#ifdef WITH_IRIX_ARRAY\n\t/* initialize array session */\n\tif (jid == 0  && newarraysess() != 0)\n\t\tfatal(\"Failed to set up new array session: %.100s\",\n\t\t    strerror(errno));\n#endif /* WITH_IRIX_ARRAY */\n#ifdef WITH_IRIX_PROJECT\n\t/* initialize irix project info */\n\tif ((projid = getdfltprojuser(pw->pw_name)) == -1) {\n\t\tdebug(\"Failed to get project id, using projid 0\");\n\t\tprojid = 0;\n\t}\n\tif (setprid(projid))\n\t\tfatal(\"Failed to initialize project %d for %s: %.100s\",\n\t\t    (int)projid, pw->pw_name, strerror(errno));\n#endif /* WITH_IRIX_PROJECT */\n#ifdef WITH_IRIX_AUDIT\n\tif (sysconf(_SC_AUDIT)) {\n\t\tdebug(\"Setting sat id to %d\", (int) pw->pw_uid);\n\t\tif (satsetid(pw->pw_uid))\n\t\t\tdebug(\"error setting satid: %.100s\", strerror(errno));\n\t}\n#endif /* WITH_IRIX_AUDIT */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pam_setcred",
          "args": [
            "use_privsep"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_setcred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1039-1064",
          "snippet": "void\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nextern int use_privsep;\nextern ServerOptions options;\n\nvoid\nplatform_setusercontext_post_groups(struct passwd *pw)\n{\n#if !defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * PAM credentials may take the form of supplementary groups.\n\t * These will have been wiped by the above initgroups() call.\n\t * Reestablish them here.\n\t */\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(use_privsep);\n\t}\n#endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && (defined(WITH_IRIX_PROJECT) || \\\n    defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY))\n\tirix_setusercontext(pw);\n#endif /* defined(WITH_IRIX_PROJECT) || defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY) */\n\n#ifdef _AIX\n\taix_usrinfo(pw);\n#endif /* _AIX */\n\n#ifdef HAVE_SETPCRED\n\t/*\n\t * If we have a chroot directory, we set all creds except real\n\t * uid which we will need for chroot.  If we don't have a\n\t * chroot directory, we don't override anything.\n\t */\n\t{\n\t\tchar **creds = NULL, *chroot_creds[] =\n\t\t    { \"REAL_USER=root\", NULL };\n\n\t\tif (options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0)\n\t\t\tcreds = chroot_creds;\n\n\t\tif (setpcred(pw->pw_name, creds) == -1)\n\t\t\tfatal(\"Failed to set process credentials\");\n\t}\n#endif /* HAVE_SETPCRED */\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_exec_context(pw->pw_name);\n#endif\n}"
  },
  {
    "function_name": "platform_setusercontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "96-138",
    "snippet": "void\nplatform_setusercontext(struct passwd *pw)\n{\n#ifdef WITH_SELINUX\n\t/* Cache selinux status for later use */\n\t(void)ssh_selinux_enabled();\n#endif\n\n#ifdef USE_SOLARIS_PROJECTS\n\t/*\n\t * If solaris projects were detected, set the default now, unless\n\t * we are using PAM in which case it is the responsibility of the\n\t * PAM stack.\n\t */\n\tif (!options.use_pam && (getuid() == 0 || geteuid() == 0))\n\t\tsolaris_set_default_project(pw);\n#endif\n\n#if defined(HAVE_LOGIN_CAP) && defined (__bsdi__)\n\tif (getuid() == 0 || geteuid() == 0)\n\t\tsetpgid(0, 0);\n# endif\n\n#if defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * If we have both LOGIN_CAP and PAM, we want to establish creds\n\t * before calling setusercontext (in session.c:do_setusercontext).\n\t */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\tif (options.use_pam) {\n\t\t\tdo_pam_setcred(use_privsep);\n\t\t}\n\t}\n# endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && defined(HAVE_GETLUID) && defined(HAVE_SETLUID)\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Sets login uid for accounting */\n\t\tif (getluid() == -1 && setluid(pw->pw_uid) == -1)\n\t\t\terror(\"setluid: %s\", strerror(errno));\n\t}\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int use_privsep;",
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setluid: %s\"",
            "strerror(errno)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setluid",
          "args": [
            "pw->pw_uid"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getluid",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pam_setcred",
          "args": [
            "use_privsep"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_setcred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1039-1064",
          "snippet": "void\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgid",
          "args": [
            "0",
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solaris_set_default_project",
          "args": [
            "pw"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "solaris_set_default_project",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "207-226",
          "snippet": "void\nsolaris_set_default_project(struct passwd *pw)\n{\n\tstruct project  *defaultproject;\n\tstruct project   tempproject;\n\tchar buf[1024];\n\n\t/* get default project, if we fail just return gracefully  */\n\tif ((defaultproject = getdefaultproj(pw->pw_name, &tempproject, &buf,\n\t    sizeof(buf))) != NULL) {\n\t\t/* set default project */\n\t\tif (setproject(defaultproject->pj_name, pw->pw_name,\n\t\t    TASK_NORMAL) != 0)\n\t\t\tdebug(\"setproject(%s): %s\", defaultproject->pj_name,\n\t\t\t    strerror(errno));\n\t} else {\n\t\t/* debug on getdefaultproj() error */\n\t\tdebug(\"getdefaultproj(%s): %s\", pw->pw_name, strerror(errno));\n\t}\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_set_default_project(struct passwd *pw)\n{\n\tstruct project  *defaultproject;\n\tstruct project   tempproject;\n\tchar buf[1024];\n\n\t/* get default project, if we fail just return gracefully  */\n\tif ((defaultproject = getdefaultproj(pw->pw_name, &tempproject, &buf,\n\t    sizeof(buf))) != NULL) {\n\t\t/* set default project */\n\t\tif (setproject(defaultproject->pj_name, pw->pw_name,\n\t\t    TASK_NORMAL) != 0)\n\t\t\tdebug(\"setproject(%s): %s\", defaultproject->pj_name,\n\t\t\t    strerror(errno));\n\t} else {\n\t\t/* debug on getdefaultproj() error */\n\t\tdebug(\"getdefaultproj(%s): %s\", pw->pw_name, strerror(errno));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_selinux_enabled",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_selinux_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "44-55",
          "snippet": "int\nssh_selinux_enabled(void)\n{\n\tstatic int enabled = -1;\n\n\tif (enabled == -1) {\n\t\tenabled = (is_selinux_enabled() == 1);\n\t\tdebug(\"SELinux support %s\", enabled ? \"enabled\" : \"disabled\");\n\t}\n\n\treturn (enabled);\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nssh_selinux_enabled(void)\n{\n\tstatic int enabled = -1;\n\n\tif (enabled == -1) {\n\t\tenabled = (is_selinux_enabled() == 1);\n\t\tdebug(\"SELinux support %s\", enabled ? \"enabled\" : \"disabled\");\n\t}\n\n\treturn (enabled);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nextern int use_privsep;\nextern ServerOptions options;\n\nvoid\nplatform_setusercontext(struct passwd *pw)\n{\n#ifdef WITH_SELINUX\n\t/* Cache selinux status for later use */\n\t(void)ssh_selinux_enabled();\n#endif\n\n#ifdef USE_SOLARIS_PROJECTS\n\t/*\n\t * If solaris projects were detected, set the default now, unless\n\t * we are using PAM in which case it is the responsibility of the\n\t * PAM stack.\n\t */\n\tif (!options.use_pam && (getuid() == 0 || geteuid() == 0))\n\t\tsolaris_set_default_project(pw);\n#endif\n\n#if defined(HAVE_LOGIN_CAP) && defined (__bsdi__)\n\tif (getuid() == 0 || geteuid() == 0)\n\t\tsetpgid(0, 0);\n# endif\n\n#if defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * If we have both LOGIN_CAP and PAM, we want to establish creds\n\t * before calling setusercontext (in session.c:do_setusercontext).\n\t */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\tif (options.use_pam) {\n\t\t\tdo_pam_setcred(use_privsep);\n\t\t}\n\t}\n# endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && defined(HAVE_GETLUID) && defined(HAVE_SETLUID)\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Sets login uid for accounting */\n\t\tif (getluid() == -1 && setluid(pw->pw_uid) == -1)\n\t\t\terror(\"setluid: %s\", strerror(errno));\n\t}\n#endif\n}"
  },
  {
    "function_name": "platform_privileged_uidswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "81-90",
    "snippet": "int\nplatform_privileged_uidswap(void)\n{\n#ifdef HAVE_CYGWIN\n\t/* uid 0 is not special on Cygwin so always try */\n\treturn 1;\n#else\n\treturn (getuid() == 0 || geteuid() == 0);\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nplatform_privileged_uidswap(void)\n{\n#ifdef HAVE_CYGWIN\n\t/* uid 0 is not special on Cygwin so always try */\n\treturn 1;\n#else\n\treturn (getuid() == 0 || geteuid() == 0);\n#endif\n}"
  },
  {
    "function_name": "platform_post_fork_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "69-78",
    "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_adjust_restore",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "oom_adjust_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "294-311",
          "snippet": "void\noom_adjust_restore(void)\n{\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\tif (oom_adj_save == INT_MIN || oom_adj_path == NULL ||\n\t    (fp = fopen(oom_adj_path, \"w\")) == NULL)\n\t\treturn;\n\n\tif (fprintf(fp, \"%d\\n\", oom_adj_save) <= 0)\n\t\tverbose(\"error writing %s: %s\", oom_adj_path, strerror(errno));\n\telse\n\t\tdebug(\"Set %s to %d\", oom_adj_path, oom_adj_save);\n\n\tfclose(fp);\n\treturn;\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\noom_adjust_restore(void)\n{\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\tif (oom_adj_save == INT_MIN || oom_adj_path == NULL ||\n\t    (fp = fopen(oom_adj_path, \"w\")) == NULL)\n\t\treturn;\n\n\tif (fprintf(fp, \"%d\\n\", oom_adj_save) <= 0)\n\t\tverbose(\"error writing %s: %s\", oom_adj_path, strerror(errno));\n\telse\n\t\tdebug(\"Set %s to %d\", oom_adj_path, oom_adj_save);\n\n\tfclose(fp);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "solaris_contract_post_fork_child",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "solaris_contract_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "124-137",
          "snippet": "void\nsolaris_contract_post_fork_child()\n{\n\tdebug2(\"%s: clearing process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* Clear the active template. */\n\tif (ct_tmpl_clear(tmpl_fd) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_contract_post_fork_child()\n{\n\tdebug2(\"%s: clearing process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* Clear the active template. */\n\tif (ct_tmpl_clear(tmpl_fd) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
  },
  {
    "function_name": "platform_post_fork_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "61-67",
    "snippet": "void\nplatform_post_fork_parent(pid_t child_pid)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_parent(child_pid);\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "solaris_contract_post_fork_parent",
          "args": [
            "child_pid"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "solaris_contract_post_fork_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "139-196",
          "snippet": "void\nsolaris_contract_post_fork_parent(pid_t pid)\n{\n\tctid_t ctid;\n\tchar ctl_path[256];\n\tint r, ctl_fd = -1, stat_fd = -1;\n\n\tdebug2(\"%s: clearing template (fd %d)\", __func__, tmpl_fd);\n\n\tif (tmpl_fd == -1)\n\t\treturn;\n\n\t/* First clear the active template. */\n\tif ((r = ct_tmpl_clear(tmpl_fd)) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n\n\t/*\n\t * If either the fork didn't succeed (pid < 0), or clearing\n\t * th active contract failed (r != 0), then we have nothing\n\t * more do.\n\t */\n\tif (r != 0 || pid <= 0)\n\t\treturn;\n\n\t/* Now lookup and abandon the contract we've created. */\n\tctid = get_active_process_contract_id();\n\n\tdebug2(\"%s: abandoning contract id %ld\", __func__, ctid);\n\n\tsnprintf(ctl_path, sizeof(ctl_path),\n\t    CTFS_ROOT \"/process/%ld/ctl\", ctid);\n\tif ((ctl_fd = open64(ctl_path, O_WRONLY)) < 0) {\n\t\terror(\"%s: Error opening process contract \"\n\t\t    \"ctl file: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_ctl_abandon(ctl_fd) < 0) {\n\t\terror(\"%s: Error abandoning process contract: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tclose(ctl_fd);\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n\tif (stat_fd != -1)\n\t\tclose(stat_fd);\n\tif (ctl_fd != -1)\n\t\tclose(ctl_fd);\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_contract_post_fork_parent(pid_t pid)\n{\n\tctid_t ctid;\n\tchar ctl_path[256];\n\tint r, ctl_fd = -1, stat_fd = -1;\n\n\tdebug2(\"%s: clearing template (fd %d)\", __func__, tmpl_fd);\n\n\tif (tmpl_fd == -1)\n\t\treturn;\n\n\t/* First clear the active template. */\n\tif ((r = ct_tmpl_clear(tmpl_fd)) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n\n\t/*\n\t * If either the fork didn't succeed (pid < 0), or clearing\n\t * th active contract failed (r != 0), then we have nothing\n\t * more do.\n\t */\n\tif (r != 0 || pid <= 0)\n\t\treturn;\n\n\t/* Now lookup and abandon the contract we've created. */\n\tctid = get_active_process_contract_id();\n\n\tdebug2(\"%s: abandoning contract id %ld\", __func__, ctid);\n\n\tsnprintf(ctl_path, sizeof(ctl_path),\n\t    CTFS_ROOT \"/process/%ld/ctl\", ctid);\n\tif ((ctl_fd = open64(ctl_path, O_WRONLY)) < 0) {\n\t\terror(\"%s: Error opening process contract \"\n\t\t    \"ctl file: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_ctl_abandon(ctl_fd) < 0) {\n\t\terror(\"%s: Error abandoning process contract: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tclose(ctl_fd);\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n\tif (stat_fd != -1)\n\t\tclose(stat_fd);\n\tif (ctl_fd != -1)\n\t\tclose(ctl_fd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_parent(pid_t child_pid)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_parent(child_pid);\n#endif\n}"
  },
  {
    "function_name": "platform_pre_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "53-59",
    "snippet": "void\nplatform_pre_restart(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_adjust_restore",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "oom_adjust_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "294-311",
          "snippet": "void\noom_adjust_restore(void)\n{\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\tif (oom_adj_save == INT_MIN || oom_adj_path == NULL ||\n\t    (fp = fopen(oom_adj_path, \"w\")) == NULL)\n\t\treturn;\n\n\tif (fprintf(fp, \"%d\\n\", oom_adj_save) <= 0)\n\t\tverbose(\"error writing %s: %s\", oom_adj_path, strerror(errno));\n\telse\n\t\tdebug(\"Set %s to %d\", oom_adj_path, oom_adj_save);\n\n\tfclose(fp);\n\treturn;\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\noom_adjust_restore(void)\n{\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\tif (oom_adj_save == INT_MIN || oom_adj_path == NULL ||\n\t    (fp = fopen(oom_adj_path, \"w\")) == NULL)\n\t\treturn;\n\n\tif (fprintf(fp, \"%d\\n\", oom_adj_save) <= 0)\n\t\tverbose(\"error writing %s: %s\", oom_adj_path, strerror(errno));\n\telse\n\t\tdebug(\"Set %s to %d\", oom_adj_path, oom_adj_save);\n\n\tfclose(fp);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_restart(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
  },
  {
    "function_name": "platform_pre_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "45-51",
    "snippet": "void\nplatform_pre_fork(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_pre_fork();\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "solaris_contract_pre_fork",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "solaris_contract_pre_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "75-122",
          "snippet": "void\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\n#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\"\n\nvoid\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_fork(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_pre_fork();\n#endif\n}"
  },
  {
    "function_name": "platform_pre_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
    "lines": "36-43",
    "snippet": "void\nplatform_pre_listen(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\t/* Adjust out-of-memory killer so listening process is not killed */\n\toom_adjust_setup();\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openbsd-compat.h\"",
      "#include \"platform.h\"",
      "#include \"auth-pam.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_adjust_setup",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "oom_adjust_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "263-291",
          "snippet": "void\noom_adjust_setup(void)\n{\n\tint i, value;\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\t for (i = 0; oom_adjust[i].path != NULL; i++) {\n\t\toom_adj_path = oom_adjust[i].path;\n\t\tvalue = oom_adjust[i].value;\n\t\tif ((fp = fopen(oom_adj_path, \"r+\")) != NULL) {\n\t\t\tif (fscanf(fp, \"%d\", &oom_adj_save) != 1)\n\t\t\t\tverbose(\"error reading %s: %s\", oom_adj_path,\n\t\t\t\t    strerror(errno));\n\t\t\telse {\n\t\t\t\trewind(fp);\n\t\t\t\tif (fprintf(fp, \"%d\\n\", value) <= 0)\n\t\t\t\t\tverbose(\"error writing %s: %s\",\n\t\t\t\t\t   oom_adj_path, strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tdebug(\"Set %s from %d to %d\",\n\t\t\t\t\t   oom_adj_path, oom_adj_save, value);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t}\n\toom_adj_path = NULL;\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\noom_adjust_setup(void)\n{\n\tint i, value;\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\t for (i = 0; oom_adjust[i].path != NULL; i++) {\n\t\toom_adj_path = oom_adjust[i].path;\n\t\tvalue = oom_adjust[i].value;\n\t\tif ((fp = fopen(oom_adj_path, \"r+\")) != NULL) {\n\t\t\tif (fscanf(fp, \"%d\", &oom_adj_save) != 1)\n\t\t\t\tverbose(\"error reading %s: %s\", oom_adj_path,\n\t\t\t\t    strerror(errno));\n\t\t\telse {\n\t\t\t\trewind(fp);\n\t\t\t\tif (fprintf(fp, \"%d\\n\", value) <= 0)\n\t\t\t\t\tverbose(\"error writing %s: %s\",\n\t\t\t\t\t   oom_adj_path, strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tdebug(\"Set %s from %d to %d\",\n\t\t\t\t\t   oom_adj_path, oom_adj_save, value);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t}\n\toom_adj_path = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_listen(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\t/* Adjust out-of-memory killer so listening process is not killed */\n\toom_adjust_setup();\n#endif\n}"
  }
]