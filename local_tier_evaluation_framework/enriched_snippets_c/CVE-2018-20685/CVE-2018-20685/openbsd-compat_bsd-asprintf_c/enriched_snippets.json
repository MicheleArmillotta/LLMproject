[
  {
    "function_name": "asprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
    "lines": "86-97",
    "snippet": "int asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <errno.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "str",
            "fmt",
            "ap"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "vasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
          "lines": "39-82",
          "snippet": "int\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define INIT_SZ\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define INIT_SZ\t128\n\nint\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint asprintf(char **str, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t*str = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(str, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vasprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-asprintf.c",
    "lines": "39-82",
    "snippet": "int\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <errno.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define INIT_SZ\t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap2"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap2"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newstr"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "newstr",
            "len",
            "fmt",
            "ap2"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "861-865",
          "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VA_COPY",
          "args": [
            "ap2",
            "ap"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap2"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "string",
            "len"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "48-56",
          "snippet": "void *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "INIT_SZ"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VA_COPY",
          "args": [
            "ap2",
            "ap"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define INIT_SZ\t128\n\nint\nvasprintf(char **str, const char *fmt, va_list ap)\n{\n\tint ret = -1;\n\tva_list ap2;\n\tchar *string, *newstr;\n\tsize_t len;\n\n\tVA_COPY(ap2, ap);\n\tif ((string = malloc(INIT_SZ)) == NULL)\n\t\tgoto fail;\n\n\tret = vsnprintf(string, INIT_SZ, fmt, ap2);\n\tif (ret >= 0 && ret < INIT_SZ) { /* succeeded with initial alloc */\n\t\t*str = string;\n\t} else if (ret == INT_MAX || ret < 0) { /* Bad length */\n\t\tfree(string);\n\t\tgoto fail;\n\t} else {\t/* bigger than initial, realloc allowing for nul */\n\t\tlen = (size_t)ret + 1;\n\t\tif ((newstr = realloc(string, len)) == NULL) {\n\t\t\tfree(string);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tva_end(ap2);\n\t\t\tVA_COPY(ap2, ap);\n\t\t\tret = vsnprintf(newstr, len, fmt, ap2);\n\t\t\tif (ret >= 0 && (size_t)ret < len) {\n\t\t\t\t*str = newstr;\n\t\t\t} else { /* failed with realloc'ed string, give up */\n\t\t\t\tfree(newstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tva_end(ap2);\n\treturn (ret);\n\nfail:\n\t*str = NULL;\n\terrno = ENOMEM;\n\tva_end(ap2);\n\treturn (-1);\n}"
  }
]