[
  {
    "function_name": "server_init_dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "899-921",
    "snippet": "static void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void server_init_dispatch(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_KEXINIT",
            "&kex_input_kexinit"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_REQUEST_FAILURE",
            "&server_input_keep_alive"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_REQUEST_SUCCESS",
            "&server_input_keep_alive"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_FAILURE",
            "&server_input_keep_alive"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_SUCCESS",
            "&server_input_keep_alive"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST",
            "&server_input_global_request"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_WINDOW_ADJUST",
            "&channel_input_window_adjust"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_REQUEST",
            "&server_input_channel_req"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_FAILURE",
            "&channel_input_open_failure"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION",
            "&channel_input_open_confirmation"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN",
            "&server_input_channel_open"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_EXTENDED_DATA",
            "&channel_input_extended_data"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_EOF",
            "&channel_input_ieof"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_DATA",
            "&channel_input_data"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_CLOSE",
            "&channel_input_oclose"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_init",
          "args": [
            "&dispatch_protocol_error"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"server_init_dispatch\""
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void server_init_dispatch(void);\n\nstatic void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}"
  },
  {
    "function_name": "server_input_channel_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "863-897",
    "snippet": "static int\nserver_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c;\n\tint id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"server_input_channel_req: channel %d request %s reply %d\",\n\t    id, rtype, reply);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tpacket_disconnect(\"server_input_channel_req: \"\n\t\t    \"unknown channel %d\", id);\n\tif (!strcmp(rtype, \"eow@openssh.com\")) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if ((c->type == SSH_CHANNEL_LARVAL ||\n\t    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, \"session\") == 0)\n\t\tsuccess = session_input_channel_req(ssh, c, rtype);\n\tif (reply && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\"%s: channel %d: no remote_id\",\n\t\t\t    __func__, c->self);\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rtype"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->remote_id"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: no remote_id\"",
            "__func__",
            "c->self"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_input_channel_req",
          "args": [
            "ssh",
            "c",
            "rtype"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "session_input_channel_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2197-2239",
          "snippet": "int\nsession_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)\n{\n\tint success = 0;\n\tSession *s;\n\n\tif ((s = session_by_channel(c->self)) == NULL) {\n\t\tlogit(\"%s: no session %d req %.100s\", __func__, c->self, rtype);\n\t\treturn 0;\n\t}\n\tdebug(\"%s: session %d req %s\", __func__, s->self, rtype);\n\n\t/*\n\t * a session is in LARVAL state until a shell, a command\n\t * or a subsystem is executed\n\t */\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\tif (strcmp(rtype, \"shell\") == 0) {\n\t\t\tsuccess = session_shell_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"exec\") == 0) {\n\t\t\tsuccess = session_exec_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"pty-req\") == 0) {\n\t\t\tsuccess = session_pty_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"x11-req\") == 0) {\n\t\t\tsuccess = session_x11_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"auth-agent-req@openssh.com\") == 0) {\n\t\t\tsuccess = session_auth_agent_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"subsystem\") == 0) {\n\t\t\tsuccess = session_subsystem_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"env\") == 0) {\n\t\t\tsuccess = session_env_req(ssh, s);\n\t\t}\n\t}\n\tif (strcmp(rtype, \"window-change\") == 0) {\n\t\tsuccess = session_window_change_req(ssh, s);\n\t} else if (strcmp(rtype, \"break\") == 0) {\n\t\tsuccess = session_break_req(ssh, s);\n\t} else if (strcmp(rtype, \"signal\") == 0) {\n\t\tsuccess = session_signal_req(ssh, s);\n\t}\n\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nint\nsession_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)\n{\n\tint success = 0;\n\tSession *s;\n\n\tif ((s = session_by_channel(c->self)) == NULL) {\n\t\tlogit(\"%s: no session %d req %.100s\", __func__, c->self, rtype);\n\t\treturn 0;\n\t}\n\tdebug(\"%s: session %d req %s\", __func__, s->self, rtype);\n\n\t/*\n\t * a session is in LARVAL state until a shell, a command\n\t * or a subsystem is executed\n\t */\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\tif (strcmp(rtype, \"shell\") == 0) {\n\t\t\tsuccess = session_shell_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"exec\") == 0) {\n\t\t\tsuccess = session_exec_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"pty-req\") == 0) {\n\t\t\tsuccess = session_pty_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"x11-req\") == 0) {\n\t\t\tsuccess = session_x11_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"auth-agent-req@openssh.com\") == 0) {\n\t\t\tsuccess = session_auth_agent_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"subsystem\") == 0) {\n\t\t\tsuccess = session_subsystem_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"env\") == 0) {\n\t\t\tsuccess = session_env_req(ssh, s);\n\t\t}\n\t}\n\tif (strcmp(rtype, \"window-change\") == 0) {\n\t\tsuccess = session_window_change_req(ssh, s);\n\t} else if (strcmp(rtype, \"break\") == 0) {\n\t\tsuccess = session_break_req(ssh, s);\n\t} else if (strcmp(rtype, \"signal\") == 0) {\n\t\tsuccess = session_signal_req(ssh, s);\n\t}\n\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->ctype",
            "\"session\""
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_eow",
          "args": [
            "ssh",
            "c"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_eow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "167-177",
          "snippet": "void\nchan_rcvd_eow(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eow\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_eow(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eow\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"server_input_channel_req: \"\n\t\t    \"unknown channel %d\"",
            "id"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"server_input_channel_req: channel %d request %s reply %d\"",
            "id",
            "rtype",
            "reply"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_char",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "221-225",
          "snippet": "u_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserver_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c;\n\tint id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"server_input_channel_req: channel %d request %s reply %d\",\n\t    id, rtype, reply);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tpacket_disconnect(\"server_input_channel_req: \"\n\t\t    \"unknown channel %d\", id);\n\tif (!strcmp(rtype, \"eow@openssh.com\")) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if ((c->type == SSH_CHANNEL_LARVAL ||\n\t    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, \"session\") == 0)\n\t\tsuccess = session_input_channel_req(ssh, c, rtype);\n\tif (reply && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\"%s: channel %d: no remote_id\",\n\t\t\t    __func__, c->self);\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}"
  },
  {
    "function_name": "server_input_global_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "754-861",
    "snippet": "static int\nserver_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint r, success = 0, allocated_listen_port = 0;\n\tstruct sshbuf *resp = NULL;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\trtype = packet_get_string(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"%s: rtype %s want_reply %d\", __func__, rtype, want_reply);\n\n\t/* -R style forwarding */\n\tif (strcmp(rtype, \"tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: tcpip-forward listen %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||\n\t\t    !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (!want_reply && fwd.listen_port == 0) ||\n\t\t    (fwd.listen_port != 0 &&\n\t\t     !bind_permitted(fwd.listen_port, pw->pw_uid))) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the port */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh, &fwd,\n\t\t\t    &allocated_listen_port, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_host);\n\t\tif ((resp = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif (allocated_listen_port != 0 &&\n\t\t    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_u32: %s\", __func__, ssh_err(r));\n\t} else if (strcmp(rtype, \"cancel-tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: cancel-tcpip-forward addr %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t\tfree(fwd.listen_host);\n\t} else if (strcmp(rtype, \"streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: streamlocal-forward listen path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n\t\t    || !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (pw->pw_uid != 0 && !use_privsep)) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled \"\n\t\t\t    \"streamlocal forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the socket */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh,\n\t\t\t    &fwd, NULL, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"cancel-streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: cancel-streamlocal-forward path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"no-more-sessions@openssh.com\") == 0) {\n\t\tno_more_sessions = 1;\n\t\tsuccess = 1;\n\t} else if (strcmp(rtype, \"hostkeys-prove-00@openssh.com\") == 0) {\n\t\tsuccess = server_input_hostkeys_prove(ssh, &resp);\n\t}\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tif (success && resp != NULL)\n\t\t\tssh_packet_put_raw(ssh, sshbuf_ptr(resp),\n\t\t\t    sshbuf_len(resp));\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\tsshbuf_free(resp);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern Authctxt *the_authctxt;",
      "extern struct sshauthopt *auth_opts;",
      "extern int use_privsep;",
      "static int no_more_sessions = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "resp"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rtype"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_write_wait",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "271-278",
          "snippet": "void\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_put_raw",
          "args": [
            "ssh",
            "sshbuf_ptr(resp)",
            "sshbuf_len(resp)"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_put_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "71-78",
          "snippet": "void\nssh_packet_put_raw(struct ssh *ssh, const void *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = sshpkt_put(ssh, buf, len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_put_raw(struct ssh *ssh, const void *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = sshpkt_put(ssh, buf, len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "resp"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "resp"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server_input_hostkeys_prove",
          "args": [
            "ssh",
            "&resp"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "server_input_hostkeys_prove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "676-752",
          "snippet": "static int\nserver_input_hostkeys_prove(struct ssh *ssh, struct sshbuf **respp)\n{\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, kexsigtype, use_kexsigtype, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(key->type) == KEY_RSA;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserver_input_hostkeys_prove(struct ssh *ssh, struct sshbuf **respp)\n{\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, kexsigtype, use_kexsigtype, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(key->type) == KEY_RSA;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rtype",
            "\"hostkeys-prove-00@openssh.com\""
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_rport_listener",
          "args": [
            "ssh",
            "&fwd"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_rport_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3625-3635",
          "snippet": "int\nchannel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_rport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_rport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_rport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_rport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: cancel-streamlocal-forward path %s\"",
            "__func__",
            "fwd.listen_path"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_setup_remote_fwd_listener",
          "args": [
            "ssh",
            "&fwd",
            "NULL",
            "&options.fwd_opts"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_remote_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3791-3807",
          "snippet": "int\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"Server has disabled \"\n\t\t\t    \"streamlocal forwarding.\""
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_put_u32: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "resp",
            "allocated_listen_port"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind_permitted",
          "args": [
            "fwd.listen_port",
            "pw->pw_uid"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "bind_permitted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "107-115",
          "snippet": "static int\nbind_permitted(int port, uid_t uid)\n{\n\tif (use_privsep)\n\t\treturn 1; /* allow system to decide */\n\tif (port < IPPORT_RESERVED && uid != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int use_privsep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern int use_privsep;\n\nstatic int\nbind_permitted(int port, uid_t uid)\n{\n\tif (use_privsep)\n\t\treturn 1; /* allow system to decide */\n\tif (port < IPPORT_RESERVED && uid != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_char",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "221-225",
          "snippet": "u_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern Authctxt *the_authctxt;\nextern struct sshauthopt *auth_opts;\nextern int use_privsep;\nstatic int no_more_sessions = 0;\n\nstatic int\nserver_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint r, success = 0, allocated_listen_port = 0;\n\tstruct sshbuf *resp = NULL;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\trtype = packet_get_string(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"%s: rtype %s want_reply %d\", __func__, rtype, want_reply);\n\n\t/* -R style forwarding */\n\tif (strcmp(rtype, \"tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: tcpip-forward listen %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||\n\t\t    !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (!want_reply && fwd.listen_port == 0) ||\n\t\t    (fwd.listen_port != 0 &&\n\t\t     !bind_permitted(fwd.listen_port, pw->pw_uid))) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the port */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh, &fwd,\n\t\t\t    &allocated_listen_port, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_host);\n\t\tif ((resp = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif (allocated_listen_port != 0 &&\n\t\t    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_u32: %s\", __func__, ssh_err(r));\n\t} else if (strcmp(rtype, \"cancel-tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: cancel-tcpip-forward addr %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t\tfree(fwd.listen_host);\n\t} else if (strcmp(rtype, \"streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: streamlocal-forward listen path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n\t\t    || !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (pw->pw_uid != 0 && !use_privsep)) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled \"\n\t\t\t    \"streamlocal forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the socket */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh,\n\t\t\t    &fwd, NULL, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"cancel-streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: cancel-streamlocal-forward path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"no-more-sessions@openssh.com\") == 0) {\n\t\tno_more_sessions = 1;\n\t\tsuccess = 1;\n\t} else if (strcmp(rtype, \"hostkeys-prove-00@openssh.com\") == 0) {\n\t\tsuccess = server_input_hostkeys_prove(ssh, &resp);\n\t}\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tif (success && resp != NULL)\n\t\t\tssh_packet_put_raw(ssh, sshbuf_ptr(resp),\n\t\t\t    sshbuf_len(resp));\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\tsshbuf_free(resp);\n\treturn 0;\n}"
  },
  {
    "function_name": "server_input_hostkeys_prove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "676-752",
    "snippet": "static int\nserver_input_hostkeys_prove(struct ssh *ssh, struct sshbuf **respp)\n{\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, kexsigtype, use_kexsigtype, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(key->type) == KEY_RSA;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sigbuf"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: couldn't prepare signature: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "resp",
            "sig",
            "slen"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh->kex->sign",
          "args": [
            "key_prv",
            "key_pub",
            "&sig",
            "&slen",
            "sshbuf_ptr(sigbuf)",
            "sshbuf_len(sigbuf)",
            "use_kexsigtype ? ssh->kex->hostkey_alg : NULL",
            "0"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sigbuf"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "sigbuf"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "key",
            "sigbuf"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "sigbuf",
            "\"hostkeys-prove-00@openssh.com\""
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "key->type"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "sigbuf"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostkey_public_by_index",
          "args": [
            "ndx",
            "ssh"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_public_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "807-813",
          "snippet": "struct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostkey_by_index",
          "args": [
            "ndx"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "799-805",
          "snippet": "struct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh->kex->host_key_index",
          "args": [
            "key",
            "1",
            "ssh"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "&key"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "&blob",
            "&blen"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_remaining",
          "args": [
            "ssh"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1757-1761",
          "snippet": "int\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "ssh->kex->hostkey_alg"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserver_input_hostkeys_prove(struct ssh *ssh, struct sshbuf **respp)\n{\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, kexsigtype, use_kexsigtype, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(key->type) == KEY_RSA;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}"
  },
  {
    "function_name": "server_input_channel_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "623-674",
    "snippet": "static int\nserver_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tconst char *errmsg = NULL;\n\tint rchan, reason = SSH2_OPEN_CONNECT_FAILED;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"%s: ctype %s rchan %d win %d max %d\", __func__,\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"session\") == 0) {\n\t\tc = server_request_session(ssh);\n\t} else if (strcmp(ctype, \"direct-tcpip\") == 0) {\n\t\tc = server_request_direct_tcpip(ssh, &reason, &errmsg);\n\t} else if (strcmp(ctype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\tc = server_request_direct_streamlocal(ssh);\n\t} else if (strcmp(ctype, \"tun@openssh.com\") == 0) {\n\t\tc = server_request_tun(ssh);\n\t}\n\tif (c != NULL) {\n\t\tdebug(\"%s: confirm %s\", __func__, ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"%s: failure %s\", __func__, ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(reason);\n\t\tpacket_put_cstring(errmsg ? errmsg : \"open failed\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctype"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "errmsg ? errmsg : \"open failed\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "reason"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "rchan"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_FAILURE"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: failure %s\"",
            "__func__",
            "ctype"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_maxpacket"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_window"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->self"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->remote_id"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server_request_tun",
          "args": [
            "ssh"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "server_request_tun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "531-590",
          "snippet": "static Channel *\nserver_request_tun(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint mode, tun, sock;\n\tchar *tmp, *ifname = NULL;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (auth_opts->force_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && auth_opts->force_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = auth_opts->force_tun_device;\n\t}\n\tsock = tun_open(tun, mode, &ifname);\n\tif (sock < 0)\n\t\tgoto done;\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n#if defined(SSH_TUN_FILTER)\n\tif (mode == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\t/*\n\t * Update the list of names exposed to the session\n\t * XXX remove these if the tunnels are closed (won't matter\n\t * much if they are already in the environment though)\n\t */\n\ttmp = tun_fwd_ifnames;\n\txasprintf(&tun_fwd_ifnames, \"%s%s%s\",\n\t    tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames,\n\t    tun_fwd_ifnames == NULL ? \"\" : \",\",\n\t    ifname);\n\tfree(tmp);\n\tfree(ifname);\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;",
            "char *tun_fwd_ifnames = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\nchar *tun_fwd_ifnames = NULL;\n\nstatic Channel *\nserver_request_tun(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint mode, tun, sock;\n\tchar *tmp, *ifname = NULL;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (auth_opts->force_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && auth_opts->force_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = auth_opts->force_tun_device;\n\t}\n\tsock = tun_open(tun, mode, &ifname);\n\tif (sock < 0)\n\t\tgoto done;\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n#if defined(SSH_TUN_FILTER)\n\tif (mode == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\t/*\n\t * Update the list of names exposed to the session\n\t * XXX remove these if the tunnels are closed (won't matter\n\t * much if they are already in the environment though)\n\t */\n\ttmp = tun_fwd_ifnames;\n\txasprintf(&tun_fwd_ifnames, \"%s%s%s\",\n\t    tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames,\n\t    tun_fwd_ifnames == NULL ? \"\" : \",\",\n\t    ifname);\n\tfree(tmp);\n\tfree(ifname);\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ctype",
            "\"tun@openssh.com\""
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_request_direct_streamlocal",
          "args": [
            "ssh"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "server_request_direct_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "494-529",
          "snippet": "static Channel *\nserver_request_direct_streamlocal(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s\", __func__,\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding && (pw->pw_uid == 0 || use_privsep)) {\n\t\tc = channel_connect_to_path(ssh, target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern Authctxt *the_authctxt;",
            "extern struct sshauthopt *auth_opts;",
            "extern int use_privsep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern Authctxt *the_authctxt;\nextern struct sshauthopt *auth_opts;\nextern int use_privsep;\n\nstatic Channel *\nserver_request_direct_streamlocal(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s\", __func__,\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding && (pw->pw_uid == 0 || use_privsep)) {\n\t\tc = channel_connect_to_path(ssh, target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_request_direct_tcpip",
          "args": [
            "ssh",
            "&reason",
            "&errmsg"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "server_request_direct_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "458-492",
          "snippet": "static Channel *\nserver_request_direct_tcpip(struct ssh *ssh, int *reason, const char **errmsg)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s port %d\", __func__,\n\t    originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(ssh, target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\", reason, errmsg);\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic Channel *\nserver_request_direct_tcpip(struct ssh *ssh, int *reason, const char **errmsg)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s port %d\", __func__,\n\t    originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(ssh, target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\", reason, errmsg);\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_request_session",
          "args": [
            "ssh"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "server_request_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "592-621",
          "snippet": "static Channel *\nserver_request_session(struct ssh *ssh)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(ssh, \"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(ssh, c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 0);\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Authctxt *the_authctxt;",
            "static int no_more_sessions = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Authctxt *the_authctxt;\nstatic int no_more_sessions = 0;\n\nstatic Channel *\nserver_request_session(struct ssh *ssh)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(ssh, \"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(ssh, c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 0);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserver_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tconst char *errmsg = NULL;\n\tint rchan, reason = SSH2_OPEN_CONNECT_FAILED;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"%s: ctype %s rchan %d win %d max %d\", __func__,\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"session\") == 0) {\n\t\tc = server_request_session(ssh);\n\t} else if (strcmp(ctype, \"direct-tcpip\") == 0) {\n\t\tc = server_request_direct_tcpip(ssh, &reason, &errmsg);\n\t} else if (strcmp(ctype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\tc = server_request_direct_streamlocal(ssh);\n\t} else if (strcmp(ctype, \"tun@openssh.com\") == 0) {\n\t\tc = server_request_tun(ssh);\n\t}\n\tif (c != NULL) {\n\t\tdebug(\"%s: confirm %s\", __func__, ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"%s: failure %s\", __func__, ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(reason);\n\t\tpacket_put_cstring(errmsg ? errmsg : \"open failed\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}"
  },
  {
    "function_name": "server_request_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "592-621",
    "snippet": "static Channel *\nserver_request_session(struct ssh *ssh)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(ssh, \"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(ssh, c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 0);\n\treturn c;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Authctxt *the_authctxt;",
      "static int no_more_sessions = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "c->self",
            "session_close_by_channel",
            "0"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session open failed, free channel %d\"",
            "c->self"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_open",
          "args": [
            "the_authctxt",
            "c->self"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "session_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1816-1832",
          "snippet": "int\nsession_open(Authctxt *authctxt, int chanid)\n{\n\tSession *s = session_new();\n\tdebug(\"session_open: channel %d\", chanid);\n\tif (s == NULL) {\n\t\terror(\"no more sessions\");\n\t\treturn 0;\n\t}\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\tif (s->pw == NULL || !authctxt->valid)\n\t\tfatal(\"no user for session %d\", s->self);\n\tdebug(\"session_open: session %d: link with channel %d\", s->self, chanid);\n\ts->chanid = chanid;\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Session *session_new(void);",
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static void do_authenticated2(struct ssh *, Authctxt *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic Session *sessions = NULL;\n\nint\nsession_open(Authctxt *authctxt, int chanid)\n{\n\tSession *s = session_new();\n\tdebug(\"session_open: channel %d\", chanid);\n\tif (s == NULL) {\n\t\terror(\"no more sessions\");\n\t\treturn 0;\n\t}\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\tif (s->pw == NULL || !authctxt->valid)\n\t\tfatal(\"no user for session %d\", s->self);\n\tdebug(\"session_open: session %d: link with channel %d\", s->self, chanid);\n\ts->chanid = chanid;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"session\"",
            "SSH_CHANNEL_LARVAL",
            "-1",
            "-1",
            "-1",
            "/*window size*/0",
            "CHAN_SES_PACKET_DEFAULT",
            "0",
            "\"server-session\"",
            "1"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Authctxt *the_authctxt;\nstatic int no_more_sessions = 0;\n\nstatic Channel *\nserver_request_session(struct ssh *ssh)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(ssh, \"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(ssh, c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 0);\n\treturn c;\n}"
  },
  {
    "function_name": "server_request_tun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "531-590",
    "snippet": "static Channel *\nserver_request_tun(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint mode, tun, sock;\n\tchar *tmp, *ifname = NULL;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (auth_opts->force_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && auth_opts->force_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = auth_opts->force_tun_device;\n\t}\n\tsock = tun_open(tun, mode, &ifname);\n\tif (sock < 0)\n\t\tgoto done;\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n#if defined(SSH_TUN_FILTER)\n\tif (mode == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\t/*\n\t * Update the list of names exposed to the session\n\t * XXX remove these if the tunnels are closed (won't matter\n\t * much if they are already in the environment though)\n\t */\n\ttmp = tun_fwd_ifnames;\n\txasprintf(&tun_fwd_ifnames, \"%s%s%s\",\n\t    tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames,\n\t    tun_fwd_ifnames == NULL ? \"\" : \",\",\n\t    ifname);\n\tfree(tmp);\n\tfree(ifname);\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;",
      "char *tun_fwd_ifnames = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"Failed to open the tunnel device.\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifname"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&tun_fwd_ifnames",
            "\"%s%s%s\"",
            "tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames",
            "tun_fwd_ifnames == NULL ? \"\" : \",\"",
            "ifname"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_filter",
          "args": [
            "ssh",
            "c->self",
            "sys_tun_infilter",
            "sys_tun_outfilter",
            "NULL",
            "NULL"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1012-1026",
          "snippet": "void\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"tun\"",
            "SSH_CHANNEL_OPEN",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"tun\"",
            "1"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Tunnel forwarding using interface %s\"",
            "ifname"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tun_open",
          "args": [
            "tun",
            "mode",
            "&ifname"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "tun_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1031-1107",
          "snippet": "int\ntun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\", __func__, tun);\n\t\treturn -1;\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open: %s\", __func__, name, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Bring interface up if it is not already */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug(\"%s: get interface %s flags: %s\", __func__,\n\t\t    ifr.ifr_name, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug(\"%s: activate interface %s: %s\", __func__,\n\t\t\t    ifr.ifr_name, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\n\tclose(sock);\n\treturn fd;\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ntun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\", __func__, tun);\n\t\treturn -1;\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open: %s\", __func__, name, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Bring interface up if it is not already */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug(\"%s: get interface %s flags: %s\", __func__,\n\t\t    ifr.ifr_name, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug(\"%s: activate interface %s: %s\", __func__,\n\t\t\t    ifr.ifr_name, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\n\tclose(sock);\n\treturn fd;\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\nchar *tun_fwd_ifnames = NULL;\n\nstatic Channel *\nserver_request_tun(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint mode, tun, sock;\n\tchar *tmp, *ifname = NULL;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (auth_opts->force_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && auth_opts->force_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = auth_opts->force_tun_device;\n\t}\n\tsock = tun_open(tun, mode, &ifname);\n\tif (sock < 0)\n\t\tgoto done;\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n#if defined(SSH_TUN_FILTER)\n\tif (mode == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\t/*\n\t * Update the list of names exposed to the session\n\t * XXX remove these if the tunnels are closed (won't matter\n\t * much if they are already in the environment though)\n\t */\n\ttmp = tun_fwd_ifnames;\n\txasprintf(&tun_fwd_ifnames, \"%s%s%s\",\n\t    tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames,\n\t    tun_fwd_ifnames == NULL ? \"\" : \",\",\n\t    ifname);\n\tfree(tmp);\n\tfree(ifname);\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}"
  },
  {
    "function_name": "server_request_direct_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "494-529",
    "snippet": "static Channel *\nserver_request_direct_streamlocal(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s\", __func__,\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding && (pw->pw_uid == 0 || use_privsep)) {\n\t\tc = channel_connect_to_path(ssh, target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern Authctxt *the_authctxt;",
      "extern struct sshauthopt *auth_opts;",
      "extern int use_privsep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "target"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\"",
            "originator",
            "originator_port",
            "target"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_to_path",
          "args": [
            "ssh",
            "target",
            "\"direct-streamlocal@openssh.com\"",
            "\"direct-streamlocal\""
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4417-4454",
          "snippet": "Channel *\nchannel_connect_to_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\", path);\n\t\treturn NULL;\n\t}\n\treturn connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_to_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\", path);\n\t\treturn NULL;\n\t}\n\treturn connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: originator %s port %d, target %s\"",
            "__func__",
            "originator",
            "originator_port",
            "target"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no/invalid user\"",
            "__func__"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern Authctxt *the_authctxt;\nextern struct sshauthopt *auth_opts;\nextern int use_privsep;\n\nstatic Channel *\nserver_request_direct_streamlocal(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\tstruct passwd *pw = the_authctxt->pw;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal(\"%s: no/invalid user\", __func__);\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s\", __func__,\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding && (pw->pw_uid == 0 || use_privsep)) {\n\t\tc = channel_connect_to_path(ssh, target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}"
  },
  {
    "function_name": "server_request_direct_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "458-492",
    "snippet": "static Channel *\nserver_request_direct_tcpip(struct ssh *ssh, int *reason, const char **errmsg)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s port %d\", __func__,\n\t    originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(ssh, target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\", reason, errmsg);\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "target"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\"",
            "originator",
            "originator_port",
            "target",
            "target_port"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_to_port",
          "args": [
            "ssh",
            "target",
            "target_port",
            "\"direct-tcpip\"",
            "\"direct-tcpip\"",
            "reason",
            "errmsg"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_to_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4357-4414",
          "snippet": "Channel *\nchannel_connect_to_port(struct ssh *ssh, const char *host, u_short port,\n    char *ctype, char *rname, int *reason, const char **errmsg)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tu_int i, permit, permit_adm = 1;\n\tint sock;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to host %.100s port %d, \"\n\t\t    \"but the request was denied.\", host, port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\treturn NULL;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, reason, errmsg);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_to_port(struct ssh *ssh, const char *host, u_short port,\n    char *ctype, char *rname, int *reason, const char **errmsg)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tu_int i, permit, permit_adm = 1;\n\tint sock;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to host %.100s port %d, \"\n\t\t    \"but the request was denied.\", host, port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\treturn NULL;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, reason, errmsg);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: originator %s port %d, target %s port %d\"",
            "__func__",
            "originator",
            "originator_port",
            "target",
            "target_port"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic Channel *\nserver_request_direct_tcpip(struct ssh *ssh, int *reason, const char **errmsg)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: originator %s port %d, target %s port %d\", __func__,\n\t    originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(ssh, target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\", reason, errmsg);\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}"
  },
  {
    "function_name": "server_input_keep_alive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "445-456",
    "snippet": "static int\nserver_input_keep_alive(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tdebug(\"Got %d/%u for keepalive\", type, seq);\n\t/*\n\t * reset timeout, since we got a sane answer from the client.\n\t * even if this was generated by something other than\n\t * the bogus CHANNEL_REQUEST we send for keepalives.\n\t */\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_set_alive_timeouts",
          "args": [
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Got %d/%u for keepalive\"",
            "type",
            "seq"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserver_input_keep_alive(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tdebug(\"Got %d/%u for keepalive\", type, seq);\n\t/*\n\t * reset timeout, since we got a sane answer from the client.\n\t * even if this was generated by something other than\n\t * the bogus CHANNEL_REQUEST we send for keepalives.\n\t */\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "server_loop2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "378-443",
    "snippet": "void\nserver_loop2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets(ssh);\n\n\t\tif (!ssh_packet_is_rekeying(ssh) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll(ssh);\n\t\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(ssh, connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children(ssh);\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\t\tif (process_input(ssh, readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children(ssh);\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all(ssh);\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(ssh, NULL);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern int use_privsep;",
      "static volatile sig_atomic_t child_terminated = 0;",
      "static volatile sig_atomic_t received_sigterm = 0;",
      "static void server_init_dispatch(void);",
      "static int notify_pipe[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_destroy_all",
          "args": [
            "ssh",
            "NULL"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "session_destroy_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2507-2520",
          "snippet": "void\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free_all",
          "args": [
            "ssh"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "642-650",
          "snippet": "void\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "writeset"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_children",
          "args": [
            "ssh"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "collect_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "356-376",
          "snippet": "static void\ncollect_children(struct ssh *ssh)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(ssh, pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t child_terminated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t child_terminated = 0;\n\nstatic void\ncollect_children(struct ssh *ssh)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(ssh, pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_output",
          "args": [
            "writeset",
            "connection_out"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "process_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "342-348",
          "snippet": "static void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_input",
          "args": [
            "ssh",
            "readset",
            "connection_in"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "process_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "309-337",
          "snippet": "static int\nprocess_input(struct ssh *ssh, fd_set *readset, int connection_in)\n{\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN &&\n\t\t\t    errno != EWOULDBLOCK) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nprocess_input(struct ssh *ssh, fd_set *readset, int connection_in)\n{\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN &&\n\t\t\t    errno != EWOULDBLOCK) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_after_select",
          "args": [
            "ssh",
            "readset",
            "writeset"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "channel_after_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2513-2517",
          "snippet": "void\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_is_rekeying",
          "args": [
            "ssh"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_is_rekeying",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "272-277",
          "snippet": "int\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Exiting on signal %d\"",
            "(int)received_sigterm"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_until_can_do_something",
          "args": [
            "ssh",
            "connection_in",
            "connection_out",
            "&readset",
            "&writeset",
            "&max_fd",
            "&nalloc",
            "rekey_timeout_ms"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "wait_until_can_do_something",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "213-303",
          "snippet": "static void\nwait_until_can_do_something(struct ssh *ssh,\n    int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\tstatic time_t last_client_time;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(ssh, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (client_alive_scheduled) {\n\t\ttime_t now = monotime();\n\n\t\tif (ret == 0) { /* timeout */\n\t\t\tclient_alive_check(ssh);\n\t\t} else if (FD_ISSET(connection_in, *readsetp)) {\n\t\t\tlast_client_time = now;\n\t\t} else if (last_client_time != 0 && last_client_time +\n\t\t    options.client_alive_interval <= now) {\n\t\t\tclient_alive_check(ssh);\n\t\t\tlast_client_time = now;\n\t\t}\n\t}\n\n\tnotify_done(*readsetp);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static volatile sig_atomic_t child_terminated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic volatile sig_atomic_t child_terminated = 0;\n\nstatic void\nwait_until_can_do_something(struct ssh *ssh,\n    int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\tstatic time_t last_client_time;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(ssh, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (client_alive_scheduled) {\n\t\ttime_t now = monotime();\n\n\t\tif (ret == 0) { /* timeout */\n\t\t\tclient_alive_check(ssh);\n\t\t} else if (FD_ISSET(connection_in, *readsetp)) {\n\t\t\tlast_client_time = now;\n\t\t} else if (last_client_time != 0 && last_client_time +\n\t\t    options.client_alive_interval <= now) {\n\t\t\tclient_alive_check(ssh);\n\t\t\tlast_client_time = now;\n\t\t}\n\t}\n\n\tnotify_done(*readsetp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_rekey_timeout",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_output_poll",
          "args": [
            "ssh"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "channel_output_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2635-2669",
          "snippet": "void\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_not_very_much_data_to_write",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_buffered_input_packets",
          "args": [
            "ssh"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "process_buffered_input_packets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "350-354",
          "snippet": "static void\nprocess_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, NULL);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_init_dispatch",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "server_init_dispatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "899-921",
          "snippet": "static void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void server_init_dispatch(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void server_init_dispatch(void);\n\nstatic void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "max_fd",
            "notify_pipe[0]"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "connection_in",
            "connection_out"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_setup",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "notify_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "122-139",
          "snippet": "static void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int notify_pipe[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "sigterm_handler"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_out",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Entering interactive session for SSH2.\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern int use_privsep;\nstatic volatile sig_atomic_t child_terminated = 0;\nstatic volatile sig_atomic_t received_sigterm = 0;\nstatic void server_init_dispatch(void);\nstatic int notify_pipe[2];\n\nvoid\nserver_loop2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets(ssh);\n\n\t\tif (!ssh_packet_is_rekeying(ssh) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll(ssh);\n\t\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(ssh, connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children(ssh);\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\t\tif (process_input(ssh, readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children(ssh);\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all(ssh);\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(ssh, NULL);\n}"
  },
  {
    "function_name": "collect_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "356-376",
    "snippet": "static void\ncollect_children(struct ssh *ssh)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(ssh, pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t child_terminated = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&oset",
            "NULL"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "sigprocmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sigact.c",
          "lines": "66-88",
          "snippet": "int\nsigprocmask (int mode, sigset_t *mask, sigset_t *omask)\n{\n\tsigset_t current = sigsetmask(0);\n\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (omask)\n\t\t*omask = current;\n\n\tif (mode == SIG_BLOCK)\n\t\tcurrent |= *mask;\n\telse if (mode == SIG_UNBLOCK)\n\t\tcurrent &= ~*mask;\n\telse if (mode == SIG_SETMASK)\n\tcurrent = *mask;\n\n\tsigsetmask(current);\n\treturn 0;\n}",
          "includes": [
            "#include \"sigact.h\"",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sigact.h\"\n#include <signal.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsigprocmask (int mode, sigset_t *mask, sigset_t *omask)\n{\n\tsigset_t current = sigsetmask(0);\n\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (omask)\n\t\t*omask = current;\n\n\tif (mode == SIG_BLOCK)\n\t\tcurrent |= *mask;\n\telse if (mode == SIG_UNBLOCK)\n\t\tcurrent &= ~*mask;\n\telse if (mode == SIG_SETMASK)\n\tcurrent = *mask;\n\n\tsigsetmask(current);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_close_by_pid",
          "args": [
            "ssh",
            "pid",
            "status"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "session_close_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2451-2464",
          "snippet": "void\nsession_close_by_pid(struct ssh *ssh, pid_t pid, int status)\n{\n\tSession *s = session_by_pid(pid);\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for pid %ld\", __func__, (long)pid);\n\t\treturn;\n\t}\n\tif (s->chanid != -1)\n\t\tsession_exit_message(ssh, s, status);\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\ts->pid = 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close_by_pid(struct ssh *ssh, pid_t pid, int status)\n{\n\tSession *s = session_by_pid(pid);\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for pid %ld\", __func__, (long)pid);\n\t\treturn;\n\t}\n\tif (s->chanid != -1)\n\t\tsession_exit_message(ssh, s, status);\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\ts->pid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "WNOHANG"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Received SIGCHLD.\""
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&nset",
            "SIGCHLD"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sigaddset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sigact.c",
          "lines": "111-120",
          "snippet": "int\nsigaddset (sigset_t *mask, int sig)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask |= sigmask(sig);\n\treturn 0;\n}",
          "includes": [
            "#include \"sigact.h\"",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sigact.h\"\n#include <signal.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsigaddset (sigset_t *mask, int sig)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask |= sigmask(sig);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&nset"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "sigemptyset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sigact.c",
          "lines": "55-64",
          "snippet": "int\nsigemptyset (sigset_t *mask)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"sigact.h\"",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sigact.h\"\n#include <signal.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsigemptyset (sigset_t *mask)\n{\n\tif (!mask) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*mask = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t child_terminated = 0;\n\nstatic void\ncollect_children(struct ssh *ssh)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(ssh, pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}"
  },
  {
    "function_name": "process_buffered_input_packets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "350-354",
    "snippet": "static void\nprocess_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, NULL);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_run_fatal",
          "args": [
            "ssh",
            "DISPATCH_NONBLOCK",
            "NULL"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_run_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "128-135",
          "snippet": "void\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, NULL);\n}"
  },
  {
    "function_name": "process_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "342-348",
    "snippet": "static void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_write_poll",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "280-287",
          "snippet": "void\npacket_write_poll(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_poll(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_poll(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_poll(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "connection_out",
            "writeset"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}"
  },
  {
    "function_name": "process_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "309-337",
    "snippet": "static int\nprocess_input(struct ssh *ssh, fd_set *readset, int connection_in)\n{\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN &&\n\t\t\t    errno != EWOULDBLOCK) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_process_incoming",
          "args": [
            "buf",
            "len"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "packet_process_incoming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "262-269",
          "snippet": "void\npacket_process_incoming(const char *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = ssh_packet_process_incoming(active_state, buf, len)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_process_incoming(const char *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = ssh_packet_process_incoming(active_state, buf, len)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\"",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "strerror(errno)"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "connection_in",
            "buf",
            "sizeof(buf)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "connection_in",
            "readset"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nprocess_input(struct ssh *ssh, fd_set *readset, int connection_in)\n{\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN &&\n\t\t\t    errno != EWOULDBLOCK) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_until_can_do_something",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "213-303",
    "snippet": "static void\nwait_until_can_do_something(struct ssh *ssh,\n    int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\tstatic time_t last_client_time;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(ssh, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (client_alive_scheduled) {\n\t\ttime_t now = monotime();\n\n\t\tif (ret == 0) { /* timeout */\n\t\t\tclient_alive_check(ssh);\n\t\t} else if (FD_ISSET(connection_in, *readsetp)) {\n\t\t\tlast_client_time = now;\n\t\t} else if (last_client_time != 0 && last_client_time +\n\t\t    options.client_alive_interval <= now) {\n\t\t\tclient_alive_check(ssh);\n\t\t\tlast_client_time = now;\n\t\t}\n\t}\n\n\tnotify_done(*readsetp);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "static volatile sig_atomic_t child_terminated = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_done",
          "args": [
            "*readsetp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "notify_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "152-160",
          "snippet": "static void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"%s: reading\", __func__);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int notify_pipe[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"%s: reading\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_alive_check",
          "args": [
            "ssh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "client_alive_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "179-205",
          "snippet": "static void\nclient_alive_check(struct ssh *ssh)\n{\n\tint channel_id;\n\tchar remote_id[512];\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"Timeout, client not responding from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open(ssh)) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(ssh, channel_id,\n\t\t    \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic void\nclient_alive_check(struct ssh *ssh)\n{\n\tint channel_id;\n\tchar remote_id[512];\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"Timeout, client not responding from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open(ssh)) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(ssh, channel_id,\n\t\t    \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "connection_in",
            "*readsetp"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"select: %.100s\"",
            "strerror(errno)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*writesetp",
            "0",
            "*nallocp"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*readsetp",
            "0",
            "*nallocp"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(*maxfdp)+1",
            "*readsetp",
            "*writesetp",
            "NULL",
            "tvp"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "110-122",
          "snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_not_very_much_data_to_write",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "connection_out",
            "*writesetp"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_have_data_to_write",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_prepare",
          "args": [
            "*readsetp"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "notify_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "146-151",
          "snippet": "static void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int notify_pipe[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_not_very_much_buffered_data",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "max_time_ms",
            "(u_int)minwait_secs * 1000"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_prepare_select",
          "args": [
            "ssh",
            "readsetp",
            "writesetp",
            "maxfdp",
            "nallocp",
            "&minwait_secs"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "channel_prepare_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2478-2507",
          "snippet": "void\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic volatile sig_atomic_t child_terminated = 0;\n\nstatic void\nwait_until_can_do_something(struct ssh *ssh,\n    int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\tstatic time_t last_client_time;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(ssh, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (client_alive_scheduled) {\n\t\ttime_t now = monotime();\n\n\t\tif (ret == 0) { /* timeout */\n\t\t\tclient_alive_check(ssh);\n\t\t} else if (FD_ISSET(connection_in, *readsetp)) {\n\t\t\tlast_client_time = now;\n\t\t} else if (last_client_time != 0 && last_client_time +\n\t\t    options.client_alive_interval <= now) {\n\t\t\tclient_alive_check(ssh);\n\t\t\tlast_client_time = now;\n\t\t}\n\t}\n\n\tnotify_done(*readsetp);\n}"
  },
  {
    "function_name": "client_alive_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "179-205",
    "snippet": "static void\nclient_alive_check(struct ssh *ssh)\n{\n\tint channel_id;\n\tchar remote_id[512];\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"Timeout, client not responding from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open(ssh)) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(ssh, channel_id,\n\t\t    \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "channel_id",
            "\"keepalive@openssh.com\"",
            "1"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "1"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"keepalive@openssh.com\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_find_open",
          "args": [
            "ssh"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "channel_find_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "761-800",
          "snippet": "int\nchannel_find_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || !c->have_remote_id)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\t\treturn i;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_find_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || !c->have_remote_id)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\t\treturn i;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Timeout, client not responding from %s\"",
            "remote_id"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_fmt_connection_id",
          "args": [
            "ssh",
            "remote_id",
            "sizeof(remote_id)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_fmt_connection_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1796-1803",
          "snippet": "void\nsshpkt_fmt_connection_id(struct ssh *ssh, char *s, size_t l)\n{\n\tsnprintf(s, l, \"%.200s%s%s port %d\",\n\t    ssh->log_preamble ? ssh->log_preamble : \"\",\n\t    ssh->log_preamble ? \" \" : \"\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshpkt_fmt_connection_id(struct ssh *ssh, char *s, size_t l)\n{\n\tsnprintf(s, l, \"%.200s%s%s port %d\",\n\t    ssh->log_preamble ? ssh->log_preamble : \"\",\n\t    ssh->log_preamble ? \" \" : \"\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_inc_alive_timeouts",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic void\nclient_alive_check(struct ssh *ssh)\n{\n\tint channel_id;\n\tchar remote_id[512];\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"Timeout, client not responding from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open(ssh)) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(ssh, channel_id,\n\t\t    \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}"
  },
  {
    "function_name": "sigterm_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "173-177",
    "snippet": "static void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_sigterm = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_sigterm = 0;\n\nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}"
  },
  {
    "function_name": "sigchld_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "163-170",
    "snippet": "static void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tchild_terminated = 1;\n\tnotify_parent();\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t child_terminated = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_parent",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "140-145",
          "snippet": "static void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int notify_pipe[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t child_terminated = 0;\n\nstatic void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tchild_terminated = 1;\n\tnotify_parent();\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "notify_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "152-160",
    "snippet": "static void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"%s: reading\", __func__);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int notify_pipe[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: reading\"",
            "__func__"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "notify_pipe[0]",
            "&c",
            "1"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "notify_pipe[0]",
            "readset"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"%s: reading\", __func__);\n}"
  },
  {
    "function_name": "notify_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "146-151",
    "snippet": "static void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int notify_pipe[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "notify_pipe[0]",
            "readset"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}"
  },
  {
    "function_name": "notify_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "140-145",
    "snippet": "static void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int notify_pipe[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "notify_pipe[1]",
            "\"\"",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}"
  },
  {
    "function_name": "notify_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "122-139",
    "snippet": "static void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int notify_pipe[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "notify_pipe[1]"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "notify_pipe[1]"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"fcntl(notify_pipe, F_SETFD) failed %s\"",
            "strerror(errno)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "notify_pipe[1]",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "notify_pipe[0]",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "notify_pipe"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int notify_pipe[2];\n\nstatic void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}"
  },
  {
    "function_name": "bind_permitted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
    "lines": "107-115",
    "snippet": "static int\nbind_permitted(int port, uid_t uid)\n{\n\tif (use_privsep)\n\t\treturn 1; /* allow system to decide */\n\tif (port < IPPORT_RESERVED && uid != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"serverloop.h\"",
      "#include \"auth-options.h\"",
      "#include \"dispatch.h\"",
      "#include \"session.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"sshpty.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int use_privsep;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern int use_privsep;\n\nstatic int\nbind_permitted(int port, uid_t uid)\n{\n\tif (use_privsep)\n\t\treturn 1; /* allow system to decide */\n\tif (port < IPPORT_RESERVED && uid != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  }
]