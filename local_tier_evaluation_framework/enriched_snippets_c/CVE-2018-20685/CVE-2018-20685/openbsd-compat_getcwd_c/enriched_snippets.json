[
  {
    "function_name": "getcwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getcwd.c",
    "lines": "51-238",
    "snippet": "char *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}",
    "includes": [
      "#include \"includes.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/dir.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "103-108",
          "snippet": "static void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "up"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bpt",
            "dp->d_name",
            "dp->d_namlen"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ept - len",
            "bpt",
            "len"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "pt",
            "ptsize *= 2"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "48-56",
          "snippet": "void *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "up",
            "&s"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "110-121",
          "snippet": "static int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nstatic int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bup",
            "dp->d_name",
            "dp->d_namlen + 1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISDOT",
          "args": [
            "dp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "process_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1034-1088",
          "snippet": "static void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "dirfd(dir)",
            "&s"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirfd",
          "args": [
            "dir"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "up"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "process_opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1004-1032",
          "snippet": "static void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "pt",
            "bpt",
            "ept - bpt"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "upsize = MAXPATHLEN"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"includes.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/dir.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nchar *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}"
  }
]