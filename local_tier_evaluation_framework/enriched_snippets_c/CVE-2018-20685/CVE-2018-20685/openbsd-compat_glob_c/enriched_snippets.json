[
  {
    "function_name": "qprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "1047-1062",
    "snippet": "static void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tM_PROTECT\t0x40",
      "#define\tM_PROTECT\t0x4000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%c\"",
            "ismeta(*p) ? '_' : ' '"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "qprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1047-1062",
          "snippet": "static void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ismeta",
          "args": [
            "*p"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHAR",
          "args": [
            "*p"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_PROTECT\t0x40\n#define\tM_PROTECT\t0x4000\n\nstatic void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}"
  },
  {
    "function_name": "g_Ctoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "1035-1044",
    "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "g_strchr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "1025-1033",
    "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
  },
  {
    "function_name": "g_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "1013-1023",
    "snippet": "static int\ng_stat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_stat)(buf, sb));\n\treturn(stat(buf, sb));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "buf",
            "sb"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "buf",
            "sb"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_Ctoc",
          "args": [
            "fn",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "g_Ctoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1035-1044",
          "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_stat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_stat)(buf, sb));\n\treturn(stat(buf, sb));\n}"
  },
  {
    "function_name": "g_lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "1001-1011",
    "snippet": "static int\ng_lstat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_lstat)(buf, sb));\n\treturn(lstat(buf, sb));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "buf",
            "sb"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "110-121",
          "snippet": "static int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nstatic int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "buf",
            "sb"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_Ctoc",
          "args": [
            "fn",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "g_Ctoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1035-1044",
          "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_lstat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_lstat)(buf, sb));\n\treturn(lstat(buf, sb));\n}"
  },
  {
    "function_name": "g_opendir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "983-999",
    "snippet": "static DIR *\ng_opendir(Char *str, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (!*str)\n\t\tstrlcpy(buf, \".\", sizeof buf);\n\telse {\n\t\tif (g_Ctoc(str, buf, sizeof(buf)))\n\t\t\treturn(NULL);\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_opendir)(buf));\n\n\treturn(opendir(buf));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "buf"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "process_opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1004-1032",
          "snippet": "static void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "buf"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_Ctoc",
          "args": [
            "str",
            "buf",
            "sizeof(buf)"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "g_Ctoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1035-1044",
          "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\".\"",
            "sizeof buf"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic DIR *\ng_opendir(Char *str, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (!*str)\n\t\tstrlcpy(buf, \".\", sizeof buf);\n\telse {\n\t\tif (g_Ctoc(str, buf, sizeof(buf)))\n\t\t\treturn(NULL);\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_opendir)(buf));\n\n\treturn(opendir(buf));\n}"
  },
  {
    "function_name": "globfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "959-981",
    "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pglob->gl_statv"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
  },
  {
    "function_name": "match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "899-956",
    "snippet": "static int\nmatch(Char *name, Char *pat, Char *patend, int recur)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\n\tif (recur-- == 0)\n\t\treturn(GLOB_NOSPACE);\n\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t/* eat consecutive '*' */\n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tdo {\n\t\t\t    if (match(name, pat, patend, recur))\n\t\t\t\t    return(1);\n\t\t\t} while (*name++ != EOS);\n\t\t\treturn(0);\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\treturn(0);\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn(*name == EOS);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tM_CLASS\t\tMETA(':')",
      "#define\tM_SET\t\tMETA('[')",
      "#define\tM_RNG\t\tMETA('-')",
      "#define\tM_ONE\t\tMETA('?')",
      "#define\tM_NOT\t\tMETA('!')",
      "#define\tM_END\t\tMETA(']')",
      "#define\tM_ALL\t\tMETA('*')",
      "#define\tM_MASK\t\t0xff",
      "#define\tM_MASK\t\t0xffff",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cclasses[idx].isctype",
          "args": [
            "k"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "name",
            "pat",
            "patend",
            "recur"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "899-956",
          "snippet": "static int\nmatch(Char *name, Char *pat, Char *patend, int recur)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\n\tif (recur-- == 0)\n\t\treturn(GLOB_NOSPACE);\n\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t/* eat consecutive '*' */\n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tdo {\n\t\t\t    if (match(name, pat, patend, recur))\n\t\t\t\t    return(1);\n\t\t\t} while (*name++ != EOS);\n\t\t\treturn(0);\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\treturn(0);\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn(*name == EOS);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_CLASS\t\tMETA(':')\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tM_MASK\t\t0xff\n#define\tM_MASK\t\t0xffff\n#define\tEOS\t\t'\\0'\n\nstatic int\nmatch(Char *name, Char *pat, Char *patend, int recur)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\n\tif (recur-- == 0)\n\t\treturn(GLOB_NOSPACE);\n\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t/* eat consecutive '*' */\n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tdo {\n\t\t\t    if (match(name, pat, patend, recur))\n\t\t\t\t    return(1);\n\t\t\t} while (*name++ != EOS);\n\t\t\treturn(0);\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\treturn(0);\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn(*name == EOS);\n}"
  },
  {
    "function_name": "globextend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "795-892",
    "snippet": "static int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tGLOB_LIMIT_MALLOC\t65536"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "copy"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_Ctoc",
          "args": [
            "path",
            "copy",
            "len"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "g_Ctoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1035-1044",
          "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "statv[pglob->gl_offs + pglob->gl_pathc]",
            "sb",
            "sizeof(*sb)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "pglob->gl_statv",
            "newn * sizeof(*statv)"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "48-56",
          "snippet": "void *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_MALLOC\t65536\n\nstatic int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}"
  },
  {
    "function_name": "glob3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "695-778",
    "snippet": "static int\nglob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tint err;\n\tchar buf[MAXPATHLEN];\n\n\t/*\n\t * The readdirfunc declaration can't be prototyped, because it is\n\t * assigned, below, to two functions which are prototyped in glob.h\n\t * and dirent.h as taking pointers to differently typed opaque\n\t * structures.\n\t */\n\tstruct dirent *(*readdirfunc)(void *);\n\n\tif (pathend > pathend_last)\n\t\treturn (1);\n\t*pathend = EOS;\n\terrno = 0;\n\n\tif ((dirp = g_opendir(pathbuf, pglob)) == NULL) {\n\t\t/* TODO: don't call for ENOENT or ENOTDIR? */\n\t\tif (pglob->gl_errfunc) {\n\t\t\tif (g_Ctoc(pathbuf, buf, sizeof(buf)))\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t\tif (pglob->gl_errfunc(buf, errno) ||\n\t\t\t    pglob->gl_flags & GLOB_ERR)\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t}\n\t\treturn(0);\n\t}\n\n\terr = 0;\n\n\t/* Search directory for matching names. */\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treaddirfunc = pglob->gl_readdir;\n\telse\n\t\treaddirfunc = (struct dirent *(*)(void *))readdir;\n\twhile ((dp = (*readdirfunc)(dirp))) {\n\t\tu_char *sc;\n\t\tChar *dc;\n\n\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {\n\t\t\terrno = 0;\n\t\t\t*pathend++ = SEP;\n\t\t\t*pathend = EOS;\n\t\t\terr = GLOB_NOSPACE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Initial DOT must be matched literally. */\n\t\tif (dp->d_name[0] == DOT && *pattern != DOT)\n\t\t\tcontinue;\n\t\tdc = pathend;\n\t\tsc = (u_char *) dp->d_name;\n\t\twhile (dc < pathend_last && (*dc++ = *sc++) != EOS)\n\t\t\t;\n\t\tif (dc >= pathend_last) {\n\t\t\t*dc = EOS;\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!match(pathend, pattern, restpattern, GLOB_LIMIT_RECUR)) {\n\t\t\t*pathend = EOS;\n\t\t\tcontinue;\n\t\t}\n\t\terr = glob2(pathbuf, pathbuf_last, --dc, pathend_last,\n\t\t    restpattern, restpattern_last, pglob, limitp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\t(*pglob->gl_closedir)(dirp);\n\telse\n\t\tclosedir(dirp);\n\treturn(err);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define GLOB_LIMIT_RECUR\t64",
      "#define\tGLOB_LIMIT_READDIR\t16384",
      "#define\tSEP\t\t'/'",
      "#define\tEOS\t\t'\\0'",
      "#define\tDOT\t\t'.'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dirp"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "103-108",
          "snippet": "static void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dirp"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob2",
          "args": [
            "pathbuf",
            "pathbuf_last",
            "--dc",
            "pathend_last",
            "restpattern",
            "restpattern_last",
            "pglob",
            "limitp"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "glob2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "627-693",
          "snippet": "static int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tGLOB_LIMIT_STAT\t\t128",
            "#define\tSEP\t\t'/'",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_STAT\t\t128\n#define\tSEP\t\t'/'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "pathend",
            "pattern",
            "restpattern",
            "GLOB_LIMIT_RECUR"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "899-956",
          "snippet": "static int\nmatch(Char *name, Char *pat, Char *patend, int recur)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\n\tif (recur-- == 0)\n\t\treturn(GLOB_NOSPACE);\n\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t/* eat consecutive '*' */\n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tdo {\n\t\t\t    if (match(name, pat, patend, recur))\n\t\t\t\t    return(1);\n\t\t\t} while (*name++ != EOS);\n\t\t\treturn(0);\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\treturn(0);\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn(*name == EOS);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_CLASS\t\tMETA(':')",
            "#define\tM_SET\t\tMETA('[')",
            "#define\tM_RNG\t\tMETA('-')",
            "#define\tM_ONE\t\tMETA('?')",
            "#define\tM_NOT\t\tMETA('!')",
            "#define\tM_END\t\tMETA(']')",
            "#define\tM_ALL\t\tMETA('*')",
            "#define\tM_MASK\t\t0xff",
            "#define\tM_MASK\t\t0xffff",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_CLASS\t\tMETA(':')\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tM_MASK\t\t0xff\n#define\tM_MASK\t\t0xffff\n#define\tEOS\t\t'\\0'\n\nstatic int\nmatch(Char *name, Char *pat, Char *patend, int recur)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\n\tif (recur-- == 0)\n\t\treturn(GLOB_NOSPACE);\n\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t/* eat consecutive '*' */\n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tdo {\n\t\t\t    if (match(name, pat, patend, recur))\n\t\t\t\t    return(1);\n\t\t\t} while (*name++ != EOS);\n\t\t\treturn(0);\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\treturn(0);\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn(*name == EOS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dirp"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pglob->gl_errfunc",
          "args": [
            "buf",
            "errno"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_Ctoc",
          "args": [
            "pathbuf",
            "buf",
            "sizeof(buf)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "g_Ctoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1035-1044",
          "snippet": "static int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\ng_Ctoc(const Char *str, char *buf, u_int len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_opendir",
          "args": [
            "pathbuf",
            "pglob"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "g_opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "983-999",
          "snippet": "static DIR *\ng_opendir(Char *str, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (!*str)\n\t\tstrlcpy(buf, \".\", sizeof buf);\n\telse {\n\t\tif (g_Ctoc(str, buf, sizeof(buf)))\n\t\t\treturn(NULL);\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_opendir)(buf));\n\n\treturn(opendir(buf));\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic DIR *\ng_opendir(Char *str, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (!*str)\n\t\tstrlcpy(buf, \".\", sizeof buf);\n\telse {\n\t\tif (g_Ctoc(str, buf, sizeof(buf)))\n\t\t\treturn(NULL);\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_opendir)(buf));\n\n\treturn(opendir(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define GLOB_LIMIT_RECUR\t64\n#define\tGLOB_LIMIT_READDIR\t16384\n#define\tSEP\t\t'/'\n#define\tEOS\t\t'\\0'\n#define\tDOT\t\t'.'\n\nstatic int\nglob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tint err;\n\tchar buf[MAXPATHLEN];\n\n\t/*\n\t * The readdirfunc declaration can't be prototyped, because it is\n\t * assigned, below, to two functions which are prototyped in glob.h\n\t * and dirent.h as taking pointers to differently typed opaque\n\t * structures.\n\t */\n\tstruct dirent *(*readdirfunc)(void *);\n\n\tif (pathend > pathend_last)\n\t\treturn (1);\n\t*pathend = EOS;\n\terrno = 0;\n\n\tif ((dirp = g_opendir(pathbuf, pglob)) == NULL) {\n\t\t/* TODO: don't call for ENOENT or ENOTDIR? */\n\t\tif (pglob->gl_errfunc) {\n\t\t\tif (g_Ctoc(pathbuf, buf, sizeof(buf)))\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t\tif (pglob->gl_errfunc(buf, errno) ||\n\t\t\t    pglob->gl_flags & GLOB_ERR)\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t}\n\t\treturn(0);\n\t}\n\n\terr = 0;\n\n\t/* Search directory for matching names. */\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treaddirfunc = pglob->gl_readdir;\n\telse\n\t\treaddirfunc = (struct dirent *(*)(void *))readdir;\n\twhile ((dp = (*readdirfunc)(dirp))) {\n\t\tu_char *sc;\n\t\tChar *dc;\n\n\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {\n\t\t\terrno = 0;\n\t\t\t*pathend++ = SEP;\n\t\t\t*pathend = EOS;\n\t\t\terr = GLOB_NOSPACE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Initial DOT must be matched literally. */\n\t\tif (dp->d_name[0] == DOT && *pattern != DOT)\n\t\t\tcontinue;\n\t\tdc = pathend;\n\t\tsc = (u_char *) dp->d_name;\n\t\twhile (dc < pathend_last && (*dc++ = *sc++) != EOS)\n\t\t\t;\n\t\tif (dc >= pathend_last) {\n\t\t\t*dc = EOS;\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!match(pathend, pattern, restpattern, GLOB_LIMIT_RECUR)) {\n\t\t\t*pathend = EOS;\n\t\t\tcontinue;\n\t\t}\n\t\terr = glob2(pathbuf, pathbuf_last, --dc, pathend_last,\n\t\t    restpattern, restpattern_last, pglob, limitp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\t(*pglob->gl_closedir)(dirp);\n\telse\n\t\tclosedir(dirp);\n\treturn(err);\n}"
  },
  {
    "function_name": "glob2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "627-693",
    "snippet": "static int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tGLOB_LIMIT_STAT\t\t128",
      "#define\tSEP\t\t'/'",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob3",
          "args": [
            "pathbuf",
            "pathbuf_last",
            "pathend",
            "pathend_last",
            "pattern",
            "p",
            "pattern_last",
            "pglob",
            "limitp"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "glob3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "695-778",
          "snippet": "static int\nglob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tint err;\n\tchar buf[MAXPATHLEN];\n\n\t/*\n\t * The readdirfunc declaration can't be prototyped, because it is\n\t * assigned, below, to two functions which are prototyped in glob.h\n\t * and dirent.h as taking pointers to differently typed opaque\n\t * structures.\n\t */\n\tstruct dirent *(*readdirfunc)(void *);\n\n\tif (pathend > pathend_last)\n\t\treturn (1);\n\t*pathend = EOS;\n\terrno = 0;\n\n\tif ((dirp = g_opendir(pathbuf, pglob)) == NULL) {\n\t\t/* TODO: don't call for ENOENT or ENOTDIR? */\n\t\tif (pglob->gl_errfunc) {\n\t\t\tif (g_Ctoc(pathbuf, buf, sizeof(buf)))\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t\tif (pglob->gl_errfunc(buf, errno) ||\n\t\t\t    pglob->gl_flags & GLOB_ERR)\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t}\n\t\treturn(0);\n\t}\n\n\terr = 0;\n\n\t/* Search directory for matching names. */\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treaddirfunc = pglob->gl_readdir;\n\telse\n\t\treaddirfunc = (struct dirent *(*)(void *))readdir;\n\twhile ((dp = (*readdirfunc)(dirp))) {\n\t\tu_char *sc;\n\t\tChar *dc;\n\n\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {\n\t\t\terrno = 0;\n\t\t\t*pathend++ = SEP;\n\t\t\t*pathend = EOS;\n\t\t\terr = GLOB_NOSPACE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Initial DOT must be matched literally. */\n\t\tif (dp->d_name[0] == DOT && *pattern != DOT)\n\t\t\tcontinue;\n\t\tdc = pathend;\n\t\tsc = (u_char *) dp->d_name;\n\t\twhile (dc < pathend_last && (*dc++ = *sc++) != EOS)\n\t\t\t;\n\t\tif (dc >= pathend_last) {\n\t\t\t*dc = EOS;\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!match(pathend, pattern, restpattern, GLOB_LIMIT_RECUR)) {\n\t\t\t*pathend = EOS;\n\t\t\tcontinue;\n\t\t}\n\t\terr = glob2(pathbuf, pathbuf_last, --dc, pathend_last,\n\t\t    restpattern, restpattern_last, pglob, limitp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\t(*pglob->gl_closedir)(dirp);\n\telse\n\t\tclosedir(dirp);\n\treturn(err);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define GLOB_LIMIT_RECUR\t64",
            "#define\tGLOB_LIMIT_READDIR\t16384",
            "#define\tSEP\t\t'/'",
            "#define\tEOS\t\t'\\0'",
            "#define\tDOT\t\t'.'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define GLOB_LIMIT_RECUR\t64\n#define\tGLOB_LIMIT_READDIR\t16384\n#define\tSEP\t\t'/'\n#define\tEOS\t\t'\\0'\n#define\tDOT\t\t'.'\n\nstatic int\nglob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tint err;\n\tchar buf[MAXPATHLEN];\n\n\t/*\n\t * The readdirfunc declaration can't be prototyped, because it is\n\t * assigned, below, to two functions which are prototyped in glob.h\n\t * and dirent.h as taking pointers to differently typed opaque\n\t * structures.\n\t */\n\tstruct dirent *(*readdirfunc)(void *);\n\n\tif (pathend > pathend_last)\n\t\treturn (1);\n\t*pathend = EOS;\n\terrno = 0;\n\n\tif ((dirp = g_opendir(pathbuf, pglob)) == NULL) {\n\t\t/* TODO: don't call for ENOENT or ENOTDIR? */\n\t\tif (pglob->gl_errfunc) {\n\t\t\tif (g_Ctoc(pathbuf, buf, sizeof(buf)))\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t\tif (pglob->gl_errfunc(buf, errno) ||\n\t\t\t    pglob->gl_flags & GLOB_ERR)\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t}\n\t\treturn(0);\n\t}\n\n\terr = 0;\n\n\t/* Search directory for matching names. */\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treaddirfunc = pglob->gl_readdir;\n\telse\n\t\treaddirfunc = (struct dirent *(*)(void *))readdir;\n\twhile ((dp = (*readdirfunc)(dirp))) {\n\t\tu_char *sc;\n\t\tChar *dc;\n\n\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {\n\t\t\terrno = 0;\n\t\t\t*pathend++ = SEP;\n\t\t\t*pathend = EOS;\n\t\t\terr = GLOB_NOSPACE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Initial DOT must be matched literally. */\n\t\tif (dp->d_name[0] == DOT && *pattern != DOT)\n\t\t\tcontinue;\n\t\tdc = pathend;\n\t\tsc = (u_char *) dp->d_name;\n\t\twhile (dc < pathend_last && (*dc++ = *sc++) != EOS)\n\t\t\t;\n\t\tif (dc >= pathend_last) {\n\t\t\t*dc = EOS;\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!match(pathend, pattern, restpattern, GLOB_LIMIT_RECUR)) {\n\t\t\t*pathend = EOS;\n\t\t\tcontinue;\n\t\t}\n\t\terr = glob2(pathbuf, pathbuf_last, --dc, pathend_last,\n\t\t    restpattern, restpattern_last, pglob, limitp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\t(*pglob->gl_closedir)(dirp);\n\telse\n\t\tclosedir(dirp);\n\treturn(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ismeta",
          "args": [
            "*p"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globextend",
          "args": [
            "pathbuf",
            "pglob",
            "limitp",
            "&sb"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "globextend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "795-892",
          "snippet": "static int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tGLOB_LIMIT_MALLOC\t65536"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_MALLOC\t65536\n\nstatic int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_stat",
          "args": [
            "pathbuf",
            "&sb",
            "pglob"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "g_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1013-1023",
          "snippet": "static int\ng_stat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_stat)(buf, sb));\n\treturn(stat(buf, sb));\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_stat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_stat)(buf, sb));\n\treturn(stat(buf, sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sb.st_mode"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lstat",
          "args": [
            "pathbuf",
            "&sb",
            "pglob"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "g_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1001-1011",
          "snippet": "static int\ng_lstat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_lstat)(buf, sb));\n\treturn(lstat(buf, sb));\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_lstat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_lstat)(buf, sb));\n\treturn(lstat(buf, sb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_STAT\t\t128\n#define\tSEP\t\t'/'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "glob1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "609-620",
    "snippet": "static int\nglob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tChar pathbuf[MAXPATHLEN];\n\n\t/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */\n\tif (*pattern == EOS)\n\t\treturn(0);\n\treturn(glob2(pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pattern, pattern_last, pglob, limitp));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob2",
          "args": [
            "pathbuf",
            "pathbuf+MAXPATHLEN-1",
            "pathbuf",
            "pathbuf+MAXPATHLEN-1",
            "pattern",
            "pattern_last",
            "pglob",
            "limitp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "glob2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "627-693",
          "snippet": "static int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tGLOB_LIMIT_STAT\t\t128",
            "#define\tSEP\t\t'/'",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_STAT\t\t128\n#define\tSEP\t\t'/'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t/*\n\t * Loop over pattern segments until end of pattern or until\n\t * segment with meta character found.\n\t */\n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t/* End of pattern? */\n\t\t\t*pathend = EOS;\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t/* Find end of next segment, copy tentatively to pathend. */\n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t/* No expansion, do next segment. */\n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t/* Need expansion, recurse. */\n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t/* NOTREACHED */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tChar pathbuf[MAXPATHLEN];\n\n\t/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */\n\tif (*pattern == EOS)\n\t\treturn(0);\n\treturn(glob2(pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pattern, pattern_last, pglob, limitp));\n}"
  },
  {
    "function_name": "compare_gps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "600-607",
    "snippet": "static int\ncompare_gps(const void *_p, const void *_q)\n{\n\tconst struct glob_path_stat *p = (const struct glob_path_stat *)_p;\n\tconst struct glob_path_stat *q = (const struct glob_path_stat *)_q;\n\n\treturn(strcmp(p->gps_path, q->gps_path));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->gps_path",
            "q->gps_path"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ncompare_gps(const void *_p, const void *_q)\n{\n\tconst struct glob_path_stat *p = (const struct glob_path_stat *)_p;\n\tconst struct glob_path_stat *q = (const struct glob_path_stat *)_q;\n\n\treturn(strcmp(p->gps_path, q->gps_path));\n}"
  },
  {
    "function_name": "compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "594-598",
    "snippet": "static int\ncompare(const void *p, const void *q)\n{\n\treturn(strcmp(*(char **)p, *(char **)q));\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*(char **)p",
            "*(char **)q"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ncompare(const void *p, const void *q)\n{\n\treturn(strcmp(*(char **)p, *(char **)q));\n}"
  },
  {
    "function_name": "glob0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "471-592",
    "snippet": "static int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tM_SET\t\tMETA('[')",
      "#define\tM_RNG\t\tMETA('-')",
      "#define\tM_ONE\t\tMETA('?')",
      "#define\tM_NOT\t\tMETA('!')",
      "#define\tM_END\t\tMETA(']')",
      "#define\tM_ALL\t\tMETA('*')",
      "#define\tSTAR\t\t'*'",
      "#define\tRBRACKET\t']'",
      "#define\tRANGE\t\t'-'",
      "#define\tQUESTION\t'?'",
      "#define\tNOT\t\t'!'",
      "#define\tLBRACKET\t'['",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "pglob->gl_pathv + pglob->gl_offs + oldpathc",
            "pglob->gl_pathc - oldpathc",
            "sizeof(char *)",
            "compare"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path_stat"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "path_stat",
            "n",
            "sizeof(*path_stat)",
            "compare_gps"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "n",
            "sizeof(*path_stat)"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globextend",
          "args": [
            "pattern",
            "pglob",
            "limitp",
            "NULL"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "globextend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "795-892",
          "snippet": "static int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tGLOB_LIMIT_MALLOC\t65536"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tGLOB_LIMIT_MALLOC\t65536\n\nstatic int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tssize_t i;\n\tsize_t newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX ||\n\t    newn >= INT_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tif (pglob->gl_pathv) {\n\t\t\tfree(pglob->gl_pathv);\n\t\t\tpglob->gl_pathv = NULL;\n\t\t}\n\t\tif (pglob->gl_statv) {\n\t\t\tfree(pglob->gl_statv);\n\t\t\tpglob->gl_statv = NULL;\n\t\t}\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t/* first time around -- clear initial gl_offs items */\n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = realloc(pglob->gl_statv, newn * sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t/* first time around -- clear initial gl_offs items */\n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; --i >= 0; )\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob1",
          "args": [
            "patbuf",
            "patbuf+MAXPATHLEN-1",
            "pglob",
            "limitp"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "glob1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "609-620",
          "snippet": "static int\nglob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tChar pathbuf[MAXPATHLEN];\n\n\t/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */\n\tif (*pattern == EOS)\n\t\treturn(0);\n\treturn(glob2(pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pattern, pattern_last, pglob, limitp));\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tChar pathbuf[MAXPATHLEN];\n\n\t/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */\n\tif (*pattern == EOS)\n\t\treturn(0);\n\treturn(glob2(pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pathbuf, pathbuf+MAXPATHLEN-1,\n\t    pattern, pattern_last, pglob, limitp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qprintf",
          "args": [
            "\"glob0:\"",
            "patbuf"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "qprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1047-1062",
          "snippet": "static void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_PROTECT\t0x40",
            "#define\tM_PROTECT\t0x4000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_PROTECT\t0x40\n#define\tM_PROTECT\t0x4000\n\nstatic void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHAR",
          "args": [
            "c"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHAR",
          "args": [
            "c"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHAR",
          "args": [
            "c"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_charclass",
          "args": [
            "&qpatnext",
            "&bufnext"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "g_charclass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "437-462",
          "snippet": "static int\ng_charclass(const Char **patternp, Char **bufnextp)\n{\n\tconst Char *pattern = *patternp + 1;\n\tChar *bufnext = *bufnextp;\n\tconst Char *colon;\n\tstruct cclass *cc;\n\tsize_t len;\n\n\tif ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')\n\t\treturn 1;\t/* not a character class */\n\n\tlen = (size_t)(colon - pattern);\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (cc->name == NULL)\n\t\treturn -1;\t/* invalid character class */\n\t*bufnext++ = M_CLASS;\n\t*bufnext++ = (Char)(cc - &cclasses[0]);\n\t*bufnextp = bufnext;\n\t*patternp += len + 3;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_CLASS\t\tMETA(':')"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_CLASS\t\tMETA(':')\n\nstatic int\ng_charclass(const Char **patternp, Char **bufnextp)\n{\n\tconst Char *pattern = *patternp + 1;\n\tChar *bufnext = *bufnextp;\n\tconst Char *colon;\n\tstruct cclass *cc;\n\tsize_t len;\n\n\tif ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')\n\t\treturn 1;\t/* not a character class */\n\n\tlen = (size_t)(colon - pattern);\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (cc->name == NULL)\n\t\treturn -1;\t/* invalid character class */\n\t*bufnext++ = M_CLASS;\n\t*bufnext++ = (Char)(cc - &cclasses[0]);\n\t*bufnextp = bufnext;\n\t*patternp += len + 3;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strchr",
          "args": [
            "qpatnext+1",
            "RBRACKET"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globtilde",
          "args": [
            "pattern",
            "patbuf",
            "MAXPATHLEN",
            "pglob"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tSTAR\t\t'*'\n#define\tRBRACKET\t']'\n#define\tRANGE\t\t'-'\n#define\tQUESTION\t'?'\n#define\tNOT\t\t'!'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}"
  },
  {
    "function_name": "g_charclass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "437-462",
    "snippet": "static int\ng_charclass(const Char **patternp, Char **bufnextp)\n{\n\tconst Char *pattern = *patternp + 1;\n\tChar *bufnext = *bufnextp;\n\tconst Char *colon;\n\tstruct cclass *cc;\n\tsize_t len;\n\n\tif ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')\n\t\treturn 1;\t/* not a character class */\n\n\tlen = (size_t)(colon - pattern);\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (cc->name == NULL)\n\t\treturn -1;\t/* invalid character class */\n\t*bufnext++ = M_CLASS;\n\t*bufnext++ = (Char)(cc - &cclasses[0]);\n\t*bufnextp = bufnext;\n\t*patternp += len + 3;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tM_CLASS\t\tMETA(':')"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc - &cclasses[0]"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strncmp",
          "args": [
            "pattern",
            "cc->name",
            "len"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strchr",
          "args": [
            "pattern",
            "':'"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_CLASS\t\tMETA(':')\n\nstatic int\ng_charclass(const Char **patternp, Char **bufnextp)\n{\n\tconst Char *pattern = *patternp + 1;\n\tChar *bufnext = *bufnextp;\n\tconst Char *colon;\n\tstruct cclass *cc;\n\tsize_t len;\n\n\tif ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')\n\t\treturn 1;\t/* not a character class */\n\n\tlen = (size_t)(colon - pattern);\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (cc->name == NULL)\n\t\treturn -1;\t/* invalid character class */\n\t*bufnext++ = M_CLASS;\n\t*bufnext++ = (Char)(cc - &cclasses[0]);\n\t*bufnextp = bufnext;\n\t*patternp += len + 3;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "g_strncmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "422-435",
    "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "globexp2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "257-355",
    "snippet": "static int\nglobexp2(const Char *ptr, const Char *pattern, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tint     i, rv;\n\tChar   *lm, *ls;\n\tconst Char *pe, *pm, *pl;\n\tChar    patbuf[MAXPATHLEN];\n\n\t/* copy part up to the brace */\n\tfor (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)\n\t\t;\n\t*lm = EOS;\n\tls = lm;\n\n\t/* Find the balanced brace */\n\tfor (i = 0, pe = ++ptr; *pe; pe++)\n\t\tif (*pe == LBRACKET) {\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)\n\t\t\t\t;\n\t\t\tif (*pe == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpe = pm;\n\t\t\t}\n\t\t} else if (*pe == LBRACE)\n\t\t\ti++;\n\t\telse if (*pe == RBRACE) {\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\n\t/* Non matching braces; just glob the pattern */\n\tif (i != 0 || *pe == EOS)\n\t\treturn glob0(patbuf, pglob, limitp);\n\n\tfor (i = 0, pl = pm = ptr; pm <= pe; pm++) {\n\t\tswitch (*pm) {\n\t\tcase LBRACKET:\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)\n\t\t\t\t;\n\t\t\tif (*pm == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpm = pl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LBRACE:\n\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase RBRACE:\n\t\t\tif (i) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase COMMA:\n\t\t\tif (i && *pm == COMMA)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\t/* Append the current string */\n\t\t\t\tfor (lm = ls; (pl < pm); *lm++ = *pl++)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * Append the rest of the pattern after the\n\t\t\t\t * closing brace\n\t\t\t\t */\n\t\t\t\tfor (pl = pe + 1; (*lm++ = *pl++) != EOS; )\n\t\t\t\t\t;\n\n\t\t\t\t/* Expand the current pattern */\n#ifdef DEBUG\n\t\t\t\tqprintf(\"globexp2:\", patbuf);\n#endif\n\t\t\t\trv = globexp1(patbuf, pglob, limitp);\n\t\t\t\tif (rv && rv != GLOB_NOMATCH)\n\t\t\t\t\treturn rv;\n\n\t\t\t\t/* move after the comma, to the next string */\n\t\t\t\tpl = pm + 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tCOMMA\t\t','",
      "#define\tRBRACE\t\t'}'",
      "#define\tLBRACE\t\t'{'",
      "#define\tRBRACKET\t']'",
      "#define\tLBRACKET\t'['",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "globexp1",
          "args": [
            "patbuf",
            "pglob",
            "limitp"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "globexp1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "236-249",
          "snippet": "static int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tRBRACE\t\t'}'",
            "#define\tLBRACE\t\t'{'",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tRBRACE\t\t'}'\n#define\tLBRACE\t\t'{'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qprintf",
          "args": [
            "\"globexp2:\"",
            "patbuf"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "qprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1047-1062",
          "snippet": "static void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_PROTECT\t0x40",
            "#define\tM_PROTECT\t0x4000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_PROTECT\t0x40\n#define\tM_PROTECT\t0x4000\n\nstatic void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob0",
          "args": [
            "patbuf",
            "pglob",
            "limitp"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "glob0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "471-592",
          "snippet": "static int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_SET\t\tMETA('[')",
            "#define\tM_RNG\t\tMETA('-')",
            "#define\tM_ONE\t\tMETA('?')",
            "#define\tM_NOT\t\tMETA('!')",
            "#define\tM_END\t\tMETA(']')",
            "#define\tM_ALL\t\tMETA('*')",
            "#define\tSTAR\t\t'*'",
            "#define\tRBRACKET\t']'",
            "#define\tRANGE\t\t'-'",
            "#define\tQUESTION\t'?'",
            "#define\tNOT\t\t'!'",
            "#define\tLBRACKET\t'['",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tSTAR\t\t'*'\n#define\tRBRACKET\t']'\n#define\tRANGE\t\t'-'\n#define\tQUESTION\t'?'\n#define\tNOT\t\t'!'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tCOMMA\t\t','\n#define\tRBRACE\t\t'}'\n#define\tLBRACE\t\t'{'\n#define\tRBRACKET\t']'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglobexp2(const Char *ptr, const Char *pattern, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tint     i, rv;\n\tChar   *lm, *ls;\n\tconst Char *pe, *pm, *pl;\n\tChar    patbuf[MAXPATHLEN];\n\n\t/* copy part up to the brace */\n\tfor (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)\n\t\t;\n\t*lm = EOS;\n\tls = lm;\n\n\t/* Find the balanced brace */\n\tfor (i = 0, pe = ++ptr; *pe; pe++)\n\t\tif (*pe == LBRACKET) {\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)\n\t\t\t\t;\n\t\t\tif (*pe == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpe = pm;\n\t\t\t}\n\t\t} else if (*pe == LBRACE)\n\t\t\ti++;\n\t\telse if (*pe == RBRACE) {\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\n\t/* Non matching braces; just glob the pattern */\n\tif (i != 0 || *pe == EOS)\n\t\treturn glob0(patbuf, pglob, limitp);\n\n\tfor (i = 0, pl = pm = ptr; pm <= pe; pm++) {\n\t\tswitch (*pm) {\n\t\tcase LBRACKET:\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)\n\t\t\t\t;\n\t\t\tif (*pm == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpm = pl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LBRACE:\n\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase RBRACE:\n\t\t\tif (i) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase COMMA:\n\t\t\tif (i && *pm == COMMA)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\t/* Append the current string */\n\t\t\t\tfor (lm = ls; (pl < pm); *lm++ = *pl++)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * Append the rest of the pattern after the\n\t\t\t\t * closing brace\n\t\t\t\t */\n\t\t\t\tfor (pl = pe + 1; (*lm++ = *pl++) != EOS; )\n\t\t\t\t\t;\n\n\t\t\t\t/* Expand the current pattern */\n#ifdef DEBUG\n\t\t\t\tqprintf(\"globexp2:\", patbuf);\n#endif\n\t\t\t\trv = globexp1(patbuf, pglob, limitp);\n\t\t\t\tif (rv && rv != GLOB_NOMATCH)\n\t\t\t\t\treturn rv;\n\n\t\t\t\t/* move after the comma, to the next string */\n\t\t\t\tpl = pm + 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "globexp1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "236-249",
    "snippet": "static int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tRBRACE\t\t'}'",
      "#define\tLBRACE\t\t'{'",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob0",
          "args": [
            "pattern",
            "pglob",
            "limitp"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "glob0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "471-592",
          "snippet": "static int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_SET\t\tMETA('[')",
            "#define\tM_RNG\t\tMETA('-')",
            "#define\tM_ONE\t\tMETA('?')",
            "#define\tM_NOT\t\tMETA('!')",
            "#define\tM_END\t\tMETA(']')",
            "#define\tM_ALL\t\tMETA('*')",
            "#define\tSTAR\t\t'*'",
            "#define\tRBRACKET\t']'",
            "#define\tRANGE\t\t'-'",
            "#define\tQUESTION\t'?'",
            "#define\tNOT\t\t'!'",
            "#define\tLBRACKET\t'['",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tSTAR\t\t'*'\n#define\tRBRACKET\t']'\n#define\tRANGE\t\t'-'\n#define\tQUESTION\t'?'\n#define\tNOT\t\t'!'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globexp2",
          "args": [
            "ptr",
            "pattern",
            "pglob",
            "limitp"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "globexp2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "257-355",
          "snippet": "static int\nglobexp2(const Char *ptr, const Char *pattern, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tint     i, rv;\n\tChar   *lm, *ls;\n\tconst Char *pe, *pm, *pl;\n\tChar    patbuf[MAXPATHLEN];\n\n\t/* copy part up to the brace */\n\tfor (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)\n\t\t;\n\t*lm = EOS;\n\tls = lm;\n\n\t/* Find the balanced brace */\n\tfor (i = 0, pe = ++ptr; *pe; pe++)\n\t\tif (*pe == LBRACKET) {\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)\n\t\t\t\t;\n\t\t\tif (*pe == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpe = pm;\n\t\t\t}\n\t\t} else if (*pe == LBRACE)\n\t\t\ti++;\n\t\telse if (*pe == RBRACE) {\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\n\t/* Non matching braces; just glob the pattern */\n\tif (i != 0 || *pe == EOS)\n\t\treturn glob0(patbuf, pglob, limitp);\n\n\tfor (i = 0, pl = pm = ptr; pm <= pe; pm++) {\n\t\tswitch (*pm) {\n\t\tcase LBRACKET:\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)\n\t\t\t\t;\n\t\t\tif (*pm == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpm = pl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LBRACE:\n\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase RBRACE:\n\t\t\tif (i) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase COMMA:\n\t\t\tif (i && *pm == COMMA)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\t/* Append the current string */\n\t\t\t\tfor (lm = ls; (pl < pm); *lm++ = *pl++)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * Append the rest of the pattern after the\n\t\t\t\t * closing brace\n\t\t\t\t */\n\t\t\t\tfor (pl = pe + 1; (*lm++ = *pl++) != EOS; )\n\t\t\t\t\t;\n\n\t\t\t\t/* Expand the current pattern */\n#ifdef DEBUG\n\t\t\t\tqprintf(\"globexp2:\", patbuf);\n#endif\n\t\t\t\trv = globexp1(patbuf, pglob, limitp);\n\t\t\t\tif (rv && rv != GLOB_NOMATCH)\n\t\t\t\t\treturn rv;\n\n\t\t\t\t/* move after the comma, to the next string */\n\t\t\t\tpl = pm + 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tCOMMA\t\t','",
            "#define\tRBRACE\t\t'}'",
            "#define\tLBRACE\t\t'{'",
            "#define\tRBRACKET\t']'",
            "#define\tLBRACKET\t'['",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tCOMMA\t\t','\n#define\tRBRACE\t\t'}'\n#define\tLBRACE\t\t'{'\n#define\tRBRACKET\t']'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglobexp2(const Char *ptr, const Char *pattern, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tint     i, rv;\n\tChar   *lm, *ls;\n\tconst Char *pe, *pm, *pl;\n\tChar    patbuf[MAXPATHLEN];\n\n\t/* copy part up to the brace */\n\tfor (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)\n\t\t;\n\t*lm = EOS;\n\tls = lm;\n\n\t/* Find the balanced brace */\n\tfor (i = 0, pe = ++ptr; *pe; pe++)\n\t\tif (*pe == LBRACKET) {\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)\n\t\t\t\t;\n\t\t\tif (*pe == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpe = pm;\n\t\t\t}\n\t\t} else if (*pe == LBRACE)\n\t\t\ti++;\n\t\telse if (*pe == RBRACE) {\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\n\t/* Non matching braces; just glob the pattern */\n\tif (i != 0 || *pe == EOS)\n\t\treturn glob0(patbuf, pglob, limitp);\n\n\tfor (i = 0, pl = pm = ptr; pm <= pe; pm++) {\n\t\tswitch (*pm) {\n\t\tcase LBRACKET:\n\t\t\t/* Ignore everything between [] */\n\t\t\tfor (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)\n\t\t\t\t;\n\t\t\tif (*pm == EOS) {\n\t\t\t\t/*\n\t\t\t\t * We could not find a matching RBRACKET.\n\t\t\t\t * Ignore and just look for RBRACE\n\t\t\t\t */\n\t\t\t\tpm = pl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LBRACE:\n\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase RBRACE:\n\t\t\tif (i) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase COMMA:\n\t\t\tif (i && *pm == COMMA)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\t/* Append the current string */\n\t\t\t\tfor (lm = ls; (pl < pm); *lm++ = *pl++)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * Append the rest of the pattern after the\n\t\t\t\t * closing brace\n\t\t\t\t */\n\t\t\t\tfor (pl = pe + 1; (*lm++ = *pl++) != EOS; )\n\t\t\t\t\t;\n\n\t\t\t\t/* Expand the current pattern */\n#ifdef DEBUG\n\t\t\t\tqprintf(\"globexp2:\", patbuf);\n#endif\n\t\t\t\trv = globexp1(patbuf, pglob, limitp);\n\t\t\t\tif (rv && rv != GLOB_NOMATCH)\n\t\t\t\t\treturn rv;\n\n\t\t\t\t/* move after the comma, to the next string */\n\t\t\t\tpl = pm + 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strchr",
          "args": [
            "ptr",
            "LBRACE"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tRBRACE\t\t'}'\n#define\tLBRACE\t\t'{'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}"
  },
  {
    "function_name": "glob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
    "lines": "177-229",
    "snippet": "int\nglob(const char *pattern, int flags, int (*errfunc)(const char *, int),\n    glob_t *pglob)\n{\n\tconst u_char *patnext;\n\tint c;\n\tChar *bufnext, *bufend, patbuf[MAXPATHLEN];\n\tstruct glob_lim limit = { 0, 0, 0 };\n\n\tif (strnlen(pattern, PATH_MAX) == PATH_MAX)\n\t\treturn(GLOB_NOMATCH);\n\n\tpatnext = (u_char *) pattern;\n\tif (!(flags & GLOB_APPEND)) {\n\t\tpglob->gl_pathc = 0;\n\t\tpglob->gl_pathv = NULL;\n\t\tpglob->gl_statv = NULL;\n\t\tif (!(flags & GLOB_DOOFFS))\n\t\t\tpglob->gl_offs = 0;\n\t}\n\tpglob->gl_flags = flags & ~GLOB_MAGCHAR;\n\tpglob->gl_errfunc = errfunc;\n\tpglob->gl_matchc = 0;\n\n\tif (pglob->gl_offs < 0 || pglob->gl_pathc < 0 ||\n\t    pglob->gl_offs >= INT_MAX || pglob->gl_pathc >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX - pglob->gl_offs - 1)\n\t\treturn GLOB_NOSPACE;\n\n\tbufnext = patbuf;\n\tbufend = bufnext + MAXPATHLEN - 1;\n\tif (flags & GLOB_NOESCAPE)\n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\t*bufnext++ = c;\n\telse {\n\t\t/* Protect the quoted characters. */\n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\tif (c == QUOTE) {\n\t\t\t\tif ((c = *patnext++) == EOS) {\n\t\t\t\t\tc = QUOTE;\n\t\t\t\t\t--patnext;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = c | M_PROTECT;\n\t\t\t} else\n\t\t\t\t*bufnext++ = c;\n\t}\n\t*bufnext = EOS;\n\n\tif (flags & GLOB_BRACE)\n\t\treturn globexp1(patbuf, pglob, &limit);\n\telse\n\t\treturn glob0(patbuf, pglob, &limit);\n}",
    "includes": [
      "#include \"charclass.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"glob.h\"",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tM_PROTECT\t0x40",
      "#define\tM_PROTECT\t0x4000",
      "#define\tQUOTE\t\t'\\\\'",
      "#define\tEOS\t\t'\\0'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob0",
          "args": [
            "patbuf",
            "pglob",
            "&limit"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "glob0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "471-592",
          "snippet": "static int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tM_SET\t\tMETA('[')",
            "#define\tM_RNG\t\tMETA('-')",
            "#define\tM_ONE\t\tMETA('?')",
            "#define\tM_NOT\t\tMETA('!')",
            "#define\tM_END\t\tMETA(']')",
            "#define\tM_ALL\t\tMETA('*')",
            "#define\tSTAR\t\t'*'",
            "#define\tRBRACKET\t']'",
            "#define\tRANGE\t\t'-'",
            "#define\tQUESTION\t'?'",
            "#define\tNOT\t\t'!'",
            "#define\tLBRACKET\t'['",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_SET\t\tMETA('[')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_END\t\tMETA(']')\n#define\tM_ALL\t\tMETA('*')\n#define\tSTAR\t\t'*'\n#define\tRBRACKET\t']'\n#define\tRANGE\t\t'-'\n#define\tQUESTION\t'?'\n#define\tNOT\t\t'!'\n#define\tLBRACKET\t'['\n#define\tEOS\t\t'\\0'\n\nstatic int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err, oldpathc;\n\tChar *bufnext, patbuf[MAXPATHLEN];\n\n\tqpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t/* We don't need to check for buffer overflow any more. */\n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t/* collapse adjacent stars to one,\n\t\t\t * to avoid exponential behavior\n\t\t\t */\n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t/*\n\t * If there was no match we are going to append the pattern\n\t * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified\n\t * and the pattern did not contain any magic characters\n\t * GLOB_NOMAGIC is there just for compatibility with csh.\n\t */\n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t/* Keep the paths and stat info synced during sort */\n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tint i;\n\t\t\tint n = pglob->gl_pathc - oldpathc;\n\t\t\tint o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "globexp1",
          "args": [
            "patbuf",
            "pglob",
            "&limit"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "globexp1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "236-249",
          "snippet": "static int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tRBRACE\t\t'}'",
            "#define\tLBRACE\t\t'{'",
            "#define\tEOS\t\t'\\0'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tRBRACE\t\t'}'\n#define\tLBRACE\t\t'{'\n#define\tEOS\t\t'\\0'\n\nstatic int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t/* Protect a single {}, for find(1), like csh */\n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "pattern",
            "PATH_MAX"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "strnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strnlen.c",
          "lines": "27-36",
          "snippet": "size_t\nstrnlen(const char *str, size_t maxlen)\n{\n\tconst char *cp;\n\n\tfor (cp = str; maxlen != 0 && *cp != '\\0'; cp++, maxlen--)\n\t\t;\n\n\treturn (size_t)(cp - str);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrnlen(const char *str, size_t maxlen)\n{\n\tconst char *cp;\n\n\tfor (cp = str; maxlen != 0 && *cp != '\\0'; cp++, maxlen--)\n\t\t;\n\n\treturn (size_t)(cp - str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\n#define\tM_PROTECT\t0x40\n#define\tM_PROTECT\t0x4000\n#define\tQUOTE\t\t'\\\\'\n#define\tEOS\t\t'\\0'\n\nint\nglob(const char *pattern, int flags, int (*errfunc)(const char *, int),\n    glob_t *pglob)\n{\n\tconst u_char *patnext;\n\tint c;\n\tChar *bufnext, *bufend, patbuf[MAXPATHLEN];\n\tstruct glob_lim limit = { 0, 0, 0 };\n\n\tif (strnlen(pattern, PATH_MAX) == PATH_MAX)\n\t\treturn(GLOB_NOMATCH);\n\n\tpatnext = (u_char *) pattern;\n\tif (!(flags & GLOB_APPEND)) {\n\t\tpglob->gl_pathc = 0;\n\t\tpglob->gl_pathv = NULL;\n\t\tpglob->gl_statv = NULL;\n\t\tif (!(flags & GLOB_DOOFFS))\n\t\t\tpglob->gl_offs = 0;\n\t}\n\tpglob->gl_flags = flags & ~GLOB_MAGCHAR;\n\tpglob->gl_errfunc = errfunc;\n\tpglob->gl_matchc = 0;\n\n\tif (pglob->gl_offs < 0 || pglob->gl_pathc < 0 ||\n\t    pglob->gl_offs >= INT_MAX || pglob->gl_pathc >= INT_MAX ||\n\t    pglob->gl_pathc >= INT_MAX - pglob->gl_offs - 1)\n\t\treturn GLOB_NOSPACE;\n\n\tbufnext = patbuf;\n\tbufend = bufnext + MAXPATHLEN - 1;\n\tif (flags & GLOB_NOESCAPE)\n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\t*bufnext++ = c;\n\telse {\n\t\t/* Protect the quoted characters. */\n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\tif (c == QUOTE) {\n\t\t\t\tif ((c = *patnext++) == EOS) {\n\t\t\t\t\tc = QUOTE;\n\t\t\t\t\t--patnext;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = c | M_PROTECT;\n\t\t\t} else\n\t\t\t\t*bufnext++ = c;\n\t}\n\t*bufnext = EOS;\n\n\tif (flags & GLOB_BRACE)\n\t\treturn globexp1(patbuf, pglob, &limit);\n\telse\n\t\treturn glob0(patbuf, pglob, &limit);\n}"
  }
]