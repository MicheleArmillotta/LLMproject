[
  {
    "function_name": "kex_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
    "lines": "189-202",
    "snippet": "void\nkex_tests(void)\n{\n\tdo_kex(\"curve25519-sha256@libssh.org\");\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex(\"ecdh-sha2-nistp256\");\n\tdo_kex(\"ecdh-sha2-nistp384\");\n\tdo_kex(\"ecdh-sha2-nistp521\");\n#endif\n\tdo_kex(\"diffie-hellman-group-exchange-sha256\");\n\tdo_kex(\"diffie-hellman-group-exchange-sha1\");\n\tdo_kex(\"diffie-hellman-group14-sha1\");\n\tdo_kex(\"diffie-hellman-group1-sha1\");\n}",
    "includes": [
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void kex_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_kex",
          "args": [
            "\"diffie-hellman-group1-sha1\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "do_kex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
          "lines": "178-187",
          "snippet": "static void\ndo_kex(char *kex)\n{\n\tdo_kex_with_key(kex, KEY_RSA, 2048);\n\tdo_kex_with_key(kex, KEY_DSA, 1024);\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex_with_key(kex, KEY_ECDSA, 256);\n#endif\n\tdo_kex_with_key(kex, KEY_ED25519, 256);\n}",
          "includes": [
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex(char *kex)\n{\n\tdo_kex_with_key(kex, KEY_RSA, 2048);\n\tdo_kex_with_key(kex, KEY_DSA, 1024);\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex_with_key(kex, KEY_ECDSA, 256);\n#endif\n\tdo_kex_with_key(kex, KEY_ED25519, 256);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid kex_tests(void);\n\nvoid\nkex_tests(void)\n{\n\tdo_kex(\"curve25519-sha256@libssh.org\");\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex(\"ecdh-sha2-nistp256\");\n\tdo_kex(\"ecdh-sha2-nistp384\");\n\tdo_kex(\"ecdh-sha2-nistp521\");\n#endif\n\tdo_kex(\"diffie-hellman-group-exchange-sha256\");\n\tdo_kex(\"diffie-hellman-group-exchange-sha1\");\n\tdo_kex(\"diffie-hellman-group14-sha1\");\n\tdo_kex(\"diffie-hellman-group1-sha1\");\n}"
  },
  {
    "function_name": "do_kex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
    "lines": "178-187",
    "snippet": "static void\ndo_kex(char *kex)\n{\n\tdo_kex_with_key(kex, KEY_RSA, 2048);\n\tdo_kex_with_key(kex, KEY_DSA, 1024);\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex_with_key(kex, KEY_ECDSA, 256);\n#endif\n\tdo_kex_with_key(kex, KEY_ED25519, 256);\n}",
    "includes": [
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_kex_with_key",
          "args": [
            "kex",
            "KEY_ED25519",
            "256"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "do_kex_with_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
          "lines": "80-176",
          "snippet": "static void\ndo_kex_with_key(char *kex, int keytype, int bits)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *private, *public;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\n\tTEST_START(\"sshkey_generate\");\n\tASSERT_INT_EQ(sshkey_generate(keytype, bits, &private), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(private, &public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = kex;\n\tkeyname = strdup(sshkey_ssh_name(private));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, private), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tserver2 = NULL;\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(server2, NULL);\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, private), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n#ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(private);\n\tsshkey_free(public);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}",
          "includes": [
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex_with_key(char *kex, int keytype, int bits)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *private, *public;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\n\tTEST_START(\"sshkey_generate\");\n\tASSERT_INT_EQ(sshkey_generate(keytype, bits, &private), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(private, &public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = kex;\n\tkeyname = strdup(sshkey_ssh_name(private));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, private), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tserver2 = NULL;\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(server2, NULL);\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, private), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n#ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(private);\n\tsshkey_free(public);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex(char *kex)\n{\n\tdo_kex_with_key(kex, KEY_RSA, 2048);\n\tdo_kex_with_key(kex, KEY_DSA, 1024);\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex_with_key(kex, KEY_ECDSA, 256);\n#endif\n\tdo_kex_with_key(kex, KEY_ED25519, 256);\n}"
  },
  {
    "function_name": "do_kex_with_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
    "lines": "80-176",
    "snippet": "static void\ndo_kex_with_key(char *kex, int keytype, int bits)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *private, *public;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\n\tTEST_START(\"sshkey_generate\");\n\tASSERT_INT_EQ(sshkey_generate(keytype, bits, &private), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(private, &public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = kex;\n\tkeyname = strdup(sshkey_ssh_name(private));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, private), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tserver2 = NULL;\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(server2, NULL);\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, private), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n#ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(private);\n\tsshkey_free(public);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}",
    "includes": [
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keyname"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_free",
          "args": [
            "server2"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"cleanup\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_kex",
          "args": [
            "client",
            "server2"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "run_kex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
          "lines": "58-78",
          "snippet": "static void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif (do_debug)\n\t\t\tprintf(\" S:\");\n\t\tif ((r = do_send_and_receive(server, client)))\n\t\t\tbreak;\n\t\tif (do_debug)\n\t\t\tprintf(\" C:\");\n\t\tif ((r = do_send_and_receive(client, server)))\n\t\t\tbreak;\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}",
          "includes": [
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_debug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif (do_debug)\n\t\t\tprintf(\" S:\");\n\t\tif ((r = do_send_and_receive(server, client)))\n\t\t\tbreak;\n\t\tif (do_debug)\n\t\t\tprintf(\" C:\");\n\t\tif ((r = do_send_and_receive(client, server)))\n\t\t\tbreak;\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(client)",
            "0"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kex_send_kexinit",
          "args": [
            "client"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "kex_send_kexinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "498-525",
          "snippet": "int\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(server2)",
            "0"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying server2\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server2->kex",
            "NULL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "state"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_len(state)",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "state"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_packet_set_state(server2, state)",
            "0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_state",
          "args": [
            "server2",
            "state"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2370-2417",
          "snippet": "int\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_free",
          "args": [
            "server2->kex"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "kex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "638-662",
          "snippet": "void\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(server2, private)",
            "0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_add_hostkey",
          "args": [
            "server2",
            "private"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_add_hostkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "177-209",
          "snippet": "int\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server2",
            "NULL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&server2, 1, NULL)",
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_init",
          "args": [
            "&server2",
            "1",
            "NULL"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "74-137",
          "snippet": "int\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_packet_set_state\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_GE",
          "args": [
            "sshbuf_len(state)",
            "1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_packet_get_state(server, state)",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_state",
          "args": [
            "server",
            "state"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2230-2254",
          "snippet": "int\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "state",
            "NULL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_packet_get_state\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(server)",
            "0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying server\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(client)",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying client\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"kex\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(client, public)",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(server, private)",
            "0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_add_hostkey\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server",
            "NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "client",
            "NULL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&server, 1, &kex_params)",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&client, 0, &kex_params)",
            "0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "keyname",
            "NULL"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "sshkey_ssh_name(private)"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "private"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kex_params.proposal",
            "myproposal",
            "sizeof(myproposal)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_init\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(private, &public)",
            "0"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "private",
            "&public"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sshkey_from_private\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(keytype, bits, &private)",
            "0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_generate",
          "args": [
            "keytype",
            "bits",
            "&private"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1605-1654",
          "snippet": "int\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sshkey_generate\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex_with_key(char *kex, int keytype, int bits)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *private, *public;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\n\tTEST_START(\"sshkey_generate\");\n\tASSERT_INT_EQ(sshkey_generate(keytype, bits, &private), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(private, &public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = kex;\n\tkeyname = strdup(sshkey_ssh_name(private));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, private), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tserver2 = NULL;\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(server2, NULL);\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, private), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n#ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(private);\n\tsshkey_free(public);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}"
  },
  {
    "function_name": "run_kex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
    "lines": "58-78",
    "snippet": "static void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif (do_debug)\n\t\t\tprintf(\" S:\");\n\t\tif ((r = do_send_and_receive(server, client)))\n\t\t\tbreak;\n\t\tif (do_debug)\n\t\t\tprintf(\" C:\");\n\t\tif ((r = do_send_and_receive(client, server)))\n\t\t\tbreak;\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}",
    "includes": [
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_debug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "client->kex->done",
            "1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "server->kex->done",
            "1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"done: %s\\n\"",
            "ssh_err(r)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_send_and_receive",
          "args": [
            "client",
            "server"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_and_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
          "lines": "32-56",
          "snippet": "static int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (do_debug)\n\t\t\tprintf(\"%zu\", len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0 ||\n\t\t    (r = ssh_input_append(to, buf, len)) != 0)\n\t\t\treturn r;\n\t}\n}",
          "includes": [
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_debug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (do_debug)\n\t\t\tprintf(\"%zu\", len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0 ||\n\t\t    (r = ssh_input_append(to, buf, len)) != 0)\n\t\t\treturn r;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" C:\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif (do_debug)\n\t\t\tprintf(\" S:\");\n\t\tif ((r = do_send_and_receive(server, client)))\n\t\t\tbreak;\n\t\tif (do_debug)\n\t\t\tprintf(\" C:\");\n\t\tif ((r = do_send_and_receive(client, server)))\n\t\t\tbreak;\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}"
  },
  {
    "function_name": "do_send_and_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/kex/test_kex.c",
    "lines": "32-56",
    "snippet": "static int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (do_debug)\n\t\t\tprintf(\"%zu\", len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0 ||\n\t\t    (r = ssh_input_append(to, buf, len)) != 0)\n\t\t\treturn r;\n\t}\n}",
    "includes": [
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_debug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_input_append",
          "args": [
            "to",
            "buf",
            "len"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_input_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "223-227",
          "snippet": "int\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_output_consume",
          "args": [
            "from",
            "len"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_output_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "297-301",
          "snippet": "int\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%zu\"",
            "len"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_output_ptr",
          "args": [
            "from",
            "&len"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_output_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "288-295",
          "snippet": "const u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nconst u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssh_packet_next: %s\\n\"",
            "ssh_err(r)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_next",
          "args": [
            "from",
            "&type"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "229-268",
          "snippet": "int\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (do_debug)\n\t\t\tprintf(\"%zu\", len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0 ||\n\t\t    (r = ssh_input_append(to, buf, len)) != 0)\n\t\t\treturn r;\n\t}\n}"
  }
]