[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/modpipe.c",
    "lines": "81-150",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint ch;\n\tu_char buf[8192];\n\tsize_t total;\n\tssize_t r, s, o;\n\tstruct modification mods[MAX_MODIFICATIONS];\n\tu_int i, wflag = 0, num_mods = 0;\n\n\twhile ((ch = getopt(argc, argv, \"wm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (num_mods >= MAX_MODIFICATIONS)\n\t\t\t\terrx(1, \"Too many modifications\");\n\t\t\tparse_modification(optarg, &(mods[num_mods++]));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tfor (total = 0;;) {\n\t\tr = s = read(STDIN_FILENO, buf, sizeof(buf));\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terr(1, \"read\");\n\t\t}\n\t\tfor (i = 0; i < num_mods; i++) {\n\t\t\tif (mods[i].offset < total ||\n\t\t\t    mods[i].offset >= total + s)\n\t\t\t\tcontinue;\n\t\t\tswitch (mods[i].what) {\n\t\t\tcase MOD_XOR:\n\t\t\t\tbuf[mods[i].offset - total] ^= mods[i].m1;\n\t\t\t\tbreak;\n\t\t\tcase MOD_AND_OR:\n\t\t\t\tbuf[mods[i].offset - total] &= mods[i].m1;\n\t\t\t\tbuf[mods[i].offset - total] |= mods[i].m2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (o = 0; o < s; o += r) {\n\t\t\tr = write(STDOUT_FILENO, buf, s - o);\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\terr(1, \"write\");\n\t\t\t}\n\t\t}\n\t\ttotal += s;\n\t}\n\t/* Warn if modifications not reached in input stream */\n\tr = 0;\n\tfor (i = 0; wflag && i < num_mods; i++) {\n\t\tif (mods[i].offset < total)\n\t\t\tcontinue;\n\t\tr = 1;\n\t\tfprintf(stderr, \"modpipe: warning - mod %u not reached\\n\", i);\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"openbsd-compat/getopt_long.c\"",
      "# include <err.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_MODIFICATIONS 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"modpipe: warning - mod %u not reached\\n\"",
            "i"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"write\""
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDOUT_FILENO",
            "buf",
            "s - o"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "STDIN_FILENO",
            "buf",
            "sizeof(buf)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "proxy_read_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1413-1433",
          "snippet": "static int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nstatic int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/modpipe.c",
          "lines": "33-41",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"Usage: modpipe -w [-m modspec ...] < in > out\\n\");\n\tfprintf(stderr, \"modspec is one of:\\n\");\n\tfprintf(stderr, \"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\");\n\tfprintf(stderr, \"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"openbsd-compat/getopt_long.c\"",
            "# include <err.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/getopt_long.c\"\n# include <err.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"Usage: modpipe -w [-m modspec ...] < in > out\\n\");\n\tfprintf(stderr, \"modspec is one of:\\n\");\n\tfprintf(stderr, \"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\");\n\tfprintf(stderr, \"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_modification",
          "args": [
            "optarg",
            "&(mods[num_mods++])"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "parse_modification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/modpipe.c",
          "lines": "50-79",
          "snippet": "static void\nparse_modification(const char *s, struct modification *m)\n{\n\tchar what[16+1];\n\tint n, m1, m2;\n\n\tbzero(m, sizeof(*m));\n\tif ((n = sscanf(s, \"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\",\n\t    what, &m->offset, &m1, &m2)) < 3)\n\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\tif (strcasecmp(what, \"xor\") == 0) {\n\t\tif (n > 3)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid XOR modification value\");\n\t\tm->what = MOD_XOR;\n\t\tm->m1 = m1;\n\t} else if (strcasecmp(what, \"andor\") == 0) {\n\t\tif (n != 4)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid AND modification value\");\n\t\tif (m2 < 0 || m2 > 0xff)\n\t\t\terrx(1, \"Invalid OR modification value\");\n\t\tm->what = MOD_AND_OR;\n\t\tm->m1 = m1;\n\t\tm->m2 = m2;\n\t} else\n\t\terrx(1, \"Invalid modification type \\\"%s\\\"\", what);\n}",
          "includes": [
            "#include \"openbsd-compat/getopt_long.c\"",
            "# include <err.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/getopt_long.c\"\n# include <err.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nparse_modification(const char *s, struct modification *m)\n{\n\tchar what[16+1];\n\tint n, m1, m2;\n\n\tbzero(m, sizeof(*m));\n\tif ((n = sscanf(s, \"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\",\n\t    what, &m->offset, &m1, &m2)) < 3)\n\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\tif (strcasecmp(what, \"xor\") == 0) {\n\t\tif (n > 3)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid XOR modification value\");\n\t\tm->what = MOD_XOR;\n\t\tm->m1 = m1;\n\t} else if (strcasecmp(what, \"andor\") == 0) {\n\t\tif (n != 4)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid AND modification value\");\n\t\tif (m2 < 0 || m2 > 0xff)\n\t\t\terrx(1, \"Invalid OR modification value\");\n\t\tm->what = MOD_AND_OR;\n\t\tm->m1 = m1;\n\t\tm->m2 = m2;\n\t} else\n\t\terrx(1, \"Invalid modification type \\\"%s\\\"\", what);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Too many modifications\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"wm:\""
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/getopt_long.c\"\n# include <err.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_MODIFICATIONS 256\n\nint\nmain(int argc, char **argv)\n{\n\tint ch;\n\tu_char buf[8192];\n\tsize_t total;\n\tssize_t r, s, o;\n\tstruct modification mods[MAX_MODIFICATIONS];\n\tu_int i, wflag = 0, num_mods = 0;\n\n\twhile ((ch = getopt(argc, argv, \"wm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (num_mods >= MAX_MODIFICATIONS)\n\t\t\t\terrx(1, \"Too many modifications\");\n\t\t\tparse_modification(optarg, &(mods[num_mods++]));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tfor (total = 0;;) {\n\t\tr = s = read(STDIN_FILENO, buf, sizeof(buf));\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terr(1, \"read\");\n\t\t}\n\t\tfor (i = 0; i < num_mods; i++) {\n\t\t\tif (mods[i].offset < total ||\n\t\t\t    mods[i].offset >= total + s)\n\t\t\t\tcontinue;\n\t\t\tswitch (mods[i].what) {\n\t\t\tcase MOD_XOR:\n\t\t\t\tbuf[mods[i].offset - total] ^= mods[i].m1;\n\t\t\t\tbreak;\n\t\t\tcase MOD_AND_OR:\n\t\t\t\tbuf[mods[i].offset - total] &= mods[i].m1;\n\t\t\t\tbuf[mods[i].offset - total] |= mods[i].m2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (o = 0; o < s; o += r) {\n\t\t\tr = write(STDOUT_FILENO, buf, s - o);\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\terr(1, \"write\");\n\t\t\t}\n\t\t}\n\t\ttotal += s;\n\t}\n\t/* Warn if modifications not reached in input stream */\n\tr = 0;\n\tfor (i = 0; wflag && i < num_mods; i++) {\n\t\tif (mods[i].offset < total)\n\t\t\tcontinue;\n\t\tr = 1;\n\t\tfprintf(stderr, \"modpipe: warning - mod %u not reached\\n\", i);\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "parse_modification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/modpipe.c",
    "lines": "50-79",
    "snippet": "static void\nparse_modification(const char *s, struct modification *m)\n{\n\tchar what[16+1];\n\tint n, m1, m2;\n\n\tbzero(m, sizeof(*m));\n\tif ((n = sscanf(s, \"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\",\n\t    what, &m->offset, &m1, &m2)) < 3)\n\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\tif (strcasecmp(what, \"xor\") == 0) {\n\t\tif (n > 3)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid XOR modification value\");\n\t\tm->what = MOD_XOR;\n\t\tm->m1 = m1;\n\t} else if (strcasecmp(what, \"andor\") == 0) {\n\t\tif (n != 4)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid AND modification value\");\n\t\tif (m2 < 0 || m2 > 0xff)\n\t\t\terrx(1, \"Invalid OR modification value\");\n\t\tm->what = MOD_AND_OR;\n\t\tm->m1 = m1;\n\t\tm->m2 = m2;\n\t} else\n\t\terrx(1, \"Invalid modification type \\\"%s\\\"\", what);\n}",
    "includes": [
      "#include \"openbsd-compat/getopt_long.c\"",
      "# include <err.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Invalid modification type \\\"%s\\\"\"",
            "what"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "what",
            "\"andor\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "what",
            "\"xor\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\"",
            "what",
            "&m->offset",
            "&m1",
            "&m2"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "m",
            "sizeof(*m)"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/getopt_long.c\"\n# include <err.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nparse_modification(const char *s, struct modification *m)\n{\n\tchar what[16+1];\n\tint n, m1, m2;\n\n\tbzero(m, sizeof(*m));\n\tif ((n = sscanf(s, \"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\",\n\t    what, &m->offset, &m1, &m2)) < 3)\n\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\tif (strcasecmp(what, \"xor\") == 0) {\n\t\tif (n > 3)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid XOR modification value\");\n\t\tm->what = MOD_XOR;\n\t\tm->m1 = m1;\n\t} else if (strcasecmp(what, \"andor\") == 0) {\n\t\tif (n != 4)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid AND modification value\");\n\t\tif (m2 < 0 || m2 > 0xff)\n\t\t\terrx(1, \"Invalid OR modification value\");\n\t\tm->what = MOD_AND_OR;\n\t\tm->m1 = m1;\n\t\tm->m2 = m2;\n\t} else\n\t\terrx(1, \"Invalid modification type \\\"%s\\\"\", what);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/modpipe.c",
    "lines": "33-41",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"Usage: modpipe -w [-m modspec ...] < in > out\\n\");\n\tfprintf(stderr, \"modspec is one of:\\n\");\n\tfprintf(stderr, \"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\");\n\tfprintf(stderr, \"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\");\n\texit(1);\n}",
    "includes": [
      "#include \"openbsd-compat/getopt_long.c\"",
      "# include <err.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"modspec is one of:\\n\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: modpipe -w [-m modspec ...] < in > out\\n\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/getopt_long.c\"\n# include <err.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"Usage: modpipe -w [-m modspec ...] < in > out\\n\");\n\tfprintf(stderr, \"modspec is one of:\\n\");\n\tfprintf(stderr, \"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\");\n\tfprintf(stderr, \"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\");\n\texit(1);\n}"
  }
]