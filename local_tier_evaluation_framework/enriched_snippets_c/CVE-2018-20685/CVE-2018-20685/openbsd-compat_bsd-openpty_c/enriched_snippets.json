[
  {
    "function_name": "openpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-openpty.c",
    "lines": "72-192",
    "snippet": "int\nopenpty(int *amaster, int *aslave, char *name, struct termios *termp,\n   struct winsize *winp)\n{\n#if defined(HAVE__GETPTY)\n\t/*\n\t * _getpty(3) exists in SGI Irix 4.x, 5.x & 6.x -- it generates more\n\t * pty's automagically when needed\n\t */\n\tchar *slave;\n\n\tif ((slave = _getpty(amaster, O_RDWR, 0622, 0)) == NULL)\n\t\treturn (-1);\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(slave, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTMX)\n\t/*\n\t * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\n\t * also has bsd-style ptys, but they simply do not work.)\n\t */\n\tint ptm;\n\tchar *pts;\n\tmysig_t old_signal;\n\n\tif ((ptm = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\n\t/* XXX: need to close ptm on error? */\n\told_signal = signal(SIGCHLD, SIG_DFL);\n\tif (grantpt(ptm) < 0)\n\t\treturn (-1);\n\tsignal(SIGCHLD, old_signal);\n\n\tif (unlockpt(ptm) < 0)\n\t\treturn (-1);\n\n\tif ((pts = ptsname(ptm)) == NULL)\n\t\treturn (-1);\n\t*amaster = ptm;\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(pts, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Try to push the appropriate streams modules, as described\n\t * in Solaris pts(7).\n\t */\n\tioctl(*aslave, I_PUSH, \"ptem\");\n\tioctl(*aslave, I_PUSH, \"ldterm\");\n# ifndef __hpux\n\tioctl(*aslave, I_PUSH, \"ttcompat\");\n# endif /* __hpux */\n\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTS_AND_PTC)\n\t/* AIX-style pty code. */\n\tconst char *ttname;\n\n\tif ((*amaster = open(\"/dev/ptc\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\tif ((ttname = ttyname(*amaster)) == NULL)\n\t\treturn (-1);\n\tif ((*aslave = open(ttname, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#else\n\t/* BSD-style pty code. */\n\tchar ptbuf[64], ttbuf[64];\n\tint i;\n\tconst char *ptymajors = \"pqrstuvwxyzabcdefghijklmno\"\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char *ptyminors = \"0123456789abcdef\";\n\tint num_minors = strlen(ptyminors);\n\tint num_ptys = strlen(ptymajors) * num_minors;\n\tstruct termios tio;\n\n\tfor (i = 0; i < num_ptys; i++) {\n\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/pty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/tty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\n\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\t/* Try SCO style naming */\n\t\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/ptyp%d\", i);\n\t\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/ttyp%d\", i);\n\t\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Open the slave side. */\n\t\tif ((*aslave = open(ttbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\tclose(*amaster);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* set tty modes to a sane state for broken clients */\n\t\tif (tcgetattr(*amaster, &tio) != -1) {\n\t\t\ttio.c_lflag |= (ECHO | ISIG | ICANON);\n\t\t\ttio.c_oflag |= (OPOST | ONLCR);\n\t\t\ttio.c_iflag |= ICRNL;\n\t\t\ttcsetattr(*amaster, TCSANOW, &tio);\n\t\t}\n\n\t\treturn (0);\n\t}\n\treturn (-1);\n#endif\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "# include <sys/stropts.h>",
      "# include <pty.h>",
      "# include <util.h>",
      "# include <fcntl.h>",
      "# include <sys/ioctl.h>",
      "# include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define O_NOCTTY 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "*amaster",
            "TCSANOW",
            "&tio"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "tcsetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "52-73",
          "snippet": "int\ntcsetattr(int fd, int opt, const struct termios *t)\n{\n\tstruct termios localterm;\n\n\tif (opt & TCSASOFT) {\n\t\tlocalterm = *t;\n\t\tlocalterm.c_cflag |= CIGNORE;\n\t\tt = &localterm;\n\t}\n\tswitch (opt & ~TCSASOFT) {\n\tcase TCSANOW:\n\t\treturn (ioctl(fd, TIOCSETA, t));\n\tcase TCSADRAIN:\n\t\treturn (ioctl(fd, TIOCSETAW, t));\n\tcase TCSAFLUSH:\n\t\treturn (ioctl(fd, TIOCSETAF, t));\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcsetattr(int fd, int opt, const struct termios *t)\n{\n\tstruct termios localterm;\n\n\tif (opt & TCSASOFT) {\n\t\tlocalterm = *t;\n\t\tlocalterm.c_cflag |= CIGNORE;\n\t\tt = &localterm;\n\t}\n\tswitch (opt & ~TCSASOFT) {\n\tcase TCSANOW:\n\t\treturn (ioctl(fd, TIOCSETA, t));\n\tcase TCSADRAIN:\n\t\treturn (ioctl(fd, TIOCSETAW, t));\n\tcase TCSAFLUSH:\n\t\treturn (ioctl(fd, TIOCSETAF, t));\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "*amaster",
            "&tio"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "tcgetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "46-50",
          "snippet": "int\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "*amaster"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "ttbuf",
            "O_RDWR | O_NOCTTY"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ttbuf",
            "sizeof(ttbuf)",
            "\"/dev/ttyp%d\"",
            "i"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptymajors"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptyminors"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "*amaster"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*aslave",
            "I_PUSH",
            "\"ttcompat\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*aslave",
            "I_PUSH",
            "\"ldterm\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*aslave",
            "I_PUSH",
            "\"ptem\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptsname",
          "args": [
            "ptm"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlockpt",
          "args": [
            "ptm"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "old_signal"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "mysignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-signal.c",
          "lines": "27-51",
          "snippet": "mysig_t\nmysignal(int sig, mysig_t act)\n{\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sa, osa;\n\n\tif (sigaction(sig, NULL, &osa) == -1)\n\t\treturn (mysig_t) -1;\n\tif (osa.sa_handler != act) {\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsa.sa_flags = 0;\n#ifdef SA_INTERRUPT\n\t\tif (sig == SIGALRM)\n\t\t\tsa.sa_flags |= SA_INTERRUPT;\n#endif\n\t\tsa.sa_handler = act;\n\t\tif (sigaction(sig, &sa, NULL) == -1)\n\t\t\treturn (mysig_t) -1;\n\t}\n\treturn (osa.sa_handler);\n#else\n\treturn (signal(sig, act));\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/bsd-signal.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/bsd-signal.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include \"includes.h\"\n\nmysig_t\nmysignal(int sig, mysig_t act)\n{\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sa, osa;\n\n\tif (sigaction(sig, NULL, &osa) == -1)\n\t\treturn (mysig_t) -1;\n\tif (osa.sa_handler != act) {\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsa.sa_flags = 0;\n#ifdef SA_INTERRUPT\n\t\tif (sig == SIGALRM)\n\t\t\tsa.sa_flags |= SA_INTERRUPT;\n#endif\n\t\tsa.sa_handler = act;\n\t\tif (sigaction(sig, &sa, NULL) == -1)\n\t\t\treturn (mysig_t) -1;\n\t}\n\treturn (osa.sa_handler);\n#else\n\treturn (signal(sig, act));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "grantpt",
          "args": [
            "ptm"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_getpty",
          "args": [
            "amaster",
            "O_RDWR",
            "0622",
            "0"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n# include <sys/stropts.h>\n# include <pty.h>\n# include <util.h>\n# include <fcntl.h>\n# include <sys/ioctl.h>\n# include <sys/stat.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nint\nopenpty(int *amaster, int *aslave, char *name, struct termios *termp,\n   struct winsize *winp)\n{\n#if defined(HAVE__GETPTY)\n\t/*\n\t * _getpty(3) exists in SGI Irix 4.x, 5.x & 6.x -- it generates more\n\t * pty's automagically when needed\n\t */\n\tchar *slave;\n\n\tif ((slave = _getpty(amaster, O_RDWR, 0622, 0)) == NULL)\n\t\treturn (-1);\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(slave, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTMX)\n\t/*\n\t * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\n\t * also has bsd-style ptys, but they simply do not work.)\n\t */\n\tint ptm;\n\tchar *pts;\n\tmysig_t old_signal;\n\n\tif ((ptm = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\n\t/* XXX: need to close ptm on error? */\n\told_signal = signal(SIGCHLD, SIG_DFL);\n\tif (grantpt(ptm) < 0)\n\t\treturn (-1);\n\tsignal(SIGCHLD, old_signal);\n\n\tif (unlockpt(ptm) < 0)\n\t\treturn (-1);\n\n\tif ((pts = ptsname(ptm)) == NULL)\n\t\treturn (-1);\n\t*amaster = ptm;\n\n\t/* Open the slave side. */\n\tif ((*aslave = open(pts, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Try to push the appropriate streams modules, as described\n\t * in Solaris pts(7).\n\t */\n\tioctl(*aslave, I_PUSH, \"ptem\");\n\tioctl(*aslave, I_PUSH, \"ldterm\");\n# ifndef __hpux\n\tioctl(*aslave, I_PUSH, \"ttcompat\");\n# endif /* __hpux */\n\n\treturn (0);\n\n#elif defined(HAVE_DEV_PTS_AND_PTC)\n\t/* AIX-style pty code. */\n\tconst char *ttname;\n\n\tif ((*amaster = open(\"/dev/ptc\", O_RDWR | O_NOCTTY)) == -1)\n\t\treturn (-1);\n\tif ((ttname = ttyname(*amaster)) == NULL)\n\t\treturn (-1);\n\tif ((*aslave = open(ttname, O_RDWR | O_NOCTTY)) == -1) {\n\t\tclose(*amaster);\n\t\treturn (-1);\n\t}\n\treturn (0);\n\n#else\n\t/* BSD-style pty code. */\n\tchar ptbuf[64], ttbuf[64];\n\tint i;\n\tconst char *ptymajors = \"pqrstuvwxyzabcdefghijklmno\"\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char *ptyminors = \"0123456789abcdef\";\n\tint num_minors = strlen(ptyminors);\n\tint num_ptys = strlen(ptymajors) * num_minors;\n\tstruct termios tio;\n\n\tfor (i = 0; i < num_ptys; i++) {\n\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/pty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/tty%c%c\",\n\t\t    ptymajors[i / num_minors], ptyminors[i % num_minors]);\n\n\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\t/* Try SCO style naming */\n\t\t\tsnprintf(ptbuf, sizeof(ptbuf), \"/dev/ptyp%d\", i);\n\t\t\tsnprintf(ttbuf, sizeof(ttbuf), \"/dev/ttyp%d\", i);\n\t\t\tif ((*amaster = open(ptbuf, O_RDWR | O_NOCTTY)) == -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Open the slave side. */\n\t\tif ((*aslave = open(ttbuf, O_RDWR | O_NOCTTY)) == -1) {\n\t\t\tclose(*amaster);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* set tty modes to a sane state for broken clients */\n\t\tif (tcgetattr(*amaster, &tio) != -1) {\n\t\t\ttio.c_lflag |= (ECHO | ISIG | ICANON);\n\t\t\ttio.c_oflag |= (OPOST | ONLCR);\n\t\t\ttio.c_iflag |= ICRNL;\n\t\t\ttcsetattr(*amaster, TCSANOW, &tio);\n\t\t}\n\n\t\treturn (0);\n\t}\n\treturn (-1);\n#endif\n}"
  }
]