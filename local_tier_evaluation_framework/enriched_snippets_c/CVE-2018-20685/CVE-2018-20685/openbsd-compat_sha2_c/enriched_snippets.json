[
  {
    "function_name": "SHA384_Final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "882-902",
    "snippet": "void\nSHA384_Final(u_int8_t digest[SHA384_DIGEST_LENGTH], SHA384_CTX *context)\n{\n\tSHA384_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tBE_64_TO_8(digest + i * 8, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA384_DIGEST_LENGTH);\n#endif\n\t}\n\n\t/* Zero out state data */\n\tmemset(context, 0, sizeof(*context));\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context",
            "0",
            "sizeof(*context)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "context->state",
            "SHA384_DIGEST_LENGTH"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_64_TO_8",
          "args": [
            "digest + i * 8",
            "context->state[i]"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA384_Pad",
          "args": [
            "context"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "SHA384_Pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "876-880",
          "snippet": "void\nSHA384_Pad(SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Pad(SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Final(u_int8_t digest[SHA384_DIGEST_LENGTH], SHA384_CTX *context)\n{\n\tSHA384_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tBE_64_TO_8(digest + i * 8, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA384_DIGEST_LENGTH);\n#endif\n\t}\n\n\t/* Zero out state data */\n\tmemset(context, 0, sizeof(*context));\n}"
  },
  {
    "function_name": "SHA384_Pad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "876-880",
    "snippet": "void\nSHA384_Pad(SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA512_Pad",
          "args": [
            "context"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "782-823",
          "snippet": "void\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\n#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)\n\nvoid\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Pad(SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n}"
  },
  {
    "function_name": "SHA384_Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "870-874",
    "snippet": "void\nSHA384_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tSHA512_Update(context, data, len);\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA512_Update",
          "args": [
            "context",
            "data",
            "len"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "736-780",
          "snippet": "void\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tSHA512_Update(context, data, len);\n}"
  },
  {
    "function_name": "SHA384_Transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "864-868",
    "snippet": "void\nSHA384_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\treturn SHA512_Transform(state, data);\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA512_Transform",
          "args": [
            "state",
            "data"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "661-732",
          "snippet": "void\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\treturn SHA512_Transform(state, data);\n}"
  },
  {
    "function_name": "SHA384_Init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "847-856",
    "snippet": "void\nSHA384_Init(SHA384_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha384_initial_hash_value,\n\t    sizeof(sha384_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount[0] = context->bitcount[1] = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "sizeof(context->buffer)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->state",
            "sha384_initial_hash_value",
            "sizeof(sha384_initial_hash_value)"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA384_Init(SHA384_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha384_initial_hash_value,\n\t    sizeof(sha384_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount[0] = context->bitcount[1] = 0;\n}"
  },
  {
    "function_name": "SHA512_Final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "825-843",
    "snippet": "void\nSHA512_Final(u_int8_t digest[SHA512_DIGEST_LENGTH], SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tBE_64_TO_8(digest + i * 8, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA512_DIGEST_LENGTH);\n#endif\n\t\tmemset(context, 0, sizeof(*context));\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context",
            "0",
            "sizeof(*context)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "context->state",
            "SHA512_DIGEST_LENGTH"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_64_TO_8",
          "args": [
            "digest + i * 8",
            "context->state[i]"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA512_Pad",
          "args": [
            "context"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "782-823",
          "snippet": "void\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\n#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)\n\nvoid\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Final(u_int8_t digest[SHA512_DIGEST_LENGTH], SHA512_CTX *context)\n{\n\tSHA512_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tBE_64_TO_8(digest + i * 8, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA512_DIGEST_LENGTH);\n#endif\n\t\tmemset(context, 0, sizeof(*context));\n\t}\n}"
  },
  {
    "function_name": "SHA512_Pad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "782-823",
    "snippet": "void\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA512_Transform",
          "args": [
            "context->state",
            "context->buffer"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "661-732",
          "snippet": "void\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BE_64_TO_8",
          "args": [
            "&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8]",
            "context->bitcount[0]"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_64_TO_8",
          "args": [
            "&context->buffer[SHA512_SHORT_BLOCK_LENGTH]",
            "context->bitcount[1]"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "SHA512_SHORT_BLOCK_LENGTH"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "SHA512_BLOCK_LENGTH - 2"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->buffer[usedspace]",
            "0",
            "SHA512_BLOCK_LENGTH - usedspace"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->buffer[usedspace]",
            "0",
            "SHA512_SHORT_BLOCK_LENGTH - usedspace"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\n#define SHA512_SHORT_BLOCK_LENGTH\t(SHA512_BLOCK_LENGTH - 16)\n\nvoid\nSHA512_Pad(SHA512_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA512_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\n\t\t\t/* And set-up for the last transform: */\n\t\t\tmemset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);\n\t\t}\n\t} else {\n\t\t/* Prepare for final transform: */\n\t\tmemset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],\n\t    context->bitcount[1]);\n\tBE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],\n\t    context->bitcount[0]);\n\n\t/* Final transform: */\n\tSHA512_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}"
  },
  {
    "function_name": "SHA512_Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "736-780",
    "snippet": "void\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADDINC128",
          "args": [
            "context->bitcount",
            "len << 3"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->buffer",
            "data",
            "len"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDINC128",
          "args": [
            "context->bitcount",
            "SHA512_BLOCK_LENGTH << 3"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA512_Transform",
          "args": [
            "context->state",
            "data"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "SHA512_Transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "661-732",
          "snippet": "void\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDINC128",
          "args": [
            "context->bitcount",
            "len << 3"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->buffer[usedspace]",
            "data",
            "len"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDINC128",
          "args": [
            "context->bitcount",
            "freespace << 3"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->buffer[usedspace]",
            "data",
            "freespace"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA512_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tADDINC128(context->bitcount, freespace << 3);\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA512_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tADDINC128(context->bitcount, len << 3);\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA512_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA512_Transform(context->state, data);\n\t\tADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);\n\t\tlen -= SHA512_BLOCK_LENGTH;\n\t\tdata += SHA512_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tADDINC128(context->bitcount, len << 3);\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}"
  },
  {
    "function_name": "SHA512_Transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "661-732",
    "snippet": "void\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Maj",
          "args": [
            "a",
            "b",
            "c"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma0_512",
          "args": [
            "a"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ch",
          "args": [
            "e",
            "f",
            "g"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma1_512",
          "args": [
            "e"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigma1_512",
          "args": [
            "s1"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigma0_512",
          "args": [
            "s0"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Maj",
          "args": [
            "a",
            "b",
            "c"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma0_512",
          "args": [
            "a"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ch",
          "args": [
            "e",
            "f",
            "g"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma1_512",
          "args": [
            "e"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_8_TO_64",
          "args": [
            "W512[j]",
            "data"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, T2, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_64(W512[j], data);\n\t\tdata += 8;\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W512[(j+1)&0x0f];\n\t\ts0 = sigma0_512(s0);\n\t\ts1 = W512[(j+14)&0x0f];\n\t\ts1 =  sigma1_512(s1);\n\n\t\t/* Apply the SHA-512 compression function to update a..h */\n\t\tT1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +\n\t\t     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_512(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
  },
  {
    "function_name": "SHA512_Transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "603-657",
    "snippet": "void\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\t/* Rounds 0 to 15 (unrolled): */\n\t\tROUND512_0_TO_15(a,b,c,d,e,f,g,h);\n\t\tROUND512_0_TO_15(h,a,b,c,d,e,f,g);\n\t\tROUND512_0_TO_15(g,h,a,b,c,d,e,f);\n\t\tROUND512_0_TO_15(f,g,h,a,b,c,d,e);\n\t\tROUND512_0_TO_15(e,f,g,h,a,b,c,d);\n\t\tROUND512_0_TO_15(d,e,f,g,h,a,b,c);\n\t\tROUND512_0_TO_15(c,d,e,f,g,h,a,b);\n\t\tROUND512_0_TO_15(b,c,d,e,f,g,h,a);\n\t} while (j < 16);\n\n\t/* Now for the remaining rounds up to 79: */\n\tdo {\n\t\tROUND512(a,b,c,d,e,f,g,h);\n\t\tROUND512(h,a,b,c,d,e,f,g);\n\t\tROUND512(g,h,a,b,c,d,e,f);\n\t\tROUND512(f,g,h,a,b,c,d,e);\n\t\tROUND512(e,f,g,h,a,b,c,d);\n\t\tROUND512(d,e,f,g,h,a,b,c);\n\t\tROUND512(c,d,e,f,g,h,a,b);\n\t\tROUND512(b,c,d,e,f,g,h,a);\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512",
          "args": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND512_0_TO_15",
          "args": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])\n{\n\tu_int64_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int64_t\tT1, W512[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\t/* Rounds 0 to 15 (unrolled): */\n\t\tROUND512_0_TO_15(a,b,c,d,e,f,g,h);\n\t\tROUND512_0_TO_15(h,a,b,c,d,e,f,g);\n\t\tROUND512_0_TO_15(g,h,a,b,c,d,e,f);\n\t\tROUND512_0_TO_15(f,g,h,a,b,c,d,e);\n\t\tROUND512_0_TO_15(e,f,g,h,a,b,c,d);\n\t\tROUND512_0_TO_15(d,e,f,g,h,a,b,c);\n\t\tROUND512_0_TO_15(c,d,e,f,g,h,a,b);\n\t\tROUND512_0_TO_15(b,c,d,e,f,g,h,a);\n\t} while (j < 16);\n\n\t/* Now for the remaining rounds up to 79: */\n\tdo {\n\t\tROUND512(a,b,c,d,e,f,g,h);\n\t\tROUND512(h,a,b,c,d,e,f,g);\n\t\tROUND512(g,h,a,b,c,d,e,f);\n\t\tROUND512(f,g,h,a,b,c,d,e);\n\t\tROUND512(e,f,g,h,a,b,c,d);\n\t\tROUND512(d,e,f,g,h,a,b,c);\n\t\tROUND512(c,d,e,f,g,h,a,b);\n\t\tROUND512(b,c,d,e,f,g,h,a);\n\t} while (j < 80);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = 0;\n}"
  },
  {
    "function_name": "SHA512_Init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "566-575",
    "snippet": "void\nSHA512_Init(SHA512_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha512_initial_hash_value,\n\t    sizeof(sha512_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount[0] = context->bitcount[1] =  0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "sizeof(context->buffer)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->state",
            "sha512_initial_hash_value",
            "sizeof(sha512_initial_hash_value)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA512_Init(SHA512_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha512_initial_hash_value,\n\t    sizeof(sha512_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount[0] = context->bitcount[1] =  0;\n}"
  },
  {
    "function_name": "SHA256_Final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "544-562",
    "snippet": "void\nSHA256_Final(u_int8_t digest[SHA256_DIGEST_LENGTH], SHA256_CTX *context)\n{\n\tSHA256_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tBE_32_TO_8(digest + i * 4, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA256_DIGEST_LENGTH);\n#endif\n\t\tmemset(context, 0, sizeof(*context));\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context",
            "0",
            "sizeof(*context)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "context->state",
            "SHA256_DIGEST_LENGTH"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_32_TO_8",
          "args": [
            "digest + i * 4",
            "context->state[i]"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA256_Pad",
          "args": [
            "context"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "SHA256_Pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "501-542",
          "snippet": "void\nSHA256_Pad(SHA256_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t    SHA256_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA256_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t\t    SHA256_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\n\t\t\t/* Prepare for last transform: */\n\t\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\t\t}\n\t} else {\n\t\t/* Set-up for the last transform: */\n\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA256_SHORT_BLOCK_LENGTH],\n\t    context->bitcount);\n\n\t/* Final transform: */\n\tSHA256_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SHA256_SHORT_BLOCK_LENGTH\t(SHA256_BLOCK_LENGTH - 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\n#define SHA256_SHORT_BLOCK_LENGTH\t(SHA256_BLOCK_LENGTH - 8)\n\nvoid\nSHA256_Pad(SHA256_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t    SHA256_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA256_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t\t    SHA256_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\n\t\t\t/* Prepare for last transform: */\n\t\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\t\t}\n\t} else {\n\t\t/* Set-up for the last transform: */\n\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA256_SHORT_BLOCK_LENGTH],\n\t    context->bitcount);\n\n\t/* Final transform: */\n\tSHA256_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Final(u_int8_t digest[SHA256_DIGEST_LENGTH], SHA256_CTX *context)\n{\n\tSHA256_Pad(context);\n\n\t/* If no digest buffer is passed, we don't bother doing this: */\n\tif (digest != NULL) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tint\ti;\n\n\t\t/* Convert TO host byte order */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tBE_32_TO_8(digest + i * 4, context->state[i]);\n#else\n\t\tmemcpy(digest, context->state, SHA256_DIGEST_LENGTH);\n#endif\n\t\tmemset(context, 0, sizeof(*context));\n\t}\n}"
  },
  {
    "function_name": "SHA256_Pad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "501-542",
    "snippet": "void\nSHA256_Pad(SHA256_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t    SHA256_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA256_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t\t    SHA256_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\n\t\t\t/* Prepare for last transform: */\n\t\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\t\t}\n\t} else {\n\t\t/* Set-up for the last transform: */\n\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA256_SHORT_BLOCK_LENGTH],\n\t    context->bitcount);\n\n\t/* Final transform: */\n\tSHA256_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SHA256_SHORT_BLOCK_LENGTH\t(SHA256_BLOCK_LENGTH - 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHA256_Transform",
          "args": [
            "context->state",
            "context->buffer"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "SHA256_Transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "380-451",
          "snippet": "void\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BE_64_TO_8",
          "args": [
            "&context->buffer[SHA256_SHORT_BLOCK_LENGTH]",
            "context->bitcount"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "SHA256_SHORT_BLOCK_LENGTH"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "SHA256_SHORT_BLOCK_LENGTH"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->buffer[usedspace]",
            "0",
            "SHA256_BLOCK_LENGTH - usedspace"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->buffer[usedspace]",
            "0",
            "SHA256_SHORT_BLOCK_LENGTH - usedspace"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\n#define SHA256_SHORT_BLOCK_LENGTH\t(SHA256_BLOCK_LENGTH - 8)\n\nvoid\nSHA256_Pad(SHA256_CTX *context)\n{\n\tunsigned int\tusedspace;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Begin padding with a 1 bit: */\n\t\tcontext->buffer[usedspace++] = 0x80;\n\n\t\tif (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {\n\t\t\t/* Set-up for the last transform: */\n\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t    SHA256_SHORT_BLOCK_LENGTH - usedspace);\n\t\t} else {\n\t\t\tif (usedspace < SHA256_BLOCK_LENGTH) {\n\t\t\t\tmemset(&context->buffer[usedspace], 0,\n\t\t\t\t    SHA256_BLOCK_LENGTH - usedspace);\n\t\t\t}\n\t\t\t/* Do second-to-last transform: */\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\n\t\t\t/* Prepare for last transform: */\n\t\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\t\t}\n\t} else {\n\t\t/* Set-up for the last transform: */\n\t\tmemset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);\n\n\t\t/* Begin padding with a 1 bit: */\n\t\t*context->buffer = 0x80;\n\t}\n\t/* Store the length of input data (in bits) in big endian format: */\n\tBE_64_TO_8(&context->buffer[SHA256_SHORT_BLOCK_LENGTH],\n\t    context->bitcount);\n\n\t/* Final transform: */\n\tSHA256_Transform(context->state, context->buffer);\n\n\t/* Clean up: */\n\tusedspace = 0;\n}"
  },
  {
    "function_name": "SHA256_Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "455-499",
    "snippet": "void\nSHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA256_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tcontext->bitcount += freespace << 3;\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tcontext->bitcount += len << 3;\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA256_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA256_Transform(context->state, data);\n\t\tcontext->bitcount += SHA256_BLOCK_LENGTH << 3;\n\t\tlen -= SHA256_BLOCK_LENGTH;\n\t\tdata += SHA256_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tcontext->bitcount += len << 3;\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->buffer",
            "data",
            "len"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA256_Transform",
          "args": [
            "context->state",
            "data"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "SHA256_Transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
          "lines": "380-451",
          "snippet": "void\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
          "includes": [
            "#include <string.h>",
            "# include <openssl/opensslv.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->buffer[usedspace]",
            "data",
            "len"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->buffer[usedspace]",
            "data",
            "freespace"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t\tfreespace, usedspace;\n\n\t/* Calling with no data is valid (we do nothing) */\n\tif (len == 0)\n\t\treturn;\n\n\tusedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;\n\tif (usedspace > 0) {\n\t\t/* Calculate how much free space is available in the buffer */\n\t\tfreespace = SHA256_BLOCK_LENGTH - usedspace;\n\n\t\tif (len >= freespace) {\n\t\t\t/* Fill the buffer completely and process it */\n\t\t\tmemcpy(&context->buffer[usedspace], data, freespace);\n\t\t\tcontext->bitcount += freespace << 3;\n\t\t\tlen -= freespace;\n\t\t\tdata += freespace;\n\t\t\tSHA256_Transform(context->state, context->buffer);\n\t\t} else {\n\t\t\t/* The buffer is not yet full */\n\t\t\tmemcpy(&context->buffer[usedspace], data, len);\n\t\t\tcontext->bitcount += len << 3;\n\t\t\t/* Clean up: */\n\t\t\tusedspace = freespace = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (len >= SHA256_BLOCK_LENGTH) {\n\t\t/* Process as many complete blocks as we can */\n\t\tSHA256_Transform(context->state, data);\n\t\tcontext->bitcount += SHA256_BLOCK_LENGTH << 3;\n\t\tlen -= SHA256_BLOCK_LENGTH;\n\t\tdata += SHA256_BLOCK_LENGTH;\n\t}\n\tif (len > 0) {\n\t\t/* There's left-overs, so save 'em */\n\t\tmemcpy(context->buffer, data, len);\n\t\tcontext->bitcount += len << 3;\n\t}\n\t/* Clean up: */\n\tusedspace = freespace = 0;\n}"
  },
  {
    "function_name": "SHA256_Transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "380-451",
    "snippet": "void\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Maj",
          "args": [
            "a",
            "b",
            "c"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma0_256",
          "args": [
            "a"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ch",
          "args": [
            "e",
            "f",
            "g"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma1_256",
          "args": [
            "e"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigma1_256",
          "args": [
            "s1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigma0_256",
          "args": [
            "s0"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Maj",
          "args": [
            "a",
            "b",
            "c"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma0_256",
          "args": [
            "a"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ch",
          "args": [
            "e",
            "f",
            "g"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sigma1_256",
          "args": [
            "e"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BE_8_TO_32",
          "args": [
            "W256[j]",
            "data"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, T2, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\tBE_8_TO_32(W256[j], data);\n\t\tdata += 4;\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 16);\n\n\tdo {\n\t\t/* Part of the message block expansion: */\n\t\ts0 = W256[(j+1)&0x0f];\n\t\ts0 = sigma0_256(s0);\n\t\ts1 = W256[(j+14)&0x0f];\t\n\t\ts1 = sigma1_256(s1);\n\n\t\t/* Apply the SHA-256 compression function to update a..h */\n\t\tT1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + \n\t\t     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);\n\t\tT2 = Sigma0_256(a) + Maj(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + T1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = T1 + T2;\n\n\t\tj++;\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = T2 = 0;\n}"
  },
  {
    "function_name": "SHA256_Transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "322-376",
    "snippet": "void\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\t/* Rounds 0 to 15 (unrolled): */\n\t\tROUND256_0_TO_15(a,b,c,d,e,f,g,h);\n\t\tROUND256_0_TO_15(h,a,b,c,d,e,f,g);\n\t\tROUND256_0_TO_15(g,h,a,b,c,d,e,f);\n\t\tROUND256_0_TO_15(f,g,h,a,b,c,d,e);\n\t\tROUND256_0_TO_15(e,f,g,h,a,b,c,d);\n\t\tROUND256_0_TO_15(d,e,f,g,h,a,b,c);\n\t\tROUND256_0_TO_15(c,d,e,f,g,h,a,b);\n\t\tROUND256_0_TO_15(b,c,d,e,f,g,h,a);\n\t} while (j < 16);\n\n\t/* Now for the remaining rounds up to 63: */\n\tdo {\n\t\tROUND256(a,b,c,d,e,f,g,h);\n\t\tROUND256(h,a,b,c,d,e,f,g);\n\t\tROUND256(g,h,a,b,c,d,e,f);\n\t\tROUND256(f,g,h,a,b,c,d,e);\n\t\tROUND256(e,f,g,h,a,b,c,d);\n\t\tROUND256(d,e,f,g,h,a,b,c);\n\t\tROUND256(c,d,e,f,g,h,a,b);\n\t\tROUND256(b,c,d,e,f,g,h,a);\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256",
          "args": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "d",
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "e",
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "f",
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "g",
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "h",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND256_0_TO_15",
          "args": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])\n{\n\tu_int32_t\ta, b, c, d, e, f, g, h, s0, s1;\n\tu_int32_t\tT1, W256[16];\n\tint\t\tj;\n\n\t/* Initialize registers with the prev. intermediate value */\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\tf = state[5];\n\tg = state[6];\n\th = state[7];\n\n\tj = 0;\n\tdo {\n\t\t/* Rounds 0 to 15 (unrolled): */\n\t\tROUND256_0_TO_15(a,b,c,d,e,f,g,h);\n\t\tROUND256_0_TO_15(h,a,b,c,d,e,f,g);\n\t\tROUND256_0_TO_15(g,h,a,b,c,d,e,f);\n\t\tROUND256_0_TO_15(f,g,h,a,b,c,d,e);\n\t\tROUND256_0_TO_15(e,f,g,h,a,b,c,d);\n\t\tROUND256_0_TO_15(d,e,f,g,h,a,b,c);\n\t\tROUND256_0_TO_15(c,d,e,f,g,h,a,b);\n\t\tROUND256_0_TO_15(b,c,d,e,f,g,h,a);\n\t} while (j < 16);\n\n\t/* Now for the remaining rounds up to 63: */\n\tdo {\n\t\tROUND256(a,b,c,d,e,f,g,h);\n\t\tROUND256(h,a,b,c,d,e,f,g);\n\t\tROUND256(g,h,a,b,c,d,e,f);\n\t\tROUND256(f,g,h,a,b,c,d,e);\n\t\tROUND256(e,f,g,h,a,b,c,d);\n\t\tROUND256(d,e,f,g,h,a,b,c);\n\t\tROUND256(c,d,e,f,g,h,a,b);\n\t\tROUND256(b,c,d,e,f,g,h,a);\n\t} while (j < 64);\n\n\t/* Compute the current intermediate hash value */\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n\t/* Clean up */\n\ta = b = c = d = e = f = g = h = T1 = 0;\n}"
  },
  {
    "function_name": "SHA256_Init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sha2.c",
    "lines": "286-295",
    "snippet": "void\nSHA256_Init(SHA256_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha256_initial_hash_value,\n\t    sizeof(sha256_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount = 0;\n}",
    "includes": [
      "#include <string.h>",
      "# include <openssl/opensslv.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "context->buffer",
            "0",
            "sizeof(context->buffer)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->state",
            "sha256_initial_hash_value",
            "sizeof(sha256_initial_hash_value)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n# include <openssl/opensslv.h>\n#include \"includes.h\"\n\nvoid\nSHA256_Init(SHA256_CTX *context)\n{\n\tif (context == NULL)\n\t\treturn;\n\tmemcpy(context->state, sha256_initial_hash_value,\n\t    sizeof(sha256_initial_hash_value));\n\tmemset(context->buffer, 0, sizeof(context->buffer));\n\tcontext->bitcount = 0;\n}"
  }
]