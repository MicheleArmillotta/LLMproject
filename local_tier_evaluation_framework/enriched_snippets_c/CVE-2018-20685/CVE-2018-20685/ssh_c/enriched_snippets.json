[
  {
    "function_name": "main_sigchld_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "2134-2145",
    "snippet": "static void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid < 0 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void main_sigchld_handler(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "WNOHANG"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void main_sigchld_handler(int);\n\nstatic void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid < 0 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "load_public_identity_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1979-2132",
    "snippet": "static void\nload_public_identity_files(struct passwd *pw)\n{\n\tchar *filename, *cp;\n\tstruct sshkey *public;\n\tint i;\n\tu_int n_ids, n_certs;\n\tchar *identity_files[SSH_MAX_IDENTITY_FILES];\n\tstruct sshkey *identity_keys[SSH_MAX_IDENTITY_FILES];\n\tint identity_file_userprovided[SSH_MAX_IDENTITY_FILES];\n\tchar *certificate_files[SSH_MAX_CERTIFICATE_FILES];\n\tstruct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];\n\tint certificate_file_userprovided[SSH_MAX_CERTIFICATE_FILES];\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys;\n\tint nkeys;\n#endif /* PKCS11 */\n\n\tn_ids = n_certs = 0;\n\tmemset(identity_files, 0, sizeof(identity_files));\n\tmemset(identity_keys, 0, sizeof(identity_keys));\n\tmemset(identity_file_userprovided, 0,\n\t    sizeof(identity_file_userprovided));\n\tmemset(certificate_files, 0, sizeof(certificate_files));\n\tmemset(certificates, 0, sizeof(certificates));\n\tmemset(certificate_file_userprovided, 0,\n\t    sizeof(certificate_file_userprovided));\n\n#ifdef ENABLE_PKCS11\n\tif (options.pkcs11_provider != NULL &&\n\t    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&\n\t    (pkcs11_init(!options.batch_mode) == 0) &&\n\t    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,\n\t    &keys)) > 0) {\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\tsshkey_free(keys[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidentity_keys[n_ids] = keys[i];\n\t\t\tidentity_files[n_ids] =\n\t\t\t    xstrdup(options.pkcs11_provider); /* XXX */\n\t\t\tn_ids++;\n\t\t}\n\t\tfree(keys);\n\t}\n#endif /* ENABLE_PKCS11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES ||\n\t\t    strcasecmp(options.identity_files[i], \"none\") == 0) {\n\t\t\tfree(options.identity_files[i]);\n\t\t\toptions.identity_files[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcp = tilde_expand_filename(options.identity_files[i], getuid());\n\t\tfilename = percent_expand(cp, \"d\", pw->pw_dir,\n\t\t    \"u\", pw->pw_name, \"l\", thishost, \"h\", host,\n\t\t    \"r\", options.user, (char *)NULL);\n\t\tfree(cp);\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.identity_files[i]);\n\t\tidentity_files[n_ids] = filename;\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tif (++n_ids >= SSH_MAX_IDENTITY_FILES)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no certificates have been explicitly listed then try\n\t\t * to add the default certificate variant too.\n\t\t */\n\t\tif (options.num_certificate_files != 0)\n\t\t\tcontinue;\n\t\txasprintf(&cp, \"%s-cert\", filename);\n\t\tcheck_load(sshkey_load_public(cp, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", cp,\n\t\t    public ? public->type : -1);\n\t\tif (public == NULL) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, cp, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* NB. leave filename pointing to private key */\n\t\tidentity_files[n_ids] = xstrdup(filename);\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tn_ids++;\n\t}\n\n\tif (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"%s: too many certificates\", __func__);\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tcp = tilde_expand_filename(options.certificate_files[i],\n\t\t    getuid());\n\t\tfilename = percent_expand(cp,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"certificate\");\n\t\tdebug(\"certificate file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t\tif (public == NULL) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, filename, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tcertificate_files[n_certs] = filename;\n\t\tcertificates[n_certs] = public;\n\t\tcertificate_file_userprovided[n_certs] =\n\t\t    options.certificate_file_userprovided[i];\n\t\t++n_certs;\n\t}\n\n\toptions.num_identity_files = n_ids;\n\tmemcpy(options.identity_files, identity_files, sizeof(identity_files));\n\tmemcpy(options.identity_keys, identity_keys, sizeof(identity_keys));\n\tmemcpy(options.identity_file_userprovided,\n\t    identity_file_userprovided, sizeof(identity_file_userprovided));\n\n\toptions.num_certificate_files = n_certs;\n\tmemcpy(options.certificate_files,\n\t    certificate_files, sizeof(certificate_files));\n\tmemcpy(options.certificates, certificates, sizeof(certificates));\n\tmemcpy(options.certificate_file_userprovided,\n\t    certificate_file_userprovided,\n\t    sizeof(certificate_file_userprovided));\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;",
      "char *host;",
      "static char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];",
      "static char uidstr[32], *host_arg, *conn_hash_hex;",
      "static int ssh_session2(struct ssh *, struct passwd *);",
      "static void load_public_identity_files(struct passwd *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.certificate_file_userprovided",
            "certificate_file_userprovided",
            "sizeof(certificate_file_userprovided)"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.certificates",
            "certificates",
            "sizeof(certificates)"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.certificate_files",
            "certificate_files",
            "sizeof(certificate_files)"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.identity_file_userprovided",
            "identity_file_userprovided",
            "sizeof(identity_file_userprovided)"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.identity_keys",
            "identity_keys",
            "sizeof(identity_keys)"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options.identity_files",
            "identity_files",
            "sizeof(identity_files)"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "filename"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: key %s type %s is not a certificate\"",
            "__func__",
            "filename",
            "sshkey_type(public)"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "public"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "public"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_load",
          "args": [
            "sshkey_load_public(filename, &public, NULL)",
            "filename",
            "\"certificate\""
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "check_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "505-523",
          "snippet": "static void\ncheck_load(int r, const char *path, const char *message)\n{\n\tswitch (r) {\n\tcase 0:\n\t\tbreak;\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\tfatal(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t/* Ignore missing files */\n\t\tif (errno == ENOENT)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\terror(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncheck_load(int r, const char *path, const char *message)\n{\n\tswitch (r) {\n\tcase 0:\n\t\tbreak;\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\tfatal(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t/* Ignore missing files */\n\t\tif (errno == ENOENT)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\terror(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "filename",
            "&public",
            "NULL"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "cp",
            "\"d\"",
            "pw->pw_dir",
            "\"h\"",
            "host",
            "\"i\"",
            "uidstr",
            "\"l\"",
            "thishost",
            "\"r\"",
            "options.user",
            "\"u\"",
            "pw->pw_name",
            "(char *)NULL"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "options.certificate_files[i]",
            "getuid()"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: too many certificates\"",
            "__func__"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "filename"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&cp",
            "\"%s-cert\"",
            "filename"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.identity_files[i]",
            "\"none\""
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pkcs11_add_provider",
          "args": [
            "options.pkcs11_provider",
            "NULL",
            "&keys"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_add_provider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "203-246",
          "snippet": "int\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_init",
          "args": [
            "!options.batch_mode"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "102-106",
          "snippet": "int\npkcs11_init(int interactive)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_init(int interactive)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "certificate_file_userprovided",
            "0",
            "sizeof(certificate_file_userprovided)"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "certificates",
            "0",
            "sizeof(certificates)"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "certificate_files",
            "0",
            "sizeof(certificate_files)"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "identity_file_userprovided",
            "0",
            "sizeof(identity_file_userprovided)"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "identity_keys",
            "0",
            "sizeof(identity_keys)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "identity_files",
            "0",
            "sizeof(identity_files)"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\nstatic char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\nstatic char uidstr[32], *host_arg, *conn_hash_hex;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic void\nload_public_identity_files(struct passwd *pw)\n{\n\tchar *filename, *cp;\n\tstruct sshkey *public;\n\tint i;\n\tu_int n_ids, n_certs;\n\tchar *identity_files[SSH_MAX_IDENTITY_FILES];\n\tstruct sshkey *identity_keys[SSH_MAX_IDENTITY_FILES];\n\tint identity_file_userprovided[SSH_MAX_IDENTITY_FILES];\n\tchar *certificate_files[SSH_MAX_CERTIFICATE_FILES];\n\tstruct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];\n\tint certificate_file_userprovided[SSH_MAX_CERTIFICATE_FILES];\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys;\n\tint nkeys;\n#endif /* PKCS11 */\n\n\tn_ids = n_certs = 0;\n\tmemset(identity_files, 0, sizeof(identity_files));\n\tmemset(identity_keys, 0, sizeof(identity_keys));\n\tmemset(identity_file_userprovided, 0,\n\t    sizeof(identity_file_userprovided));\n\tmemset(certificate_files, 0, sizeof(certificate_files));\n\tmemset(certificates, 0, sizeof(certificates));\n\tmemset(certificate_file_userprovided, 0,\n\t    sizeof(certificate_file_userprovided));\n\n#ifdef ENABLE_PKCS11\n\tif (options.pkcs11_provider != NULL &&\n\t    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&\n\t    (pkcs11_init(!options.batch_mode) == 0) &&\n\t    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,\n\t    &keys)) > 0) {\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\tsshkey_free(keys[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidentity_keys[n_ids] = keys[i];\n\t\t\tidentity_files[n_ids] =\n\t\t\t    xstrdup(options.pkcs11_provider); /* XXX */\n\t\t\tn_ids++;\n\t\t}\n\t\tfree(keys);\n\t}\n#endif /* ENABLE_PKCS11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES ||\n\t\t    strcasecmp(options.identity_files[i], \"none\") == 0) {\n\t\t\tfree(options.identity_files[i]);\n\t\t\toptions.identity_files[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcp = tilde_expand_filename(options.identity_files[i], getuid());\n\t\tfilename = percent_expand(cp, \"d\", pw->pw_dir,\n\t\t    \"u\", pw->pw_name, \"l\", thishost, \"h\", host,\n\t\t    \"r\", options.user, (char *)NULL);\n\t\tfree(cp);\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.identity_files[i]);\n\t\tidentity_files[n_ids] = filename;\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tif (++n_ids >= SSH_MAX_IDENTITY_FILES)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no certificates have been explicitly listed then try\n\t\t * to add the default certificate variant too.\n\t\t */\n\t\tif (options.num_certificate_files != 0)\n\t\t\tcontinue;\n\t\txasprintf(&cp, \"%s-cert\", filename);\n\t\tcheck_load(sshkey_load_public(cp, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", cp,\n\t\t    public ? public->type : -1);\n\t\tif (public == NULL) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, cp, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* NB. leave filename pointing to private key */\n\t\tidentity_files[n_ids] = xstrdup(filename);\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tn_ids++;\n\t}\n\n\tif (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"%s: too many certificates\", __func__);\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tcp = tilde_expand_filename(options.certificate_files[i],\n\t\t    getuid());\n\t\tfilename = percent_expand(cp,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"certificate\");\n\t\tdebug(\"certificate file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t\tif (public == NULL) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, filename, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tcertificate_files[n_certs] = filename;\n\t\tcertificates[n_certs] = public;\n\t\tcertificate_file_userprovided[n_certs] =\n\t\t    options.certificate_file_userprovided[i];\n\t\t++n_certs;\n\t}\n\n\toptions.num_identity_files = n_ids;\n\tmemcpy(options.identity_files, identity_files, sizeof(identity_files));\n\tmemcpy(options.identity_keys, identity_keys, sizeof(identity_keys));\n\tmemcpy(options.identity_file_userprovided,\n\t    identity_file_userprovided, sizeof(identity_file_userprovided));\n\n\toptions.num_certificate_files = n_certs;\n\tmemcpy(options.certificate_files,\n\t    certificate_files, sizeof(certificate_files));\n\tmemcpy(options.certificates, certificates, sizeof(certificates));\n\tmemcpy(options.certificate_file_userprovided,\n\t    certificate_file_userprovided,\n\t    sizeof(certificate_file_userprovided));\n}"
  },
  {
    "function_name": "ssh_session2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1858-1976",
    "snippet": "static int\nssh_session2(struct ssh *ssh, struct passwd *pw)\n{\n\tint devnull, id = -1;\n\tchar *cp, *tun_fwd_ifname = NULL;\n\n\t/* XXX should be pre-session */\n\tif (!options.control_persist)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tssh_init_forwarding(ssh, &tun_fwd_ifname);\n\n\tif (options.local_command != NULL) {\n\t\tdebug3(\"expanding LocalCommand: %s\", options.local_command);\n\t\tcp = options.local_command;\n\t\toptions.local_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"T\", tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded LocalCommand: %s\", options.local_command);\n\t\tfree(cp);\n\t}\n\n\t/* Start listening for multiplex clients */\n\tif (!packet_get_mux())\n\t\tmuxserver_listen(ssh);\n\n\t/*\n\t * If we are in control persist mode and have a working mux listen\n\t * socket, then prepare to background ourselves and have a foreground\n\t * client attach as a control slave.\n\t * NB. we must save copies of the flags that we override for\n\t * the backgrounding, since we defer attachment of the slave until\n\t * after the connection is fully established (in particular,\n\t * async rfwd replies have been received for ExitOnForwardFailure).\n\t */\n\tif (options.control_persist && muxserver_sock != -1) {\n\t\tostdin_null_flag = stdin_null_flag;\n\t\tono_shell_flag = no_shell_flag;\n\t\torequest_tty = options.request_tty;\n\t\totty_flag = tty_flag;\n\t\tstdin_null_flag = 1;\n\t\tno_shell_flag = 1;\n\t\ttty_flag = 0;\n\t\tif (!fork_after_authentication_flag)\n\t\t\tneed_controlpersist_detach = 1;\n\t\tfork_after_authentication_flag = 1;\n\t}\n\t/*\n\t * ControlPersist mux listen socket setup failed, attempt the\n\t * stdio forward setup that we skipped earlier.\n\t */\n\tif (options.control_persist && muxserver_sock == -1)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tif (!no_shell_flag)\n\t\tid = ssh_session2_open(ssh);\n\telse {\n\t\tpacket_set_interactive(\n\t\t    options.control_master == SSHCTL_MASTER_NO,\n\t\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\t}\n\n\t/* If we don't expect to open a new session, then disallow it */\n\tif (options.control_master == SSHCTL_MASTER_NO &&\n\t    (datafellows & SSH_NEW_OPENSSH)) {\n\t\tdebug(\"Requesting no-more-sessions@openssh.com\");\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"no-more-sessions@openssh.com\");\n\t\tpacket_put_char(0);\n\t\tpacket_send();\n\t}\n\n\t/* Execute a local command */\n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t/*\n\t * stdout is now owned by the session channel; clobber it here\n\t * so future channel closes are propagated to the local fd.\n\t * NB. this can only happen after LocalCommand has completed,\n\t * as it may want to write to stdout.\n\t */\n\tif (!need_controlpersist_detach) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_WRONLY)) == -1)\n\t\t\terror(\"%s: open %s: %s\", __func__,\n\t\t\t    _PATH_DEVNULL, strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2() stdout failed\", __func__);\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\t/*\n\t * If requested and we are not interested in replies to remote\n\t * forwarding requests, then let ssh continue in the background.\n\t */\n\tif (fork_after_authentication_flag) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\treturn client_loop(ssh, tty_flag, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, id);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tty_flag = 0;",
      "int no_shell_flag = 0;",
      "int stdin_null_flag = 0;",
      "int need_controlpersist_detach = 0;",
      "int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;",
      "int fork_after_authentication_flag = 0;",
      "Options options;",
      "char *host;",
      "static char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];",
      "static char uidstr[32], *host_arg, *conn_hash_hex;",
      "struct sshbuf *command;",
      "extern int muxserver_sock;",
      "static int ssh_session2(struct ssh *, struct passwd *);",
      "static void load_public_identity_files(struct passwd *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "client_loop",
          "args": [
            "ssh",
            "tty_flag",
            "tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE",
            "id"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "client_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1235-1480",
          "snippet": "int\nclient_loop(struct ssh *ssh, int have_pty, int escape_char_arg,\n    int ssh2_chan_id)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tdouble start_time, total_time;\n\tint r, max_fd = 0, max_fd2 = 0, len;\n\tu_int64_t ibytes, obytes;\n\tu_int nalloc = 0;\n\tchar buf[100];\n\n\tdebug(\"Entering interactive session.\");\n\n\tif (options.control_master &&\n\t    !option_clear_or_none(options.control_path)) {\n\t\tdebug(\"pledge: id\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns recvfd proc exec id tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.forward_x11 || options.permit_local_command) {\n\t\tdebug(\"pledge: exec\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc exec tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.update_hostkeys) {\n\t\tdebug(\"pledge: filesystem full\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (!option_clear_or_none(options.proxy_command) ||\n\t    fork_after_authentication_flag) {\n\t\tdebug(\"pledge: proc\");\n\t\tif (pledge(\"stdio cpath unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else {\n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\t}\n\n\tstart_time = monotime_double();\n\n\t/* Initialize variables. */\n\tlast_was_cr = 1;\n\texit_status = -1;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\n\tquit_pending = 0;\n\n\t/* Initialize buffer. */\n\tif ((stderr_buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tclient_init_dispatch();\n\n\t/*\n\t * Set signal handlers, (e.g. to restore non-blocking mode)\n\t * but don't overwrite SIG_IGN, matches behaviour from rsh(1)\n\t */\n\tif (signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGHUP, signal_handler);\n\tif (signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGINT, signal_handler);\n\tif (signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGQUIT, signal_handler);\n\tif (signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsession_ident = ssh2_chan_id;\n\tif (session_ident != -1) {\n\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\tchannel_register_filter(ssh, session_ident,\n\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t    client_filter_cleanup,\n\t\t\t    client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg));\n\t\t}\n\t\tchannel_register_cleanup(ssh, session_ident,\n\t\t    client_channel_closed, 0);\n\t}\n\n\t/* Main loop of the client for the interactive session mode. */\n\twhile (!quit_pending) {\n\n\t\t/* Process buffered packets sent by the server. */\n\t\tclient_process_buffered_input_packets();\n\n\t\tif (session_closed && !channel_still_open(ssh))\n\t\t\tbreak;\n\n\t\tif (ssh_packet_is_rekeying(ssh)) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else if (need_rekeying) {\n\t\t\t/* manual rekey request */\n\t\t\tdebug(\"need rekeying\");\n\t\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\t\tfatal(\"%s: kex_start_rekex: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\tneed_rekeying = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make packets from buffered channel data, and\n\t\t\t * enqueue them for sending to the server.\n\t\t\t */\n\t\t\tif (packet_not_very_much_data_to_write())\n\t\t\t\tchannel_output_poll(ssh);\n\n\t\t\t/*\n\t\t\t * Check if the window size has changed, and buffer a\n\t\t\t * message about it to the server if so.\n\t\t\t */\n\t\t\tclient_check_window_change(ssh);\n\n\t\t\tif (quit_pending)\n\t\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Wait until we have something to do (something becomes\n\t\t * available on one of the descriptors).\n\t\t */\n\t\tmax_fd2 = max_fd;\n\t\tclient_wait_until_can_do_something(ssh, &readset, &writeset,\n\t\t    &max_fd2, &nalloc, ssh_packet_is_rekeying(ssh));\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/* Do channel operations unless rekeying in progress. */\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\n\t\t/* Buffer input from the connection.  */\n\t\tclient_process_net_input(readset);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Send as much buffered packet data as possible to the\n\t\t * sender.\n\t\t */\n\t\tif (FD_ISSET(connection_out, writeset))\n\t\t\tpacket_write_poll();\n\n\t\t/*\n\t\t * If we are a backgrounded control master, and the\n\t\t * timeout has expired without any active client\n\t\t * connections, then quit.\n\t\t */\n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (monotime() >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(readset);\n\tfree(writeset);\n\n\t/* Terminate the session. */\n\n\t/* Stop watching for window change. */\n\tsignal(SIGWINCH, SIG_DFL);\n\n\tpacket_start(SSH2_MSG_DISCONNECT);\n\tpacket_put_int(SSH2_DISCONNECT_BY_APPLICATION);\n\tpacket_put_cstring(\"disconnected by user\");\n\tpacket_put_cstring(\"\"); /* language tag */\n\tpacket_send();\n\tpacket_write_wait();\n\n\tchannel_free_all(ssh);\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/* restore blocking io */\n\tif (!isatty(fileno(stdin)))\n\t\tunset_nonblock(fileno(stdin));\n\tif (!isatty(fileno(stdout)))\n\t\tunset_nonblock(fileno(stdout));\n\tif (!isatty(fileno(stderr)))\n\t\tunset_nonblock(fileno(stderr));\n\n\t/*\n\t * If there was no shell or command requested, there will be no remote\n\t * exit status to be returned.  In that case, clear error code if the\n\t * connection was deliberately terminated at this end.\n\t */\n\tif (no_shell_flag && received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal) {\n\t\tverbose(\"Killed by signal %d.\", (int) received_signal);\n\t\tcleanup_exit(0);\n\t}\n\n\t/*\n\t * In interactive mode (with pseudo tty) display a message indicating\n\t * that the connection has been closed.\n\t */\n\tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"Connection to %.64s closed.\\r\\n\", host)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Output any buffered data for stderr. */\n\tif (sshbuf_len(stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    (u_char *)sshbuf_ptr(stderr_buffer),\n\t\t    sshbuf_len(stderr_buffer));\n\t\tif (len < 0 || (u_int)len != sshbuf_len(stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse if ((r = sshbuf_consume(stderr_buffer, len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Clear and free any buffers. */\n\texplicit_bzero(buf, sizeof(buf));\n\tsshbuf_free(stderr_buffer);\n\n\t/* Report bytes transferred, and transfer rates. */\n\ttotal_time = monotime_double() - start_time;\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t/* Return the exit status of the program. */\n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int no_shell_flag;",
            "extern int fork_after_authentication_flag;",
            "extern char *host;",
            "static volatile sig_atomic_t received_signal = 0;",
            "static time_t control_persist_exit_time = 0;",
            "volatile sig_atomic_t quit_pending;",
            "static int last_was_cr;",
            "static int exit_status;",
            "static struct sshbuf *stderr_buffer;",
            "static int connection_in;",
            "static int connection_out;",
            "static int need_rekeying;",
            "static int session_closed;",
            "static void client_init_dispatch(void);",
            "int\tsession_ident = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int no_shell_flag;\nextern int fork_after_authentication_flag;\nextern char *host;\nstatic volatile sig_atomic_t received_signal = 0;\nstatic time_t control_persist_exit_time = 0;\nvolatile sig_atomic_t quit_pending;\nstatic int last_was_cr;\nstatic int exit_status;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\nstatic int connection_out;\nstatic int need_rekeying;\nstatic int session_closed;\nstatic void client_init_dispatch(void);\nint\tsession_ident = -1;\n\nint\nclient_loop(struct ssh *ssh, int have_pty, int escape_char_arg,\n    int ssh2_chan_id)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tdouble start_time, total_time;\n\tint r, max_fd = 0, max_fd2 = 0, len;\n\tu_int64_t ibytes, obytes;\n\tu_int nalloc = 0;\n\tchar buf[100];\n\n\tdebug(\"Entering interactive session.\");\n\n\tif (options.control_master &&\n\t    !option_clear_or_none(options.control_path)) {\n\t\tdebug(\"pledge: id\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns recvfd proc exec id tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.forward_x11 || options.permit_local_command) {\n\t\tdebug(\"pledge: exec\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc exec tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.update_hostkeys) {\n\t\tdebug(\"pledge: filesystem full\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (!option_clear_or_none(options.proxy_command) ||\n\t    fork_after_authentication_flag) {\n\t\tdebug(\"pledge: proc\");\n\t\tif (pledge(\"stdio cpath unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else {\n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\t}\n\n\tstart_time = monotime_double();\n\n\t/* Initialize variables. */\n\tlast_was_cr = 1;\n\texit_status = -1;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\n\tquit_pending = 0;\n\n\t/* Initialize buffer. */\n\tif ((stderr_buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tclient_init_dispatch();\n\n\t/*\n\t * Set signal handlers, (e.g. to restore non-blocking mode)\n\t * but don't overwrite SIG_IGN, matches behaviour from rsh(1)\n\t */\n\tif (signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGHUP, signal_handler);\n\tif (signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGINT, signal_handler);\n\tif (signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGQUIT, signal_handler);\n\tif (signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsession_ident = ssh2_chan_id;\n\tif (session_ident != -1) {\n\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\tchannel_register_filter(ssh, session_ident,\n\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t    client_filter_cleanup,\n\t\t\t    client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg));\n\t\t}\n\t\tchannel_register_cleanup(ssh, session_ident,\n\t\t    client_channel_closed, 0);\n\t}\n\n\t/* Main loop of the client for the interactive session mode. */\n\twhile (!quit_pending) {\n\n\t\t/* Process buffered packets sent by the server. */\n\t\tclient_process_buffered_input_packets();\n\n\t\tif (session_closed && !channel_still_open(ssh))\n\t\t\tbreak;\n\n\t\tif (ssh_packet_is_rekeying(ssh)) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else if (need_rekeying) {\n\t\t\t/* manual rekey request */\n\t\t\tdebug(\"need rekeying\");\n\t\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\t\tfatal(\"%s: kex_start_rekex: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\tneed_rekeying = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make packets from buffered channel data, and\n\t\t\t * enqueue them for sending to the server.\n\t\t\t */\n\t\t\tif (packet_not_very_much_data_to_write())\n\t\t\t\tchannel_output_poll(ssh);\n\n\t\t\t/*\n\t\t\t * Check if the window size has changed, and buffer a\n\t\t\t * message about it to the server if so.\n\t\t\t */\n\t\t\tclient_check_window_change(ssh);\n\n\t\t\tif (quit_pending)\n\t\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Wait until we have something to do (something becomes\n\t\t * available on one of the descriptors).\n\t\t */\n\t\tmax_fd2 = max_fd;\n\t\tclient_wait_until_can_do_something(ssh, &readset, &writeset,\n\t\t    &max_fd2, &nalloc, ssh_packet_is_rekeying(ssh));\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/* Do channel operations unless rekeying in progress. */\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\n\t\t/* Buffer input from the connection.  */\n\t\tclient_process_net_input(readset);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Send as much buffered packet data as possible to the\n\t\t * sender.\n\t\t */\n\t\tif (FD_ISSET(connection_out, writeset))\n\t\t\tpacket_write_poll();\n\n\t\t/*\n\t\t * If we are a backgrounded control master, and the\n\t\t * timeout has expired without any active client\n\t\t * connections, then quit.\n\t\t */\n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (monotime() >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(readset);\n\tfree(writeset);\n\n\t/* Terminate the session. */\n\n\t/* Stop watching for window change. */\n\tsignal(SIGWINCH, SIG_DFL);\n\n\tpacket_start(SSH2_MSG_DISCONNECT);\n\tpacket_put_int(SSH2_DISCONNECT_BY_APPLICATION);\n\tpacket_put_cstring(\"disconnected by user\");\n\tpacket_put_cstring(\"\"); /* language tag */\n\tpacket_send();\n\tpacket_write_wait();\n\n\tchannel_free_all(ssh);\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/* restore blocking io */\n\tif (!isatty(fileno(stdin)))\n\t\tunset_nonblock(fileno(stdin));\n\tif (!isatty(fileno(stdout)))\n\t\tunset_nonblock(fileno(stdout));\n\tif (!isatty(fileno(stderr)))\n\t\tunset_nonblock(fileno(stderr));\n\n\t/*\n\t * If there was no shell or command requested, there will be no remote\n\t * exit status to be returned.  In that case, clear error code if the\n\t * connection was deliberately terminated at this end.\n\t */\n\tif (no_shell_flag && received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal) {\n\t\tverbose(\"Killed by signal %d.\", (int) received_signal);\n\t\tcleanup_exit(0);\n\t}\n\n\t/*\n\t * In interactive mode (with pseudo tty) display a message indicating\n\t * that the connection has been closed.\n\t */\n\tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"Connection to %.64s closed.\\r\\n\", host)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Output any buffered data for stderr. */\n\tif (sshbuf_len(stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    (u_char *)sshbuf_ptr(stderr_buffer),\n\t\t    sshbuf_len(stderr_buffer));\n\t\tif (len < 0 || (u_int)len != sshbuf_len(stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse if ((r = sshbuf_consume(stderr_buffer, len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Clear and free any buffers. */\n\texplicit_bzero(buf, sizeof(buf));\n\tsshbuf_free(stderr_buffer);\n\n\t/* Report bytes transferred, and transfer rates. */\n\ttotal_time = monotime_double() - start_time;\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t/* Return the exit status of the program. */\n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork_postauth",
          "args": [],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "fork_postauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1585-1594",
          "snippet": "static void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int need_controlpersist_detach = 0;",
            "int fork_after_authentication_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint need_controlpersist_detach = 0;\nint fork_after_authentication_flag = 0;\n\nstatic void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\""
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devnull"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: dup2() stdout failed\"",
            "__func__"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDOUT_FILENO"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: open %s: %s\"",
            "__func__",
            "_PATH_DEVNULL",
            "strerror(errno)"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_WRONLY"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_local_cmd",
          "args": [
            "options.local_command"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1513-1548",
          "snippet": "int\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nint\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "0"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"no-more-sessions@openssh.com\""
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_set_interactive",
          "args": [
            "options.control_master == SSHCTL_MASTER_NO",
            "options.ip_qos_interactive",
            "options.ip_qos_bulk"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_session2_open",
          "args": [
            "ssh"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_session2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1812-1856",
          "snippet": "static int\nssh_session2_open(struct ssh *ssh)\n{\n\tChannel *c;\n\tint window, packetmax, in, out, err;\n\n\tif (stdin_null_flag) {\n\t\tin = open(_PATH_DEVNULL, O_RDONLY);\n\t} else {\n\t\tin = dup(STDIN_FILENO);\n\t}\n\tout = dup(STDOUT_FILENO);\n\terr = dup(STDERR_FILENO);\n\n\tif (in < 0 || out < 0 || err < 0)\n\t\tfatal(\"dup() in/out/err failed\");\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(in))\n\t\tset_nonblock(in);\n\tif (!isatty(out))\n\t\tset_nonblock(out);\n\tif (!isatty(err))\n\t\tset_nonblock(err);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (tty_flag) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\tc = channel_new(ssh,\n\t    \"session\", SSH_CHANNEL_OPENING, in, out, err,\n\t    window, packetmax, CHAN_EXTENDED_WRITE,\n\t    \"client-session\", /*nonblock*/0);\n\n\tdebug3(\"%s: channel_new: %d\", __func__, c->self);\n\n\tchannel_send_open(ssh, c->self);\n\tif (!no_shell_flag)\n\t\tchannel_register_open_confirm(ssh, c->self,\n\t\t    ssh_session2_setup, NULL);\n\n\treturn c->self;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tty_flag = 0;",
            "int no_shell_flag = 0;",
            "int stdin_null_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint tty_flag = 0;\nint no_shell_flag = 0;\nint stdin_null_flag = 0;\n\nstatic int\nssh_session2_open(struct ssh *ssh)\n{\n\tChannel *c;\n\tint window, packetmax, in, out, err;\n\n\tif (stdin_null_flag) {\n\t\tin = open(_PATH_DEVNULL, O_RDONLY);\n\t} else {\n\t\tin = dup(STDIN_FILENO);\n\t}\n\tout = dup(STDOUT_FILENO);\n\terr = dup(STDERR_FILENO);\n\n\tif (in < 0 || out < 0 || err < 0)\n\t\tfatal(\"dup() in/out/err failed\");\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(in))\n\t\tset_nonblock(in);\n\tif (!isatty(out))\n\t\tset_nonblock(out);\n\tif (!isatty(err))\n\t\tset_nonblock(err);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (tty_flag) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\tc = channel_new(ssh,\n\t    \"session\", SSH_CHANNEL_OPENING, in, out, err,\n\t    window, packetmax, CHAN_EXTENDED_WRITE,\n\t    \"client-session\", /*nonblock*/0);\n\n\tdebug3(\"%s: channel_new: %d\", __func__, c->self);\n\n\tchannel_send_open(ssh, c->self);\n\tif (!no_shell_flag)\n\t\tchannel_register_open_confirm(ssh, c->self,\n\t\t    ssh_session2_setup, NULL);\n\n\treturn c->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_init_stdio_forwarding",
          "args": [
            "ssh"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_init_stdio_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1661-1681",
          "snippet": "static void\nssh_init_stdio_forwarding(struct ssh *ssh)\n{\n\tChannel *c;\n\tint in, out;\n\n\tif (options.stdio_forward_host == NULL)\n\t\treturn;\n\n\tdebug3(\"%s: %s:%d\", __func__, options.stdio_forward_host,\n\t    options.stdio_forward_port);\n\n\tif ((in = dup(STDIN_FILENO)) < 0 ||\n\t    (out = dup(STDOUT_FILENO)) < 0)\n\t\tfatal(\"channel_connect_stdio_fwd: dup() in/out failed\");\n\tif ((c = channel_connect_stdio_fwd(ssh, options.stdio_forward_host,\n\t    options.stdio_forward_port, in, out)) == NULL)\n\t\tfatal(\"%s: channel_connect_stdio_fwd failed\", __func__);\n\tchannel_register_cleanup(ssh, c->self, client_cleanup_stdio_fwd, 0);\n\tchannel_register_open_confirm(ssh, c->self, ssh_stdio_confirm, NULL);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\nssh_init_stdio_forwarding(struct ssh *ssh)\n{\n\tChannel *c;\n\tint in, out;\n\n\tif (options.stdio_forward_host == NULL)\n\t\treturn;\n\n\tdebug3(\"%s: %s:%d\", __func__, options.stdio_forward_host,\n\t    options.stdio_forward_port);\n\n\tif ((in = dup(STDIN_FILENO)) < 0 ||\n\t    (out = dup(STDOUT_FILENO)) < 0)\n\t\tfatal(\"channel_connect_stdio_fwd: dup() in/out failed\");\n\tif ((c = channel_connect_stdio_fwd(ssh, options.stdio_forward_host,\n\t    options.stdio_forward_port, in, out)) == NULL)\n\t\tfatal(\"%s: channel_connect_stdio_fwd failed\", __func__);\n\tchannel_register_cleanup(ssh, c->self, client_cleanup_stdio_fwd, 0);\n\tchannel_register_open_confirm(ssh, c->self, ssh_stdio_confirm, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "muxserver_listen",
          "args": [
            "ssh"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "muxserver_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1277-1358",
          "snippet": "void\nmuxserver_listen(struct ssh *ssh)\n{\n\tmode_t old_umask;\n\tchar *orig_control_path = options.control_path;\n\tchar rbuf[16+1];\n\tu_int i, r;\n\tint oerrno;\n\n\tif (options.control_path == NULL ||\n\t    options.control_master == SSHCTL_MASTER_NO)\n\t\treturn;\n\n\tdebug(\"setting up multiplex master socket\");\n\n\t/*\n\t * Use a temporary path before listen so we can pseudo-atomically\n\t * establish the listening socket in its final location to avoid\n\t * other processes racing in between bind() and listen() and hitting\n\t * an unready socket.\n\t */\n\tfor (i = 0; i < sizeof(rbuf) - 1; i++) {\n\t\tr = arc4random_uniform(26+26+10);\n\t\trbuf[i] = (r < 26) ? 'a' + r :\n\t\t    (r < 26*2) ? 'A' + r - 26 :\n\t\t    '0' + r - 26 - 26;\n\t}\n\trbuf[sizeof(rbuf) - 1] = '\\0';\n\toptions.control_path = NULL;\n\txasprintf(&options.control_path, \"%s.%s\", orig_control_path, rbuf);\n\tdebug3(\"%s: temporary control path %s\", __func__, options.control_path);\n\n\told_umask = umask(0177);\n\tmuxserver_sock = unix_listener(options.control_path, 64, 0);\n\toerrno = errno;\n\tumask(old_umask);\n\tif (muxserver_sock < 0) {\n\t\tif (oerrno == EINVAL || oerrno == EADDRINUSE) {\n\t\t\terror(\"ControlSocket %s already exists, \"\n\t\t\t    \"disabling multiplexing\", options.control_path);\n disable_mux_master:\n\t\t\tif (muxserver_sock != -1) {\n\t\t\t\tclose(muxserver_sock);\n\t\t\t\tmuxserver_sock = -1;\n\t\t\t}\n\t\t\tfree(orig_control_path);\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = NULL;\n\t\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* unix_listener() logs the error */\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Now atomically \"move\" the mux socket into position */\n\tif (link(options.control_path, orig_control_path) != 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tfatal(\"%s: link mux listener %s => %s: %s\", __func__,\n\t\t\t    options.control_path, orig_control_path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\terror(\"ControlSocket %s already exists, disabling multiplexing\",\n\t\t    orig_control_path);\n\t\tunlink(options.control_path);\n\t\tgoto disable_mux_master;\n\t}\n\tunlink(options.control_path);\n\tfree(options.control_path);\n\toptions.control_path = orig_control_path;\n\n\tset_nonblock(muxserver_sock);\n\n\tmux_listener_channel = channel_new(ssh, \"mux listener\",\n\t    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, options.control_path, 1);\n\tmux_listener_channel->mux_rcb = mux_master_read_cb;\n\tdebug3(\"%s: mux listener channel %d fd %d\", __func__,\n\t    mux_listener_channel->self, mux_listener_channel->sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int muxserver_sock = -1;",
            "static Channel *mux_listener_channel = NULL;",
            "static void mux_session_confirm(struct ssh *, int, int, void *);",
            "static void mux_stdio_confirm(struct ssh *, int, int, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint muxserver_sock = -1;\nstatic Channel *mux_listener_channel = NULL;\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\n\nvoid\nmuxserver_listen(struct ssh *ssh)\n{\n\tmode_t old_umask;\n\tchar *orig_control_path = options.control_path;\n\tchar rbuf[16+1];\n\tu_int i, r;\n\tint oerrno;\n\n\tif (options.control_path == NULL ||\n\t    options.control_master == SSHCTL_MASTER_NO)\n\t\treturn;\n\n\tdebug(\"setting up multiplex master socket\");\n\n\t/*\n\t * Use a temporary path before listen so we can pseudo-atomically\n\t * establish the listening socket in its final location to avoid\n\t * other processes racing in between bind() and listen() and hitting\n\t * an unready socket.\n\t */\n\tfor (i = 0; i < sizeof(rbuf) - 1; i++) {\n\t\tr = arc4random_uniform(26+26+10);\n\t\trbuf[i] = (r < 26) ? 'a' + r :\n\t\t    (r < 26*2) ? 'A' + r - 26 :\n\t\t    '0' + r - 26 - 26;\n\t}\n\trbuf[sizeof(rbuf) - 1] = '\\0';\n\toptions.control_path = NULL;\n\txasprintf(&options.control_path, \"%s.%s\", orig_control_path, rbuf);\n\tdebug3(\"%s: temporary control path %s\", __func__, options.control_path);\n\n\told_umask = umask(0177);\n\tmuxserver_sock = unix_listener(options.control_path, 64, 0);\n\toerrno = errno;\n\tumask(old_umask);\n\tif (muxserver_sock < 0) {\n\t\tif (oerrno == EINVAL || oerrno == EADDRINUSE) {\n\t\t\terror(\"ControlSocket %s already exists, \"\n\t\t\t    \"disabling multiplexing\", options.control_path);\n disable_mux_master:\n\t\t\tif (muxserver_sock != -1) {\n\t\t\t\tclose(muxserver_sock);\n\t\t\t\tmuxserver_sock = -1;\n\t\t\t}\n\t\t\tfree(orig_control_path);\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = NULL;\n\t\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* unix_listener() logs the error */\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Now atomically \"move\" the mux socket into position */\n\tif (link(options.control_path, orig_control_path) != 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tfatal(\"%s: link mux listener %s => %s: %s\", __func__,\n\t\t\t    options.control_path, orig_control_path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\terror(\"ControlSocket %s already exists, disabling multiplexing\",\n\t\t    orig_control_path);\n\t\tunlink(options.control_path);\n\t\tgoto disable_mux_master;\n\t}\n\tunlink(options.control_path);\n\tfree(options.control_path);\n\toptions.control_path = orig_control_path;\n\n\tset_nonblock(muxserver_sock);\n\n\tmux_listener_channel = channel_new(ssh, \"mux listener\",\n\t    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, options.control_path, 1);\n\tmux_listener_channel->mux_rcb = mux_master_read_cb;\n\tdebug3(\"%s: mux listener channel %d fd %d\", __func__,\n\t    mux_listener_channel->self, mux_listener_channel->sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_mux",
          "args": [],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "cp",
            "\"C\"",
            "conn_hash_hex",
            "\"L\"",
            "shorthost",
            "\"d\"",
            "pw->pw_dir",
            "\"h\"",
            "host",
            "\"i\"",
            "uidstr",
            "\"l\"",
            "thishost",
            "\"n\"",
            "host_arg",
            "\"p\"",
            "portstr",
            "\"r\"",
            "options.user",
            "\"u\"",
            "pw->pw_name",
            "\"T\"",
            "tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname",
            "(char *)NULL"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_init_forwarding",
          "args": [
            "ssh",
            "&tun_fwd_ifname"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_init_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1683-1751",
          "snippet": "static void\nssh_init_forwarding(struct ssh *ssh, char **ifname)\n{\n\tint success = 0;\n\tint i;\n\n\t/* Initiate local TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tdebug(\"Local connections to %.200s:%d forwarded to remote \"\n\t\t    \"address %.200s:%d\",\n\t\t    (options.local_forwards[i].listen_path != NULL) ?\n\t\t    options.local_forwards[i].listen_path :\n\t\t    (options.local_forwards[i].listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    options.local_forwards[i].listen_host,\n\t\t    options.local_forwards[i].listen_port,\n\t\t    (options.local_forwards[i].connect_path != NULL) ?\n\t\t    options.local_forwards[i].connect_path :\n\t\t    options.local_forwards[i].connect_host,\n\t\t    options.local_forwards[i].connect_port);\n\t\tsuccess += channel_setup_local_fwd_listener(ssh,\n\t\t    &options.local_forwards[i], &options.fwd_opts);\n\t}\n\tif (i > 0 && success != i && options.exit_on_forward_failure)\n\t\tfatal(\"Could not request local forwarding.\");\n\tif (i > 0 && success == 0)\n\t\terror(\"Could not request local forwarding.\");\n\n\t/* Initiate remote TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tdebug(\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\",\n\t\t    (options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host,\n\t\t    options.remote_forwards[i].listen_port,\n\t\t    (options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host,\n\t\t    options.remote_forwards[i].connect_port);\n\t\toptions.remote_forwards[i].handle =\n\t\t    channel_request_remote_forwarding(ssh,\n\t\t    &options.remote_forwards[i]);\n\t\tif (options.remote_forwards[i].handle < 0) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request remote forwarding.\");\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Could not request remote \"\n\t\t\t\t    \"forwarding.\");\n\t\t} else {\n\t\t\tclient_register_global_confirm(\n\t\t\t    ssh_confirm_remote_forward,\n\t\t\t    &options.remote_forwards[i]);\n\t\t}\n\t}\n\n\t/* Initiate tunnel forwarding. */\n\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\tif ((*ifname = client_request_tun_fwd(ssh,\n\t\t    options.tun_open, options.tun_local,\n\t\t    options.tun_remote)) == NULL) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request tunnel forwarding.\");\n\t\t\telse\n\t\t\t\terror(\"Could not request tunnel forwarding.\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\nssh_init_forwarding(struct ssh *ssh, char **ifname)\n{\n\tint success = 0;\n\tint i;\n\n\t/* Initiate local TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tdebug(\"Local connections to %.200s:%d forwarded to remote \"\n\t\t    \"address %.200s:%d\",\n\t\t    (options.local_forwards[i].listen_path != NULL) ?\n\t\t    options.local_forwards[i].listen_path :\n\t\t    (options.local_forwards[i].listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    options.local_forwards[i].listen_host,\n\t\t    options.local_forwards[i].listen_port,\n\t\t    (options.local_forwards[i].connect_path != NULL) ?\n\t\t    options.local_forwards[i].connect_path :\n\t\t    options.local_forwards[i].connect_host,\n\t\t    options.local_forwards[i].connect_port);\n\t\tsuccess += channel_setup_local_fwd_listener(ssh,\n\t\t    &options.local_forwards[i], &options.fwd_opts);\n\t}\n\tif (i > 0 && success != i && options.exit_on_forward_failure)\n\t\tfatal(\"Could not request local forwarding.\");\n\tif (i > 0 && success == 0)\n\t\terror(\"Could not request local forwarding.\");\n\n\t/* Initiate remote TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tdebug(\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\",\n\t\t    (options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host,\n\t\t    options.remote_forwards[i].listen_port,\n\t\t    (options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host,\n\t\t    options.remote_forwards[i].connect_port);\n\t\toptions.remote_forwards[i].handle =\n\t\t    channel_request_remote_forwarding(ssh,\n\t\t    &options.remote_forwards[i]);\n\t\tif (options.remote_forwards[i].handle < 0) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request remote forwarding.\");\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Could not request remote \"\n\t\t\t\t    \"forwarding.\");\n\t\t} else {\n\t\t\tclient_register_global_confirm(\n\t\t\t    ssh_confirm_remote_forward,\n\t\t\t    &options.remote_forwards[i]);\n\t\t}\n\t}\n\n\t/* Initiate tunnel forwarding. */\n\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\tif ((*ifname = client_request_tun_fwd(ssh,\n\t\t    options.tun_open, options.tun_local,\n\t\t    options.tun_remote)) == NULL) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request tunnel forwarding.\");\n\t\t\telse\n\t\t\t\terror(\"Could not request tunnel forwarding.\");\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint tty_flag = 0;\nint no_shell_flag = 0;\nint stdin_null_flag = 0;\nint need_controlpersist_detach = 0;\nint ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;\nint fork_after_authentication_flag = 0;\nOptions options;\nchar *host;\nstatic char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\nstatic char uidstr[32], *host_arg, *conn_hash_hex;\nstruct sshbuf *command;\nextern int muxserver_sock;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic int\nssh_session2(struct ssh *ssh, struct passwd *pw)\n{\n\tint devnull, id = -1;\n\tchar *cp, *tun_fwd_ifname = NULL;\n\n\t/* XXX should be pre-session */\n\tif (!options.control_persist)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tssh_init_forwarding(ssh, &tun_fwd_ifname);\n\n\tif (options.local_command != NULL) {\n\t\tdebug3(\"expanding LocalCommand: %s\", options.local_command);\n\t\tcp = options.local_command;\n\t\toptions.local_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"T\", tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded LocalCommand: %s\", options.local_command);\n\t\tfree(cp);\n\t}\n\n\t/* Start listening for multiplex clients */\n\tif (!packet_get_mux())\n\t\tmuxserver_listen(ssh);\n\n\t/*\n\t * If we are in control persist mode and have a working mux listen\n\t * socket, then prepare to background ourselves and have a foreground\n\t * client attach as a control slave.\n\t * NB. we must save copies of the flags that we override for\n\t * the backgrounding, since we defer attachment of the slave until\n\t * after the connection is fully established (in particular,\n\t * async rfwd replies have been received for ExitOnForwardFailure).\n\t */\n\tif (options.control_persist && muxserver_sock != -1) {\n\t\tostdin_null_flag = stdin_null_flag;\n\t\tono_shell_flag = no_shell_flag;\n\t\torequest_tty = options.request_tty;\n\t\totty_flag = tty_flag;\n\t\tstdin_null_flag = 1;\n\t\tno_shell_flag = 1;\n\t\ttty_flag = 0;\n\t\tif (!fork_after_authentication_flag)\n\t\t\tneed_controlpersist_detach = 1;\n\t\tfork_after_authentication_flag = 1;\n\t}\n\t/*\n\t * ControlPersist mux listen socket setup failed, attempt the\n\t * stdio forward setup that we skipped earlier.\n\t */\n\tif (options.control_persist && muxserver_sock == -1)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tif (!no_shell_flag)\n\t\tid = ssh_session2_open(ssh);\n\telse {\n\t\tpacket_set_interactive(\n\t\t    options.control_master == SSHCTL_MASTER_NO,\n\t\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\t}\n\n\t/* If we don't expect to open a new session, then disallow it */\n\tif (options.control_master == SSHCTL_MASTER_NO &&\n\t    (datafellows & SSH_NEW_OPENSSH)) {\n\t\tdebug(\"Requesting no-more-sessions@openssh.com\");\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"no-more-sessions@openssh.com\");\n\t\tpacket_put_char(0);\n\t\tpacket_send();\n\t}\n\n\t/* Execute a local command */\n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t/*\n\t * stdout is now owned by the session channel; clobber it here\n\t * so future channel closes are propagated to the local fd.\n\t * NB. this can only happen after LocalCommand has completed,\n\t * as it may want to write to stdout.\n\t */\n\tif (!need_controlpersist_detach) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_WRONLY)) == -1)\n\t\t\terror(\"%s: open %s: %s\", __func__,\n\t\t\t    _PATH_DEVNULL, strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2() stdout failed\", __func__);\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\t/*\n\t * If requested and we are not interested in replies to remote\n\t * forwarding requests, then let ssh continue in the background.\n\t */\n\tif (fork_after_authentication_flag) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\treturn client_loop(ssh, tty_flag, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, id);\n}"
  },
  {
    "function_name": "ssh_session2_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1812-1856",
    "snippet": "static int\nssh_session2_open(struct ssh *ssh)\n{\n\tChannel *c;\n\tint window, packetmax, in, out, err;\n\n\tif (stdin_null_flag) {\n\t\tin = open(_PATH_DEVNULL, O_RDONLY);\n\t} else {\n\t\tin = dup(STDIN_FILENO);\n\t}\n\tout = dup(STDOUT_FILENO);\n\terr = dup(STDERR_FILENO);\n\n\tif (in < 0 || out < 0 || err < 0)\n\t\tfatal(\"dup() in/out/err failed\");\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(in))\n\t\tset_nonblock(in);\n\tif (!isatty(out))\n\t\tset_nonblock(out);\n\tif (!isatty(err))\n\t\tset_nonblock(err);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (tty_flag) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\tc = channel_new(ssh,\n\t    \"session\", SSH_CHANNEL_OPENING, in, out, err,\n\t    window, packetmax, CHAN_EXTENDED_WRITE,\n\t    \"client-session\", /*nonblock*/0);\n\n\tdebug3(\"%s: channel_new: %d\", __func__, c->self);\n\n\tchannel_send_open(ssh, c->self);\n\tif (!no_shell_flag)\n\t\tchannel_register_open_confirm(ssh, c->self,\n\t\t    ssh_session2_setup, NULL);\n\n\treturn c->self;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tty_flag = 0;",
      "int no_shell_flag = 0;",
      "int stdin_null_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_open_confirm",
          "args": [
            "ssh",
            "c->self",
            "ssh_session2_setup",
            "NULL"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_open_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "971-983",
          "snippet": "void\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_send_open",
          "args": [
            "ssh",
            "c->self"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "channel_send_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "916-930",
          "snippet": "void\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel_new: %d\"",
            "__func__",
            "c->self"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"session\"",
            "SSH_CHANNEL_OPENING",
            "in",
            "out",
            "err",
            "window",
            "packetmax",
            "CHAN_EXTENDED_WRITE",
            "\"client-session\"",
            "/*nonblock*/0"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "err"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "err"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "out"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "in"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"dup() in/out/err failed\""
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDONLY"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint tty_flag = 0;\nint no_shell_flag = 0;\nint stdin_null_flag = 0;\n\nstatic int\nssh_session2_open(struct ssh *ssh)\n{\n\tChannel *c;\n\tint window, packetmax, in, out, err;\n\n\tif (stdin_null_flag) {\n\t\tin = open(_PATH_DEVNULL, O_RDONLY);\n\t} else {\n\t\tin = dup(STDIN_FILENO);\n\t}\n\tout = dup(STDOUT_FILENO);\n\terr = dup(STDERR_FILENO);\n\n\tif (in < 0 || out < 0 || err < 0)\n\t\tfatal(\"dup() in/out/err failed\");\n\n\t/* enable nonblocking unless tty */\n\tif (!isatty(in))\n\t\tset_nonblock(in);\n\tif (!isatty(out))\n\t\tset_nonblock(out);\n\tif (!isatty(err))\n\t\tset_nonblock(err);\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (tty_flag) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\tc = channel_new(ssh,\n\t    \"session\", SSH_CHANNEL_OPENING, in, out, err,\n\t    window, packetmax, CHAN_EXTENDED_WRITE,\n\t    \"client-session\", /*nonblock*/0);\n\n\tdebug3(\"%s: channel_new: %d\", __func__, c->self);\n\n\tchannel_send_open(ssh, c->self);\n\tif (!no_shell_flag)\n\t\tchannel_register_open_confirm(ssh, c->self,\n\t\t    ssh_session2_setup, NULL);\n\n\treturn c->self;\n}"
  },
  {
    "function_name": "ssh_session2_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1769-1809",
    "snippet": "static void\nssh_session2_setup(struct ssh *ssh, int id, int success, void *arg)\n{\n\textern char **environ;\n\tconst char *display;\n\tint interactive = tty_flag;\n\tchar *proto = NULL, *data = NULL;\n\n\tif (!success)\n\t\treturn; /* No need for error message, channels code sens one */\n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (display == NULL && options.forward_x11)\n\t\tdebug(\"X11 forwarding requested but DISPLAY not set\");\n\tif (options.forward_x11 && client_x11_get_proto(ssh, display,\n\t    options.xauth_location, options.forward_x11_trusted,\n\t    options.forward_x11_timeout, &proto, &data) == 0) {\n\t\t/* Request forwarding with authentication spoofing. */\n\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t    \"spoofing.\");\n\t\tx11_request_forwarding_with_spoofing(ssh, id, display, proto,\n\t\t    data, 1);\n\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\", CONFIRM_WARN);\n\t\t/* XXX exit_on_forward_failure */\n\t\tinteractive = 1;\n\t}\n\n\tcheck_agent_present();\n\tif (options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tpacket_send();\n\t}\n\n\t/* Tell the packet module whether this is an interactive session. */\n\tpacket_set_interactive(interactive,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tclient_session2_setup(ssh, id, tty_flag, subsystem_flag, getenv(\"TERM\"),\n\t    NULL, fileno(stdin), command, environ);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tty_flag = 0;",
      "Options options;",
      "struct sshbuf *command;",
      "int subsystem_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "client_session2_setup",
          "args": [
            "ssh",
            "id",
            "tty_flag",
            "subsystem_flag",
            "getenv(\"TERM\")",
            "NULL",
            "fileno(stdin)",
            "command",
            "environ"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "client_session2_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2193-2305",
          "snippet": "void\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nvoid\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TERM\""
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_interactive",
          "args": [
            "interactive",
            "options.ip_qos_interactive",
            "options.ip_qos_bulk"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "id",
            "\"auth-agent-req@openssh.com\"",
            "0"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Requesting authentication agent forwarding.\""
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_agent_present",
          "args": [],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "check_agent_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1753-1767",
          "snippet": "static void\ncheck_agent_present(void)\n{\n\tint r;\n\n\tif (options.forward_agent) {\n\t\t/* Clear agent forwarding if we don't have an agent. */\n\t\tif ((r = ssh_get_authentication_socket(NULL)) != 0) {\n\t\t\toptions.forward_agent = 0;\n\t\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\t\tdebug(\"ssh_get_authentication_socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\ncheck_agent_present(void)\n{\n\tint r;\n\n\tif (options.forward_agent) {\n\t\t/* Clear agent forwarding if we don't have an agent. */\n\t\tif ((r = ssh_get_authentication_socket(NULL)) != 0) {\n\t\t\toptions.forward_agent = 0;\n\t\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\t\tdebug(\"ssh_get_authentication_socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_expect_confirm",
          "args": [
            "ssh",
            "id",
            "\"X11 forwarding\"",
            "CONFIRM_WARN"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "client_expect_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "734-745",
          "snippet": "void\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_request_forwarding_with_spoofing",
          "args": [
            "ssh",
            "id",
            "display",
            "proto",
            "data",
            "1"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "x11_request_forwarding_with_spoofing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4816-4876",
          "snippet": "void\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_x11_get_proto",
          "args": [
            "ssh",
            "display",
            "options.xauth_location",
            "options.forward_x11_trusted",
            "options.forward_x11_timeout",
            "&proto",
            "&data"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "client_x11_get_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "277-441",
          "snippet": "int\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define X11_TIMEOUT_SLACK\t60",
            "#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\""
          ],
          "globals_used": [
            "static u_int x11_refuse_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define X11_TIMEOUT_SLACK\t60\n#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\"\n\nstatic u_int x11_refuse_time;\n\nint\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint tty_flag = 0;\nOptions options;\nstruct sshbuf *command;\nint subsystem_flag = 0;\n\nstatic void\nssh_session2_setup(struct ssh *ssh, int id, int success, void *arg)\n{\n\textern char **environ;\n\tconst char *display;\n\tint interactive = tty_flag;\n\tchar *proto = NULL, *data = NULL;\n\n\tif (!success)\n\t\treturn; /* No need for error message, channels code sens one */\n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (display == NULL && options.forward_x11)\n\t\tdebug(\"X11 forwarding requested but DISPLAY not set\");\n\tif (options.forward_x11 && client_x11_get_proto(ssh, display,\n\t    options.xauth_location, options.forward_x11_trusted,\n\t    options.forward_x11_timeout, &proto, &data) == 0) {\n\t\t/* Request forwarding with authentication spoofing. */\n\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t    \"spoofing.\");\n\t\tx11_request_forwarding_with_spoofing(ssh, id, display, proto,\n\t\t    data, 1);\n\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\", CONFIRM_WARN);\n\t\t/* XXX exit_on_forward_failure */\n\t\tinteractive = 1;\n\t}\n\n\tcheck_agent_present();\n\tif (options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tpacket_send();\n\t}\n\n\t/* Tell the packet module whether this is an interactive session. */\n\tpacket_set_interactive(interactive,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tclient_session2_setup(ssh, id, tty_flag, subsystem_flag, getenv(\"TERM\"),\n\t    NULL, fileno(stdin), command, environ);\n}"
  },
  {
    "function_name": "check_agent_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1753-1767",
    "snippet": "static void\ncheck_agent_present(void)\n{\n\tint r;\n\n\tif (options.forward_agent) {\n\t\t/* Clear agent forwarding if we don't have an agent. */\n\t\tif ((r = ssh_get_authentication_socket(NULL)) != 0) {\n\t\t\toptions.forward_agent = 0;\n\t\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\t\tdebug(\"ssh_get_authentication_socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ssh_get_authentication_socket: %s\"",
            "ssh_err(r)"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "NULL"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\ncheck_agent_present(void)\n{\n\tint r;\n\n\tif (options.forward_agent) {\n\t\t/* Clear agent forwarding if we don't have an agent. */\n\t\tif ((r = ssh_get_authentication_socket(NULL)) != 0) {\n\t\t\toptions.forward_agent = 0;\n\t\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\t\tdebug(\"ssh_get_authentication_socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ssh_init_forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1683-1751",
    "snippet": "static void\nssh_init_forwarding(struct ssh *ssh, char **ifname)\n{\n\tint success = 0;\n\tint i;\n\n\t/* Initiate local TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tdebug(\"Local connections to %.200s:%d forwarded to remote \"\n\t\t    \"address %.200s:%d\",\n\t\t    (options.local_forwards[i].listen_path != NULL) ?\n\t\t    options.local_forwards[i].listen_path :\n\t\t    (options.local_forwards[i].listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    options.local_forwards[i].listen_host,\n\t\t    options.local_forwards[i].listen_port,\n\t\t    (options.local_forwards[i].connect_path != NULL) ?\n\t\t    options.local_forwards[i].connect_path :\n\t\t    options.local_forwards[i].connect_host,\n\t\t    options.local_forwards[i].connect_port);\n\t\tsuccess += channel_setup_local_fwd_listener(ssh,\n\t\t    &options.local_forwards[i], &options.fwd_opts);\n\t}\n\tif (i > 0 && success != i && options.exit_on_forward_failure)\n\t\tfatal(\"Could not request local forwarding.\");\n\tif (i > 0 && success == 0)\n\t\terror(\"Could not request local forwarding.\");\n\n\t/* Initiate remote TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tdebug(\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\",\n\t\t    (options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host,\n\t\t    options.remote_forwards[i].listen_port,\n\t\t    (options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host,\n\t\t    options.remote_forwards[i].connect_port);\n\t\toptions.remote_forwards[i].handle =\n\t\t    channel_request_remote_forwarding(ssh,\n\t\t    &options.remote_forwards[i]);\n\t\tif (options.remote_forwards[i].handle < 0) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request remote forwarding.\");\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Could not request remote \"\n\t\t\t\t    \"forwarding.\");\n\t\t} else {\n\t\t\tclient_register_global_confirm(\n\t\t\t    ssh_confirm_remote_forward,\n\t\t\t    &options.remote_forwards[i]);\n\t\t}\n\t}\n\n\t/* Initiate tunnel forwarding. */\n\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\tif ((*ifname = client_request_tun_fwd(ssh,\n\t\t    options.tun_open, options.tun_local,\n\t\t    options.tun_remote)) == NULL) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request tunnel forwarding.\");\n\t\t\telse\n\t\t\t\terror(\"Could not request tunnel forwarding.\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Could not request tunnel forwarding.\""
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Could not request tunnel forwarding.\""
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_request_tun_fwd",
          "args": [
            "ssh",
            "options.tun_open",
            "options.tun_local",
            "options.tun_remote"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "client_request_tun_fwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1621-1661",
          "snippet": "char *\nclient_request_tun_fwd(struct ssh *ssh, int tun_mode,\n    int local_tun, int remote_tun)\n{\n\tChannel *c;\n\tint fd;\n\tchar *ifname = NULL;\n\n\tif (tun_mode == SSH_TUNMODE_NO)\n\t\treturn 0;\n\n\tdebug(\"Requesting tun unit %d in mode %d\", local_tun, tun_mode);\n\n\t/* Open local tunnel device */\n\tif ((fd = tun_open(local_tun, tun_mode, &ifname)) == -1) {\n\t\terror(\"Tunnel device open failed.\");\n\t\treturn NULL;\n\t}\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPENING, fd, fd, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n#if defined(SSH_TUN_FILTER)\n\tif (options.tun_open == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\tpacket_start(SSH2_MSG_CHANNEL_OPEN);\n\tpacket_put_cstring(\"tun@openssh.com\");\n\tpacket_put_int(c->self);\n\tpacket_put_int(c->local_window_max);\n\tpacket_put_int(c->local_maxpacket);\n\tpacket_put_int(tun_mode);\n\tpacket_put_int(remote_tun);\n\tpacket_send();\n\n\treturn ifname;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nchar *\nclient_request_tun_fwd(struct ssh *ssh, int tun_mode,\n    int local_tun, int remote_tun)\n{\n\tChannel *c;\n\tint fd;\n\tchar *ifname = NULL;\n\n\tif (tun_mode == SSH_TUNMODE_NO)\n\t\treturn 0;\n\n\tdebug(\"Requesting tun unit %d in mode %d\", local_tun, tun_mode);\n\n\t/* Open local tunnel device */\n\tif ((fd = tun_open(local_tun, tun_mode, &ifname)) == -1) {\n\t\terror(\"Tunnel device open failed.\");\n\t\treturn NULL;\n\t}\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPENING, fd, fd, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n#if defined(SSH_TUN_FILTER)\n\tif (options.tun_open == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\tpacket_start(SSH2_MSG_CHANNEL_OPEN);\n\tpacket_put_cstring(\"tun@openssh.com\");\n\tpacket_put_int(c->self);\n\tpacket_put_int(c->local_window_max);\n\tpacket_put_int(c->local_maxpacket);\n\tpacket_put_int(tun_mode);\n\tpacket_put_int(remote_tun);\n\tpacket_send();\n\n\treturn ifname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_register_global_confirm",
          "args": [
            "ssh_confirm_remote_forward",
            "&options.remote_forwards[i]"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "client_register_global_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "747-766",
          "snippet": "void\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Warning: Could not request remote \"\n\t\t\t\t    \"forwarding.\""
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_remote_forwarding",
          "args": [
            "ssh",
            "&options.remote_forwards[i]"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_remote_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3830-3886",
          "snippet": "int\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\"",
            "(options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host",
            "options.remote_forwards[i].listen_port",
            "(options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host",
            "options.remote_forwards[i].connect_port"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_setup_local_fwd_listener",
          "args": [
            "ssh",
            "&options.local_forwards[i]",
            "&options.fwd_opts"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_local_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3714-3725",
          "snippet": "int\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\nssh_init_forwarding(struct ssh *ssh, char **ifname)\n{\n\tint success = 0;\n\tint i;\n\n\t/* Initiate local TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tdebug(\"Local connections to %.200s:%d forwarded to remote \"\n\t\t    \"address %.200s:%d\",\n\t\t    (options.local_forwards[i].listen_path != NULL) ?\n\t\t    options.local_forwards[i].listen_path :\n\t\t    (options.local_forwards[i].listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    options.local_forwards[i].listen_host,\n\t\t    options.local_forwards[i].listen_port,\n\t\t    (options.local_forwards[i].connect_path != NULL) ?\n\t\t    options.local_forwards[i].connect_path :\n\t\t    options.local_forwards[i].connect_host,\n\t\t    options.local_forwards[i].connect_port);\n\t\tsuccess += channel_setup_local_fwd_listener(ssh,\n\t\t    &options.local_forwards[i], &options.fwd_opts);\n\t}\n\tif (i > 0 && success != i && options.exit_on_forward_failure)\n\t\tfatal(\"Could not request local forwarding.\");\n\tif (i > 0 && success == 0)\n\t\terror(\"Could not request local forwarding.\");\n\n\t/* Initiate remote TCP/IP port forwardings. */\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tdebug(\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\",\n\t\t    (options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host,\n\t\t    options.remote_forwards[i].listen_port,\n\t\t    (options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host,\n\t\t    options.remote_forwards[i].connect_port);\n\t\toptions.remote_forwards[i].handle =\n\t\t    channel_request_remote_forwarding(ssh,\n\t\t    &options.remote_forwards[i]);\n\t\tif (options.remote_forwards[i].handle < 0) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request remote forwarding.\");\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Could not request remote \"\n\t\t\t\t    \"forwarding.\");\n\t\t} else {\n\t\t\tclient_register_global_confirm(\n\t\t\t    ssh_confirm_remote_forward,\n\t\t\t    &options.remote_forwards[i]);\n\t\t}\n\t}\n\n\t/* Initiate tunnel forwarding. */\n\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\tif ((*ifname = client_request_tun_fwd(ssh,\n\t\t    options.tun_open, options.tun_local,\n\t\t    options.tun_remote)) == NULL) {\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tfatal(\"Could not request tunnel forwarding.\");\n\t\t\telse\n\t\t\t\terror(\"Could not request tunnel forwarding.\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ssh_init_stdio_forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1661-1681",
    "snippet": "static void\nssh_init_stdio_forwarding(struct ssh *ssh)\n{\n\tChannel *c;\n\tint in, out;\n\n\tif (options.stdio_forward_host == NULL)\n\t\treturn;\n\n\tdebug3(\"%s: %s:%d\", __func__, options.stdio_forward_host,\n\t    options.stdio_forward_port);\n\n\tif ((in = dup(STDIN_FILENO)) < 0 ||\n\t    (out = dup(STDOUT_FILENO)) < 0)\n\t\tfatal(\"channel_connect_stdio_fwd: dup() in/out failed\");\n\tif ((c = channel_connect_stdio_fwd(ssh, options.stdio_forward_host,\n\t    options.stdio_forward_port, in, out)) == NULL)\n\t\tfatal(\"%s: channel_connect_stdio_fwd failed\", __func__);\n\tchannel_register_cleanup(ssh, c->self, client_cleanup_stdio_fwd, 0);\n\tchannel_register_open_confirm(ssh, c->self, ssh_stdio_confirm, NULL);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_open_confirm",
          "args": [
            "ssh",
            "c->self",
            "ssh_stdio_confirm",
            "NULL"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_open_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "971-983",
          "snippet": "void\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "c->self",
            "client_cleanup_stdio_fwd",
            "0"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel_connect_stdio_fwd failed\"",
            "__func__"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_stdio_fwd",
          "args": [
            "ssh",
            "options.stdio_forward_host",
            "options.stdio_forward_port",
            "in",
            "out"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_stdio_fwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1489-1510",
          "snippet": "Channel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"channel_connect_stdio_fwd: dup() in/out failed\""
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s:%d\"",
            "__func__",
            "options.stdio_forward_host",
            "options.stdio_forward_port"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic void\nssh_init_stdio_forwarding(struct ssh *ssh)\n{\n\tChannel *c;\n\tint in, out;\n\n\tif (options.stdio_forward_host == NULL)\n\t\treturn;\n\n\tdebug3(\"%s: %s:%d\", __func__, options.stdio_forward_host,\n\t    options.stdio_forward_port);\n\n\tif ((in = dup(STDIN_FILENO)) < 0 ||\n\t    (out = dup(STDOUT_FILENO)) < 0)\n\t\tfatal(\"channel_connect_stdio_fwd: dup() in/out failed\");\n\tif ((c = channel_connect_stdio_fwd(ssh, options.stdio_forward_host,\n\t    options.stdio_forward_port, in, out)) == NULL)\n\t\tfatal(\"%s: channel_connect_stdio_fwd failed\", __func__);\n\tchannel_register_cleanup(ssh, c->self, client_cleanup_stdio_fwd, 0);\n\tchannel_register_open_confirm(ssh, c->self, ssh_stdio_confirm, NULL);\n}"
  },
  {
    "function_name": "ssh_stdio_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1654-1659",
    "snippet": "static void\nssh_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tif (!success)\n\t\tfatal(\"stdio forwarding failed\");\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"stdio forwarding failed\""
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nssh_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tif (!success)\n\t\tfatal(\"stdio forwarding failed\");\n}"
  },
  {
    "function_name": "client_cleanup_stdio_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1647-1652",
    "snippet": "static void\nclient_cleanup_stdio_fwd(struct ssh *ssh, int id, void *arg)\n{\n\tdebug(\"stdio forwarding: done\");\n\tcleanup_exit(0);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "0"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"stdio forwarding: done\""
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclient_cleanup_stdio_fwd(struct ssh *ssh, int id, void *arg)\n{\n\tdebug(\"stdio forwarding: done\");\n\tcleanup_exit(0);\n}"
  },
  {
    "function_name": "ssh_confirm_remote_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1597-1645",
    "snippet": "static void\nssh_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct Forward *rfwd = (struct Forward *)ctxt;\n\n\t/* XXX verbose() on failure? */\n\tdebug(\"remote forward %s for: listen %s%s%d, connect %s:%d\",\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_path ? rfwd->listen_path :\n\t    rfwd->listen_host ? rfwd->listen_host : \"\",\n\t    (rfwd->listen_path || rfwd->listen_host) ? \":\" : \"\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (rfwd->listen_path == NULL && rfwd->listen_port == 0) {\n\t\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\t\trfwd->allocated_port = packet_get_int();\n\t\t\tlogit(\"Allocated port %u for remote forward to %s:%d\",\n\t\t\t    rfwd->allocated_port,\n\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\tchannel_update_permission(ssh,\n\t\t\t    rfwd->handle, rfwd->allocated_port);\n\t\t} else {\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\t}\n\t}\n\n\tif (type == SSH2_MSG_REQUEST_FAILURE) {\n\t\tif (options.exit_on_forward_failure) {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t} else {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t}\n\t}\n\tif (++remote_forward_confirms_received == options.num_remote_forwards) {\n\t\tdebug(\"All remote forwarding requests processed\");\n\t\tif (fork_after_authentication_flag)\n\t\t\tfork_postauth();\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fork_after_authentication_flag = 0;",
      "Options options;",
      "static int remote_forward_confirms_received = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fork_postauth",
          "args": [],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "fork_postauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1585-1594",
          "snippet": "static void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int need_controlpersist_detach = 0;",
            "int fork_after_authentication_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint need_controlpersist_detach = 0;\nint fork_after_authentication_flag = 0;\n\nstatic void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"All remote forwarding requests processed\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\"",
            "rfwd->listen_port"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\"",
            "rfwd->listen_port"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_update_permission",
          "args": [
            "ssh",
            "rfwd->handle",
            "-1"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "channel_update_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4100-4121",
          "snippet": "void\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint fork_after_authentication_flag = 0;\nOptions options;\nstatic int remote_forward_confirms_received = 0;\n\nstatic void\nssh_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct Forward *rfwd = (struct Forward *)ctxt;\n\n\t/* XXX verbose() on failure? */\n\tdebug(\"remote forward %s for: listen %s%s%d, connect %s:%d\",\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_path ? rfwd->listen_path :\n\t    rfwd->listen_host ? rfwd->listen_host : \"\",\n\t    (rfwd->listen_path || rfwd->listen_host) ? \":\" : \"\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (rfwd->listen_path == NULL && rfwd->listen_port == 0) {\n\t\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\t\trfwd->allocated_port = packet_get_int();\n\t\t\tlogit(\"Allocated port %u for remote forward to %s:%d\",\n\t\t\t    rfwd->allocated_port,\n\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\tchannel_update_permission(ssh,\n\t\t\t    rfwd->handle, rfwd->allocated_port);\n\t\t} else {\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\t}\n\t}\n\n\tif (type == SSH2_MSG_REQUEST_FAILURE) {\n\t\tif (options.exit_on_forward_failure) {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t} else {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t}\n\t}\n\tif (++remote_forward_confirms_received == options.num_remote_forwards) {\n\t\tdebug(\"All remote forwarding requests processed\");\n\t\tif (fork_after_authentication_flag)\n\t\t\tfork_postauth();\n\t}\n}"
  },
  {
    "function_name": "fork_postauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1585-1594",
    "snippet": "static void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int need_controlpersist_detach = 0;",
      "int fork_after_authentication_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"daemon() failed: %.200s\"",
            "strerror(errno)"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemon",
          "args": [
            "1",
            "1"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/daemon.c",
          "lines": "51-79",
          "snippet": "int\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}",
          "includes": [
            "# include <unistd.h>",
            "# include <fcntl.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"forking to background\""
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_persist_detach",
          "args": [],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "control_persist_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1537-1582",
          "snippet": "static void\ncontrol_persist_detach(void)\n{\n\tpid_t pid;\n\tint devnull, keep_stderr;\n\n\tdebug(\"%s: backgrounding master process\", __func__);\n\n\t/*\n\t * master (current process) into the background, and make the\n\t * foreground process a client of the backgrounded master.\n\t */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\tfatal(\"%s: fork: %s\", __func__, strerror(errno));\n\tcase 0:\n\t\t/* Child: master process continues mainloop */\n\t\tbreak;\n\tdefault:\n\t\t/* Parent: set up mux slave to connect to backgrounded master */\n\t\tdebug2(\"%s: background process is %ld\", __func__, (long)pid);\n\t\tstdin_null_flag = ostdin_null_flag;\n\t\toptions.request_tty = orequest_tty;\n\t\ttty_flag = otty_flag;\n\t\tclose(muxserver_sock);\n\t\tmuxserver_sock = -1;\n\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\tmuxclient(options.control_path);\n\t\t/* muxclient() doesn't return on success. */\n\t\tfatal(\"Failed to connect to new control master\");\n\t}\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\terror(\"%s: open(\\\"/dev/null\\\"): %s\", __func__,\n\t\t    strerror(errno));\n\t} else {\n\t\tkeep_stderr = log_is_on_stderr() && debug_flag;\n\t\tif (dup2(devnull, STDIN_FILENO) == -1 ||\n\t\t    dup2(devnull, STDOUT_FILENO) == -1 ||\n\t\t    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))\n\t\t\terror(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\tdaemon(1, 1);\n\tsetproctitle(\"%s [mux]\", options.control_path);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int debug_flag = 0;",
            "int tty_flag = 0;",
            "int stdin_null_flag = 0;",
            "int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;",
            "Options options;",
            "extern int muxserver_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint debug_flag = 0;\nint tty_flag = 0;\nint stdin_null_flag = 0;\nint ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;\nOptions options;\nextern int muxserver_sock;\n\nstatic void\ncontrol_persist_detach(void)\n{\n\tpid_t pid;\n\tint devnull, keep_stderr;\n\n\tdebug(\"%s: backgrounding master process\", __func__);\n\n\t/*\n\t * master (current process) into the background, and make the\n\t * foreground process a client of the backgrounded master.\n\t */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\tfatal(\"%s: fork: %s\", __func__, strerror(errno));\n\tcase 0:\n\t\t/* Child: master process continues mainloop */\n\t\tbreak;\n\tdefault:\n\t\t/* Parent: set up mux slave to connect to backgrounded master */\n\t\tdebug2(\"%s: background process is %ld\", __func__, (long)pid);\n\t\tstdin_null_flag = ostdin_null_flag;\n\t\toptions.request_tty = orequest_tty;\n\t\ttty_flag = otty_flag;\n\t\tclose(muxserver_sock);\n\t\tmuxserver_sock = -1;\n\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\tmuxclient(options.control_path);\n\t\t/* muxclient() doesn't return on success. */\n\t\tfatal(\"Failed to connect to new control master\");\n\t}\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\terror(\"%s: open(\\\"/dev/null\\\"): %s\", __func__,\n\t\t    strerror(errno));\n\t} else {\n\t\tkeep_stderr = log_is_on_stderr() && debug_flag;\n\t\tif (dup2(devnull, STDIN_FILENO) == -1 ||\n\t\t    dup2(devnull, STDOUT_FILENO) == -1 ||\n\t\t    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))\n\t\t\terror(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\tdaemon(1, 1);\n\tsetproctitle(\"%s [mux]\", options.control_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint need_controlpersist_detach = 0;\nint fork_after_authentication_flag = 0;\n\nstatic void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}"
  },
  {
    "function_name": "control_persist_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "1537-1582",
    "snippet": "static void\ncontrol_persist_detach(void)\n{\n\tpid_t pid;\n\tint devnull, keep_stderr;\n\n\tdebug(\"%s: backgrounding master process\", __func__);\n\n\t/*\n\t * master (current process) into the background, and make the\n\t * foreground process a client of the backgrounded master.\n\t */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\tfatal(\"%s: fork: %s\", __func__, strerror(errno));\n\tcase 0:\n\t\t/* Child: master process continues mainloop */\n\t\tbreak;\n\tdefault:\n\t\t/* Parent: set up mux slave to connect to backgrounded master */\n\t\tdebug2(\"%s: background process is %ld\", __func__, (long)pid);\n\t\tstdin_null_flag = ostdin_null_flag;\n\t\toptions.request_tty = orequest_tty;\n\t\ttty_flag = otty_flag;\n\t\tclose(muxserver_sock);\n\t\tmuxserver_sock = -1;\n\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\tmuxclient(options.control_path);\n\t\t/* muxclient() doesn't return on success. */\n\t\tfatal(\"Failed to connect to new control master\");\n\t}\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\terror(\"%s: open(\\\"/dev/null\\\"): %s\", __func__,\n\t\t    strerror(errno));\n\t} else {\n\t\tkeep_stderr = log_is_on_stderr() && debug_flag;\n\t\tif (dup2(devnull, STDIN_FILENO) == -1 ||\n\t\t    dup2(devnull, STDOUT_FILENO) == -1 ||\n\t\t    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))\n\t\t\terror(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\tdaemon(1, 1);\n\tsetproctitle(\"%s [mux]\", options.control_path);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int debug_flag = 0;",
      "int tty_flag = 0;",
      "int stdin_null_flag = 0;",
      "int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;",
      "Options options;",
      "extern int muxserver_sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s [mux]\"",
            "options.control_path"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemon",
          "args": [
            "1",
            "1"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/daemon.c",
          "lines": "51-79",
          "snippet": "int\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}",
          "includes": [
            "# include <unistd.h>",
            "# include <fcntl.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devnull"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: dup2: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDERR_FILENO"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDOUT_FILENO"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDIN_FILENO"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_is_on_stderr",
          "args": [],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "log_is_on_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "361-365",
          "snippet": "int\nlog_is_on_stderr(void)\n{\n\treturn log_on_stderr && log_stderr_fd == STDERR_FILENO;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_stderr_fd = STDERR_FILENO;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_stderr_fd = STDERR_FILENO;\n\nint\nlog_is_on_stderr(void)\n{\n\treturn log_on_stderr && log_stderr_fd == STDERR_FILENO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to connect to new control master\""
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "muxclient",
          "args": [
            "options.control_path"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "muxclient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "2284-2391",
          "snippet": "int\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "u_int muxclient_command = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_int muxclient_command = 0;\n\nint\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: background process is %ld\"",
            "__func__",
            "(long)pid"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "fork_postauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1585-1594",
          "snippet": "static void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int need_controlpersist_detach = 0;",
            "int fork_after_authentication_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint need_controlpersist_detach = 0;\nint fork_after_authentication_flag = 0;\n\nstatic void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\tfork_after_authentication_flag = 0;\n\tif (daemon(1, 1) < 0)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: backgrounding master process\"",
            "__func__"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint debug_flag = 0;\nint tty_flag = 0;\nint stdin_null_flag = 0;\nint ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;\nOptions options;\nextern int muxserver_sock;\n\nstatic void\ncontrol_persist_detach(void)\n{\n\tpid_t pid;\n\tint devnull, keep_stderr;\n\n\tdebug(\"%s: backgrounding master process\", __func__);\n\n\t/*\n\t * master (current process) into the background, and make the\n\t * foreground process a client of the backgrounded master.\n\t */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\tfatal(\"%s: fork: %s\", __func__, strerror(errno));\n\tcase 0:\n\t\t/* Child: master process continues mainloop */\n\t\tbreak;\n\tdefault:\n\t\t/* Parent: set up mux slave to connect to backgrounded master */\n\t\tdebug2(\"%s: background process is %ld\", __func__, (long)pid);\n\t\tstdin_null_flag = ostdin_null_flag;\n\t\toptions.request_tty = orequest_tty;\n\t\ttty_flag = otty_flag;\n\t\tclose(muxserver_sock);\n\t\tmuxserver_sock = -1;\n\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\tmuxclient(options.control_path);\n\t\t/* muxclient() doesn't return on success. */\n\t\tfatal(\"Failed to connect to new control master\");\n\t}\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\terror(\"%s: open(\\\"/dev/null\\\"): %s\", __func__,\n\t\t    strerror(errno));\n\t} else {\n\t\tkeep_stderr = log_is_on_stderr() && debug_flag;\n\t\tif (dup2(devnull, STDIN_FILENO) == -1 ||\n\t\t    dup2(devnull, STDOUT_FILENO) == -1 ||\n\t\t    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))\n\t\t\terror(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\tdaemon(1, 1);\n\tsetproctitle(\"%s [mux]\", options.control_path);\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "579-1535",
    "snippet": "int\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\tint i, r, opt, exit_status, use_syslog, direct, timeout_ms;\n\tint was_addr, config_test = 0, opt_terminated = 0;\n\tchar *p, *cp, *line, *argv0, buf[PATH_MAX], *logfile;\n\tchar cname[NI_MAXHOST];\n\tstruct stat st;\n\tstruct passwd *pw;\n\textern int optind, optreset;\n\textern char *optarg;\n\tstruct Forward fwd;\n\tstruct addrinfo *addrs = NULL;\n\tstruct ssh_digest_ctx *md;\n\tu_char conn_hash[SSH_DIGEST_MAX_LENGTH];\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(av[0]);\n\n#ifndef HAVE_SETPROCTITLE\n\t/* Prepare for later setproctitle emulation */\n\t/* Save argv so it isn't clobbered by setproctitle() emulation */\n\tsaved_av = xcalloc(ac + 1, sizeof(*saved_av));\n\tfor (i = 0; i < ac; i++)\n\t\tsaved_av[i] = xstrdup(av[i]);\n\tsaved_av[i] = NULL;\n\tcompat_init_setproctitle(ac, av);\n\tav = saved_av;\n#endif\n\n\t/*\n\t * Discard other fds that are hanging around. These can cause problem\n\t * with backgrounded ssh processes started by ControlPersist.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n\n\t/* Get user data. */\n\tpw = getpwuid(getuid());\n\tif (!pw) {\n\t\tlogit(\"No user exists for uid %lu\", (u_long)getuid());\n\t\texit(255);\n\t}\n\t/* Take a copy of the returned structure. */\n\tpw = pwcopy(pw);\n\n\t/*\n\t * Set our umask to something reasonable, as some files are created\n\t * with the default umask.  This will make them world-readable but\n\t * writable only by the owner, which is ok for all files for which we\n\t * don't set the modes explicitly.\n\t */\n\tumask(022);\n\n\tmsetlocale();\n\n\t/*\n\t * Initialize option structure to indicate that no values have been\n\t * set.\n\t */\n\tinitialize_options(&options);\n\n\t/*\n\t * Prepare main ssh transport/connection structures\n\t */\n\tif ((ssh = ssh_alloc_session_state()) == NULL)\n\t\tfatal(\"Couldn't allocate session state\");\n\tchannel_init_channels(ssh);\n\tactive_state = ssh; /* XXX legacy API compat */\n\n\t/* Parse command-line arguments. */\n\thost = NULL;\n\tuse_syslog = 0;\n\tlogfile = NULL;\n\targv0 = av[0];\n\n again:\n\twhile ((opt = getopt(ac, av, \"1246ab:c:e:fgi:kl:m:no:p:qstvx\"\n\t    \"AB:CD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tstdin_null_flag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfork_after_authentication_flag = 1;\n\t\t\tstdin_null_flag = 1;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\toptions.forward_x11 = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\toptions.forward_x11 = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tuse_syslog = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tconfig_test = 1;\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\toptions.forward_x11 = 1;\n\t\t\toptions.forward_x11_trusted = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\toptions.fwd_opts.gateway_ports = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"Cannot specify multiplexing \"\n\t\t\t\t    \"command with -W\");\n\t\t\telse if (muxclient_command != 0)\n\t\t\t\tfatal(\"Multiplexing command already specified\");\n\t\t\tif (strcmp(optarg, \"check\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;\n\t\t\telse if (strcmp(optarg, \"forward\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_FORWARD;\n\t\t\telse if (strcmp(optarg, \"exit\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_TERMINATE;\n\t\t\telse if (strcmp(optarg, \"stop\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_STOP;\n\t\t\telse if (strcmp(optarg, \"cancel\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_CANCEL_FWD;\n\t\t\telse if (strcmp(optarg, \"proxy\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_PROXY;\n\t\t\telse\n\t\t\t\tfatal(\"Invalid multiplex command.\");\n\t\t\tbreak;\n\t\tcase 'P':\t/* deprecated */\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcp = NULL;\n\t\t\tif (strcmp(optarg, \"cipher\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 0);\n\t\t\telse if (strcmp(optarg, \"cipher-auth\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 1);\n\t\t\telse if (strcmp(optarg, \"mac\") == 0)\n\t\t\t\tcp = mac_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"kex\") == 0)\n\t\t\t\tcp = kex_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"key\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-cert\") == 0)\n\t\t\t\tcp = sshkey_alg_list(1, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-plain\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"sig\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 1, '\\n');\n\t\t\telse if (strcmp(optarg, \"protocol-version\") == 0)\n\t\t\t\tcp = xstrdup(\"2\");\n\t\t\telse if (strcmp(optarg, \"help\") == 0) {\n\t\t\t\tcp = xstrdup(\n\t\t\t\t    \"cipher\\ncipher-auth\\nkex\\nkey\\n\"\n\t\t\t\t    \"key-cert\\nkey-plain\\nmac\\n\"\n\t\t\t\t    \"protocol-version\\nsig\");\n\t\t\t}\n\t\t\tif (cp == NULL)\n\t\t\t\tfatal(\"Unsupported query \\\"%s\\\"\", optarg);\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\tfree(cp);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\toptions.forward_agent = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\toptions.forward_agent = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\toptions.gss_deleg_creds = 0;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\toptions.gss_authentication = 1;\n\t\t\toptions.gss_deleg_creds = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp = tilde_expand_filename(optarg, getuid());\n\t\t\tif (stat(p, &st) < 0)\n\t\t\t\tfprintf(stderr, \"Warning: Identity file %s \"\n\t\t\t\t    \"not accessible: %s.\\n\", p,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tadd_identity_file(&options, NULL, p, 1);\n\t\t\tfree(p);\n\t\t\tbreak;\n\t\tcase 'I':\n#ifdef ENABLE_PKCS11\n\t\t\tfree(options.pkcs11_provider);\n\t\t\toptions.pkcs11_provider = xstrdup(optarg);\n#else\n\t\t\tfprintf(stderr, \"no support for PKCS#11.\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tif (options.jump_host != NULL)\n\t\t\t\tfatal(\"Only a single -J option permitted\");\n\t\t\tif (options.proxy_command != NULL)\n\t\t\t\tfatal(\"Cannot specify -J with ProxyCommand\");\n\t\t\tif (parse_jump(optarg, &options, 1) == -1)\n\t\t\t\tfatal(\"Invalid -J argument\");\n\t\t\toptions.proxy_command = xstrdup(\"none\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (options.request_tty == REQUEST_TTY_YES)\n\t\t\t\toptions.request_tty = REQUEST_TTY_FORCE;\n\t\t\telse\n\t\t\t\toptions.request_tty = REQUEST_TTY_YES;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else {\n\t\t\t\tif (options.log_level < SYSLOG_LEVEL_DEBUG3) {\n\t\t\t\t\tdebug_flag++;\n\t\t\t\t\toptions.log_level++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tfprintf(stderr, \"%s, %s\\n\",\n\t\t\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t\t\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t\t\t    \"without OpenSSL\"\n#endif\n\t\t\t);\n\t\t\tif (opt == 'V')\n\t\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (options.tun_open == -1)\n\t\t\t\toptions.tun_open = SSH_TUNMODE_DEFAULT;\n\t\t\toptions.tun_local = a2tun(optarg, &options.tun_remote);\n\t\t\tif (options.tun_local == SSH_TUNID_ERR) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad tun device '%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"stdio forward already specified\");\n\t\t\tif (muxclient_command != 0)\n\t\t\t\tfatal(\"Cannot specify stdio forward with -O\");\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\toptions.stdio_forward_host = fwd.listen_host;\n\t\t\t\toptions.stdio_forward_port = fwd.listen_port;\n\t\t\t\tfree(fwd.connect_host);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad stdio forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tno_shell_flag = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '^' && optarg[2] == 0 &&\n\t\t\t    (u_char) optarg[1] >= 64 &&\n\t\t\t    (u_char) optarg[1] < 128)\n\t\t\t\toptions.escape_char = (u_char) optarg[1] & 31;\n\t\t\telse if (strlen(optarg) == 1)\n\t\t\t\toptions.escape_char = (u_char) optarg[0];\n\t\t\telse if (strcmp(optarg, \"none\") == 0)\n\t\t\t\toptions.escape_char = SSH_ESCAPECHAR_NONE;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Bad escape character '%s'.\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (!ciphers_valid(*optarg == '+' ?\n\t\t\t    optarg + 1 : optarg)) {\n\t\t\t\tfprintf(stderr, \"Unknown cipher type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tfree(options.ciphers);\n\t\t\toptions.ciphers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mac_valid(optarg)) {\n\t\t\t\tfree(options.macs);\n\t\t\t\toptions.macs = xstrdup(optarg);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown mac type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (options.control_master == SSHCTL_MASTER_YES)\n\t\t\t\toptions.control_master = SSHCTL_MASTER_ASK;\n\t\t\telse\n\t\t\t\toptions.control_master = SSHCTL_MASTER_YES;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (options.port == -1) {\n\t\t\t\toptions.port = a2port(optarg);\n\t\t\t\tif (options.port <= 0) {\n\t\t\t\t\tfprintf(stderr, \"Bad port '%s'\\n\",\n\t\t\t\t\t    optarg);\n\t\t\t\t\texit(255);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (options.user == NULL)\n\t\t\t\toptions.user = optarg;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 0))\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\telse {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad local forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 1) ||\n\t\t\t    parse_forward(&fwd, optarg, 1, 1)) {\n\t\t\t\tadd_remote_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad remote forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad dynamic forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\toptions.compression = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tno_shell_flag = 1;\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_config_line(&options, pw,\n\t\t\t    host ? host : \"\", host ? host : \"\", line,\n\t\t\t    \"command-line\", 0, NULL, SSHCONF_USERCONF) != 0)\n\t\t\t\texit(255);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsubsystem_flag = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toptions.bind_address = optarg;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toptions.bind_interface = optarg;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tconfig = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (optind > 1 && strcmp(av[optind - 1], \"--\") == 0)\n\t\topt_terminated = 1;\n\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && !host) {\n\t\tint tport;\n\t\tchar *tuser;\n\t\tswitch (parse_ssh_uri(*av, &tuser, &host, &tport)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (options.user == NULL) {\n\t\t\t\toptions.user = tuser;\n\t\t\t\ttuser = NULL;\n\t\t\t}\n\t\t\tfree(tuser);\n\t\t\tif (options.port == -1 && tport != -1)\n\t\t\t\toptions.port = tport;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xstrdup(*av);\n\t\t\tcp = strrchr(p, '@');\n\t\t\tif (cp != NULL) {\n\t\t\t\tif (cp == p)\n\t\t\t\t\tusage();\n\t\t\t\tif (options.user == NULL) {\n\t\t\t\t\toptions.user = p;\n\t\t\t\t\tp = NULL;\n\t\t\t\t}\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thost = xstrdup(cp);\n\t\t\t\tfree(p);\n\t\t\t} else\n\t\t\t\thost = p;\n\t\t\tbreak;\n\t\t}\n\t\tif (ac > 1 && !opt_terminated) {\n\t\t\toptind = optreset = 1;\n\t\t\tgoto again;\n\t\t}\n\t\tac--, av++;\n\t}\n\n\t/* Check that we got a host name. */\n\tif (!host)\n\t\tusage();\n\n\thost_arg = xstrdup(host);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n#endif\n\n\t/* Initialize the command to execute on remote host. */\n\tif ((command = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\n\t/*\n\t * Save the command to execute on the remote host in a buffer. There\n\t * is no limit on the length of the command, except by the maximum\n\t * packet size.  Also sets the tty flag if there is no command.\n\t */\n\tif (!ac) {\n\t\t/* No command specified - execute shell on a tty. */\n\t\tif (subsystem_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"You must specify a subsystem to invoke.\\n\");\n\t\t\tusage();\n\t\t}\n\t} else {\n\t\t/* A command has been specified.  Store it into the buffer. */\n\t\tfor (i = 0; i < ac; i++) {\n\t\t\tif ((r = sshbuf_putf(command, \"%s%s\",\n\t\t\t    i ? \" \" : \"\", av[i])) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\n\t/*\n\t * Initialize \"log\" output.  Since we are the client all output\n\t * goes to stderr unless otherwise specified by -y or -E.\n\t */\n\tif (use_syslog && logfile != NULL)\n\t\tfatal(\"Can't specify both -y and -E\");\n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\tlog_init(argv0,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_USER : options.log_facility,\n\t    !use_syslog);\n\n\tif (debug_flag)\n\t\tlogit(\"%s, %s\", SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t\t    \"without OpenSSL\"\n#endif\n\t\t);\n\n\t/* Parse the configuration files */\n\tprocess_config_files(host_arg, pw, 0);\n\n\t/* Hostname canonicalisation needs a few options filled. */\n\tfill_default_options_for_canonicalization(&options);\n\n\t/* If the user has replaced the hostname then take it into use now */\n\tif (options.hostname != NULL) {\n\t\t/* NB. Please keep in sync with readconf.c:match_cfg_line() */\n\t\tcp = percent_expand(options.hostname,\n\t\t    \"h\", host, (char *)NULL);\n\t\tfree(host);\n\t\thost = cp;\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t}\n\n\t/* Don't lowercase addresses, they will be explicitly canonicalised */\n\tif ((was_addr = is_addr(host)) == 0)\n\t\tlowercase(host);\n\n\t/*\n\t * Try to canonicalize if requested by configuration or the\n\t * hostname is an address.\n\t */\n\tif (options.canonicalize_hostname != SSH_CANONICALISE_NO || was_addr)\n\t\taddrs = resolve_canonicalize(&host, options.port);\n\n\t/*\n\t * If CanonicalizePermittedCNAMEs have been specified but\n\t * other canonicalization did not happen (by not being requested\n\t * or by failing with fallback) then the hostname may still be changed\n\t * as a result of CNAME following.\n\t *\n\t * Try to resolve the bare hostname name using the system resolver's\n\t * usual search rules and then apply the CNAME follow rules.\n\t *\n\t * Skip the lookup if a ProxyCommand is being used unless the user\n\t * has specifically requested canonicalisation for this case via\n\t * CanonicalizeHostname=always\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (addrs == NULL && options.num_permitted_cnames != 0 && (direct ||\n\t    options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {\n\t\tif ((addrs = resolve_host(host, options.port,\n\t\t    direct, cname, sizeof(cname))) == NULL) {\n\t\t\t/* Don't fatal proxied host names not in the DNS */\n\t\t\tif (direct)\n\t\t\t\tcleanup_exit(255); /* logged in resolve_host */\n\t\t} else\n\t\t\tcheck_follow_cname(direct, &host, cname);\n\t}\n\n\t/*\n\t * If canonicalisation is enabled then re-parse the configuration\n\t * files as new stanzas may match.\n\t */\n\tif (options.canonicalize_hostname != 0) {\n\t\tdebug(\"Re-reading configuration after hostname \"\n\t\t    \"canonicalisation\");\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t\tprocess_config_files(host_arg, pw, 1);\n\t\t/*\n\t\t * Address resolution happens early with canonicalisation\n\t\t * enabled and the port number may have changed since, so\n\t\t * reset it in address list\n\t\t */\n\t\tif (addrs != NULL && options.port > 0)\n\t\t\tset_addrinfo_port(addrs, options.port);\n\t}\n\n\t/* Fill configuration defaults. */\n\tfill_default_options(&options);\n\n\t/*\n\t * If ProxyJump option specified, then construct a ProxyCommand now.\n\t */\n\tif (options.jump_host != NULL) {\n\t\tchar port_s[8];\n\t\tconst char *sshbin = argv0;\n\n\t\t/*\n\t\t * Try to use SSH indicated by argv[0], but fall back to\n\t\t * \"ssh\" if it appears unavailable.\n\t\t */\n\t\tif (strchr(argv0, '/') != NULL && access(argv0, X_OK) != 0)\n\t\t\tsshbin = \"ssh\";\n\n\t\t/* Consistency check */\n\t\tif (options.proxy_command != NULL)\n\t\t\tfatal(\"inconsistent options: ProxyCommand+ProxyJump\");\n\t\t/* Never use FD passing for ProxyJump */\n\t\toptions.proxy_use_fdpass = 0;\n\t\tsnprintf(port_s, sizeof(port_s), \"%d\", options.jump_port);\n\t\txasprintf(&options.proxy_command,\n\t\t    \"%s%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s\",\n\t\t    sshbin,\n\t\t    /* Optional \"-l user\" argument if jump_user set */\n\t\t    options.jump_user == NULL ? \"\" : \" -l \",\n\t\t    options.jump_user == NULL ? \"\" : options.jump_user,\n\t\t    /* Optional \"-p port\" argument if jump_port set */\n\t\t    options.jump_port <= 0 ? \"\" : \" -p \",\n\t\t    options.jump_port <= 0 ? \"\" : port_s,\n\t\t    /* Optional additional jump hosts \",...\" */\n\t\t    options.jump_extra == NULL ? \"\" : \" -J \",\n\t\t    options.jump_extra == NULL ? \"\" : options.jump_extra,\n\t\t    /* Optional \"-F\" argumment if -F specified */\n\t\t    config == NULL ? \"\" : \" -F \",\n\t\t    config == NULL ? \"\" : config,\n\t\t    /* Optional \"-v\" arguments if -v set */\n\t\t    debug_flag ? \" -\" : \"\",\n\t\t    debug_flag, \"vvv\",\n\t\t    /* Mandatory hostname */\n\t\t    options.jump_host);\n\t\tdebug(\"Setting implicit ProxyCommand from ProxyJump: %s\",\n\t\t    options.proxy_command);\n\t}\n\n\tif (options.port == 0)\n\t\toptions.port = default_ssh_port();\n\tchannel_set_af(ssh, options.address_family);\n\n\t/* Tidy and check options */\n\tif (options.host_key_alias != NULL)\n\t\tlowercase(options.host_key_alias);\n\tif (options.proxy_command != NULL &&\n\t    strcmp(options.proxy_command, \"-\") == 0 &&\n\t    options.proxy_use_fdpass)\n\t\tfatal(\"ProxyCommand=- and ProxyUseFDPass are incompatible\");\n\tif (options.control_persist &&\n\t    options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tdebug(\"UpdateHostKeys=ask is incompatible with ControlPersist; \"\n\t\t    \"disabling\");\n\t\toptions.update_hostkeys = 0;\n\t}\n\tif (options.connection_attempts <= 0)\n\t\tfatal(\"Invalid number of ConnectionAttempts\");\n\n\tif (sshbuf_len(command) != 0 && options.remote_command != NULL)\n\t\tfatal(\"Cannot execute command-line and remote command.\");\n\n\t/* Cannot fork to background if no command. */\n\tif (fork_after_authentication_flag && sshbuf_len(command) == 0 &&\n\t    options.remote_command == NULL && !no_shell_flag)\n\t\tfatal(\"Cannot fork into background without a command \"\n\t\t    \"to execute.\");\n\n\t/* reinit */\n\tlog_init(argv0, options.log_level, options.log_facility, !use_syslog);\n\n\tif (options.request_tty == REQUEST_TTY_YES ||\n\t    options.request_tty == REQUEST_TTY_FORCE)\n\t\ttty_flag = 1;\n\n\t/* Allocate a tty by default if no command specified. */\n\tif (sshbuf_len(command) == 0 && options.remote_command == NULL)\n\t\ttty_flag = options.request_tty != REQUEST_TTY_NO;\n\n\t/* Force no tty */\n\tif (options.request_tty == REQUEST_TTY_NO ||\n\t    (muxclient_command && muxclient_command != SSHMUX_COMMAND_PROXY))\n\t\ttty_flag = 0;\n\t/* Do not allocate a tty if stdin is not a tty. */\n\tif ((!isatty(fileno(stdin)) || stdin_null_flag) &&\n\t    options.request_tty != REQUEST_TTY_FORCE) {\n\t\tif (tty_flag)\n\t\t\tlogit(\"Pseudo-terminal will not be allocated because \"\n\t\t\t    \"stdin is not a terminal.\");\n\t\ttty_flag = 0;\n\t}\n\n\tseed_rng();\n\n\tif (options.user == NULL)\n\t\toptions.user = xstrdup(pw->pw_name);\n\n\t/* Set up strings used to percent_expand() arguments */\n\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\tsnprintf(portstr, sizeof(portstr), \"%d\", options.port);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\n\tif ((md = ssh_digest_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_digest_update(md, thishost, strlen(thishost)) < 0 ||\n\t    ssh_digest_update(md, host, strlen(host)) < 0 ||\n\t    ssh_digest_update(md, portstr, strlen(portstr)) < 0 ||\n\t    ssh_digest_update(md, options.user, strlen(options.user)) < 0 ||\n\t    ssh_digest_final(md, conn_hash, sizeof(conn_hash)) < 0)\n\t\tfatal(\"%s: mux digest failed\", __func__);\n\tssh_digest_free(md);\n\tconn_hash_hex = tohex(conn_hash, ssh_digest_bytes(SSH_DIGEST_SHA1));\n\n\t/*\n\t * Expand tokens in arguments. NB. LocalCommand is expanded later,\n\t * after port-forwarding is set up, so it may pick up any local\n\t * tunnel interface name allocated.\n\t */\n\tif (options.remote_command != NULL) {\n\t\tdebug3(\"expanding RemoteCommand: %s\", options.remote_command);\n\t\tcp = options.remote_command;\n\t\toptions.remote_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded RemoteCommand: %s\", options.remote_command);\n\t\tfree(cp);\n\t\tif ((r = sshbuf_put(command, options.remote_command,\n\t\t    strlen(options.remote_command))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (options.control_path != NULL) {\n\t\tcp = tilde_expand_filename(options.control_path, getuid());\n\t\tfree(options.control_path);\n\t\toptions.control_path = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"i\", uidstr,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\t}\n\n\tif (config_test) {\n\t\tdump_client_config(&options, host);\n\t\texit(0);\n\t}\n\n\tif (muxclient_command != 0 && options.control_path == NULL)\n\t\tfatal(\"No ControlPath specified for \\\"-O\\\" command\");\n\tif (options.control_path != NULL) {\n\t\tint sock;\n\t\tif ((sock = muxclient(options.control_path)) >= 0) {\n\t\t\tssh_packet_set_connection(ssh, sock, sock);\n\t\t\tpacket_set_mux();\n\t\t\tgoto skip_connect;\n\t\t}\n\t}\n\n\t/*\n\t * If hostname canonicalisation was not enabled, then we may not\n\t * have yet resolved the hostname. Do so now.\n\t */\n\tif (addrs == NULL && options.proxy_command == NULL) {\n\t\tdebug2(\"resolving \\\"%s\\\" port %d\", host, options.port);\n\t\tif ((addrs = resolve_host(host, options.port, 1,\n\t\t    cname, sizeof(cname))) == NULL)\n\t\t\tcleanup_exit(255); /* resolve_host logs the error */\n\t}\n\n\ttimeout_ms = options.connection_timeout * 1000;\n\n\t/* Open a connection to the remote host. */\n\tif (ssh_connect(ssh, host, addrs, &hostaddr, options.port,\n\t    options.address_family, options.connection_attempts,\n\t    &timeout_ms, options.tcp_keep_alive) != 0)\n \t\texit(255);\n\n\tif (addrs != NULL)\n\t\tfreeaddrinfo(addrs);\n\n\tpacket_set_timeout(options.server_alive_interval,\n\t    options.server_alive_count_max);\n\n\tssh = active_state; /* XXX */\n\n\tif (timeout_ms > 0)\n\t\tdebug3(\"timeout: %d ms remain after connect\", timeout_ms);\n\n\t/*\n\t * If we successfully made the connection and we have hostbased auth\n\t * enabled, load the public keys so we can later use the ssh-keysign\n\t * helper to sign challenges.\n\t */\n\tsensitive_data.nkeys = 0;\n\tsensitive_data.keys = NULL;\n\tif (options.hostbased_authentication) {\n\t\tsensitive_data.nkeys = 10;\n\t\tsensitive_data.keys = xcalloc(sensitive_data.nkeys,\n\t\t    sizeof(struct sshkey));\n\n\t\t/* XXX check errors? */\n#define L_PUBKEY(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal(\"%s pubkey out of array bounds\", __func__); \\\n\tcheck_load(sshkey_load_public(p, &(sensitive_data.keys[o]), NULL), \\\n\t    p, \"pubkey\"); \\\n} while (0)\n#define L_CERT(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal(\"%s cert out of array bounds\", __func__); \\\n\tcheck_load(sshkey_load_cert(p, &(sensitive_data.keys[o])), p, \"cert\"); \\\n} while (0)\n\n\t\tif (options.hostbased_authentication == 1) {\n\t\t\tL_CERT(_PATH_HOST_ECDSA_KEY_FILE, 0);\n\t\t\tL_CERT(_PATH_HOST_ED25519_KEY_FILE, 1);\n\t\t\tL_CERT(_PATH_HOST_RSA_KEY_FILE, 2);\n\t\t\tL_CERT(_PATH_HOST_DSA_KEY_FILE, 3);\n\t\t\tL_PUBKEY(_PATH_HOST_ECDSA_KEY_FILE, 4);\n\t\t\tL_PUBKEY(_PATH_HOST_ED25519_KEY_FILE, 5);\n\t\t\tL_PUBKEY(_PATH_HOST_RSA_KEY_FILE, 6);\n\t\t\tL_PUBKEY(_PATH_HOST_DSA_KEY_FILE, 7);\n\t\t\tL_CERT(_PATH_HOST_XMSS_KEY_FILE, 8);\n\t\t\tL_PUBKEY(_PATH_HOST_XMSS_KEY_FILE, 9);\n\t\t}\n\t}\n\n\t/* Create ~/.ssh * directory if it doesn't already exist. */\n\tif (config == NULL) {\n\t\tr = snprintf(buf, sizeof buf, \"%s%s%s\", pw->pw_dir,\n\t\t    strcmp(pw->pw_dir, \"/\") ? \"/\" : \"\", _PATH_SSH_USER_DIR);\n\t\tif (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0) {\n#ifdef WITH_SELINUX\n\t\t\tssh_selinux_setfscreatecon(buf);\n#endif\n\t\t\tif (mkdir(buf, 0700) < 0)\n\t\t\t\terror(\"Could not create directory '%.200s'.\",\n\t\t\t\t    buf);\n#ifdef WITH_SELINUX\n\t\t\tssh_selinux_setfscreatecon(NULL);\n#endif\n\t\t}\n\t}\n\t/* load options.identity_files */\n\tload_public_identity_files(pw);\n\n\t/* optionally set the SSH_AUTHSOCKET_ENV_NAME variable */\n\tif (options.identity_agent &&\n\t    strcmp(options.identity_agent, SSH_AUTHSOCKET_ENV_NAME) != 0) {\n\t\tif (strcmp(options.identity_agent, \"none\") == 0) {\n\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t} else {\n\t\t\tp = tilde_expand_filename(options.identity_agent,\n\t\t\t    getuid());\n\t\t\tcp = percent_expand(p,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"i\", uidstr,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"r\", options.user,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    (char *)NULL);\n\t\t\tfree(p);\n\t\t\t/*\n\t\t\t * If identity_agent represents an environment variable\n\t\t\t * then recheck that it is valid (since processing with\n\t\t\t * percent_expand() may have changed it) and substitute\n\t\t\t * its value.\n\t\t\t */\n\t\t\tif (cp[0] == '$') {\n\t\t\t\tif (!valid_env_name(cp + 1)) {\n\t\t\t\t\tfatal(\"Invalid IdentityAgent \"\n\t\t\t\t\t    \"environment variable name %s\", cp);\n\t\t\t\t}\n\t\t\t\tif ((p = getenv(cp + 1)) == NULL)\n\t\t\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t\t\telse\n\t\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, p, 1);\n\t\t\t} else {\n\t\t\t\t/* identity_agent specifies a path directly */\n\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, cp, 1);\n\t\t\t}\n\t\t\tfree(cp);\n\t\t}\n\t}\n\n\t/* Expand ~ in known host file names. */\n\ttilde_expand_paths(options.system_hostfiles,\n\t    options.num_system_hostfiles);\n\ttilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);\n\n\tsignal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */\n\tsignal(SIGCHLD, main_sigchld_handler);\n\n\t/* Log into the remote system.  Never returns if the login fails. */\n\tssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,\n\t    options.port, pw, timeout_ms);\n\n\tif (packet_connection_is_on_socket()) {\n\t\tverbose(\"Authenticated to %s ([%s]:%d).\", host,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t} else {\n\t\tverbose(\"Authenticated to %s (via proxy).\", host);\n\t}\n\n\t/* We no longer need the private host keys.  Clear them now. */\n\tif (sensitive_data.nkeys != 0) {\n\t\tfor (i = 0; i < sensitive_data.nkeys; i++) {\n\t\t\tif (sensitive_data.keys[i] != NULL) {\n\t\t\t\t/* Destroys contents safely */\n\t\t\t\tdebug3(\"clear hostkey %d\", i);\n\t\t\t\tsshkey_free(sensitive_data.keys[i]);\n\t\t\t\tsensitive_data.keys[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(sensitive_data.keys);\n\t}\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tfree(options.identity_files[i]);\n\t\toptions.identity_files[i] = NULL;\n\t\tif (options.identity_keys[i]) {\n\t\t\tsshkey_free(options.identity_keys[i]);\n\t\t\toptions.identity_keys[i] = NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t}\n\n skip_connect:\n\texit_status = ssh_session2(ssh, pw);\n\tpacket_close();\n\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\n\t/* Kill ProxyCommand if it is running. */\n\tssh_kill_proxy_command();\n\n\treturn exit_status;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *__progname;",
      "int debug_flag = 0;",
      "int tty_flag = 0;",
      "int no_shell_flag = 0;",
      "int stdin_null_flag = 0;",
      "int fork_after_authentication_flag = 0;",
      "Options options;",
      "char *config = NULL;",
      "char *host;",
      "static char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];",
      "static char uidstr[32], *host_arg, *conn_hash_hex;",
      "struct sockaddr_storage hostaddr;",
      "Sensitive sensitive_data;",
      "struct sshbuf *command;",
      "int subsystem_flag = 0;",
      "extern int muxserver_sock;",
      "extern u_int muxclient_command;",
      "static int ssh_session2(struct ssh *, struct passwd *);",
      "static void load_public_identity_files(struct passwd *);",
      "static void main_sigchld_handler(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_kill_proxy_command",
          "args": [],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_kill_proxy_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "256-265",
          "snippet": "void\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t proxy_command_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t proxy_command_pid = 0;\n\nvoid\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.control_path"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_close",
          "args": [],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "packet_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "255-260",
          "snippet": "void\npacket_close(void)\n{\n\tssh_packet_close(active_state);\n\tactive_state = NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_close(void)\n{\n\tssh_packet_close(active_state);\n\tactive_state = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_session2",
          "args": [
            "ssh",
            "pw"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_session2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1858-1976",
          "snippet": "static int\nssh_session2(struct ssh *ssh, struct passwd *pw)\n{\n\tint devnull, id = -1;\n\tchar *cp, *tun_fwd_ifname = NULL;\n\n\t/* XXX should be pre-session */\n\tif (!options.control_persist)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tssh_init_forwarding(ssh, &tun_fwd_ifname);\n\n\tif (options.local_command != NULL) {\n\t\tdebug3(\"expanding LocalCommand: %s\", options.local_command);\n\t\tcp = options.local_command;\n\t\toptions.local_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"T\", tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded LocalCommand: %s\", options.local_command);\n\t\tfree(cp);\n\t}\n\n\t/* Start listening for multiplex clients */\n\tif (!packet_get_mux())\n\t\tmuxserver_listen(ssh);\n\n\t/*\n\t * If we are in control persist mode and have a working mux listen\n\t * socket, then prepare to background ourselves and have a foreground\n\t * client attach as a control slave.\n\t * NB. we must save copies of the flags that we override for\n\t * the backgrounding, since we defer attachment of the slave until\n\t * after the connection is fully established (in particular,\n\t * async rfwd replies have been received for ExitOnForwardFailure).\n\t */\n\tif (options.control_persist && muxserver_sock != -1) {\n\t\tostdin_null_flag = stdin_null_flag;\n\t\tono_shell_flag = no_shell_flag;\n\t\torequest_tty = options.request_tty;\n\t\totty_flag = tty_flag;\n\t\tstdin_null_flag = 1;\n\t\tno_shell_flag = 1;\n\t\ttty_flag = 0;\n\t\tif (!fork_after_authentication_flag)\n\t\t\tneed_controlpersist_detach = 1;\n\t\tfork_after_authentication_flag = 1;\n\t}\n\t/*\n\t * ControlPersist mux listen socket setup failed, attempt the\n\t * stdio forward setup that we skipped earlier.\n\t */\n\tif (options.control_persist && muxserver_sock == -1)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tif (!no_shell_flag)\n\t\tid = ssh_session2_open(ssh);\n\telse {\n\t\tpacket_set_interactive(\n\t\t    options.control_master == SSHCTL_MASTER_NO,\n\t\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\t}\n\n\t/* If we don't expect to open a new session, then disallow it */\n\tif (options.control_master == SSHCTL_MASTER_NO &&\n\t    (datafellows & SSH_NEW_OPENSSH)) {\n\t\tdebug(\"Requesting no-more-sessions@openssh.com\");\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"no-more-sessions@openssh.com\");\n\t\tpacket_put_char(0);\n\t\tpacket_send();\n\t}\n\n\t/* Execute a local command */\n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t/*\n\t * stdout is now owned by the session channel; clobber it here\n\t * so future channel closes are propagated to the local fd.\n\t * NB. this can only happen after LocalCommand has completed,\n\t * as it may want to write to stdout.\n\t */\n\tif (!need_controlpersist_detach) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_WRONLY)) == -1)\n\t\t\terror(\"%s: open %s: %s\", __func__,\n\t\t\t    _PATH_DEVNULL, strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2() stdout failed\", __func__);\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\t/*\n\t * If requested and we are not interested in replies to remote\n\t * forwarding requests, then let ssh continue in the background.\n\t */\n\tif (fork_after_authentication_flag) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\treturn client_loop(ssh, tty_flag, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tty_flag = 0;",
            "int no_shell_flag = 0;",
            "int stdin_null_flag = 0;",
            "int need_controlpersist_detach = 0;",
            "int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;",
            "int fork_after_authentication_flag = 0;",
            "Options options;",
            "char *host;",
            "static char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];",
            "static char uidstr[32], *host_arg, *conn_hash_hex;",
            "struct sshbuf *command;",
            "extern int muxserver_sock;",
            "static int ssh_session2(struct ssh *, struct passwd *);",
            "static void load_public_identity_files(struct passwd *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint tty_flag = 0;\nint no_shell_flag = 0;\nint stdin_null_flag = 0;\nint need_controlpersist_detach = 0;\nint ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;\nint fork_after_authentication_flag = 0;\nOptions options;\nchar *host;\nstatic char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\nstatic char uidstr[32], *host_arg, *conn_hash_hex;\nstruct sshbuf *command;\nextern int muxserver_sock;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic int\nssh_session2(struct ssh *ssh, struct passwd *pw)\n{\n\tint devnull, id = -1;\n\tchar *cp, *tun_fwd_ifname = NULL;\n\n\t/* XXX should be pre-session */\n\tif (!options.control_persist)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tssh_init_forwarding(ssh, &tun_fwd_ifname);\n\n\tif (options.local_command != NULL) {\n\t\tdebug3(\"expanding LocalCommand: %s\", options.local_command);\n\t\tcp = options.local_command;\n\t\toptions.local_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"T\", tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded LocalCommand: %s\", options.local_command);\n\t\tfree(cp);\n\t}\n\n\t/* Start listening for multiplex clients */\n\tif (!packet_get_mux())\n\t\tmuxserver_listen(ssh);\n\n\t/*\n\t * If we are in control persist mode and have a working mux listen\n\t * socket, then prepare to background ourselves and have a foreground\n\t * client attach as a control slave.\n\t * NB. we must save copies of the flags that we override for\n\t * the backgrounding, since we defer attachment of the slave until\n\t * after the connection is fully established (in particular,\n\t * async rfwd replies have been received for ExitOnForwardFailure).\n\t */\n\tif (options.control_persist && muxserver_sock != -1) {\n\t\tostdin_null_flag = stdin_null_flag;\n\t\tono_shell_flag = no_shell_flag;\n\t\torequest_tty = options.request_tty;\n\t\totty_flag = tty_flag;\n\t\tstdin_null_flag = 1;\n\t\tno_shell_flag = 1;\n\t\ttty_flag = 0;\n\t\tif (!fork_after_authentication_flag)\n\t\t\tneed_controlpersist_detach = 1;\n\t\tfork_after_authentication_flag = 1;\n\t}\n\t/*\n\t * ControlPersist mux listen socket setup failed, attempt the\n\t * stdio forward setup that we skipped earlier.\n\t */\n\tif (options.control_persist && muxserver_sock == -1)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tif (!no_shell_flag)\n\t\tid = ssh_session2_open(ssh);\n\telse {\n\t\tpacket_set_interactive(\n\t\t    options.control_master == SSHCTL_MASTER_NO,\n\t\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\t}\n\n\t/* If we don't expect to open a new session, then disallow it */\n\tif (options.control_master == SSHCTL_MASTER_NO &&\n\t    (datafellows & SSH_NEW_OPENSSH)) {\n\t\tdebug(\"Requesting no-more-sessions@openssh.com\");\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"no-more-sessions@openssh.com\");\n\t\tpacket_put_char(0);\n\t\tpacket_send();\n\t}\n\n\t/* Execute a local command */\n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t/*\n\t * stdout is now owned by the session channel; clobber it here\n\t * so future channel closes are propagated to the local fd.\n\t * NB. this can only happen after LocalCommand has completed,\n\t * as it may want to write to stdout.\n\t */\n\tif (!need_controlpersist_detach) {\n\t\tif ((devnull = open(_PATH_DEVNULL, O_WRONLY)) == -1)\n\t\t\terror(\"%s: open %s: %s\", __func__,\n\t\t\t    _PATH_DEVNULL, strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2() stdout failed\", __func__);\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t}\n\n\t/*\n\t * If requested and we are not interested in replies to remote\n\t * forwarding requests, then let ssh continue in the background.\n\t */\n\tif (fork_after_authentication_flag) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\treturn client_loop(ssh, tty_flag, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.certificate_files[i]"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "options.identity_keys[i]"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"clear hostkey %d\"",
            "i"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Authenticated to %s (via proxy).\"",
            "host"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_connection_is_on_socket",
          "args": [],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_login",
          "args": [
            "&sensitive_data",
            "host",
            "(struct sockaddr *)&hostaddr",
            "options.port",
            "pw",
            "timeout_ms"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1399-1425",
          "snippet": "void\nssh_login(Sensitive *sensitive, const char *orighost,\n    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms)\n{\n\tchar *host;\n\tchar *server_user, *local_user;\n\n\tlocal_user = xstrdup(pw->pw_name);\n\tserver_user = options.user ? options.user : local_user;\n\n\t/* Convert the user-supplied hostname into all lowercase. */\n\thost = xstrdup(orighost);\n\tlowercase(host);\n\n\t/* Exchange protocol version identification strings with the server. */\n\tssh_exchange_identification(timeout_ms);\n\n\t/* Put the connection into non-blocking mode. */\n\tpacket_set_nonblocking();\n\n\t/* key exchange */\n\t/* authenticate user */\n\tdebug(\"Authenticating to %s:%d as '%s'\", host, port, server_user);\n\tssh_kex2(host, hostaddr, port);\n\tssh_userauth2(local_user, server_user, host, sensitive);\n\tfree(local_user);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nssh_login(Sensitive *sensitive, const char *orighost,\n    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms)\n{\n\tchar *host;\n\tchar *server_user, *local_user;\n\n\tlocal_user = xstrdup(pw->pw_name);\n\tserver_user = options.user ? options.user : local_user;\n\n\t/* Convert the user-supplied hostname into all lowercase. */\n\thost = xstrdup(orighost);\n\tlowercase(host);\n\n\t/* Exchange protocol version identification strings with the server. */\n\tssh_exchange_identification(timeout_ms);\n\n\t/* Put the connection into non-blocking mode. */\n\tpacket_set_nonblocking();\n\n\t/* key exchange */\n\t/* authenticate user */\n\tdebug(\"Authenticating to %s:%d as '%s'\", host, port, server_user);\n\tssh_kex2(host, hostaddr, port);\n\tssh_userauth2(local_user, server_user, host, sensitive);\n\tfree(local_user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "main_sigchld_handler"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_paths",
          "args": [
            "options.user_hostfiles",
            "options.num_user_hostfiles"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "215-226",
          "snippet": "static void\ntilde_expand_paths(char **paths, u_int num_paths)\n{\n\tu_int i;\n\tchar *cp;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tcp = tilde_expand_filename(paths[i], getuid());\n\t\tfree(paths[i]);\n\t\tpaths[i] = cp;\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ntilde_expand_paths(char **paths, u_int num_paths)\n{\n\tu_int i;\n\tchar *cp;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tcp = tilde_expand_filename(paths[i], getuid());\n\t\tfree(paths[i]);\n\t\tpaths[i] = cp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "SSH_AUTHSOCKET_ENV_NAME",
            "cp",
            "1"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "setenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setenv.c",
          "lines": "131-188",
          "snippet": "int\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "SSH_AUTHSOCKET_ENV_NAME"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "unsetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setenv.c",
          "lines": "197-222",
          "snippet": "int\nunsetenv(const char *name)\n{\n\tchar **P;\n\tconst char *np;\n\tint offset = 0;\n\n\tif (!name || !*name) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n\n\t/* could be set multiple times */\n\twhile (__findenv(name, (int)(np - name), &offset)) {\n\t\tfor (P = &environ[offset];; ++P)\n\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\tbreak;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nunsetenv(const char *name)\n{\n\tchar **P;\n\tconst char *np;\n\tint offset = 0;\n\n\tif (!name || !*name) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n\n\t/* could be set multiple times */\n\twhile (__findenv(name, (int)(np - name), &offset)) {\n\t\tfor (P = &environ[offset];; ++P)\n\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\tbreak;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "cp + 1"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid IdentityAgent \"\n\t\t\t\t\t    \"environment variable name %s\"",
            "cp"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_env_name",
          "args": [
            "cp + 1"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "valid_env_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1960-1972",
          "snippet": "int\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "p",
            "\"d\"",
            "pw->pw_dir",
            "\"h\"",
            "host",
            "\"i\"",
            "uidstr",
            "\"l\"",
            "thishost",
            "\"r\"",
            "options.user",
            "\"u\"",
            "pw->pw_name",
            "(char *)NULL"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "options.identity_agent",
            "getuid()"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options.identity_agent",
            "\"none\""
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_public_identity_files",
          "args": [
            "pw"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "load_public_identity_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "1979-2132",
          "snippet": "static void\nload_public_identity_files(struct passwd *pw)\n{\n\tchar *filename, *cp;\n\tstruct sshkey *public;\n\tint i;\n\tu_int n_ids, n_certs;\n\tchar *identity_files[SSH_MAX_IDENTITY_FILES];\n\tstruct sshkey *identity_keys[SSH_MAX_IDENTITY_FILES];\n\tint identity_file_userprovided[SSH_MAX_IDENTITY_FILES];\n\tchar *certificate_files[SSH_MAX_CERTIFICATE_FILES];\n\tstruct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];\n\tint certificate_file_userprovided[SSH_MAX_CERTIFICATE_FILES];\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys;\n\tint nkeys;\n#endif /* PKCS11 */\n\n\tn_ids = n_certs = 0;\n\tmemset(identity_files, 0, sizeof(identity_files));\n\tmemset(identity_keys, 0, sizeof(identity_keys));\n\tmemset(identity_file_userprovided, 0,\n\t    sizeof(identity_file_userprovided));\n\tmemset(certificate_files, 0, sizeof(certificate_files));\n\tmemset(certificates, 0, sizeof(certificates));\n\tmemset(certificate_file_userprovided, 0,\n\t    sizeof(certificate_file_userprovided));\n\n#ifdef ENABLE_PKCS11\n\tif (options.pkcs11_provider != NULL &&\n\t    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&\n\t    (pkcs11_init(!options.batch_mode) == 0) &&\n\t    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,\n\t    &keys)) > 0) {\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\tsshkey_free(keys[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidentity_keys[n_ids] = keys[i];\n\t\t\tidentity_files[n_ids] =\n\t\t\t    xstrdup(options.pkcs11_provider); /* XXX */\n\t\t\tn_ids++;\n\t\t}\n\t\tfree(keys);\n\t}\n#endif /* ENABLE_PKCS11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES ||\n\t\t    strcasecmp(options.identity_files[i], \"none\") == 0) {\n\t\t\tfree(options.identity_files[i]);\n\t\t\toptions.identity_files[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcp = tilde_expand_filename(options.identity_files[i], getuid());\n\t\tfilename = percent_expand(cp, \"d\", pw->pw_dir,\n\t\t    \"u\", pw->pw_name, \"l\", thishost, \"h\", host,\n\t\t    \"r\", options.user, (char *)NULL);\n\t\tfree(cp);\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.identity_files[i]);\n\t\tidentity_files[n_ids] = filename;\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tif (++n_ids >= SSH_MAX_IDENTITY_FILES)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no certificates have been explicitly listed then try\n\t\t * to add the default certificate variant too.\n\t\t */\n\t\tif (options.num_certificate_files != 0)\n\t\t\tcontinue;\n\t\txasprintf(&cp, \"%s-cert\", filename);\n\t\tcheck_load(sshkey_load_public(cp, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", cp,\n\t\t    public ? public->type : -1);\n\t\tif (public == NULL) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, cp, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* NB. leave filename pointing to private key */\n\t\tidentity_files[n_ids] = xstrdup(filename);\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tn_ids++;\n\t}\n\n\tif (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"%s: too many certificates\", __func__);\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tcp = tilde_expand_filename(options.certificate_files[i],\n\t\t    getuid());\n\t\tfilename = percent_expand(cp,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"certificate\");\n\t\tdebug(\"certificate file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t\tif (public == NULL) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, filename, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tcertificate_files[n_certs] = filename;\n\t\tcertificates[n_certs] = public;\n\t\tcertificate_file_userprovided[n_certs] =\n\t\t    options.certificate_file_userprovided[i];\n\t\t++n_certs;\n\t}\n\n\toptions.num_identity_files = n_ids;\n\tmemcpy(options.identity_files, identity_files, sizeof(identity_files));\n\tmemcpy(options.identity_keys, identity_keys, sizeof(identity_keys));\n\tmemcpy(options.identity_file_userprovided,\n\t    identity_file_userprovided, sizeof(identity_file_userprovided));\n\n\toptions.num_certificate_files = n_certs;\n\tmemcpy(options.certificate_files,\n\t    certificate_files, sizeof(certificate_files));\n\tmemcpy(options.certificates, certificates, sizeof(certificates));\n\tmemcpy(options.certificate_file_userprovided,\n\t    certificate_file_userprovided,\n\t    sizeof(certificate_file_userprovided));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;",
            "char *host;",
            "static char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];",
            "static char uidstr[32], *host_arg, *conn_hash_hex;",
            "static int ssh_session2(struct ssh *, struct passwd *);",
            "static void load_public_identity_files(struct passwd *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\nstatic char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\nstatic char uidstr[32], *host_arg, *conn_hash_hex;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic void\nload_public_identity_files(struct passwd *pw)\n{\n\tchar *filename, *cp;\n\tstruct sshkey *public;\n\tint i;\n\tu_int n_ids, n_certs;\n\tchar *identity_files[SSH_MAX_IDENTITY_FILES];\n\tstruct sshkey *identity_keys[SSH_MAX_IDENTITY_FILES];\n\tint identity_file_userprovided[SSH_MAX_IDENTITY_FILES];\n\tchar *certificate_files[SSH_MAX_CERTIFICATE_FILES];\n\tstruct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];\n\tint certificate_file_userprovided[SSH_MAX_CERTIFICATE_FILES];\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys;\n\tint nkeys;\n#endif /* PKCS11 */\n\n\tn_ids = n_certs = 0;\n\tmemset(identity_files, 0, sizeof(identity_files));\n\tmemset(identity_keys, 0, sizeof(identity_keys));\n\tmemset(identity_file_userprovided, 0,\n\t    sizeof(identity_file_userprovided));\n\tmemset(certificate_files, 0, sizeof(certificate_files));\n\tmemset(certificates, 0, sizeof(certificates));\n\tmemset(certificate_file_userprovided, 0,\n\t    sizeof(certificate_file_userprovided));\n\n#ifdef ENABLE_PKCS11\n\tif (options.pkcs11_provider != NULL &&\n\t    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&\n\t    (pkcs11_init(!options.batch_mode) == 0) &&\n\t    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,\n\t    &keys)) > 0) {\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\tsshkey_free(keys[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidentity_keys[n_ids] = keys[i];\n\t\t\tidentity_files[n_ids] =\n\t\t\t    xstrdup(options.pkcs11_provider); /* XXX */\n\t\t\tn_ids++;\n\t\t}\n\t\tfree(keys);\n\t}\n#endif /* ENABLE_PKCS11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES ||\n\t\t    strcasecmp(options.identity_files[i], \"none\") == 0) {\n\t\t\tfree(options.identity_files[i]);\n\t\t\toptions.identity_files[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcp = tilde_expand_filename(options.identity_files[i], getuid());\n\t\tfilename = percent_expand(cp, \"d\", pw->pw_dir,\n\t\t    \"u\", pw->pw_name, \"l\", thishost, \"h\", host,\n\t\t    \"r\", options.user, (char *)NULL);\n\t\tfree(cp);\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.identity_files[i]);\n\t\tidentity_files[n_ids] = filename;\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tif (++n_ids >= SSH_MAX_IDENTITY_FILES)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no certificates have been explicitly listed then try\n\t\t * to add the default certificate variant too.\n\t\t */\n\t\tif (options.num_certificate_files != 0)\n\t\t\tcontinue;\n\t\txasprintf(&cp, \"%s-cert\", filename);\n\t\tcheck_load(sshkey_load_public(cp, &public, NULL),\n\t\t    filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", cp,\n\t\t    public ? public->type : -1);\n\t\tif (public == NULL) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, cp, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* NB. leave filename pointing to private key */\n\t\tidentity_files[n_ids] = xstrdup(filename);\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tn_ids++;\n\t}\n\n\tif (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"%s: too many certificates\", __func__);\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tcp = tilde_expand_filename(options.certificate_files[i],\n\t\t    getuid());\n\t\tfilename = percent_expand(cp,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    filename, \"certificate\");\n\t\tdebug(\"certificate file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t\tif (public == NULL) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug(\"%s: key %s type %s is not a certificate\",\n\t\t\t    __func__, filename, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tcertificate_files[n_certs] = filename;\n\t\tcertificates[n_certs] = public;\n\t\tcertificate_file_userprovided[n_certs] =\n\t\t    options.certificate_file_userprovided[i];\n\t\t++n_certs;\n\t}\n\n\toptions.num_identity_files = n_ids;\n\tmemcpy(options.identity_files, identity_files, sizeof(identity_files));\n\tmemcpy(options.identity_keys, identity_keys, sizeof(identity_keys));\n\tmemcpy(options.identity_file_userprovided,\n\t    identity_file_userprovided, sizeof(identity_file_userprovided));\n\n\toptions.num_certificate_files = n_certs;\n\tmemcpy(options.certificate_files,\n\t    certificate_files, sizeof(certificate_files));\n\tmemcpy(options.certificates, certificates, sizeof(certificates));\n\tmemcpy(options.certificate_file_userprovided,\n\t    certificate_file_userprovided,\n\t    sizeof(certificate_file_userprovided));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_selinux_setfscreatecon",
          "args": [
            "NULL"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_selinux_setfscreatecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "224-237",
          "snippet": "void\nssh_selinux_setfscreatecon(const char *path)\n{\n\tsecurity_context_t context;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\tif (path == NULL) {\n\t\tsetfscreatecon(NULL);\n\t\treturn;\n\t}\n\tif (matchpathcon(path, 0700, &context) == 0)\n\t\tsetfscreatecon(context);\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nssh_selinux_setfscreatecon(const char *path)\n{\n\tsecurity_context_t context;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\tif (path == NULL) {\n\t\tsetfscreatecon(NULL);\n\t\treturn;\n\t}\n\tif (matchpathcon(path, 0700, &context) == 0)\n\t\tsetfscreatecon(context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Could not create directory '%.200s'.\"",
            "buf"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "buf",
            "0700"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "buf",
            "&st"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%s%s%s\"",
            "pw->pw_dir",
            "strcmp(pw->pw_dir, \"/\") ? \"/\" : \"\"",
            "_PATH_SSH_USER_DIR"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "L_PUBKEY",
          "args": [
            "_PATH_HOST_XMSS_KEY_FILE",
            "9"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_CERT",
          "args": [
            "_PATH_HOST_XMSS_KEY_FILE",
            "8"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_PUBKEY",
          "args": [
            "_PATH_HOST_DSA_KEY_FILE",
            "7"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_PUBKEY",
          "args": [
            "_PATH_HOST_RSA_KEY_FILE",
            "6"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_PUBKEY",
          "args": [
            "_PATH_HOST_ED25519_KEY_FILE",
            "5"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_PUBKEY",
          "args": [
            "_PATH_HOST_ECDSA_KEY_FILE",
            "4"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_CERT",
          "args": [
            "_PATH_HOST_DSA_KEY_FILE",
            "3"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_CERT",
          "args": [
            "_PATH_HOST_RSA_KEY_FILE",
            "2"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_CERT",
          "args": [
            "_PATH_HOST_ED25519_KEY_FILE",
            "1"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L_CERT",
          "args": [
            "_PATH_HOST_ECDSA_KEY_FILE",
            "0"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "sensitive_data.nkeys",
            "sizeof(struct sshkey)"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_timeout",
          "args": [
            "options.server_alive_interval",
            "options.server_alive_count_max"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "addrs"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "255"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_connect",
          "args": [
            "ssh",
            "host",
            "addrs",
            "&hostaddr",
            "options.port",
            "options.address_family",
            "options.connection_attempts",
            "&timeout_ms",
            "options.tcp_keep_alive"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "583-601",
          "snippet": "int\nssh_connect(struct ssh *ssh, const char *host, struct addrinfo *addrs,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tif (options.proxy_command == NULL) {\n\t\treturn ssh_connect_direct(ssh, host, addrs, hostaddr, port,\n\t\t    family, connection_attempts, timeout_ms, want_keepalive);\n\t} else if (strcmp(options.proxy_command, \"-\") == 0) {\n\t\tif ((ssh_packet_set_connection(ssh,\n\t\t    STDIN_FILENO, STDOUT_FILENO)) == NULL)\n\t\t\treturn -1; /* ssh_packet_set_connection logs error */\n\t\treturn 0;\n\t} else if (options.proxy_use_fdpass) {\n\t\treturn ssh_proxy_fdpass_connect(ssh, host, port,\n\t\t    options.proxy_command);\n\t}\n\treturn ssh_proxy_connect(ssh, host, port, options.proxy_command);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nint\nssh_connect(struct ssh *ssh, const char *host, struct addrinfo *addrs,\n    struct sockaddr_storage *hostaddr, u_short port, int family,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tif (options.proxy_command == NULL) {\n\t\treturn ssh_connect_direct(ssh, host, addrs, hostaddr, port,\n\t\t    family, connection_attempts, timeout_ms, want_keepalive);\n\t} else if (strcmp(options.proxy_command, \"-\") == 0) {\n\t\tif ((ssh_packet_set_connection(ssh,\n\t\t    STDIN_FILENO, STDOUT_FILENO)) == NULL)\n\t\t\treturn -1; /* ssh_packet_set_connection logs error */\n\t\treturn 0;\n\t} else if (options.proxy_use_fdpass) {\n\t\treturn ssh_proxy_fdpass_connect(ssh, host, port,\n\t\t    options.proxy_command);\n\t}\n\treturn ssh_proxy_connect(ssh, host, port, options.proxy_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_host",
          "args": [
            "host",
            "options.port",
            "1",
            "cname",
            "sizeof(cname)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "234-267",
          "snippet": "static struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *__progname;",
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"resolving \\\"%s\\\" port %d\"",
            "host",
            "options.port"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_mux",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_connection",
          "args": [
            "ssh",
            "sock",
            "sock"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "282-317",
          "snippet": "struct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror(\"%s: cannot load cipher 'none'\", __func__);\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror(\"%s: cound not allocate state\", __func__);\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror(\"%s: cipher_init failed: %s\", __func__, ssh_err(r));\n\t\tfree(ssh); /* XXX need ssh_free_session_state? */\n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t/*\n\t * Cache the IP address of the remote connection for use in error\n\t * messages that might be generated after the connection has closed.\n\t */\n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "muxclient",
          "args": [
            "options.control_path"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "muxclient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "2284-2391",
          "snippet": "int\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "u_int muxclient_command = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_int muxclient_command = 0;\n\nint\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master\");\n\t\t/* FALLTHROUGH */\n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t     (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\tfatal(\"%s socket(): %s\", __func__, strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\tif (mux_client_hello_exchange(sock) != 0) {\n\t\terror(\"%s: master hello exchange failed\", __func__);\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal(\"%s: master alive check failed\", __func__);\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal(\"%s: master forward request failed\", __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror(\"%s: master forward request failed\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror(\"%s: master cancel forward request failed\",\n\t\t\t    __func__);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"No ControlPath specified for \\\"-O\\\" command\""
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_client_config",
          "args": [
            "&options",
            "host"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "dump_client_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2568-2757",
          "snippet": "void\ndump_client_config(Options *o, const char *host)\n{\n\tint i;\n\tchar buf[8], *all_key;\n\n\t/* This is normally prepared in ssh_kex2 */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif (kex_assemble_names( &o->hostkeyalgorithms,\n\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\tfatal(\"%s: kex_assemble_names failed\", __func__);\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostName, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers ? o->ciphers : KEX_CLIENT_ENCRYPT);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedKeyTypes, o->hostbased_key_types);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms ? o->kex_algorithms : KEX_CLIENT_KEX);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms ? o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs ? o->macs : KEX_CLIENT_MAC);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedKeyTypes, o->pubkey_key_types);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\n\t/* Special cases */\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndump_client_config(Options *o, const char *host)\n{\n\tint i;\n\tchar buf[8], *all_key;\n\n\t/* This is normally prepared in ssh_kex2 */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif (kex_assemble_names( &o->hostkeyalgorithms,\n\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\tfatal(\"%s: kex_assemble_names failed\", __func__);\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostName, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers ? o->ciphers : KEX_CLIENT_ENCRYPT);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedKeyTypes, o->hostbased_key_types);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms ? o->kex_algorithms : KEX_CLIENT_KEX);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms ? o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs ? o->macs : KEX_CLIENT_MAC);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedKeyTypes, o->pubkey_key_types);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\n\t/* Special cases */\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "command",
            "options.remote_command",
            "strlen(options.remote_command)"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "options.remote_command"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohex",
          "args": [
            "conn_hash",
            "ssh_digest_bytes(SSH_DIGEST_SHA1)"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "tohex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1132-1149",
          "snippet": "char *\ntohex(const void *vp, size_t l)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tchar b[3], *r;\n\tsize_t i, hl;\n\n\tif (l > 65536)\n\t\treturn xstrdup(\"tohex: length > 65536\");\n\n\thl = l * 2 + 1;\n\tr = xcalloc(1, hl);\n\tfor (i = 0; i < l; i++) {\n\t\tsnprintf(b, sizeof(b), \"%02x\", p[i]);\n\t\tstrlcat(r, b, hl);\n\t}\n\treturn (r);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntohex(const void *vp, size_t l)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tchar b[3], *r;\n\tsize_t i, hl;\n\n\tif (l > 65536)\n\t\treturn xstrdup(\"tohex: length > 65536\");\n\n\thl = l * 2 + 1;\n\tr = xcalloc(1, hl);\n\tfor (i = 0; i < l; i++) {\n\t\tsnprintf(b, sizeof(b), \"%02x\", p[i]);\n\t\tstrlcat(r, b, hl);\n\t}\n\treturn (r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_bytes",
          "args": [
            "SSH_DIGEST_SHA1"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "143-149",
          "snippet": "size_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_free",
          "args": [
            "md"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "219-233",
          "snippet": "void\nssh_digest_free(struct ssh_digest_ctx *ctx)\n{\n\tconst struct ssh_digest *digest;\n\n\tif (ctx != NULL) {\n\t\tdigest = ssh_digest_by_alg(ctx->alg);\n\t\tif (digest) {\n\t\t\texplicit_bzero(ctx->mdctx, digest->ctx_len);\n\t\t\tfree(ctx->mdctx);\n\t\t\texplicit_bzero(ctx, sizeof(*ctx));\n\t\t\tfree(ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_digest_free(struct ssh_digest_ctx *ctx)\n{\n\tconst struct ssh_digest *digest;\n\n\tif (ctx != NULL) {\n\t\tdigest = ssh_digest_by_alg(ctx->alg);\n\t\tif (digest) {\n\t\t\texplicit_bzero(ctx->mdctx, digest->ctx_len);\n\t\t\tfree(ctx->mdctx);\n\t\t\texplicit_bzero(ctx, sizeof(*ctx));\n\t\t\tfree(ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_final",
          "args": [
            "md",
            "conn_hash",
            "sizeof(conn_hash)"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "204-217",
          "snippet": "int\nssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen > UINT_MAX)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen < digest->digest_len) /* No truncation allowed */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_final(d, ctx->mdctx);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen > UINT_MAX)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen < digest->digest_len) /* No truncation allowed */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_final(d, ctx->mdctx);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_update",
          "args": [
            "md",
            "options.user",
            "strlen(options.user)"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "187-196",
          "snippet": "int\nssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_update(ctx->mdctx, m, mlen);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_update(ctx->mdctx, m, mlen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "options.user"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "portstr"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "thishost"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_digest_start",
          "args": [
            "SSH_DIGEST_SHA1"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "159-174",
          "snippet": "struct ssh_digest_ctx *\nssh_digest_start(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\tstruct ssh_digest_ctx *ret;\n\n\tif (digest == NULL || (ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->mdctx = calloc(1, digest->ctx_len)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->alg = alg;\n\tdigest->md_init(ret->mdctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_digest_ctx *\nssh_digest_start(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\tstruct ssh_digest_ctx *ret;\n\n\tif (digest == NULL || (ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->mdctx = calloc(1, digest->ctx_len)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->alg = alg;\n\tdigest->md_init(ret->mdctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "thishost",
            "\".\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "shorthost",
            "thishost",
            "sizeof(shorthost)"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "thishost",
            "sizeof(thishost)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "pw->pw_name"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed_rng",
          "args": [],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "seed_rng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "247-250",
          "snippet": "void\nseed_rng(void)\n{\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nseed_rng(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Pseudo-terminal will not be allocated because \"\n\t\t\t    \"stdin is not a terminal.\""
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fileno(stdin)"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "command"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "argv0",
            "options.log_level",
            "options.log_facility",
            "!use_syslog"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "options.host_key_alias"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_set_af",
          "args": [
            "ssh",
            "options.address_family"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "channel_set_af",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3278-3282",
          "snippet": "void\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_ssh_port",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "default_ssh_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "461-472",
          "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&options.proxy_command",
            "\"%s%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s\"",
            "sshbin",
            "/* Optional \"-l user\" argument if jump_user set */options.jump_user == NULL ? \"\" : \" -l \"",
            "options.jump_user == NULL ? \"\" : options.jump_user",
            "/* Optional \"-p port\" argument if jump_port set */options.jump_port <= 0 ? \"\" : \" -p \"",
            "options.jump_port <= 0 ? \"\" : port_s",
            "/* Optional additional jump hosts \",...\" */options.jump_extra == NULL ? \"\" : \" -J \"",
            "options.jump_extra == NULL ? \"\" : options.jump_extra",
            "/* Optional \"-F\" argumment if -F specified */config == NULL ? \"\" : \" -F \"",
            "config == NULL ? \"\" : config",
            "/* Optional \"-v\" arguments if -v set */debug_flag ? \" -\" : \"\"",
            "debug_flag",
            "\"vvv\"",
            "/* Mandatory hostname */options.jump_host"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "argv0",
            "X_OK"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv0",
            "'/'"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_default_options",
          "args": [
            "&options"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "fill_default_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1950-2149",
          "snippet": "void\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_addrinfo_port",
          "args": [
            "addrs",
            "options.port"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "set_addrinfo_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "557-574",
          "snippet": "static void\nset_addrinfo_port(struct addrinfo *addrs, int port)\n{\n\tstruct addrinfo *addr;\n\n\tfor (addr = addrs; addr != NULL; addr = addr->ai_next) {\n\t\tswitch (addr->ai_family) {\n\t\tcase AF_INET:\n\t\t\t((struct sockaddr_in *)addr->ai_addr)->\n\t\t\t    sin_port = htons(port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t((struct sockaddr_in6 *)addr->ai_addr)->\n\t\t\t    sin6_port = htons(port);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nset_addrinfo_port(struct addrinfo *addrs, int port)\n{\n\tstruct addrinfo *addr;\n\n\tfor (addr = addrs; addr != NULL; addr = addr->ai_next) {\n\t\tswitch (addr->ai_family) {\n\t\tcase AF_INET:\n\t\t\t((struct sockaddr_in *)addr->ai_addr)->\n\t\t\t    sin_port = htons(port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t((struct sockaddr_in6 *)addr->ai_addr)->\n\t\t\t    sin6_port = htons(port);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_config_files",
          "args": [
            "host_arg",
            "pw",
            "1"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "process_config_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "529-554",
          "snippet": "static void\nprocess_config_files(const char *host_name, struct passwd *pw, int post_canon)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_name, &options,\n\t\t    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_name,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (post_canon ? SSHCONF_POSTCANON : 0));\n\n\t\t/* Read systemwide configuration file after user config. */\n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_name, &options,\n\t\t    post_canon ? SSHCONF_POSTCANON : 0);\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;",
            "char *config = NULL;",
            "char *host;",
            "static int ssh_session2(struct ssh *, struct passwd *);",
            "static void load_public_identity_files(struct passwd *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *config = NULL;\nchar *host;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic void\nprocess_config_files(const char *host_name, struct passwd *pw, int post_canon)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_name, &options,\n\t\t    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_name,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (post_canon ? SSHCONF_POSTCANON : 0));\n\n\t\t/* Read systemwide configuration file after user config. */\n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_name, &options,\n\t\t    post_canon ? SSHCONF_POSTCANON : 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_follow_cname",
          "args": [
            "direct",
            "&host",
            "cname"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "check_follow_cname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "362-393",
          "snippet": "static int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\n\nstatic int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "option_clear_or_none",
          "args": [
            "options.proxy_command"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "option_clear_or_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "186-190",
          "snippet": "static int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_canonicalize",
          "args": [
            "&host",
            "options.port"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_canonicalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "401-499",
          "snippet": "static struct addrinfo *\nresolve_canonicalize(char **hostp, int port)\n{\n\tint i, direct, ndots;\n\tchar *cp, *fullhost, newname[NI_MAXHOST];\n\tstruct addrinfo *addrs;\n\n\t/*\n\t * Attempt to canonicalise addresses, regardless of\n\t * whether hostname canonicalisation was requested\n\t */\n\tif ((addrs = resolve_addr(*hostp, port,\n\t    newname, sizeof(newname))) != NULL) {\n\t\tdebug2(\"%s: hostname %.100s is address\", __func__, *hostp);\n\t\tif (strcasecmp(*hostp, newname) != 0) {\n\t\t\tdebug2(\"%s: canonicalised address \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    __func__, *hostp, newname);\n\t\t\tfree(*hostp);\n\t\t\t*hostp = xstrdup(newname);\n\t\t}\n\t\treturn addrs;\n\t}\n\n\t/*\n\t * If this looks like an address but didn't parse as one, it might\n\t * be an address with an invalid interface scope. Skip further\n\t * attempts at canonicalisation.\n\t */\n\tif (is_addr_fast(*hostp)) {\n\t\tdebug(\"%s: hostname %.100s is an unrecognised address\",\n\t\t    __func__, *hostp);\n\t\treturn NULL;\n\t}\n\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn NULL;\n\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy unless the user specifically requests so.\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn NULL;\n\n\t/* If domain name is anchored, then resolve it now */\n\tif ((*hostp)[strlen(*hostp) - 1] == '.') {\n\t\tdebug3(\"%s: name is fully qualified\", __func__);\n\t\tfullhost = xstrdup(*hostp);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) != NULL)\n\t\t\tgoto found;\n\t\tfree(fullhost);\n\t\tgoto notfound;\n\t}\n\n\t/* Don't apply canonicalization to sufficiently-qualified hostnames */\n\tndots = 0;\n\tfor (cp = *hostp; *cp != '\\0'; cp++) {\n\t\tif (*cp == '.')\n\t\t\tndots++;\n\t}\n\tif (ndots > options.canonicalize_max_dots) {\n\t\tdebug3(\"%s: not canonicalizing hostname \\\"%s\\\" (max dots %d)\",\n\t\t    __func__, *hostp, options.canonicalize_max_dots);\n\t\treturn NULL;\n\t}\n\t/* Attempt each supplied suffix */\n\tfor (i = 0; i < options.num_canonical_domains; i++) {\n\t\t*newname = '\\0';\n\t\txasprintf(&fullhost, \"%s.%s.\", *hostp,\n\t\t    options.canonical_domains[i]);\n\t\tdebug3(\"%s: attempting \\\"%s\\\" => \\\"%s\\\"\", __func__,\n\t\t    *hostp, fullhost);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) == NULL) {\n\t\t\tfree(fullhost);\n\t\t\tcontinue;\n\t\t}\n found:\n\t\t/* Remove trailing '.' */\n\t\tfullhost[strlen(fullhost) - 1] = '\\0';\n\t\t/* Follow CNAME if requested */\n\t\tif (!check_follow_cname(direct, &fullhost, newname)) {\n\t\t\tdebug(\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, fullhost);\n\t\t}\n\t\tfree(*hostp);\n\t\t*hostp = fullhost;\n\t\treturn addrs;\n\t}\n notfound:\n\tif (!options.canonicalize_fallback_local)\n\t\tfatal(\"%s: Could not resolve host \\\"%s\\\"\", __progname, *hostp);\n\tdebug2(\"%s: host %s not found in any suffix\", __func__, *hostp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *__progname;",
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_canonicalize(char **hostp, int port)\n{\n\tint i, direct, ndots;\n\tchar *cp, *fullhost, newname[NI_MAXHOST];\n\tstruct addrinfo *addrs;\n\n\t/*\n\t * Attempt to canonicalise addresses, regardless of\n\t * whether hostname canonicalisation was requested\n\t */\n\tif ((addrs = resolve_addr(*hostp, port,\n\t    newname, sizeof(newname))) != NULL) {\n\t\tdebug2(\"%s: hostname %.100s is address\", __func__, *hostp);\n\t\tif (strcasecmp(*hostp, newname) != 0) {\n\t\t\tdebug2(\"%s: canonicalised address \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    __func__, *hostp, newname);\n\t\t\tfree(*hostp);\n\t\t\t*hostp = xstrdup(newname);\n\t\t}\n\t\treturn addrs;\n\t}\n\n\t/*\n\t * If this looks like an address but didn't parse as one, it might\n\t * be an address with an invalid interface scope. Skip further\n\t * attempts at canonicalisation.\n\t */\n\tif (is_addr_fast(*hostp)) {\n\t\tdebug(\"%s: hostname %.100s is an unrecognised address\",\n\t\t    __func__, *hostp);\n\t\treturn NULL;\n\t}\n\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn NULL;\n\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy unless the user specifically requests so.\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn NULL;\n\n\t/* If domain name is anchored, then resolve it now */\n\tif ((*hostp)[strlen(*hostp) - 1] == '.') {\n\t\tdebug3(\"%s: name is fully qualified\", __func__);\n\t\tfullhost = xstrdup(*hostp);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) != NULL)\n\t\t\tgoto found;\n\t\tfree(fullhost);\n\t\tgoto notfound;\n\t}\n\n\t/* Don't apply canonicalization to sufficiently-qualified hostnames */\n\tndots = 0;\n\tfor (cp = *hostp; *cp != '\\0'; cp++) {\n\t\tif (*cp == '.')\n\t\t\tndots++;\n\t}\n\tif (ndots > options.canonicalize_max_dots) {\n\t\tdebug3(\"%s: not canonicalizing hostname \\\"%s\\\" (max dots %d)\",\n\t\t    __func__, *hostp, options.canonicalize_max_dots);\n\t\treturn NULL;\n\t}\n\t/* Attempt each supplied suffix */\n\tfor (i = 0; i < options.num_canonical_domains; i++) {\n\t\t*newname = '\\0';\n\t\txasprintf(&fullhost, \"%s.%s.\", *hostp,\n\t\t    options.canonical_domains[i]);\n\t\tdebug3(\"%s: attempting \\\"%s\\\" => \\\"%s\\\"\", __func__,\n\t\t    *hostp, fullhost);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) == NULL) {\n\t\t\tfree(fullhost);\n\t\t\tcontinue;\n\t\t}\n found:\n\t\t/* Remove trailing '.' */\n\t\tfullhost[strlen(fullhost) - 1] = '\\0';\n\t\t/* Follow CNAME if requested */\n\t\tif (!check_follow_cname(direct, &fullhost, newname)) {\n\t\t\tdebug(\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, fullhost);\n\t\t}\n\t\tfree(*hostp);\n\t\t*hostp = fullhost;\n\t\treturn addrs;\n\t}\n notfound:\n\tif (!options.canonicalize_fallback_local)\n\t\tfatal(\"%s: Could not resolve host \\\"%s\\\"\", __progname, *hostp);\n\tdebug2(\"%s: host %s not found in any suffix\", __func__, *hostp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_addr",
          "args": [
            "host"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "is_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "278-301",
          "snippet": "static int\nis_addr(const char *name)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\n\tif (is_addr_fast(name))\n\t\treturn 1;\n\n\tsnprintf(strport, sizeof strport, \"%u\", default_ssh_port());\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif (getaddrinfo(name, strport, &hints, &res) != 0)\n\t\treturn 0;\n\tif (res == NULL || res->ai_next != NULL) {\n\t\tfreeaddrinfo(res);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(res);\n\treturn 1;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic int\nis_addr(const char *name)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\n\tif (is_addr_fast(name))\n\t\treturn 1;\n\n\tsnprintf(strport, sizeof strport, \"%u\", default_ssh_port());\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif (getaddrinfo(name, strport, &hints, &res) != 0)\n\t\treturn 0;\n\tif (res == NULL || res->ai_next != NULL) {\n\t\tfreeaddrinfo(res);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(res);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_default_options_for_canonicalization",
          "args": [
            "&options"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "fill_default_options_for_canonicalization",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1935-1944",
          "snippet": "void\nfill_default_options_for_canonicalization(Options *options)\n{\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfill_default_options_for_canonicalization(Options *options)\n{\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_version",
          "args": [
            "OPENSSL_VERSION"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_redirect_stderr_to",
          "args": [
            "logfile"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "log_redirect_stderr_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "368-379",
          "snippet": "void\nlog_redirect_stderr_to(const char *logfile)\n{\n\tint fd;\n\n\tif ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open logfile %s: %s\\n\", logfile,\n\t\t     strerror(errno));\n\t\texit(1);\n\t}\n\tlog_stderr_fd = fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_stderr_fd = STDERR_FILENO;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_stderr_fd = STDERR_FILENO;\n\nvoid\nlog_redirect_stderr_to(const char *logfile)\n{\n\tint fd;\n\n\tif ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open logfile %s: %s\\n\", logfile,\n\t\t     strerror(errno));\n\t\texit(1);\n\t}\n\tlog_stderr_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "195-208",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\\n\"\n\"           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\\n\"\n\"           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\\n\"\n\"           [-i identity_file] [-J [user@]host[:port]] [-L address]\\n\"\n\"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\\n\"\n\"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\\n\"\n\"           [-w local_tun[:remote_tun]] destination [command]\\n\"\n\t);\n\texit(255);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host;",
            "struct sshbuf *command;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *host;\nstruct sshbuf *command;\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\\n\"\n\"           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\\n\"\n\"           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\\n\"\n\"           [-i identity_file] [-J [user@]host[:port]] [-L address]\\n\"\n\"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\\n\"\n\"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\\n\"\n\"           [-w local_tun[:remote_tun]] destination [command]\\n\"\n\t);\n\texit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You must specify a subsystem to invoke.\\n\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_load_crypto_strings",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "p",
            "'@'"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_ssh_uri",
          "args": [
            "*av",
            "&tuser",
            "&host",
            "&tport"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ssh_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2417-2427",
          "snippet": "int\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_config_line",
          "args": [
            "&options",
            "pw",
            "host ? host : \"\"",
            "host ? host : \"\"",
            "line",
            "\"command-line\"",
            "0",
            "NULL",
            "SSHCONF_USERCONF"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "process_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "821-828",
          "snippet": "int\nprocess_config_line(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags)\n{\n\treturn process_config_line_depth(options, pw, host, original_host,\n\t    line, filename, linenum, activep, flags, 0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nprocess_config_line(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags)\n{\n\treturn process_config_line_depth(options, pw, host, original_host,\n\t    line, filename, linenum, activep, flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad dynamic forwarding specification \"\n\t\t\t\t    \"'%s'\\n\"",
            "optarg"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_local_forward",
          "args": [
            "&options",
            "&fwd"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "add_local_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "321-343",
          "snippet": "void\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_forward",
          "args": [
            "&fwd",
            "optarg",
            "1",
            "0"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "parse_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2229-2358",
          "snippet": "int\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad remote forwarding specification \"\n\t\t\t\t    \"'%s'\\n\"",
            "optarg"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_remote_forward",
          "args": [
            "&options",
            "&fwd"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "add_remote_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "350-374",
          "snippet": "void\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad local forwarding specification '%s'\\n\"",
            "optarg"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad port '%s'\\n\"",
            "optarg"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "optarg"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unknown mac type '%s'\\n\"",
            "optarg"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_valid",
          "args": [
            "optarg"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "mac_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "247-265",
          "snippet": "int\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tMAC_SEP\t\",\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tMAC_SEP\t\",\"\n\nint\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unknown cipher type '%s'\\n\"",
            "optarg"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ciphers_valid",
          "args": [
            "*optarg == '+' ?\n\t\t\t    optarg + 1 : optarg"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ciphers_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "203-224",
          "snippet": "int\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tCIPHER_SEP\t\",\"",
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tCIPHER_SEP\t\",\"\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nint\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad escape character '%s'.\\n\"",
            "optarg"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "optarg"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad stdio forwarding specification '%s'\\n\"",
            "optarg"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad tun device '%s'\\n\"",
            "optarg"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a2tun",
          "args": [
            "optarg",
            "&options.tun_remote"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "a2tun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "348-377",
          "snippet": "int\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s, %s\\n\"",
            "SSH_RELEASE",
            "#ifdef WITH_OPENSSL\n\t\t\t    OpenSSL_version(OPENSSL_VERSION)\n#else\"without OpenSSL\"#endif"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenSSL_version",
          "args": [
            "OPENSSL_VERSION"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_jump",
          "args": [
            "optarg",
            "&options",
            "1"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "parse_jump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2360-2415",
          "snippet": "int\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"no support for PKCS#11.\\n\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_identity_file",
          "args": [
            "&options",
            "NULL",
            "p",
            "1"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "add_identity_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "430-459",
          "snippet": "void\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: Identity file %s \"\n\t\t\t\t    \"not accessible: %s.\\n\"",
            "p",
            "strerror(errno)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_alg_list",
          "args": [
            "0",
            "1",
            "1",
            "'\\n'"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "218-244",
          "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_alg_list",
          "args": [
            "'\\n'"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "kex_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "109-129",
          "snippet": "char *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_alg_list",
          "args": [
            "'\\n'"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "mac_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "86-106",
          "snippet": "char *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};\n\nchar *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_alg_list",
          "args": [
            "'\\n'",
            "1"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "117-141",
          "snippet": "char *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nchar *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "ac",
            "av",
            "\"1246ab:c:e:fgi:kl:m:no:p:qstvx\"\n\t    \"AB:CD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy\""
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_init_channels",
          "args": [
            "ssh"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "channel_init_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "225-242",
          "snippet": "void\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_alloc_session_state",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_alloc_session_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "223-262",
          "snippet": "struct ssh *\nssh_alloc_session_state(void)\n{\n\tstruct ssh *ssh = NULL;\n\tstruct session_state *state = NULL;\n\n\tif ((ssh = calloc(1, sizeof(*ssh))) == NULL ||\n\t    (state = calloc(1, sizeof(*state))) == NULL ||\n\t    (state->input = sshbuf_new()) == NULL ||\n\t    (state->output = sshbuf_new()) == NULL ||\n\t    (state->outgoing_packet = sshbuf_new()) == NULL ||\n\t    (state->incoming_packet = sshbuf_new()) == NULL)\n\t\tgoto fail;\n\tTAILQ_INIT(&state->outgoing);\n\tTAILQ_INIT(&ssh->private_keys);\n\tTAILQ_INIT(&ssh->public_keys);\n\tstate->connection_in = -1;\n\tstate->connection_out = -1;\n\tstate->max_packet_size = 32768;\n\tstate->packet_timeout_ms = -1;\n\tstate->p_send.packets = state->p_read.packets = 0;\n\tstate->initialized = 1;\n\t/*\n\t * ssh_packet_send2() needs to queue packets until\n\t * we've done the initial key exchange.\n\t */\n\tstate->rekeying = 1;\n\tssh->state = state;\n\treturn ssh;\n fail:\n\tif (state) {\n\t\tsshbuf_free(state->input);\n\t\tsshbuf_free(state->output);\n\t\tsshbuf_free(state->incoming_packet);\n\t\tsshbuf_free(state->outgoing_packet);\n\t\tfree(state);\n\t}\n\tfree(ssh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh *\nssh_alloc_session_state(void)\n{\n\tstruct ssh *ssh = NULL;\n\tstruct session_state *state = NULL;\n\n\tif ((ssh = calloc(1, sizeof(*ssh))) == NULL ||\n\t    (state = calloc(1, sizeof(*state))) == NULL ||\n\t    (state->input = sshbuf_new()) == NULL ||\n\t    (state->output = sshbuf_new()) == NULL ||\n\t    (state->outgoing_packet = sshbuf_new()) == NULL ||\n\t    (state->incoming_packet = sshbuf_new()) == NULL)\n\t\tgoto fail;\n\tTAILQ_INIT(&state->outgoing);\n\tTAILQ_INIT(&ssh->private_keys);\n\tTAILQ_INIT(&ssh->public_keys);\n\tstate->connection_in = -1;\n\tstate->connection_out = -1;\n\tstate->max_packet_size = 32768;\n\tstate->packet_timeout_ms = -1;\n\tstate->p_send.packets = state->p_read.packets = 0;\n\tstate->initialized = 1;\n\t/*\n\t * ssh_packet_send2() needs to queue packets until\n\t * we've done the initial key exchange.\n\t */\n\tstate->rekeying = 1;\n\tssh->state = state;\n\treturn ssh;\n fail:\n\tif (state) {\n\t\tsshbuf_free(state->input);\n\t\tsshbuf_free(state->output);\n\t\tsshbuf_free(state->incoming_packet);\n\t\tsshbuf_free(state->outgoing_packet);\n\t\tfree(state);\n\t}\n\tfree(ssh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_options",
          "args": [
            "&options"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1826-1929",
          "snippet": "void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msetlocale",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "msetlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "310-340",
          "snippet": "void\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "022"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwcopy",
          "args": [
            "pw"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "pwcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "302-326",
          "snippet": "struct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_init_setproctitle",
          "args": [
            "ac",
            "av"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "compat_init_setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "67-119",
          "snippet": "void\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n\nvoid\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "av[0]"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nint debug_flag = 0;\nint tty_flag = 0;\nint no_shell_flag = 0;\nint stdin_null_flag = 0;\nint fork_after_authentication_flag = 0;\nOptions options;\nchar *config = NULL;\nchar *host;\nstatic char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\nstatic char uidstr[32], *host_arg, *conn_hash_hex;\nstruct sockaddr_storage hostaddr;\nSensitive sensitive_data;\nstruct sshbuf *command;\nint subsystem_flag = 0;\nextern int muxserver_sock;\nextern u_int muxclient_command;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\nstatic void main_sigchld_handler(int);\n\nint\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\tint i, r, opt, exit_status, use_syslog, direct, timeout_ms;\n\tint was_addr, config_test = 0, opt_terminated = 0;\n\tchar *p, *cp, *line, *argv0, buf[PATH_MAX], *logfile;\n\tchar cname[NI_MAXHOST];\n\tstruct stat st;\n\tstruct passwd *pw;\n\textern int optind, optreset;\n\textern char *optarg;\n\tstruct Forward fwd;\n\tstruct addrinfo *addrs = NULL;\n\tstruct ssh_digest_ctx *md;\n\tu_char conn_hash[SSH_DIGEST_MAX_LENGTH];\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(av[0]);\n\n#ifndef HAVE_SETPROCTITLE\n\t/* Prepare for later setproctitle emulation */\n\t/* Save argv so it isn't clobbered by setproctitle() emulation */\n\tsaved_av = xcalloc(ac + 1, sizeof(*saved_av));\n\tfor (i = 0; i < ac; i++)\n\t\tsaved_av[i] = xstrdup(av[i]);\n\tsaved_av[i] = NULL;\n\tcompat_init_setproctitle(ac, av);\n\tav = saved_av;\n#endif\n\n\t/*\n\t * Discard other fds that are hanging around. These can cause problem\n\t * with backgrounded ssh processes started by ControlPersist.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n\n\t/* Get user data. */\n\tpw = getpwuid(getuid());\n\tif (!pw) {\n\t\tlogit(\"No user exists for uid %lu\", (u_long)getuid());\n\t\texit(255);\n\t}\n\t/* Take a copy of the returned structure. */\n\tpw = pwcopy(pw);\n\n\t/*\n\t * Set our umask to something reasonable, as some files are created\n\t * with the default umask.  This will make them world-readable but\n\t * writable only by the owner, which is ok for all files for which we\n\t * don't set the modes explicitly.\n\t */\n\tumask(022);\n\n\tmsetlocale();\n\n\t/*\n\t * Initialize option structure to indicate that no values have been\n\t * set.\n\t */\n\tinitialize_options(&options);\n\n\t/*\n\t * Prepare main ssh transport/connection structures\n\t */\n\tif ((ssh = ssh_alloc_session_state()) == NULL)\n\t\tfatal(\"Couldn't allocate session state\");\n\tchannel_init_channels(ssh);\n\tactive_state = ssh; /* XXX legacy API compat */\n\n\t/* Parse command-line arguments. */\n\thost = NULL;\n\tuse_syslog = 0;\n\tlogfile = NULL;\n\targv0 = av[0];\n\n again:\n\twhile ((opt = getopt(ac, av, \"1246ab:c:e:fgi:kl:m:no:p:qstvx\"\n\t    \"AB:CD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tstdin_null_flag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfork_after_authentication_flag = 1;\n\t\t\tstdin_null_flag = 1;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\toptions.forward_x11 = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\toptions.forward_x11 = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tuse_syslog = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tconfig_test = 1;\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\toptions.forward_x11 = 1;\n\t\t\toptions.forward_x11_trusted = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\toptions.fwd_opts.gateway_ports = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"Cannot specify multiplexing \"\n\t\t\t\t    \"command with -W\");\n\t\t\telse if (muxclient_command != 0)\n\t\t\t\tfatal(\"Multiplexing command already specified\");\n\t\t\tif (strcmp(optarg, \"check\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;\n\t\t\telse if (strcmp(optarg, \"forward\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_FORWARD;\n\t\t\telse if (strcmp(optarg, \"exit\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_TERMINATE;\n\t\t\telse if (strcmp(optarg, \"stop\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_STOP;\n\t\t\telse if (strcmp(optarg, \"cancel\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_CANCEL_FWD;\n\t\t\telse if (strcmp(optarg, \"proxy\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_PROXY;\n\t\t\telse\n\t\t\t\tfatal(\"Invalid multiplex command.\");\n\t\t\tbreak;\n\t\tcase 'P':\t/* deprecated */\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcp = NULL;\n\t\t\tif (strcmp(optarg, \"cipher\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 0);\n\t\t\telse if (strcmp(optarg, \"cipher-auth\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 1);\n\t\t\telse if (strcmp(optarg, \"mac\") == 0)\n\t\t\t\tcp = mac_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"kex\") == 0)\n\t\t\t\tcp = kex_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"key\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-cert\") == 0)\n\t\t\t\tcp = sshkey_alg_list(1, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-plain\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"sig\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 1, '\\n');\n\t\t\telse if (strcmp(optarg, \"protocol-version\") == 0)\n\t\t\t\tcp = xstrdup(\"2\");\n\t\t\telse if (strcmp(optarg, \"help\") == 0) {\n\t\t\t\tcp = xstrdup(\n\t\t\t\t    \"cipher\\ncipher-auth\\nkex\\nkey\\n\"\n\t\t\t\t    \"key-cert\\nkey-plain\\nmac\\n\"\n\t\t\t\t    \"protocol-version\\nsig\");\n\t\t\t}\n\t\t\tif (cp == NULL)\n\t\t\t\tfatal(\"Unsupported query \\\"%s\\\"\", optarg);\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\tfree(cp);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\toptions.forward_agent = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\toptions.forward_agent = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\toptions.gss_deleg_creds = 0;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\toptions.gss_authentication = 1;\n\t\t\toptions.gss_deleg_creds = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp = tilde_expand_filename(optarg, getuid());\n\t\t\tif (stat(p, &st) < 0)\n\t\t\t\tfprintf(stderr, \"Warning: Identity file %s \"\n\t\t\t\t    \"not accessible: %s.\\n\", p,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tadd_identity_file(&options, NULL, p, 1);\n\t\t\tfree(p);\n\t\t\tbreak;\n\t\tcase 'I':\n#ifdef ENABLE_PKCS11\n\t\t\tfree(options.pkcs11_provider);\n\t\t\toptions.pkcs11_provider = xstrdup(optarg);\n#else\n\t\t\tfprintf(stderr, \"no support for PKCS#11.\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tif (options.jump_host != NULL)\n\t\t\t\tfatal(\"Only a single -J option permitted\");\n\t\t\tif (options.proxy_command != NULL)\n\t\t\t\tfatal(\"Cannot specify -J with ProxyCommand\");\n\t\t\tif (parse_jump(optarg, &options, 1) == -1)\n\t\t\t\tfatal(\"Invalid -J argument\");\n\t\t\toptions.proxy_command = xstrdup(\"none\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (options.request_tty == REQUEST_TTY_YES)\n\t\t\t\toptions.request_tty = REQUEST_TTY_FORCE;\n\t\t\telse\n\t\t\t\toptions.request_tty = REQUEST_TTY_YES;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else {\n\t\t\t\tif (options.log_level < SYSLOG_LEVEL_DEBUG3) {\n\t\t\t\t\tdebug_flag++;\n\t\t\t\t\toptions.log_level++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tfprintf(stderr, \"%s, %s\\n\",\n\t\t\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t\t\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t\t\t    \"without OpenSSL\"\n#endif\n\t\t\t);\n\t\t\tif (opt == 'V')\n\t\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (options.tun_open == -1)\n\t\t\t\toptions.tun_open = SSH_TUNMODE_DEFAULT;\n\t\t\toptions.tun_local = a2tun(optarg, &options.tun_remote);\n\t\t\tif (options.tun_local == SSH_TUNID_ERR) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad tun device '%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"stdio forward already specified\");\n\t\t\tif (muxclient_command != 0)\n\t\t\t\tfatal(\"Cannot specify stdio forward with -O\");\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\toptions.stdio_forward_host = fwd.listen_host;\n\t\t\t\toptions.stdio_forward_port = fwd.listen_port;\n\t\t\t\tfree(fwd.connect_host);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad stdio forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tno_shell_flag = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '^' && optarg[2] == 0 &&\n\t\t\t    (u_char) optarg[1] >= 64 &&\n\t\t\t    (u_char) optarg[1] < 128)\n\t\t\t\toptions.escape_char = (u_char) optarg[1] & 31;\n\t\t\telse if (strlen(optarg) == 1)\n\t\t\t\toptions.escape_char = (u_char) optarg[0];\n\t\t\telse if (strcmp(optarg, \"none\") == 0)\n\t\t\t\toptions.escape_char = SSH_ESCAPECHAR_NONE;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Bad escape character '%s'.\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (!ciphers_valid(*optarg == '+' ?\n\t\t\t    optarg + 1 : optarg)) {\n\t\t\t\tfprintf(stderr, \"Unknown cipher type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tfree(options.ciphers);\n\t\t\toptions.ciphers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mac_valid(optarg)) {\n\t\t\t\tfree(options.macs);\n\t\t\t\toptions.macs = xstrdup(optarg);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown mac type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (options.control_master == SSHCTL_MASTER_YES)\n\t\t\t\toptions.control_master = SSHCTL_MASTER_ASK;\n\t\t\telse\n\t\t\t\toptions.control_master = SSHCTL_MASTER_YES;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (options.port == -1) {\n\t\t\t\toptions.port = a2port(optarg);\n\t\t\t\tif (options.port <= 0) {\n\t\t\t\t\tfprintf(stderr, \"Bad port '%s'\\n\",\n\t\t\t\t\t    optarg);\n\t\t\t\t\texit(255);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (options.user == NULL)\n\t\t\t\toptions.user = optarg;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 0))\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\telse {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad local forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 1) ||\n\t\t\t    parse_forward(&fwd, optarg, 1, 1)) {\n\t\t\t\tadd_remote_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad remote forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad dynamic forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\toptions.compression = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tno_shell_flag = 1;\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_config_line(&options, pw,\n\t\t\t    host ? host : \"\", host ? host : \"\", line,\n\t\t\t    \"command-line\", 0, NULL, SSHCONF_USERCONF) != 0)\n\t\t\t\texit(255);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsubsystem_flag = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toptions.bind_address = optarg;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toptions.bind_interface = optarg;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tconfig = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (optind > 1 && strcmp(av[optind - 1], \"--\") == 0)\n\t\topt_terminated = 1;\n\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && !host) {\n\t\tint tport;\n\t\tchar *tuser;\n\t\tswitch (parse_ssh_uri(*av, &tuser, &host, &tport)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (options.user == NULL) {\n\t\t\t\toptions.user = tuser;\n\t\t\t\ttuser = NULL;\n\t\t\t}\n\t\t\tfree(tuser);\n\t\t\tif (options.port == -1 && tport != -1)\n\t\t\t\toptions.port = tport;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xstrdup(*av);\n\t\t\tcp = strrchr(p, '@');\n\t\t\tif (cp != NULL) {\n\t\t\t\tif (cp == p)\n\t\t\t\t\tusage();\n\t\t\t\tif (options.user == NULL) {\n\t\t\t\t\toptions.user = p;\n\t\t\t\t\tp = NULL;\n\t\t\t\t}\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thost = xstrdup(cp);\n\t\t\t\tfree(p);\n\t\t\t} else\n\t\t\t\thost = p;\n\t\t\tbreak;\n\t\t}\n\t\tif (ac > 1 && !opt_terminated) {\n\t\t\toptind = optreset = 1;\n\t\t\tgoto again;\n\t\t}\n\t\tac--, av++;\n\t}\n\n\t/* Check that we got a host name. */\n\tif (!host)\n\t\tusage();\n\n\thost_arg = xstrdup(host);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n#endif\n\n\t/* Initialize the command to execute on remote host. */\n\tif ((command = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\n\t/*\n\t * Save the command to execute on the remote host in a buffer. There\n\t * is no limit on the length of the command, except by the maximum\n\t * packet size.  Also sets the tty flag if there is no command.\n\t */\n\tif (!ac) {\n\t\t/* No command specified - execute shell on a tty. */\n\t\tif (subsystem_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"You must specify a subsystem to invoke.\\n\");\n\t\t\tusage();\n\t\t}\n\t} else {\n\t\t/* A command has been specified.  Store it into the buffer. */\n\t\tfor (i = 0; i < ac; i++) {\n\t\t\tif ((r = sshbuf_putf(command, \"%s%s\",\n\t\t\t    i ? \" \" : \"\", av[i])) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\n\t/*\n\t * Initialize \"log\" output.  Since we are the client all output\n\t * goes to stderr unless otherwise specified by -y or -E.\n\t */\n\tif (use_syslog && logfile != NULL)\n\t\tfatal(\"Can't specify both -y and -E\");\n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\tlog_init(argv0,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_USER : options.log_facility,\n\t    !use_syslog);\n\n\tif (debug_flag)\n\t\tlogit(\"%s, %s\", SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t\t    \"without OpenSSL\"\n#endif\n\t\t);\n\n\t/* Parse the configuration files */\n\tprocess_config_files(host_arg, pw, 0);\n\n\t/* Hostname canonicalisation needs a few options filled. */\n\tfill_default_options_for_canonicalization(&options);\n\n\t/* If the user has replaced the hostname then take it into use now */\n\tif (options.hostname != NULL) {\n\t\t/* NB. Please keep in sync with readconf.c:match_cfg_line() */\n\t\tcp = percent_expand(options.hostname,\n\t\t    \"h\", host, (char *)NULL);\n\t\tfree(host);\n\t\thost = cp;\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t}\n\n\t/* Don't lowercase addresses, they will be explicitly canonicalised */\n\tif ((was_addr = is_addr(host)) == 0)\n\t\tlowercase(host);\n\n\t/*\n\t * Try to canonicalize if requested by configuration or the\n\t * hostname is an address.\n\t */\n\tif (options.canonicalize_hostname != SSH_CANONICALISE_NO || was_addr)\n\t\taddrs = resolve_canonicalize(&host, options.port);\n\n\t/*\n\t * If CanonicalizePermittedCNAMEs have been specified but\n\t * other canonicalization did not happen (by not being requested\n\t * or by failing with fallback) then the hostname may still be changed\n\t * as a result of CNAME following.\n\t *\n\t * Try to resolve the bare hostname name using the system resolver's\n\t * usual search rules and then apply the CNAME follow rules.\n\t *\n\t * Skip the lookup if a ProxyCommand is being used unless the user\n\t * has specifically requested canonicalisation for this case via\n\t * CanonicalizeHostname=always\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (addrs == NULL && options.num_permitted_cnames != 0 && (direct ||\n\t    options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {\n\t\tif ((addrs = resolve_host(host, options.port,\n\t\t    direct, cname, sizeof(cname))) == NULL) {\n\t\t\t/* Don't fatal proxied host names not in the DNS */\n\t\t\tif (direct)\n\t\t\t\tcleanup_exit(255); /* logged in resolve_host */\n\t\t} else\n\t\t\tcheck_follow_cname(direct, &host, cname);\n\t}\n\n\t/*\n\t * If canonicalisation is enabled then re-parse the configuration\n\t * files as new stanzas may match.\n\t */\n\tif (options.canonicalize_hostname != 0) {\n\t\tdebug(\"Re-reading configuration after hostname \"\n\t\t    \"canonicalisation\");\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t\tprocess_config_files(host_arg, pw, 1);\n\t\t/*\n\t\t * Address resolution happens early with canonicalisation\n\t\t * enabled and the port number may have changed since, so\n\t\t * reset it in address list\n\t\t */\n\t\tif (addrs != NULL && options.port > 0)\n\t\t\tset_addrinfo_port(addrs, options.port);\n\t}\n\n\t/* Fill configuration defaults. */\n\tfill_default_options(&options);\n\n\t/*\n\t * If ProxyJump option specified, then construct a ProxyCommand now.\n\t */\n\tif (options.jump_host != NULL) {\n\t\tchar port_s[8];\n\t\tconst char *sshbin = argv0;\n\n\t\t/*\n\t\t * Try to use SSH indicated by argv[0], but fall back to\n\t\t * \"ssh\" if it appears unavailable.\n\t\t */\n\t\tif (strchr(argv0, '/') != NULL && access(argv0, X_OK) != 0)\n\t\t\tsshbin = \"ssh\";\n\n\t\t/* Consistency check */\n\t\tif (options.proxy_command != NULL)\n\t\t\tfatal(\"inconsistent options: ProxyCommand+ProxyJump\");\n\t\t/* Never use FD passing for ProxyJump */\n\t\toptions.proxy_use_fdpass = 0;\n\t\tsnprintf(port_s, sizeof(port_s), \"%d\", options.jump_port);\n\t\txasprintf(&options.proxy_command,\n\t\t    \"%s%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s\",\n\t\t    sshbin,\n\t\t    /* Optional \"-l user\" argument if jump_user set */\n\t\t    options.jump_user == NULL ? \"\" : \" -l \",\n\t\t    options.jump_user == NULL ? \"\" : options.jump_user,\n\t\t    /* Optional \"-p port\" argument if jump_port set */\n\t\t    options.jump_port <= 0 ? \"\" : \" -p \",\n\t\t    options.jump_port <= 0 ? \"\" : port_s,\n\t\t    /* Optional additional jump hosts \",...\" */\n\t\t    options.jump_extra == NULL ? \"\" : \" -J \",\n\t\t    options.jump_extra == NULL ? \"\" : options.jump_extra,\n\t\t    /* Optional \"-F\" argumment if -F specified */\n\t\t    config == NULL ? \"\" : \" -F \",\n\t\t    config == NULL ? \"\" : config,\n\t\t    /* Optional \"-v\" arguments if -v set */\n\t\t    debug_flag ? \" -\" : \"\",\n\t\t    debug_flag, \"vvv\",\n\t\t    /* Mandatory hostname */\n\t\t    options.jump_host);\n\t\tdebug(\"Setting implicit ProxyCommand from ProxyJump: %s\",\n\t\t    options.proxy_command);\n\t}\n\n\tif (options.port == 0)\n\t\toptions.port = default_ssh_port();\n\tchannel_set_af(ssh, options.address_family);\n\n\t/* Tidy and check options */\n\tif (options.host_key_alias != NULL)\n\t\tlowercase(options.host_key_alias);\n\tif (options.proxy_command != NULL &&\n\t    strcmp(options.proxy_command, \"-\") == 0 &&\n\t    options.proxy_use_fdpass)\n\t\tfatal(\"ProxyCommand=- and ProxyUseFDPass are incompatible\");\n\tif (options.control_persist &&\n\t    options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tdebug(\"UpdateHostKeys=ask is incompatible with ControlPersist; \"\n\t\t    \"disabling\");\n\t\toptions.update_hostkeys = 0;\n\t}\n\tif (options.connection_attempts <= 0)\n\t\tfatal(\"Invalid number of ConnectionAttempts\");\n\n\tif (sshbuf_len(command) != 0 && options.remote_command != NULL)\n\t\tfatal(\"Cannot execute command-line and remote command.\");\n\n\t/* Cannot fork to background if no command. */\n\tif (fork_after_authentication_flag && sshbuf_len(command) == 0 &&\n\t    options.remote_command == NULL && !no_shell_flag)\n\t\tfatal(\"Cannot fork into background without a command \"\n\t\t    \"to execute.\");\n\n\t/* reinit */\n\tlog_init(argv0, options.log_level, options.log_facility, !use_syslog);\n\n\tif (options.request_tty == REQUEST_TTY_YES ||\n\t    options.request_tty == REQUEST_TTY_FORCE)\n\t\ttty_flag = 1;\n\n\t/* Allocate a tty by default if no command specified. */\n\tif (sshbuf_len(command) == 0 && options.remote_command == NULL)\n\t\ttty_flag = options.request_tty != REQUEST_TTY_NO;\n\n\t/* Force no tty */\n\tif (options.request_tty == REQUEST_TTY_NO ||\n\t    (muxclient_command && muxclient_command != SSHMUX_COMMAND_PROXY))\n\t\ttty_flag = 0;\n\t/* Do not allocate a tty if stdin is not a tty. */\n\tif ((!isatty(fileno(stdin)) || stdin_null_flag) &&\n\t    options.request_tty != REQUEST_TTY_FORCE) {\n\t\tif (tty_flag)\n\t\t\tlogit(\"Pseudo-terminal will not be allocated because \"\n\t\t\t    \"stdin is not a terminal.\");\n\t\ttty_flag = 0;\n\t}\n\n\tseed_rng();\n\n\tif (options.user == NULL)\n\t\toptions.user = xstrdup(pw->pw_name);\n\n\t/* Set up strings used to percent_expand() arguments */\n\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\tsnprintf(portstr, sizeof(portstr), \"%d\", options.port);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\n\tif ((md = ssh_digest_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_digest_update(md, thishost, strlen(thishost)) < 0 ||\n\t    ssh_digest_update(md, host, strlen(host)) < 0 ||\n\t    ssh_digest_update(md, portstr, strlen(portstr)) < 0 ||\n\t    ssh_digest_update(md, options.user, strlen(options.user)) < 0 ||\n\t    ssh_digest_final(md, conn_hash, sizeof(conn_hash)) < 0)\n\t\tfatal(\"%s: mux digest failed\", __func__);\n\tssh_digest_free(md);\n\tconn_hash_hex = tohex(conn_hash, ssh_digest_bytes(SSH_DIGEST_SHA1));\n\n\t/*\n\t * Expand tokens in arguments. NB. LocalCommand is expanded later,\n\t * after port-forwarding is set up, so it may pick up any local\n\t * tunnel interface name allocated.\n\t */\n\tif (options.remote_command != NULL) {\n\t\tdebug3(\"expanding RemoteCommand: %s\", options.remote_command);\n\t\tcp = options.remote_command;\n\t\toptions.remote_command = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"d\", pw->pw_dir,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded RemoteCommand: %s\", options.remote_command);\n\t\tfree(cp);\n\t\tif ((r = sshbuf_put(command, options.remote_command,\n\t\t    strlen(options.remote_command))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (options.control_path != NULL) {\n\t\tcp = tilde_expand_filename(options.control_path, getuid());\n\t\tfree(options.control_path);\n\t\toptions.control_path = percent_expand(cp,\n\t\t    \"C\", conn_hash_hex,\n\t\t    \"L\", shorthost,\n\t\t    \"h\", host,\n\t\t    \"i\", uidstr,\n\t\t    \"l\", thishost,\n\t\t    \"n\", host_arg,\n\t\t    \"p\", portstr,\n\t\t    \"r\", options.user,\n\t\t    \"u\", pw->pw_name,\n\t\t    \"i\", uidstr,\n\t\t    (char *)NULL);\n\t\tfree(cp);\n\t}\n\n\tif (config_test) {\n\t\tdump_client_config(&options, host);\n\t\texit(0);\n\t}\n\n\tif (muxclient_command != 0 && options.control_path == NULL)\n\t\tfatal(\"No ControlPath specified for \\\"-O\\\" command\");\n\tif (options.control_path != NULL) {\n\t\tint sock;\n\t\tif ((sock = muxclient(options.control_path)) >= 0) {\n\t\t\tssh_packet_set_connection(ssh, sock, sock);\n\t\t\tpacket_set_mux();\n\t\t\tgoto skip_connect;\n\t\t}\n\t}\n\n\t/*\n\t * If hostname canonicalisation was not enabled, then we may not\n\t * have yet resolved the hostname. Do so now.\n\t */\n\tif (addrs == NULL && options.proxy_command == NULL) {\n\t\tdebug2(\"resolving \\\"%s\\\" port %d\", host, options.port);\n\t\tif ((addrs = resolve_host(host, options.port, 1,\n\t\t    cname, sizeof(cname))) == NULL)\n\t\t\tcleanup_exit(255); /* resolve_host logs the error */\n\t}\n\n\ttimeout_ms = options.connection_timeout * 1000;\n\n\t/* Open a connection to the remote host. */\n\tif (ssh_connect(ssh, host, addrs, &hostaddr, options.port,\n\t    options.address_family, options.connection_attempts,\n\t    &timeout_ms, options.tcp_keep_alive) != 0)\n \t\texit(255);\n\n\tif (addrs != NULL)\n\t\tfreeaddrinfo(addrs);\n\n\tpacket_set_timeout(options.server_alive_interval,\n\t    options.server_alive_count_max);\n\n\tssh = active_state; /* XXX */\n\n\tif (timeout_ms > 0)\n\t\tdebug3(\"timeout: %d ms remain after connect\", timeout_ms);\n\n\t/*\n\t * If we successfully made the connection and we have hostbased auth\n\t * enabled, load the public keys so we can later use the ssh-keysign\n\t * helper to sign challenges.\n\t */\n\tsensitive_data.nkeys = 0;\n\tsensitive_data.keys = NULL;\n\tif (options.hostbased_authentication) {\n\t\tsensitive_data.nkeys = 10;\n\t\tsensitive_data.keys = xcalloc(sensitive_data.nkeys,\n\t\t    sizeof(struct sshkey));\n\n\t\t/* XXX check errors? */\n#define L_PUBKEY(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal(\"%s pubkey out of array bounds\", __func__); \\\n\tcheck_load(sshkey_load_public(p, &(sensitive_data.keys[o]), NULL), \\\n\t    p, \"pubkey\"); \\\n} while (0)\n#define L_CERT(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal(\"%s cert out of array bounds\", __func__); \\\n\tcheck_load(sshkey_load_cert(p, &(sensitive_data.keys[o])), p, \"cert\"); \\\n} while (0)\n\n\t\tif (options.hostbased_authentication == 1) {\n\t\t\tL_CERT(_PATH_HOST_ECDSA_KEY_FILE, 0);\n\t\t\tL_CERT(_PATH_HOST_ED25519_KEY_FILE, 1);\n\t\t\tL_CERT(_PATH_HOST_RSA_KEY_FILE, 2);\n\t\t\tL_CERT(_PATH_HOST_DSA_KEY_FILE, 3);\n\t\t\tL_PUBKEY(_PATH_HOST_ECDSA_KEY_FILE, 4);\n\t\t\tL_PUBKEY(_PATH_HOST_ED25519_KEY_FILE, 5);\n\t\t\tL_PUBKEY(_PATH_HOST_RSA_KEY_FILE, 6);\n\t\t\tL_PUBKEY(_PATH_HOST_DSA_KEY_FILE, 7);\n\t\t\tL_CERT(_PATH_HOST_XMSS_KEY_FILE, 8);\n\t\t\tL_PUBKEY(_PATH_HOST_XMSS_KEY_FILE, 9);\n\t\t}\n\t}\n\n\t/* Create ~/.ssh * directory if it doesn't already exist. */\n\tif (config == NULL) {\n\t\tr = snprintf(buf, sizeof buf, \"%s%s%s\", pw->pw_dir,\n\t\t    strcmp(pw->pw_dir, \"/\") ? \"/\" : \"\", _PATH_SSH_USER_DIR);\n\t\tif (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0) {\n#ifdef WITH_SELINUX\n\t\t\tssh_selinux_setfscreatecon(buf);\n#endif\n\t\t\tif (mkdir(buf, 0700) < 0)\n\t\t\t\terror(\"Could not create directory '%.200s'.\",\n\t\t\t\t    buf);\n#ifdef WITH_SELINUX\n\t\t\tssh_selinux_setfscreatecon(NULL);\n#endif\n\t\t}\n\t}\n\t/* load options.identity_files */\n\tload_public_identity_files(pw);\n\n\t/* optionally set the SSH_AUTHSOCKET_ENV_NAME variable */\n\tif (options.identity_agent &&\n\t    strcmp(options.identity_agent, SSH_AUTHSOCKET_ENV_NAME) != 0) {\n\t\tif (strcmp(options.identity_agent, \"none\") == 0) {\n\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t} else {\n\t\t\tp = tilde_expand_filename(options.identity_agent,\n\t\t\t    getuid());\n\t\t\tcp = percent_expand(p,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"i\", uidstr,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"r\", options.user,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    (char *)NULL);\n\t\t\tfree(p);\n\t\t\t/*\n\t\t\t * If identity_agent represents an environment variable\n\t\t\t * then recheck that it is valid (since processing with\n\t\t\t * percent_expand() may have changed it) and substitute\n\t\t\t * its value.\n\t\t\t */\n\t\t\tif (cp[0] == '$') {\n\t\t\t\tif (!valid_env_name(cp + 1)) {\n\t\t\t\t\tfatal(\"Invalid IdentityAgent \"\n\t\t\t\t\t    \"environment variable name %s\", cp);\n\t\t\t\t}\n\t\t\t\tif ((p = getenv(cp + 1)) == NULL)\n\t\t\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t\t\telse\n\t\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, p, 1);\n\t\t\t} else {\n\t\t\t\t/* identity_agent specifies a path directly */\n\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, cp, 1);\n\t\t\t}\n\t\t\tfree(cp);\n\t\t}\n\t}\n\n\t/* Expand ~ in known host file names. */\n\ttilde_expand_paths(options.system_hostfiles,\n\t    options.num_system_hostfiles);\n\ttilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);\n\n\tsignal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */\n\tsignal(SIGCHLD, main_sigchld_handler);\n\n\t/* Log into the remote system.  Never returns if the login fails. */\n\tssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,\n\t    options.port, pw, timeout_ms);\n\n\tif (packet_connection_is_on_socket()) {\n\t\tverbose(\"Authenticated to %s ([%s]:%d).\", host,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t} else {\n\t\tverbose(\"Authenticated to %s (via proxy).\", host);\n\t}\n\n\t/* We no longer need the private host keys.  Clear them now. */\n\tif (sensitive_data.nkeys != 0) {\n\t\tfor (i = 0; i < sensitive_data.nkeys; i++) {\n\t\t\tif (sensitive_data.keys[i] != NULL) {\n\t\t\t\t/* Destroys contents safely */\n\t\t\t\tdebug3(\"clear hostkey %d\", i);\n\t\t\t\tsshkey_free(sensitive_data.keys[i]);\n\t\t\t\tsensitive_data.keys[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(sensitive_data.keys);\n\t}\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tfree(options.identity_files[i]);\n\t\toptions.identity_files[i] = NULL;\n\t\tif (options.identity_keys[i]) {\n\t\t\tsshkey_free(options.identity_keys[i]);\n\t\t\toptions.identity_keys[i] = NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t}\n\n skip_connect:\n\texit_status = ssh_session2(ssh, pw);\n\tpacket_close();\n\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\n\t/* Kill ProxyCommand if it is running. */\n\tssh_kill_proxy_command();\n\n\treturn exit_status;\n}"
  },
  {
    "function_name": "set_addrinfo_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "557-574",
    "snippet": "static void\nset_addrinfo_port(struct addrinfo *addrs, int port)\n{\n\tstruct addrinfo *addr;\n\n\tfor (addr = addrs; addr != NULL; addr = addr->ai_next) {\n\t\tswitch (addr->ai_family) {\n\t\tcase AF_INET:\n\t\t\t((struct sockaddr_in *)addr->ai_addr)->\n\t\t\t    sin_port = htons(port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t((struct sockaddr_in6 *)addr->ai_addr)->\n\t\t\t    sin6_port = htons(port);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nset_addrinfo_port(struct addrinfo *addrs, int port)\n{\n\tstruct addrinfo *addr;\n\n\tfor (addr = addrs; addr != NULL; addr = addr->ai_next) {\n\t\tswitch (addr->ai_family) {\n\t\tcase AF_INET:\n\t\t\t((struct sockaddr_in *)addr->ai_addr)->\n\t\t\t    sin_port = htons(port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t((struct sockaddr_in6 *)addr->ai_addr)->\n\t\t\t    sin6_port = htons(port);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "process_config_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "529-554",
    "snippet": "static void\nprocess_config_files(const char *host_name, struct passwd *pw, int post_canon)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_name, &options,\n\t\t    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_name,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (post_canon ? SSHCONF_POSTCANON : 0));\n\n\t\t/* Read systemwide configuration file after user config. */\n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_name, &options,\n\t\t    post_canon ? SSHCONF_POSTCANON : 0);\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;",
      "char *config = NULL;",
      "char *host;",
      "static int ssh_session2(struct ssh *, struct passwd *);",
      "static void load_public_identity_files(struct passwd *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_config_file",
          "args": [
            "_PATH_HOST_CONFIG_FILE",
            "pw",
            "host",
            "host_name",
            "&options",
            "post_canon ? SSHCONF_POSTCANON : 0"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1752-1760",
          "snippet": "int\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%s/%s\"",
            "pw->pw_dir",
            "_PATH_SSH_USER_CONFFILE"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\"",
            "config",
            "strerror(errno)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "config",
            "\"none\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *config = NULL;\nchar *host;\nstatic int ssh_session2(struct ssh *, struct passwd *);\nstatic void load_public_identity_files(struct passwd *);\n\nstatic void\nprocess_config_files(const char *host_name, struct passwd *pw, int post_canon)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_name, &options,\n\t\t    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_name,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (post_canon ? SSHCONF_POSTCANON : 0));\n\n\t\t/* Read systemwide configuration file after user config. */\n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_name, &options,\n\t\t    post_canon ? SSHCONF_POSTCANON : 0);\n\t}\n}"
  },
  {
    "function_name": "check_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "505-523",
    "snippet": "static void\ncheck_load(int r, const char *path, const char *message)\n{\n\tswitch (r) {\n\tcase 0:\n\t\tbreak;\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\tfatal(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t/* Ignore missing files */\n\t\tif (errno == ENOENT)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\terror(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"load %s \\\"%s\\\": %s\"",
            "message",
            "path",
            "ssh_err(r)"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"load %s \\\"%s\\\": %s\"",
            "message",
            "path",
            "ssh_err(r)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncheck_load(int r, const char *path, const char *message)\n{\n\tswitch (r) {\n\tcase 0:\n\t\tbreak;\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\tfatal(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t/* Ignore missing files */\n\t\tif (errno == ENOENT)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\terror(\"load %s \\\"%s\\\": %s\", message, path, ssh_err(r));\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "resolve_canonicalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "401-499",
    "snippet": "static struct addrinfo *\nresolve_canonicalize(char **hostp, int port)\n{\n\tint i, direct, ndots;\n\tchar *cp, *fullhost, newname[NI_MAXHOST];\n\tstruct addrinfo *addrs;\n\n\t/*\n\t * Attempt to canonicalise addresses, regardless of\n\t * whether hostname canonicalisation was requested\n\t */\n\tif ((addrs = resolve_addr(*hostp, port,\n\t    newname, sizeof(newname))) != NULL) {\n\t\tdebug2(\"%s: hostname %.100s is address\", __func__, *hostp);\n\t\tif (strcasecmp(*hostp, newname) != 0) {\n\t\t\tdebug2(\"%s: canonicalised address \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    __func__, *hostp, newname);\n\t\t\tfree(*hostp);\n\t\t\t*hostp = xstrdup(newname);\n\t\t}\n\t\treturn addrs;\n\t}\n\n\t/*\n\t * If this looks like an address but didn't parse as one, it might\n\t * be an address with an invalid interface scope. Skip further\n\t * attempts at canonicalisation.\n\t */\n\tif (is_addr_fast(*hostp)) {\n\t\tdebug(\"%s: hostname %.100s is an unrecognised address\",\n\t\t    __func__, *hostp);\n\t\treturn NULL;\n\t}\n\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn NULL;\n\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy unless the user specifically requests so.\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn NULL;\n\n\t/* If domain name is anchored, then resolve it now */\n\tif ((*hostp)[strlen(*hostp) - 1] == '.') {\n\t\tdebug3(\"%s: name is fully qualified\", __func__);\n\t\tfullhost = xstrdup(*hostp);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) != NULL)\n\t\t\tgoto found;\n\t\tfree(fullhost);\n\t\tgoto notfound;\n\t}\n\n\t/* Don't apply canonicalization to sufficiently-qualified hostnames */\n\tndots = 0;\n\tfor (cp = *hostp; *cp != '\\0'; cp++) {\n\t\tif (*cp == '.')\n\t\t\tndots++;\n\t}\n\tif (ndots > options.canonicalize_max_dots) {\n\t\tdebug3(\"%s: not canonicalizing hostname \\\"%s\\\" (max dots %d)\",\n\t\t    __func__, *hostp, options.canonicalize_max_dots);\n\t\treturn NULL;\n\t}\n\t/* Attempt each supplied suffix */\n\tfor (i = 0; i < options.num_canonical_domains; i++) {\n\t\t*newname = '\\0';\n\t\txasprintf(&fullhost, \"%s.%s.\", *hostp,\n\t\t    options.canonical_domains[i]);\n\t\tdebug3(\"%s: attempting \\\"%s\\\" => \\\"%s\\\"\", __func__,\n\t\t    *hostp, fullhost);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) == NULL) {\n\t\t\tfree(fullhost);\n\t\t\tcontinue;\n\t\t}\n found:\n\t\t/* Remove trailing '.' */\n\t\tfullhost[strlen(fullhost) - 1] = '\\0';\n\t\t/* Follow CNAME if requested */\n\t\tif (!check_follow_cname(direct, &fullhost, newname)) {\n\t\t\tdebug(\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, fullhost);\n\t\t}\n\t\tfree(*hostp);\n\t\t*hostp = fullhost;\n\t\treturn addrs;\n\t}\n notfound:\n\tif (!options.canonicalize_fallback_local)\n\t\tfatal(\"%s: Could not resolve host \\\"%s\\\"\", __progname, *hostp);\n\tdebug2(\"%s: host %s not found in any suffix\", __func__, *hostp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *__progname;",
      "Options options;",
      "char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: host %s not found in any suffix\"",
            "__func__",
            "*hostp"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: Could not resolve host \\\"%s\\\"\"",
            "__progname",
            "*hostp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*hostp"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\"",
            "*hostp",
            "fullhost"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_follow_cname",
          "args": [
            "direct",
            "&fullhost",
            "newname"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "check_follow_cname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "362-393",
          "snippet": "static int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\n\nstatic int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fullhost"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_host",
          "args": [
            "fullhost",
            "port",
            "0",
            "newname",
            "sizeof(newname)"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "234-267",
          "snippet": "static struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *__progname;",
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&fullhost",
            "\"%s.%s.\"",
            "*hostp",
            "options.canonical_domains[i]"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "*hostp"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*hostp"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option_clear_or_none",
          "args": [
            "options.proxy_command"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "option_clear_or_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "186-190",
          "snippet": "static int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_addr_fast",
          "args": [
            "*hostp"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "is_addr_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "270-275",
          "snippet": "static int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*hostp",
            "newname"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_addr",
          "args": [
            "*hostp",
            "port",
            "newname",
            "sizeof(newname)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "309-355",
          "snippet": "static struct addrinfo *\nresolve_addr(const char *name, int port, char *caddr, size_t clen)\n{\n\tchar addr[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tsnprintf(strport, sizeof strport, \"%u\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tdebug2(\"%s: could not resolve name %.100s as address: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (res == NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned no addresses\",\n\t\t __func__, name);\n\t\treturn NULL;\n\t}\n\tif (res->ai_next != NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned multiple addresses\",\n\t\t    __func__, name);\n\t\tgoto fail;\n\t}\n\tif ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\tdebug(\"%s: Could not format address for name %.100s: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\tgoto fail;\n\t}\n\tif (strlcpy(caddr, addr, clen) >= clen) {\n\t\terror(\"%s: host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\",\n\t\t    __func__, name,  addr, (u_long)clen);\n\t\tif (clen > 0)\n\t\t\t*caddr = '\\0';\n fail:\n\t\tfreeaddrinfo(res);\n\t\treturn NULL;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Options options;",
            "char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_addr(const char *name, int port, char *caddr, size_t clen)\n{\n\tchar addr[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tsnprintf(strport, sizeof strport, \"%u\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tdebug2(\"%s: could not resolve name %.100s as address: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (res == NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned no addresses\",\n\t\t __func__, name);\n\t\treturn NULL;\n\t}\n\tif (res->ai_next != NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned multiple addresses\",\n\t\t    __func__, name);\n\t\tgoto fail;\n\t}\n\tif ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\tdebug(\"%s: Could not format address for name %.100s: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\tgoto fail;\n\t}\n\tif (strlcpy(caddr, addr, clen) >= clen) {\n\t\terror(\"%s: host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\",\n\t\t    __func__, name,  addr, (u_long)clen);\n\t\tif (clen > 0)\n\t\t\t*caddr = '\\0';\n fail:\n\t\tfreeaddrinfo(res);\n\t\treturn NULL;\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_canonicalize(char **hostp, int port)\n{\n\tint i, direct, ndots;\n\tchar *cp, *fullhost, newname[NI_MAXHOST];\n\tstruct addrinfo *addrs;\n\n\t/*\n\t * Attempt to canonicalise addresses, regardless of\n\t * whether hostname canonicalisation was requested\n\t */\n\tif ((addrs = resolve_addr(*hostp, port,\n\t    newname, sizeof(newname))) != NULL) {\n\t\tdebug2(\"%s: hostname %.100s is address\", __func__, *hostp);\n\t\tif (strcasecmp(*hostp, newname) != 0) {\n\t\t\tdebug2(\"%s: canonicalised address \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    __func__, *hostp, newname);\n\t\t\tfree(*hostp);\n\t\t\t*hostp = xstrdup(newname);\n\t\t}\n\t\treturn addrs;\n\t}\n\n\t/*\n\t * If this looks like an address but didn't parse as one, it might\n\t * be an address with an invalid interface scope. Skip further\n\t * attempts at canonicalisation.\n\t */\n\tif (is_addr_fast(*hostp)) {\n\t\tdebug(\"%s: hostname %.100s is an unrecognised address\",\n\t\t    __func__, *hostp);\n\t\treturn NULL;\n\t}\n\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn NULL;\n\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy unless the user specifically requests so.\n\t */\n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    options.jump_host == NULL;\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn NULL;\n\n\t/* If domain name is anchored, then resolve it now */\n\tif ((*hostp)[strlen(*hostp) - 1] == '.') {\n\t\tdebug3(\"%s: name is fully qualified\", __func__);\n\t\tfullhost = xstrdup(*hostp);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) != NULL)\n\t\t\tgoto found;\n\t\tfree(fullhost);\n\t\tgoto notfound;\n\t}\n\n\t/* Don't apply canonicalization to sufficiently-qualified hostnames */\n\tndots = 0;\n\tfor (cp = *hostp; *cp != '\\0'; cp++) {\n\t\tif (*cp == '.')\n\t\t\tndots++;\n\t}\n\tif (ndots > options.canonicalize_max_dots) {\n\t\tdebug3(\"%s: not canonicalizing hostname \\\"%s\\\" (max dots %d)\",\n\t\t    __func__, *hostp, options.canonicalize_max_dots);\n\t\treturn NULL;\n\t}\n\t/* Attempt each supplied suffix */\n\tfor (i = 0; i < options.num_canonical_domains; i++) {\n\t\t*newname = '\\0';\n\t\txasprintf(&fullhost, \"%s.%s.\", *hostp,\n\t\t    options.canonical_domains[i]);\n\t\tdebug3(\"%s: attempting \\\"%s\\\" => \\\"%s\\\"\", __func__,\n\t\t    *hostp, fullhost);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) == NULL) {\n\t\t\tfree(fullhost);\n\t\t\tcontinue;\n\t\t}\n found:\n\t\t/* Remove trailing '.' */\n\t\tfullhost[strlen(fullhost) - 1] = '\\0';\n\t\t/* Follow CNAME if requested */\n\t\tif (!check_follow_cname(direct, &fullhost, newname)) {\n\t\t\tdebug(\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, fullhost);\n\t\t}\n\t\tfree(*hostp);\n\t\t*hostp = fullhost;\n\t\treturn addrs;\n\t}\n notfound:\n\tif (!options.canonicalize_fallback_local)\n\t\tfatal(\"%s: Could not resolve host \\\"%s\\\"\", __progname, *hostp);\n\tdebug2(\"%s: host %s not found in any suffix\", __func__, *hostp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "check_follow_cname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "362-393",
    "snippet": "static int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;",
      "char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cname"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*namep"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\"",
            "*namep",
            "cname"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "cname",
            "rule->target_list",
            "1"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\"",
            "__func__",
            "*namep",
            "cname"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*namep",
            "cname"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\n\nstatic int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || options.num_permitted_cnames == 0 ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t/*\n\t * Don't attempt to canonicalize names that will be interpreted by\n\t * a proxy or jump host unless the user specifically requests so.\n\t */\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3(\"%s: check \\\"%s\\\" CNAME \\\"%s\\\"\", __func__, *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "resolve_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "309-355",
    "snippet": "static struct addrinfo *\nresolve_addr(const char *name, int port, char *caddr, size_t clen)\n{\n\tchar addr[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tsnprintf(strport, sizeof strport, \"%u\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tdebug2(\"%s: could not resolve name %.100s as address: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (res == NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned no addresses\",\n\t\t __func__, name);\n\t\treturn NULL;\n\t}\n\tif (res->ai_next != NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned multiple addresses\",\n\t\t    __func__, name);\n\t\tgoto fail;\n\t}\n\tif ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\tdebug(\"%s: Could not format address for name %.100s: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\tgoto fail;\n\t}\n\tif (strlcpy(caddr, addr, clen) >= clen) {\n\t\terror(\"%s: host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\",\n\t\t    __func__, name,  addr, (u_long)clen);\n\t\tif (clen > 0)\n\t\t\t*caddr = '\\0';\n fail:\n\t\tfreeaddrinfo(res);\n\t\treturn NULL;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;",
      "char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\"",
            "__func__",
            "name",
            "addr",
            "(u_long)clen"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "caddr",
            "addr",
            "clen"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: Could not format address for name %.100s: %s\"",
            "__func__",
            "name",
            "ssh_gai_strerror(gaierr)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "gaierr"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "res->ai_addr",
            "res->ai_addrlen",
            "addr",
            "sizeof(addr)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: could not resolve name %.100s as address: %s\"",
            "__func__",
            "name",
            "ssh_gai_strerror(gaierr)"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "name",
            "strport",
            "&hints",
            "&res"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%u\"",
            "port"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_ssh_port",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "default_ssh_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "461-472",
          "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_addr(const char *name, int port, char *caddr, size_t clen)\n{\n\tchar addr[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tsnprintf(strport, sizeof strport, \"%u\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tdebug2(\"%s: could not resolve name %.100s as address: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (res == NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned no addresses\",\n\t\t __func__, name);\n\t\treturn NULL;\n\t}\n\tif (res->ai_next != NULL) {\n\t\tdebug(\"%s: getaddrinfo %.100s returned multiple addresses\",\n\t\t    __func__, name);\n\t\tgoto fail;\n\t}\n\tif ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\tdebug(\"%s: Could not format address for name %.100s: %s\",\n\t\t    __func__, name, ssh_gai_strerror(gaierr));\n\t\tgoto fail;\n\t}\n\tif (strlcpy(caddr, addr, clen) >= clen) {\n\t\terror(\"%s: host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\",\n\t\t    __func__, name,  addr, (u_long)clen);\n\t\tif (clen > 0)\n\t\t\t*caddr = '\\0';\n fail:\n\t\tfreeaddrinfo(res);\n\t\treturn NULL;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "is_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "278-301",
    "snippet": "static int\nis_addr(const char *name)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\n\tif (is_addr_fast(name))\n\t\treturn 1;\n\n\tsnprintf(strport, sizeof strport, \"%u\", default_ssh_port());\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif (getaddrinfo(name, strport, &hints, &res) != 0)\n\t\treturn 0;\n\tif (res == NULL || res->ai_next != NULL) {\n\t\tfreeaddrinfo(res);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(res);\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "name",
            "strport",
            "&hints",
            "&res"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%u\"",
            "default_ssh_port()"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_ssh_port",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "default_ssh_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "461-472",
          "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_addr_fast",
          "args": [
            "name"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "is_addr_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
          "lines": "270-275",
          "snippet": "static int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"utf8.h\"",
            "#include \"myproposal.h\"",
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshconnect.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"clientloop.h\"",
            "#include \"dispatch.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"canohost.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/resource.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOptions options;\n\nstatic int\nis_addr(const char *name)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\n\tif (is_addr_fast(name))\n\t\treturn 1;\n\n\tsnprintf(strport, sizeof strport, \"%u\", default_ssh_port());\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif (getaddrinfo(name, strport, &hints, &res) != 0)\n\t\treturn 0;\n\tif (res == NULL || res->ai_next != NULL) {\n\t\tfreeaddrinfo(res);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(res);\n\treturn 1;\n}"
  },
  {
    "function_name": "is_addr_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "270-275",
    "snippet": "static int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "name",
            "\"0123456789.\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "':'"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}"
  },
  {
    "function_name": "resolve_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "234-267",
    "snippet": "static struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *__progname;",
      "Options options;",
      "char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\"",
            "__func__",
            "name",
            "res->ai_canonname",
            "(u_long)clen"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "cname",
            "res->ai_canonname",
            "clen"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "loglevel",
            "\"%s: Could not resolve hostname %.100s: %s\"",
            "__progname",
            "name",
            "ssh_gai_strerror(gaierr)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "gaierr"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "name",
            "strport",
            "&hints",
            "&res"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "port"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_ssh_port",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "default_ssh_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "461-472",
          "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nOptions options;\nchar *host;\n\nstatic struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror(\"%s: host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    __func__, name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "tilde_expand_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "215-226",
    "snippet": "static void\ntilde_expand_paths(char **paths, u_int num_paths)\n{\n\tu_int i;\n\tchar *cp;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tcp = tilde_expand_filename(paths[i], getuid());\n\t\tfree(paths[i]);\n\t\tpaths[i] = cp;\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "paths[i]"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "paths[i]",
            "getuid()"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ntilde_expand_paths(char **paths, u_int num_paths)\n{\n\tu_int i;\n\tchar *cp;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tcp = tilde_expand_filename(paths[i], getuid());\n\t\tfree(paths[i]);\n\t\tpaths[i] = cp;\n\t}\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh.c",
    "lines": "195-208",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\\n\"\n\"           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\\n\"\n\"           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\\n\"\n\"           [-i identity_file] [-J [user@]host[:port]] [-L address]\\n\"\n\"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\\n\"\n\"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\\n\"\n\"           [-w local_tun[:remote_tun]] destination [command]\\n\"\n\t);\n\texit(255);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"utf8.h\"",
      "#include \"myproposal.h\"",
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"sshconnect.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"clientloop.h\"",
      "#include \"dispatch.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"canohost.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/err.h>",
      "#include <openssl/evp.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/resource.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host;",
      "struct sshbuf *command;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "255"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\\n\"\n\"           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\\n\"\n\"           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\\n\"\n\"           [-i identity_file] [-J [user@]host[:port]] [-L address]\\n\"\n\"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\\n\"\n\"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\\n\"\n\"           [-w local_tun[:remote_tun]] destination [command]\\n\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"utf8.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"version.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"clientloop.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *host;\nstruct sshbuf *command;\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\\n\"\n\"           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\\n\"\n\"           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\\n\"\n\"           [-i identity_file] [-J [user@]host[:port]] [-L address]\\n\"\n\"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\\n\"\n\"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\\n\"\n\"           [-w local_tun[:remote_tun]] destination [command]\\n\"\n\t);\n\texit(255);\n}"
  }
]