[
  {
    "function_name": "setproctitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
    "lines": "122-167",
    "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
    "includes": [
      "#include <vis.h>",
      "#include <string.h>",
      "#include <sys/pstat.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
      "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
      "#define SPT_NONE\t0\t/* don't use it at all */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "argv_start",
            "ptitle",
            "argv_env_len"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstat",
          "args": [
            "PSTAT_SETCMD",
            "pst",
            "strlen(ptitle)",
            "0",
            "0"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptitle"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnvis",
          "args": [
            "ptitle",
            "buf",
            "sizeof(ptitle)",
            "VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "strnvis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/vis.c",
          "lines": "173-214",
          "snippet": "int\nstrnvis(char *dst, const char *src, size_t siz, int flag)\n{\n\tchar *start, *end;\n\tchar tbuf[5];\n\tint c, i;\n\n\ti = 0;\n\tfor (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {\n\t\tif (isvisible(c, flag)) {\n\t\t\tif ((c == '\"' && (flag & VIS_DQ) != 0) ||\n\t\t\t    (c == '\\\\' && (flag & VIS_NOSLASH) == 0)) {\n\t\t\t\t/* need space for the extra '\\\\' */\n\t\t\t\tif (dst + 1 >= end) {\n\t\t\t\t\ti = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t}\n\t\t\ti = 1;\n\t\t\t*dst++ = c;\n\t\t\tsrc++;\n\t\t} else {\n\t\t\ti = vis(tbuf, c, flag, *++src) - tbuf;\n\t\t\tif (dst + i <= end) {\n\t\t\t\tmemcpy(dst, tbuf, i);\n\t\t\t\tdst += i;\n\t\t\t} else {\n\t\t\t\tsrc--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (siz > 0)\n\t\t*dst = '\\0';\n\tif (dst + i > end) {\n\t\t/* adjust return value for truncation */\n\t\twhile ((c = *src))\n\t\t\tdst += vis(tbuf, c, flag, *++src) - tbuf;\n\t}\n\treturn (dst - start);\n}",
          "includes": [
            "#include \"vis.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vis.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nstrnvis(char *dst, const char *src, size_t siz, int flag)\n{\n\tchar *start, *end;\n\tchar tbuf[5];\n\tint c, i;\n\n\ti = 0;\n\tfor (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {\n\t\tif (isvisible(c, flag)) {\n\t\t\tif ((c == '\"' && (flag & VIS_DQ) != 0) ||\n\t\t\t    (c == '\\\\' && (flag & VIS_NOSLASH) == 0)) {\n\t\t\t\t/* need space for the extra '\\\\' */\n\t\t\t\tif (dst + 1 >= end) {\n\t\t\t\t\ti = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t}\n\t\t\ti = 1;\n\t\t\t*dst++ = c;\n\t\t\tsrc++;\n\t\t} else {\n\t\t\ti = vis(tbuf, c, flag, *++src) - tbuf;\n\t\t\tif (dst + i <= end) {\n\t\t\t\tmemcpy(dst, tbuf, i);\n\t\t\t\tdst += i;\n\t\t\t} else {\n\t\t\t\tsrc--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (siz > 0)\n\t\t*dst = '\\0';\n\tif (dst + i > end) {\n\t\t/* adjust return value for truncation */\n\t\twhile ((c = *src))\n\t\t\tdst += vis(tbuf, c, flag, *++src) - tbuf;\n\t}\n\treturn (dst - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buf + len",
            "sizeof(buf) - len",
            "fmt",
            "ap"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "861-865",
          "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "buf",
            "\": \"",
            "sizeof(buf)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
  },
  {
    "function_name": "compat_init_setproctitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
    "lines": "67-119",
    "snippet": "void\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}",
    "includes": [
      "#include <vis.h>",
      "#include <string.h>",
      "#include <sys/pstat.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SPT_REUSEARGV\t2\t/* cover argv with title information */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "envp[i]"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "envp[i]"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "i + 1",
            "sizeof(*environ)"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n\nvoid\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}"
  }
]