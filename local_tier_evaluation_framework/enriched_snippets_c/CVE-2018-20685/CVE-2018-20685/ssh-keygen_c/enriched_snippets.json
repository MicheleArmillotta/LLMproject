[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2432-2950",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tchar dotsshdir[PATH_MAX], comment[1024], *passphrase1, *passphrase2;\n\tchar *rr_hostname = NULL, *ep, *fp, *ra;\n\tstruct sshkey *private, *public;\n\tstruct passwd *pw;\n\tstruct stat st;\n\tint r, opt, type, fd;\n\tint gen_all_hostkeys = 0, gen_krl = 0, update_krl = 0, check_krl = 0;\n\tFILE *f;\n\tconst char *errstr;\n#ifdef WITH_OPENSSL\n\t/* Moduli generation/screening */\n\tchar out_file[PATH_MAX], *checkpoint = NULL;\n\tu_int32_t memory = 0, generator_wanted = 0;\n\tint do_gen_candidates = 0, do_screen_candidates = 0;\n\tunsigned long start_lineno = 0, lines_to_process = 0;\n\tBIGNUM *start = NULL;\n#endif\n\n\textern int optind;\n\textern char *optarg;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(argv[0]);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\tlog_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);\n\n\tseed_rng();\n\n\tmsetlocale();\n\n\t/* we need this for the home * directory.  */\n\tpw = getpwuid(getuid());\n\tif (!pw)\n\t\tfatal(\"No user exists for uid %lu\", (u_long)getuid());\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\n\t/* Remaining characters: Ydw */\n\twhile ((opt = getopt(argc, argv, \"ABHLQUXceghiklopquvxy\"\n\t    \"C:D:E:F:G:I:J:K:M:N:O:P:R:S:T:V:W:Z:\"\n\t    \"a:b:f:g:j:m:n:r:s:t:z:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'A':\n\t\t\tgen_all_hostkeys = 1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbits = (u_int32_t)strtonum(optarg, 10, 32768, &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Bits has bad value %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfind_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\thash_hosts = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tcert_key_id = optarg;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdelete_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tshow_cert = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tprint_fingerprint = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tprint_bubblebabble = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"RFC4716\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"ssh2\") == 0) {\n\t\t\t\tconvert_format = FMT_RFC4716;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PKCS8\") == 0) {\n\t\t\t\tconvert_format = FMT_PKCS8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PEM\") == 0) {\n\t\t\t\tconvert_format = FMT_PEM;\n\t\t\t\tuse_new_format = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfatal(\"Unsupported conversion format \\\"%s\\\"\", optarg);\n\t\tcase 'n':\n\t\t\tcert_principals = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t/* no-op; new format is already the default */\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tchange_passphrase = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tchange_comment = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (strlcpy(identity_file, optarg,\n\t\t\t    sizeof(identity_file)) >= sizeof(identity_file))\n\t\t\t\tfatal(\"Identity filename too long\");\n\t\t\thave_identity = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tprint_generic = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tidentity_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tidentity_new_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcheck_krl = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tadd_cert_option(optarg);\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tnew_format_cipher = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tidentity_comment = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\tcase 'x':\n\t\t\t/* export key */\n\t\t\tconvert_to = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcert_key_type = SSH2_CERT_TYPE_HOST;\n\t\t\tcertflags_flags = 0;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tgen_krl = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\tcase 'X':\n\t\t\t/* import key */\n\t\t\tconvert_from = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tprint_public = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tca_key_path = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tkey_type_name = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tpkcs11provider = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tprefer_agent = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tupdate_krl = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (log_level == SYSLOG_LEVEL_INFO)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse {\n\t\t\t\tif (log_level >= SYSLOG_LEVEL_DEBUG1 &&\n\t\t\t\t    log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_level++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\trounds = (int)strtonum(optarg, 1, INT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Invalid number: %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tparse_cert_times(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\terrno = 0;\n\t\t\tcert_serial = strtoull(optarg, &ep, 10);\n\t\t\tif (*optarg < '0' || *optarg > '9' || *ep != '\\0' ||\n\t\t\t    (errno == ERANGE && cert_serial == ULLONG_MAX))\n\t\t\t\tfatal(\"Invalid serial number \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n#ifdef WITH_OPENSSL\n\t\t/* Moduli generation/screening */\n\t\tcase 'G':\n\t\t\tdo_gen_candidates = 1;\n\t\t\tif (strlcpy(out_file, optarg, sizeof(out_file)) >=\n\t\t\t    sizeof(out_file))\n\t\t\t\tfatal(\"Output filename too long\");\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tlines_to_process = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tstart_lineno = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tif (strlen(optarg) >= PATH_MAX)\n\t\t\t\tfatal(\"Checkpoint filename too long\");\n\t\t\tcheckpoint = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmemory = (u_int32_t)strtonum(optarg, 1, UINT_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Memory limit is %s: %s\", errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t/* XXX - also compare length against bits */\n\t\t\tif (BN_hex2bn(&start, optarg) == 0)\n\t\t\t\tfatal(\"Invalid start point.\");\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tdo_screen_candidates = 1;\n\t\t\tif (strlcpy(out_file, optarg, sizeof(out_file)) >=\n\t\t\t    sizeof(out_file))\n\t\t\t\tfatal(\"Output filename too long\");\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tgenerator_wanted = (u_int32_t)strtonum(optarg, 1,\n\t\t\t    UINT_MAX, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tfatal(\"Desired generator invalid: %s (%s)\",\n\t\t\t\t    optarg, errstr);\n\t\t\tbreak;\n#endif /* WITH_OPENSSL */\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/* reinit */\n\tlog_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);\n\n\targv += optind;\n\targc -= optind;\n\n\tif (ca_key_path != NULL) {\n\t\tif (argc < 1 && !gen_krl) {\n\t\t\terror(\"Too few arguments.\");\n\t\t\tusage();\n\t\t}\n\t} else if (argc > 0 && !gen_krl && !check_krl) {\n\t\terror(\"Too many arguments.\");\n\t\tusage();\n\t}\n\tif (change_passphrase && change_comment) {\n\t\terror(\"Can only have one of -p and -c.\");\n\t\tusage();\n\t}\n\tif (print_fingerprint && (delete_host || hash_hosts)) {\n\t\terror(\"Cannot use -l with -H or -R.\");\n\t\tusage();\n\t}\n\tif (gen_krl) {\n\t\tdo_gen_krl(pw, update_krl, argc, argv);\n\t\treturn (0);\n\t}\n\tif (check_krl) {\n\t\tdo_check_krl(pw, argc, argv);\n\t\treturn (0);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (cert_key_id == NULL)\n\t\t\tfatal(\"Must specify key id (-I) when certifying\");\n\t\tdo_ca_sign(pw, argc, argv);\n\t}\n\tif (show_cert)\n\t\tdo_show_cert(pw);\n\tif (delete_host || hash_hosts || find_host)\n\t\tdo_known_hosts(pw, rr_hostname);\n\tif (pkcs11provider != NULL)\n\t\tdo_download(pw);\n\tif (print_fingerprint || print_bubblebabble)\n\t\tdo_fingerprint(pw);\n\tif (change_passphrase)\n\t\tdo_change_passphrase(pw);\n\tif (change_comment)\n\t\tdo_change_comment(pw);\n#ifdef WITH_OPENSSL\n\tif (convert_to)\n\t\tdo_convert_to(pw);\n\tif (convert_from)\n\t\tdo_convert_from(pw);\n#endif\n\tif (print_public)\n\t\tdo_print_public(pw);\n\tif (rr_hostname != NULL) {\n\t\tunsigned int n = 0;\n\n\t\tif (have_identity) {\n\t\t\tn = do_print_resource_record(pw,\n\t\t\t    identity_file, rr_hostname);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t\t\texit(0);\n\t\t} else {\n\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_RSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_DSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ECDSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ED25519_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_XMSS_KEY_FILE, rr_hostname);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"no keys found.\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n#ifdef WITH_OPENSSL\n\tif (do_gen_candidates) {\n\t\tFILE *out = fopen(out_file, \"w\");\n\n\t\tif (out == NULL) {\n\t\t\terror(\"Couldn't open modulus candidate file \\\"%s\\\": %s\",\n\t\t\t    out_file, strerror(errno));\n\t\t\treturn (1);\n\t\t}\n\t\tif (bits == 0)\n\t\t\tbits = DEFAULT_BITS;\n\t\tif (gen_candidates(out, memory, bits, start) != 0)\n\t\t\tfatal(\"modulus candidate generation failed\");\n\n\t\treturn (0);\n\t}\n\n\tif (do_screen_candidates) {\n\t\tFILE *in;\n\t\tFILE *out = fopen(out_file, \"a\");\n\n\t\tif (have_identity && strcmp(identity_file, \"-\") != 0) {\n\t\t\tif ((in = fopen(identity_file, \"r\")) == NULL) {\n\t\t\t\tfatal(\"Couldn't open modulus candidate \"\n\t\t\t\t    \"file \\\"%s\\\": %s\", identity_file,\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t} else\n\t\t\tin = stdin;\n\n\t\tif (out == NULL) {\n\t\t\tfatal(\"Couldn't open moduli file \\\"%s\\\": %s\",\n\t\t\t    out_file, strerror(errno));\n\t\t}\n\t\tif (prime_test(in, out, rounds == 0 ? 100 : rounds,\n\t\t    generator_wanted, checkpoint,\n\t\t    start_lineno, lines_to_process) != 0)\n\t\t\tfatal(\"modulus screening failed\");\n\t\treturn (0);\n\t}\n#endif\n\n\tif (gen_all_hostkeys) {\n\t\tdo_gen_all_hostkeys(pw);\n\t\treturn (0);\n\t}\n\n\tif (key_type_name == NULL)\n\t\tkey_type_name = DEFAULT_KEY_TYPE_NAME;\n\n\ttype = sshkey_type_from_name(key_type_name);\n\ttype_bits_valid(type, key_type_name, &bits);\n\n\tif (!quiet)\n\t\tprintf(\"Generating public/private %s key pair.\\n\",\n\t\t    key_type_name);\n\tif ((r = sshkey_generate(type, bits, &private)) != 0)\n\t\tfatal(\"sshkey_generate failed\");\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\\n\", ssh_err(r));\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which to save the key\");\n\n\t/* Create ~/.ssh directory if it doesn't already exist. */\n\tsnprintf(dotsshdir, sizeof dotsshdir, \"%s/%s\",\n\t    pw->pw_dir, _PATH_SSH_USER_DIR);\n\tif (strstr(identity_file, dotsshdir) != NULL) {\n\t\tif (stat(dotsshdir, &st) < 0) {\n\t\t\tif (errno != ENOENT) {\n\t\t\t\terror(\"Could not stat %s: %s\", dotsshdir,\n\t\t\t\t    strerror(errno));\n\t\t\t} else if (mkdir(dotsshdir, 0700) < 0) {\n\t\t\t\terror(\"Could not create directory '%s': %s\",\n\t\t\t\t    dotsshdir, strerror(errno));\n\t\t\t} else if (!quiet)\n\t\t\t\tprintf(\"Created directory '%s'.\\n\", dotsshdir);\n\t\t}\n\t}\n\t/* If the file already exists, ask the user to confirm. */\n\tif (stat(identity_file, &st) >= 0) {\n\t\tchar yesno[3];\n\t\tprintf(\"%s already exists.\\n\", identity_file);\n\t\tprintf(\"Overwrite (y/n)? \");\n\t\tfflush(stdout);\n\t\tif (fgets(yesno, sizeof(yesno), stdin) == NULL)\n\t\t\texit(1);\n\t\tif (yesno[0] != 'y' && yesno[0] != 'Y')\n\t\t\texit(1);\n\t}\n\t/* Ask for a passphrase (twice). */\n\tif (identity_passphrase)\n\t\tpassphrase1 = xstrdup(identity_passphrase);\n\telse if (identity_new_passphrase)\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\telse {\npassphrase_again:\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\t/*\n\t\t\t * The passphrases do not match.  Clear them and\n\t\t\t * retry.\n\t\t\t */\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Passphrases do not match.  Try again.\\n\");\n\t\t\tgoto passphrase_again;\n\t\t}\n\t\t/* Clear the other copy of the passphrase. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\tif (identity_comment) {\n\t\tstrlcpy(comment, identity_comment, sizeof(comment));\n\t} else {\n\t\t/* Create default comment field for the passphrase. */\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name, hostname);\n\t}\n\n\t/* Save the key with the given passphrase and comment. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\texit(1);\n\t}\n\t/* Clear the passphrase. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\n\t/* Clear the private key and the random number generator. */\n\tsshkey_free(private);\n\n\tif (!quiet)\n\t\tprintf(\"Your identification has been saved in %s.\\n\", identity_file);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"Unable to save public key to %s: %s\",\n\t\t    identity_file, strerror(errno));\n\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\terror(\"write key failed: %s\", ssh_err(r));\n\tfprintf(f, \" %s\\n\", comment);\n\tif (ferror(f) || fclose(f) != 0)\n\t\tfatal(\"write public failed: %s\", strerror(errno));\n\n\tif (!quiet) {\n\t\tfp = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tprintf(\"Your public key has been saved in %s.\\n\",\n\t\t    identity_file);\n\t\tprintf(\"The key fingerprint is:\\n\");\n\t\tprintf(\"%s %s\\n\", fp, comment);\n\t\tprintf(\"The key's randomart image is:\\n\");\n\t\tprintf(\"%s\\n\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t}\n\n\tsshkey_free(public);\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DEFAULT_BITS\t\t2048"
    ],
    "globals_used": [
      "u_int32_t bits = 0;",
      "int change_passphrase = 0;",
      "int change_comment = 0;",
      "int quiet = 0;",
      "int log_level = SYSLOG_LEVEL_INFO;",
      "int hash_hosts = 0;",
      "int find_host = 0;",
      "int delete_host = 0;",
      "int show_cert = 0;",
      "int print_fingerprint = 0;",
      "int print_bubblebabble = 0;",
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;",
      "char identity_file[1024];",
      "int have_identity = 0;",
      "char *identity_passphrase = NULL;",
      "char *identity_new_passphrase = NULL;",
      "char *identity_comment = NULL;",
      "char *ca_key_path = NULL;",
      "int prefer_agent = 0;",
      "unsigned long long cert_serial = 0;",
      "u_int cert_key_type = SSH2_CERT_TYPE_USER;",
      "char *cert_key_id = NULL;",
      "char *cert_principals = NULL;",
      "u_int32_t certflags_flags = CERTOPT_DEFAULT;",
      "int convert_to = 0;",
      "int convert_from = 0;",
      "enum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;",
      "int print_public = 0;",
      "int print_generic = 0;",
      "char *key_type_name = NULL;",
      "char *pkcs11provider = NULL;",
      "int use_new_format = 1;",
      "char *new_format_cipher = NULL;",
      "int rounds = 0;",
      "extern char *__progname;",
      "char hostname[NI_MAXHOST];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "ra"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"The key's randomart image is:\\n\""
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_fingerprint failed\""
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "public",
            "fingerprint_hash",
            "SSH_FP_RANDOMART"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"write public failed: %s\"",
            "strerror(errno)"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "f"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\\n\"",
            "comment"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"write key failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "public",
            "f"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"w\""
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "identity_file",
            "O_WRONLY|O_CREAT|O_TRUNC",
            "0644"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "identity_file",
            "\".pub\"",
            "sizeof(identity_file)"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passphrase1",
            "strlen(passphrase1)"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_save_private",
          "args": [
            "private",
            "identity_file",
            "passphrase1",
            "comment",
            "use_new_format",
            "new_format_cipher",
            "rounds"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_save_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "74-93",
          "snippet": "int\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "comment",
            "sizeof comment",
            "\"%s@%s\"",
            "pw->pw_name",
            "hostname"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "comment",
            "identity_comment",
            "sizeof(comment)"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase2"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase2"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "passphrase1",
            "passphrase2"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"Enter same passphrase again: \"",
            "RP_ALLOW_STDIN"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "identity_new_passphrase"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "yesno",
            "sizeof(yesno)",
            "stdin"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dotsshdir",
            "0700"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "identity_file",
            "dotsshdir"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which to save the key\""
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "private",
            "&public"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_generate",
          "args": [
            "type",
            "bits",
            "&private"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1605-1654",
          "snippet": "int\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_bits_valid",
          "args": [
            "type",
            "key_type_name",
            "&bits"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "type_bits_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "205-253",
          "snippet": "static void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DEFAULT_BITS_ECDSA\t256",
            "#define DEFAULT_BITS_DSA\t1024",
            "#define DEFAULT_BITS\t\t2048"
          ],
          "globals_used": [
            "u_int32_t bits = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define DEFAULT_BITS_ECDSA\t256\n#define DEFAULT_BITS_DSA\t1024\n#define DEFAULT_BITS\t\t2048\n\nu_int32_t bits = 0;\nchar *key_type_name = NULL;\n\nstatic void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "key_type_name"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_gen_all_hostkeys",
          "args": [
            "pw"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "do_gen_all_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1000-1137",
          "snippet": "static void\ndo_gen_all_hostkeys(struct passwd *pw)\n{\n\tstruct {\n\t\tchar *key_type;\n\t\tchar *key_type_display;\n\t\tchar *path;\n\t} key_types[] = {\n#ifdef WITH_OPENSSL\n\t\t{ \"rsa\", \"RSA\" ,_PATH_HOST_RSA_KEY_FILE },\n\t\t{ \"dsa\", \"DSA\", _PATH_HOST_DSA_KEY_FILE },\n#ifdef OPENSSL_HAS_ECC\n\t\t{ \"ecdsa\", \"ECDSA\",_PATH_HOST_ECDSA_KEY_FILE },\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t\t{ \"ed25519\", \"ED25519\",_PATH_HOST_ED25519_KEY_FILE },\n#ifdef WITH_XMSS\n\t\t{ \"xmss\", \"XMSS\",_PATH_HOST_XMSS_KEY_FILE },\n#endif /* WITH_XMSS */\n\t\t{ NULL, NULL, NULL }\n\t};\n\n\tint first = 0;\n\tstruct stat st;\n\tstruct sshkey *private, *public;\n\tchar comment[1024], *prv_tmp, *pub_tmp, *prv_file, *pub_file;\n\tint i, type, fd, r;\n\tFILE *f;\n\n\tfor (i = 0; key_types[i].key_type; i++) {\n\t\tpublic = private = NULL;\n\t\tprv_tmp = pub_tmp = prv_file = pub_file = NULL;\n\n\t\txasprintf(&prv_file, \"%s%s\",\n\t\t    identity_file, key_types[i].path);\n\n\t\t/* Check whether private key exists and is not zero-length */\n\t\tif (stat(prv_file, &st) == 0) {\n\t\t\tif (st.st_size != 0)\n\t\t\t\tgoto next;\n\t\t} else if (errno != ENOENT) {\n\t\t\terror(\"Could not stat %s: %s\", key_types[i].path,\n\t\t\t    strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/*\n\t\t * Private key doesn't exist or is invalid; proceed with\n\t\t * key generation.\n\t\t */\n\t\txasprintf(&prv_tmp, \"%s%s.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_tmp, \"%s%s.pub.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_file, \"%s%s.pub\",\n\t\t    identity_file, key_types[i].path);\n\n\t\tif (first == 0) {\n\t\t\tfirst = 1;\n\t\t\tprintf(\"%s: generating new host keys: \", __progname);\n\t\t}\n\t\tprintf(\"%s \", key_types[i].key_type_display);\n\t\tfflush(stdout);\n\t\ttype = sshkey_type_from_name(key_types[i].key_type);\n\t\tif ((fd = mkstemp(prv_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    prv_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tclose(fd); /* just using mkstemp() to generate/reserve a name */\n\t\tbits = 0;\n\t\ttype_bits_valid(type, NULL, &bits);\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0) {\n\t\t\terror(\"sshkey_generate failed: %s\", ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name,\n\t\t    hostname);\n\t\tif ((r = sshkey_save_private(private, prv_tmp, \"\",\n\t\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t\t    prv_tmp, ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((fd = mkstemp(pub_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    pub_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)fchmod(fd, 0644);\n\t\tf = fdopen(fd, \"w\");\n\t\tif (f == NULL) {\n\t\t\terror(\"fdopen %s failed: %s\", pub_tmp, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_write(public, f)) != 0) {\n\t\t\terror(\"write key failed: %s\", ssh_err(r));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tif (ferror(f) != 0) {\n\t\t\terror(\"write key failed: %s\", strerror(errno));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (fclose(f) != 0) {\n\t\t\terror(\"key close failed: %s\", strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/* Rename temporary files to their permanent locations. */\n\t\tif (rename(pub_tmp, pub_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    pub_file, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (rename(prv_tmp, prv_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    key_types[i].path, strerror(errno));\n failnext:\n\t\t\tfirst = 0;\n\t\t\tgoto next;\n\t\t}\n next:\n\t\tsshkey_free(private);\n\t\tsshkey_free(public);\n\t\tfree(prv_tmp);\n\t\tfree(pub_tmp);\n\t\tfree(prv_file);\n\t\tfree(pub_file);\n\t}\n\tif (first != 0)\n\t\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t bits = 0;",
            "char identity_file[1024];",
            "int use_new_format = 1;",
            "char *new_format_cipher = NULL;",
            "int rounds = 0;",
            "extern char *__progname;",
            "char hostname[NI_MAXHOST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t bits = 0;\nchar identity_file[1024];\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\nextern char *__progname;\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_gen_all_hostkeys(struct passwd *pw)\n{\n\tstruct {\n\t\tchar *key_type;\n\t\tchar *key_type_display;\n\t\tchar *path;\n\t} key_types[] = {\n#ifdef WITH_OPENSSL\n\t\t{ \"rsa\", \"RSA\" ,_PATH_HOST_RSA_KEY_FILE },\n\t\t{ \"dsa\", \"DSA\", _PATH_HOST_DSA_KEY_FILE },\n#ifdef OPENSSL_HAS_ECC\n\t\t{ \"ecdsa\", \"ECDSA\",_PATH_HOST_ECDSA_KEY_FILE },\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t\t{ \"ed25519\", \"ED25519\",_PATH_HOST_ED25519_KEY_FILE },\n#ifdef WITH_XMSS\n\t\t{ \"xmss\", \"XMSS\",_PATH_HOST_XMSS_KEY_FILE },\n#endif /* WITH_XMSS */\n\t\t{ NULL, NULL, NULL }\n\t};\n\n\tint first = 0;\n\tstruct stat st;\n\tstruct sshkey *private, *public;\n\tchar comment[1024], *prv_tmp, *pub_tmp, *prv_file, *pub_file;\n\tint i, type, fd, r;\n\tFILE *f;\n\n\tfor (i = 0; key_types[i].key_type; i++) {\n\t\tpublic = private = NULL;\n\t\tprv_tmp = pub_tmp = prv_file = pub_file = NULL;\n\n\t\txasprintf(&prv_file, \"%s%s\",\n\t\t    identity_file, key_types[i].path);\n\n\t\t/* Check whether private key exists and is not zero-length */\n\t\tif (stat(prv_file, &st) == 0) {\n\t\t\tif (st.st_size != 0)\n\t\t\t\tgoto next;\n\t\t} else if (errno != ENOENT) {\n\t\t\terror(\"Could not stat %s: %s\", key_types[i].path,\n\t\t\t    strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/*\n\t\t * Private key doesn't exist or is invalid; proceed with\n\t\t * key generation.\n\t\t */\n\t\txasprintf(&prv_tmp, \"%s%s.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_tmp, \"%s%s.pub.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_file, \"%s%s.pub\",\n\t\t    identity_file, key_types[i].path);\n\n\t\tif (first == 0) {\n\t\t\tfirst = 1;\n\t\t\tprintf(\"%s: generating new host keys: \", __progname);\n\t\t}\n\t\tprintf(\"%s \", key_types[i].key_type_display);\n\t\tfflush(stdout);\n\t\ttype = sshkey_type_from_name(key_types[i].key_type);\n\t\tif ((fd = mkstemp(prv_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    prv_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tclose(fd); /* just using mkstemp() to generate/reserve a name */\n\t\tbits = 0;\n\t\ttype_bits_valid(type, NULL, &bits);\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0) {\n\t\t\terror(\"sshkey_generate failed: %s\", ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name,\n\t\t    hostname);\n\t\tif ((r = sshkey_save_private(private, prv_tmp, \"\",\n\t\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t\t    prv_tmp, ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((fd = mkstemp(pub_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    pub_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)fchmod(fd, 0644);\n\t\tf = fdopen(fd, \"w\");\n\t\tif (f == NULL) {\n\t\t\terror(\"fdopen %s failed: %s\", pub_tmp, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_write(public, f)) != 0) {\n\t\t\terror(\"write key failed: %s\", ssh_err(r));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tif (ferror(f) != 0) {\n\t\t\terror(\"write key failed: %s\", strerror(errno));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (fclose(f) != 0) {\n\t\t\terror(\"key close failed: %s\", strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/* Rename temporary files to their permanent locations. */\n\t\tif (rename(pub_tmp, pub_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    pub_file, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (rename(prv_tmp, prv_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    key_types[i].path, strerror(errno));\n failnext:\n\t\t\tfirst = 0;\n\t\t\tgoto next;\n\t\t}\n next:\n\t\tsshkey_free(private);\n\t\tsshkey_free(public);\n\t\tfree(prv_tmp);\n\t\tfree(pub_tmp);\n\t\tfree(prv_file);\n\t\tfree(pub_file);\n\t}\n\tif (first != 0)\n\t\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "prime_test",
          "args": [
            "in",
            "out",
            "rounds == 0 ? 100 : rounds",
            "generator_wanted",
            "checkpoint",
            "start_lineno",
            "lines_to_process"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "prime_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "574-806",
          "snippet": "int\nprime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,\n    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)\n{\n\tBIGNUM *q, *p, *a;\n\tBN_CTX *ctx;\n\tchar *cp, *lp;\n\tu_int32_t count_in = 0, count_out = 0, count_possible = 0;\n\tu_int32_t generator_known, in_tests, in_tries, in_type, in_size;\n\tunsigned long last_processed = 0, end_lineno;\n\ttime_t time_start, time_stop;\n\tint res;\n\n\tif (trials < TRIAL_MINIMUM) {\n\t\terror(\"Minimum primality trials is %d\", TRIAL_MINIMUM);\n\t\treturn (-1);\n\t}\n\n\tif (num_lines == 0)\n\t\tend_lineno = count_lines(in);\n\telse\n\t\tend_lineno = start_lineno + num_lines;\n\n\ttime(&time_start);\n\n\tif ((p = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\tfatal(\"BN_CTX_new failed\");\n\n\tdebug2(\"%.24s Final %u Miller-Rabin trials (%x generator)\",\n\t    ctime(&time_start), trials, generator_wanted);\n\n\tif (checkpoint_file != NULL)\n\t\tlast_processed = read_checkpoint(checkpoint_file);\n\tlast_processed = start_lineno = MAXIMUM(last_processed, start_lineno);\n\tif (end_lineno == ULONG_MAX)\n\t\tdebug(\"process from line %lu from pipe\", last_processed);\n\telse\n\t\tdebug(\"process from line %lu to line %lu\", last_processed,\n\t\t    end_lineno);\n\n\tres = 0;\n\tlp = xmalloc(QLINESIZE + 1);\n\twhile (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {\n\t\tcount_in++;\n\t\tif (count_in <= last_processed) {\n\t\t\tdebug3(\"skipping line %u, before checkpoint or \"\n\t\t\t    \"specified start line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tif (checkpoint_file != NULL)\n\t\t\twrite_checkpoint(checkpoint_file, count_in);\n\t\tprint_progress(start_lineno, count_in, end_lineno);\n\t\tif (strlen(lp) < 14 || *lp == '!' || *lp == '#') {\n\t\t\tdebug2(\"%10u: comment or short line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX - fragile parser */\n\t\t/* time */\n\t\tcp = &lp[14];\t/* (skip) */\n\n\t\t/* type */\n\t\tin_type = strtoul(cp, &cp, 10);\n\n\t\t/* tests */\n\t\tin_tests = strtoul(cp, &cp, 10);\n\n\t\tif (in_tests & MODULI_TESTS_COMPOSITE) {\n\t\t\tdebug2(\"%10u: known composite\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* tries */\n\t\tin_tries = strtoul(cp, &cp, 10);\n\n\t\t/* size (most significant bit) */\n\t\tin_size = strtoul(cp, &cp, 10);\n\n\t\t/* generator (hex) */\n\t\tgenerator_known = strtoul(cp, &cp, 16);\n\n\t\t/* Skip white space */\n\t\tcp += strspn(cp, \" \");\n\n\t\t/* modulus (hex) */\n\t\tswitch (in_type) {\n\t\tcase MODULI_TYPE_SOPHIE_GERMAIN:\n\t\t\tdebug2(\"%10u: (%u) Sophie-Germain\", count_in, in_type);\n\t\t\ta = q;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* p = 2*q + 1 */\n\t\t\tif (BN_lshift(p, q, 1) == 0)\n\t\t\t\tfatal(\"BN_lshift failed\");\n\t\t\tif (BN_add_word(p, 1) == 0)\n\t\t\t\tfatal(\"BN_add_word failed\");\n\t\t\tin_size += 1;\n\t\t\tgenerator_known = 0;\n\t\t\tbreak;\n\t\tcase MODULI_TYPE_UNSTRUCTURED:\n\t\tcase MODULI_TYPE_SAFE:\n\t\tcase MODULI_TYPE_SCHNORR:\n\t\tcase MODULI_TYPE_STRONG:\n\t\tcase MODULI_TYPE_UNKNOWN:\n\t\t\tdebug2(\"%10u: (%u)\", count_in, in_type);\n\t\t\ta = p;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* q = (p-1) / 2 */\n\t\t\tif (BN_rshift(q, p, 1) == 0)\n\t\t\t\tfatal(\"BN_rshift failed\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug2(\"Unknown prime type\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * due to earlier inconsistencies in interpretation, check\n\t\t * the proposed bit size.\n\t\t */\n\t\tif ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {\n\t\t\tdebug2(\"%10u: bit size %u mismatch\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_size < QSIZE_MINIMUM) {\n\t\t\tdebug2(\"%10u: bit size %u too short\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_tests & MODULI_TESTS_MILLER_RABIN)\n\t\t\tin_tries += trials;\n\t\telse\n\t\t\tin_tries = trials;\n\n\t\t/*\n\t\t * guess unknown generator\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tif (BN_mod_word(p, 24) == 11)\n\t\t\t\tgenerator_known = 2;\n\t\t\telse if (BN_mod_word(p, 12) == 5)\n\t\t\t\tgenerator_known = 3;\n\t\t\telse {\n\t\t\t\tu_int32_t r = BN_mod_word(p, 10);\n\n\t\t\t\tif (r == 3 || r == 7)\n\t\t\t\t\tgenerator_known = 5;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * skip tests when desired generator doesn't match\n\t\t */\n\t\tif (generator_wanted > 0 &&\n\t\t    generator_wanted != generator_known) {\n\t\t\tdebug2(\"%10u: generator %d != %d\",\n\t\t\t    count_in, generator_known, generator_wanted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Primes with no known generator are useless for DH, so\n\t\t * skip those.\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tdebug2(\"%10u: no known generator\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_possible++;\n\n\t\t/*\n\t\t * The (1/4)^N performance bound on Miller-Rabin is\n\t\t * extremely pessimistic, so don't spend a lot of time\n\t\t * really verifying that q is prime until after we know\n\t\t * that p is also prime. A single pass will weed out the\n\t\t * vast majority of composite q's.\n\t\t */\n\t\tif (BN_is_prime_ex(q, 1, ctx, NULL) <= 0) {\n\t\t\tdebug(\"%10u: q failed first possible prime test\",\n\t\t\t    count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * q is possibly prime, so go ahead and really make sure\n\t\t * that p is prime. If it is, then we can go back and do\n\t\t * the same for q. If p is composite, chances are that\n\t\t * will show up on the first Rabin-Miller iteration so it\n\t\t * doesn't hurt to specify a high iteration count.\n\t\t */\n\t\tif (!BN_is_prime_ex(p, trials, ctx, NULL)) {\n\t\t\tdebug(\"%10u: p is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: p is almost certainly prime\", count_in);\n\n\t\t/* recheck q more rigorously */\n\t\tif (!BN_is_prime_ex(q, trials - 1, ctx, NULL)) {\n\t\t\tdebug(\"%10u: q is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: q is almost certainly prime\", count_in);\n\n\t\tif (qfileout(out, MODULI_TYPE_SAFE,\n\t\t    in_tests | MODULI_TESTS_MILLER_RABIN,\n\t\t    in_tries, in_size, generator_known, p)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount_out++;\n\t}\n\n\ttime(&time_stop);\n\tfree(lp);\n\tBN_free(p);\n\tBN_free(q);\n\tBN_CTX_free(ctx);\n\n\tif (checkpoint_file != NULL)\n\t\tunlink(checkpoint_file);\n\n\tlogit(\"%.24s Found %u safe primes of %u candidates in %ld seconds\",\n\t    ctime(&time_stop), count_out, count_possible,\n\t    (long) (time_stop - time_start));\n\n\treturn (res);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TRIAL_MINIMUM\t(4)",
            "#define QSIZE_MINIMUM\t\t(511)",
            "#define QLINESIZE\t\t(100+8192)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TRIAL_MINIMUM\t(4)\n#define QSIZE_MINIMUM\t\t(511)\n#define QLINESIZE\t\t(100+8192)\n\nint\nprime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,\n    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)\n{\n\tBIGNUM *q, *p, *a;\n\tBN_CTX *ctx;\n\tchar *cp, *lp;\n\tu_int32_t count_in = 0, count_out = 0, count_possible = 0;\n\tu_int32_t generator_known, in_tests, in_tries, in_type, in_size;\n\tunsigned long last_processed = 0, end_lineno;\n\ttime_t time_start, time_stop;\n\tint res;\n\n\tif (trials < TRIAL_MINIMUM) {\n\t\terror(\"Minimum primality trials is %d\", TRIAL_MINIMUM);\n\t\treturn (-1);\n\t}\n\n\tif (num_lines == 0)\n\t\tend_lineno = count_lines(in);\n\telse\n\t\tend_lineno = start_lineno + num_lines;\n\n\ttime(&time_start);\n\n\tif ((p = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\tfatal(\"BN_CTX_new failed\");\n\n\tdebug2(\"%.24s Final %u Miller-Rabin trials (%x generator)\",\n\t    ctime(&time_start), trials, generator_wanted);\n\n\tif (checkpoint_file != NULL)\n\t\tlast_processed = read_checkpoint(checkpoint_file);\n\tlast_processed = start_lineno = MAXIMUM(last_processed, start_lineno);\n\tif (end_lineno == ULONG_MAX)\n\t\tdebug(\"process from line %lu from pipe\", last_processed);\n\telse\n\t\tdebug(\"process from line %lu to line %lu\", last_processed,\n\t\t    end_lineno);\n\n\tres = 0;\n\tlp = xmalloc(QLINESIZE + 1);\n\twhile (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {\n\t\tcount_in++;\n\t\tif (count_in <= last_processed) {\n\t\t\tdebug3(\"skipping line %u, before checkpoint or \"\n\t\t\t    \"specified start line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tif (checkpoint_file != NULL)\n\t\t\twrite_checkpoint(checkpoint_file, count_in);\n\t\tprint_progress(start_lineno, count_in, end_lineno);\n\t\tif (strlen(lp) < 14 || *lp == '!' || *lp == '#') {\n\t\t\tdebug2(\"%10u: comment or short line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX - fragile parser */\n\t\t/* time */\n\t\tcp = &lp[14];\t/* (skip) */\n\n\t\t/* type */\n\t\tin_type = strtoul(cp, &cp, 10);\n\n\t\t/* tests */\n\t\tin_tests = strtoul(cp, &cp, 10);\n\n\t\tif (in_tests & MODULI_TESTS_COMPOSITE) {\n\t\t\tdebug2(\"%10u: known composite\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* tries */\n\t\tin_tries = strtoul(cp, &cp, 10);\n\n\t\t/* size (most significant bit) */\n\t\tin_size = strtoul(cp, &cp, 10);\n\n\t\t/* generator (hex) */\n\t\tgenerator_known = strtoul(cp, &cp, 16);\n\n\t\t/* Skip white space */\n\t\tcp += strspn(cp, \" \");\n\n\t\t/* modulus (hex) */\n\t\tswitch (in_type) {\n\t\tcase MODULI_TYPE_SOPHIE_GERMAIN:\n\t\t\tdebug2(\"%10u: (%u) Sophie-Germain\", count_in, in_type);\n\t\t\ta = q;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* p = 2*q + 1 */\n\t\t\tif (BN_lshift(p, q, 1) == 0)\n\t\t\t\tfatal(\"BN_lshift failed\");\n\t\t\tif (BN_add_word(p, 1) == 0)\n\t\t\t\tfatal(\"BN_add_word failed\");\n\t\t\tin_size += 1;\n\t\t\tgenerator_known = 0;\n\t\t\tbreak;\n\t\tcase MODULI_TYPE_UNSTRUCTURED:\n\t\tcase MODULI_TYPE_SAFE:\n\t\tcase MODULI_TYPE_SCHNORR:\n\t\tcase MODULI_TYPE_STRONG:\n\t\tcase MODULI_TYPE_UNKNOWN:\n\t\t\tdebug2(\"%10u: (%u)\", count_in, in_type);\n\t\t\ta = p;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t/* q = (p-1) / 2 */\n\t\t\tif (BN_rshift(q, p, 1) == 0)\n\t\t\t\tfatal(\"BN_rshift failed\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug2(\"Unknown prime type\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * due to earlier inconsistencies in interpretation, check\n\t\t * the proposed bit size.\n\t\t */\n\t\tif ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {\n\t\t\tdebug2(\"%10u: bit size %u mismatch\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_size < QSIZE_MINIMUM) {\n\t\t\tdebug2(\"%10u: bit size %u too short\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_tests & MODULI_TESTS_MILLER_RABIN)\n\t\t\tin_tries += trials;\n\t\telse\n\t\t\tin_tries = trials;\n\n\t\t/*\n\t\t * guess unknown generator\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tif (BN_mod_word(p, 24) == 11)\n\t\t\t\tgenerator_known = 2;\n\t\t\telse if (BN_mod_word(p, 12) == 5)\n\t\t\t\tgenerator_known = 3;\n\t\t\telse {\n\t\t\t\tu_int32_t r = BN_mod_word(p, 10);\n\n\t\t\t\tif (r == 3 || r == 7)\n\t\t\t\t\tgenerator_known = 5;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * skip tests when desired generator doesn't match\n\t\t */\n\t\tif (generator_wanted > 0 &&\n\t\t    generator_wanted != generator_known) {\n\t\t\tdebug2(\"%10u: generator %d != %d\",\n\t\t\t    count_in, generator_known, generator_wanted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Primes with no known generator are useless for DH, so\n\t\t * skip those.\n\t\t */\n\t\tif (generator_known == 0) {\n\t\t\tdebug2(\"%10u: no known generator\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_possible++;\n\n\t\t/*\n\t\t * The (1/4)^N performance bound on Miller-Rabin is\n\t\t * extremely pessimistic, so don't spend a lot of time\n\t\t * really verifying that q is prime until after we know\n\t\t * that p is also prime. A single pass will weed out the\n\t\t * vast majority of composite q's.\n\t\t */\n\t\tif (BN_is_prime_ex(q, 1, ctx, NULL) <= 0) {\n\t\t\tdebug(\"%10u: q failed first possible prime test\",\n\t\t\t    count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * q is possibly prime, so go ahead and really make sure\n\t\t * that p is prime. If it is, then we can go back and do\n\t\t * the same for q. If p is composite, chances are that\n\t\t * will show up on the first Rabin-Miller iteration so it\n\t\t * doesn't hurt to specify a high iteration count.\n\t\t */\n\t\tif (!BN_is_prime_ex(p, trials, ctx, NULL)) {\n\t\t\tdebug(\"%10u: p is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: p is almost certainly prime\", count_in);\n\n\t\t/* recheck q more rigorously */\n\t\tif (!BN_is_prime_ex(q, trials - 1, ctx, NULL)) {\n\t\t\tdebug(\"%10u: q is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: q is almost certainly prime\", count_in);\n\n\t\tif (qfileout(out, MODULI_TYPE_SAFE,\n\t\t    in_tests | MODULI_TESTS_MILLER_RABIN,\n\t\t    in_tries, in_size, generator_known, p)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount_out++;\n\t}\n\n\ttime(&time_stop);\n\tfree(lp);\n\tBN_free(p);\n\tBN_free(q);\n\tBN_CTX_free(ctx);\n\n\tif (checkpoint_file != NULL)\n\t\tunlink(checkpoint_file);\n\n\tlogit(\"%.24s Found %u safe primes of %u candidates in %ld seconds\",\n\t    ctime(&time_stop), count_out, count_possible,\n\t    (long) (time_stop - time_start));\n\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "identity_file",
            "\"r\""
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "out_file",
            "\"a\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_candidates",
          "args": [
            "out",
            "memory",
            "bits",
            "start"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "gen_candidates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/moduli.c",
          "lines": "242-446",
          "snippet": "int\ngen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)\n{\n\tBIGNUM *q;\n\tu_int32_t j, r, s, t;\n\tu_int32_t smallwords = TINY_NUMBER >> 6;\n\tu_int32_t tinywords = TINY_NUMBER >> 6;\n\ttime_t time_start, time_stop;\n\tu_int32_t i;\n\tint ret = 0;\n\n\tlargememory = memory;\n\n\tif (memory != 0 &&\n\t    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {\n\t\terror(\"Invalid memory amount (min %ld, max %ld)\",\n\t\t    LARGE_MINIMUM, LARGE_MAXIMUM);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Set power to the length in bits of the prime to be generated.\n\t * This is changed to 1 less than the desired safe prime moduli p.\n\t */\n\tif (power > TEST_MAXIMUM) {\n\t\terror(\"Too many bits: %u > %lu\", power, TEST_MAXIMUM);\n\t\treturn (-1);\n\t} else if (power < TEST_MINIMUM) {\n\t\terror(\"Too few bits: %u < %u\", power, TEST_MINIMUM);\n\t\treturn (-1);\n\t}\n\tpower--; /* decrement before squaring */\n\n\t/*\n\t * The density of ordinary primes is on the order of 1/bits, so the\n\t * density of safe primes should be about (1/bits)**2. Set test range\n\t * to something well above bits**2 to be reasonably sure (but not\n\t * guaranteed) of catching at least one safe prime.\n\t */\n\tlargewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));\n\n\t/*\n\t * Need idea of how much memory is available. We don't have to use all\n\t * of it.\n\t */\n\tif (largememory > LARGE_MAXIMUM) {\n\t\tlogit(\"Limited memory: %u MB; limit %lu MB\",\n\t\t    largememory, LARGE_MAXIMUM);\n\t\tlargememory = LARGE_MAXIMUM;\n\t}\n\n\tif (largewords <= (largememory << SHIFT_MEGAWORD)) {\n\t\tlogit(\"Increased memory: %u MB; need %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t} else if (largememory > 0) {\n\t\tlogit(\"Decreased memory: %u MB; want %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t}\n\n\tTinySieve = xcalloc(tinywords, sizeof(u_int32_t));\n\ttinybits = tinywords << SHIFT_WORD;\n\n\tSmallSieve = xcalloc(smallwords, sizeof(u_int32_t));\n\tsmallbits = smallwords << SHIFT_WORD;\n\n\t/*\n\t * dynamically determine available memory\n\t */\n\twhile ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)\n\t\tlargewords -= (1L << (SHIFT_MEGAWORD - 2)); /* 1/4 MB chunks */\n\n\tlargebits = largewords << SHIFT_WORD;\n\tlargenumbers = largebits * 2;\t/* even numbers excluded */\n\n\t/* validation check: count the number of primes tried */\n\tlargetries = 0;\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\t/*\n\t * Generate random starting point for subprime search, or use\n\t * specified parameter.\n\t */\n\tif ((largebase = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif (start == NULL) {\n\t\tif (BN_rand(largebase, power, 1, 1) == 0)\n\t\t\tfatal(\"BN_rand failed\");\n\t} else {\n\t\tif (BN_copy(largebase, start) == NULL)\n\t\t\tfatal(\"BN_copy: failed\");\n\t}\n\n\t/* ensure odd */\n\tif (BN_set_bit(largebase, 0) == 0)\n\t\tfatal(\"BN_set_bit: failed\");\n\n\ttime(&time_start);\n\n\tlogit(\"%.24s Sieve next %u plus %u-bit\", ctime(&time_start),\n\t    largenumbers, power);\n\tdebug2(\"start point: 0x%s\", BN_bn2hex(largebase));\n\n\t/*\n\t * TinySieve\n\t */\n\tfor (i = 0; i < tinybits; i++) {\n\t\tif (BIT_TEST(TinySieve, i))\n\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t/* The next tiny prime */\n\t\tt = 2 * i + 3;\n\n\t\t/* Mark all multiples of t */\n\t\tfor (j = i + t; j < tinybits; j += t)\n\t\t\tBIT_SET(TinySieve, j);\n\n\t\tsieve_large(t);\n\t}\n\n\t/*\n\t * Start the small block search at the next possible prime. To avoid\n\t * fencepost errors, the last pass is skipped.\n\t */\n\tfor (smallbase = TINY_NUMBER + 3;\n\t    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);\n\t    smallbase += TINY_NUMBER) {\n\t\tfor (i = 0; i < tinybits; i++) {\n\t\t\tif (BIT_TEST(TinySieve, i))\n\t\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t\t/* The next tiny prime */\n\t\t\tt = 2 * i + 3;\n\t\t\tr = smallbase % t;\n\n\t\t\tif (r == 0) {\n\t\t\t\ts = 0; /* t divides into smallbase exactly */\n\t\t\t} else {\n\t\t\t\t/* smallbase+s is first entry divisible by t */\n\t\t\t\ts = t - r;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The sieve omits even numbers, so ensure that\n\t\t\t * smallbase+s is odd. Then, step through the sieve\n\t\t\t * in increments of 2*t\n\t\t\t */\n\t\t\tif (s & 1)\n\t\t\t\ts += t; /* Make smallbase+s odd, and s even */\n\n\t\t\t/* Mark all multiples of 2*t */\n\t\t\tfor (s /= 2; s < smallbits; s += t)\n\t\t\t\tBIT_SET(SmallSieve, s);\n\t\t}\n\n\t\t/*\n\t\t * SmallSieve\n\t\t */\n\t\tfor (i = 0; i < smallbits; i++) {\n\t\t\tif (BIT_TEST(SmallSieve, i))\n\t\t\t\tcontinue; /* 2*i+smallbase is composite */\n\n\t\t\t/* The next small prime */\n\t\t\tsieve_large((2 * i) + smallbase);\n\t\t}\n\n\t\tmemset(SmallSieve, 0, smallwords << SHIFT_BYTE);\n\t}\n\n\ttime(&time_stop);\n\n\tlogit(\"%.24s Sieved with %u small primes in %lld seconds\",\n\t    ctime(&time_stop), largetries, (long long)(time_stop - time_start));\n\n\tfor (j = r = 0; j < largebits; j++) {\n\t\tif (BIT_TEST(LargeSieve, j))\n\t\t\tcontinue; /* Definitely composite, skip */\n\n\t\tdebug2(\"test q = largebase+%u\", 2 * j);\n\t\tif (BN_set_word(q, 2 * j) == 0)\n\t\t\tfatal(\"BN_set_word failed\");\n\t\tif (BN_add(q, q, largebase) == 0)\n\t\t\tfatal(\"BN_add failed\");\n\t\tif (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,\n\t\t    MODULI_TESTS_SIEVE, largetries,\n\t\t    (power - 1) /* MSB */, (0), q) == -1) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr++; /* count q */\n\t}\n\n\ttime(&time_stop);\n\n\tfree(LargeSieve);\n\tfree(SmallSieve);\n\tfree(TinySieve);\n\n\tlogit(\"%.24s Found %u candidates\", ctime(&time_stop), r);\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"dh.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TEST_POWER\t(3)\t/* 2**n, n < SHIFT_WORD */",
            "#define TEST_MINIMUM\t(QSIZE_MINIMUM + 1)",
            "#define TEST_MAXIMUM\t(1UL<<16)",
            "#define TINY_NUMBER\t(1UL<<16)",
            "#define SMALL_MAXIMUM\t(0xffffffffUL)",
            "#define LARGE_MAXIMUM\t(127UL)\t/* megabytes */",
            "#define LARGE_MINIMUM\t(8UL)\t/* megabytes */",
            "#define SHIFT_MEGAWORD\t(SHIFT_MEGABYTE-SHIFT_BYTE)",
            "#define SHIFT_WORD\t(SHIFT_BIT+SHIFT_BYTE)",
            "#define SHIFT_BYTE\t(2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"dh.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TEST_POWER\t(3)\t/* 2**n, n < SHIFT_WORD */\n#define TEST_MINIMUM\t(QSIZE_MINIMUM + 1)\n#define TEST_MAXIMUM\t(1UL<<16)\n#define TINY_NUMBER\t(1UL<<16)\n#define SMALL_MAXIMUM\t(0xffffffffUL)\n#define LARGE_MAXIMUM\t(127UL)\t/* megabytes */\n#define LARGE_MINIMUM\t(8UL)\t/* megabytes */\n#define SHIFT_MEGAWORD\t(SHIFT_MEGABYTE-SHIFT_BYTE)\n#define SHIFT_WORD\t(SHIFT_BIT+SHIFT_BYTE)\n#define SHIFT_BYTE\t(2)\n\nint\ngen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)\n{\n\tBIGNUM *q;\n\tu_int32_t j, r, s, t;\n\tu_int32_t smallwords = TINY_NUMBER >> 6;\n\tu_int32_t tinywords = TINY_NUMBER >> 6;\n\ttime_t time_start, time_stop;\n\tu_int32_t i;\n\tint ret = 0;\n\n\tlargememory = memory;\n\n\tif (memory != 0 &&\n\t    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {\n\t\terror(\"Invalid memory amount (min %ld, max %ld)\",\n\t\t    LARGE_MINIMUM, LARGE_MAXIMUM);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Set power to the length in bits of the prime to be generated.\n\t * This is changed to 1 less than the desired safe prime moduli p.\n\t */\n\tif (power > TEST_MAXIMUM) {\n\t\terror(\"Too many bits: %u > %lu\", power, TEST_MAXIMUM);\n\t\treturn (-1);\n\t} else if (power < TEST_MINIMUM) {\n\t\terror(\"Too few bits: %u < %u\", power, TEST_MINIMUM);\n\t\treturn (-1);\n\t}\n\tpower--; /* decrement before squaring */\n\n\t/*\n\t * The density of ordinary primes is on the order of 1/bits, so the\n\t * density of safe primes should be about (1/bits)**2. Set test range\n\t * to something well above bits**2 to be reasonably sure (but not\n\t * guaranteed) of catching at least one safe prime.\n\t */\n\tlargewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));\n\n\t/*\n\t * Need idea of how much memory is available. We don't have to use all\n\t * of it.\n\t */\n\tif (largememory > LARGE_MAXIMUM) {\n\t\tlogit(\"Limited memory: %u MB; limit %lu MB\",\n\t\t    largememory, LARGE_MAXIMUM);\n\t\tlargememory = LARGE_MAXIMUM;\n\t}\n\n\tif (largewords <= (largememory << SHIFT_MEGAWORD)) {\n\t\tlogit(\"Increased memory: %u MB; need %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t} else if (largememory > 0) {\n\t\tlogit(\"Decreased memory: %u MB; want %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t}\n\n\tTinySieve = xcalloc(tinywords, sizeof(u_int32_t));\n\ttinybits = tinywords << SHIFT_WORD;\n\n\tSmallSieve = xcalloc(smallwords, sizeof(u_int32_t));\n\tsmallbits = smallwords << SHIFT_WORD;\n\n\t/*\n\t * dynamically determine available memory\n\t */\n\twhile ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)\n\t\tlargewords -= (1L << (SHIFT_MEGAWORD - 2)); /* 1/4 MB chunks */\n\n\tlargebits = largewords << SHIFT_WORD;\n\tlargenumbers = largebits * 2;\t/* even numbers excluded */\n\n\t/* validation check: count the number of primes tried */\n\tlargetries = 0;\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\t/*\n\t * Generate random starting point for subprime search, or use\n\t * specified parameter.\n\t */\n\tif ((largebase = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif (start == NULL) {\n\t\tif (BN_rand(largebase, power, 1, 1) == 0)\n\t\t\tfatal(\"BN_rand failed\");\n\t} else {\n\t\tif (BN_copy(largebase, start) == NULL)\n\t\t\tfatal(\"BN_copy: failed\");\n\t}\n\n\t/* ensure odd */\n\tif (BN_set_bit(largebase, 0) == 0)\n\t\tfatal(\"BN_set_bit: failed\");\n\n\ttime(&time_start);\n\n\tlogit(\"%.24s Sieve next %u plus %u-bit\", ctime(&time_start),\n\t    largenumbers, power);\n\tdebug2(\"start point: 0x%s\", BN_bn2hex(largebase));\n\n\t/*\n\t * TinySieve\n\t */\n\tfor (i = 0; i < tinybits; i++) {\n\t\tif (BIT_TEST(TinySieve, i))\n\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t/* The next tiny prime */\n\t\tt = 2 * i + 3;\n\n\t\t/* Mark all multiples of t */\n\t\tfor (j = i + t; j < tinybits; j += t)\n\t\t\tBIT_SET(TinySieve, j);\n\n\t\tsieve_large(t);\n\t}\n\n\t/*\n\t * Start the small block search at the next possible prime. To avoid\n\t * fencepost errors, the last pass is skipped.\n\t */\n\tfor (smallbase = TINY_NUMBER + 3;\n\t    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);\n\t    smallbase += TINY_NUMBER) {\n\t\tfor (i = 0; i < tinybits; i++) {\n\t\t\tif (BIT_TEST(TinySieve, i))\n\t\t\t\tcontinue; /* 2*i+3 is composite */\n\n\t\t\t/* The next tiny prime */\n\t\t\tt = 2 * i + 3;\n\t\t\tr = smallbase % t;\n\n\t\t\tif (r == 0) {\n\t\t\t\ts = 0; /* t divides into smallbase exactly */\n\t\t\t} else {\n\t\t\t\t/* smallbase+s is first entry divisible by t */\n\t\t\t\ts = t - r;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The sieve omits even numbers, so ensure that\n\t\t\t * smallbase+s is odd. Then, step through the sieve\n\t\t\t * in increments of 2*t\n\t\t\t */\n\t\t\tif (s & 1)\n\t\t\t\ts += t; /* Make smallbase+s odd, and s even */\n\n\t\t\t/* Mark all multiples of 2*t */\n\t\t\tfor (s /= 2; s < smallbits; s += t)\n\t\t\t\tBIT_SET(SmallSieve, s);\n\t\t}\n\n\t\t/*\n\t\t * SmallSieve\n\t\t */\n\t\tfor (i = 0; i < smallbits; i++) {\n\t\t\tif (BIT_TEST(SmallSieve, i))\n\t\t\t\tcontinue; /* 2*i+smallbase is composite */\n\n\t\t\t/* The next small prime */\n\t\t\tsieve_large((2 * i) + smallbase);\n\t\t}\n\n\t\tmemset(SmallSieve, 0, smallwords << SHIFT_BYTE);\n\t}\n\n\ttime(&time_stop);\n\n\tlogit(\"%.24s Sieved with %u small primes in %lld seconds\",\n\t    ctime(&time_stop), largetries, (long long)(time_stop - time_start));\n\n\tfor (j = r = 0; j < largebits; j++) {\n\t\tif (BIT_TEST(LargeSieve, j))\n\t\t\tcontinue; /* Definitely composite, skip */\n\n\t\tdebug2(\"test q = largebase+%u\", 2 * j);\n\t\tif (BN_set_word(q, 2 * j) == 0)\n\t\t\tfatal(\"BN_set_word failed\");\n\t\tif (BN_add(q, q, largebase) == 0)\n\t\t\tfatal(\"BN_add failed\");\n\t\tif (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,\n\t\t    MODULI_TESTS_SIEVE, largetries,\n\t\t    (power - 1) /* MSB */, (0), q) == -1) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr++; /* count q */\n\t}\n\n\ttime(&time_stop);\n\n\tfree(LargeSieve);\n\tfree(SmallSieve);\n\tfree(TinySieve);\n\n\tlogit(\"%.24s Found %u candidates\", ctime(&time_stop), r);\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "out_file",
            "\"w\""
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_print_resource_record",
          "args": [
            "pw",
            "_PATH_HOST_XMSS_KEY_FILE",
            "rr_hostname"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "do_print_resource_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1439-1461",
          "snippet": "static int\ndo_print_resource_record(struct passwd *pw, char *fname, char *hname)\n{\n\tstruct sshkey *public;\n\tchar *comment = NULL;\n\tstruct stat st;\n\tint r;\n\n\tif (fname == NULL)\n\t\tfatal(\"%s: no filename\", __func__);\n\tif (stat(fname, &st) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tfatal(\"%s: %s\", fname, strerror(errno));\n\t}\n\tif ((r = sshkey_load_public(fname, &public, &comment)) != 0)\n\t\tfatal(\"Failed to read v2 public key from \\\"%s\\\": %s.\",\n\t\t    fname, ssh_err(r));\n\texport_dns_rr(hname, public, stdout, print_generic);\n\tsshkey_free(public);\n\tfree(comment);\n\treturn 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int print_generic = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint print_generic = 0;\n\nstatic int\ndo_print_resource_record(struct passwd *pw, char *fname, char *hname)\n{\n\tstruct sshkey *public;\n\tchar *comment = NULL;\n\tstruct stat st;\n\tint r;\n\n\tif (fname == NULL)\n\t\tfatal(\"%s: no filename\", __func__);\n\tif (stat(fname, &st) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tfatal(\"%s: %s\", fname, strerror(errno));\n\t}\n\tif ((r = sshkey_load_public(fname, &public, &comment)) != 0)\n\t\tfatal(\"Failed to read v2 public key from \\\"%s\\\": %s.\",\n\t\t    fname, ssh_err(r));\n\texport_dns_rr(hname, public, stdout, print_generic);\n\tsshkey_free(public);\n\tfree(comment);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_print_public",
          "args": [
            "pw"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "do_print_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "781-798",
          "snippet": "static void\ndo_print_public(struct passwd *pw)\n{\n\tstruct sshkey *prv;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tprv = load_identity(identity_file);\n\tif ((r = sshkey_write(prv, stdout)) != 0)\n\t\terror(\"sshkey_write failed: %s\", ssh_err(r));\n\tsshkey_free(prv);\n\tfprintf(stdout, \"\\n\");\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\n\nstatic void\ndo_print_public(struct passwd *pw)\n{\n\tstruct sshkey *prv;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tprv = load_identity(identity_file);\n\tif ((r = sshkey_write(prv, stdout)) != 0)\n\t\terror(\"sshkey_write failed: %s\", ssh_err(r));\n\tsshkey_free(prv);\n\tfprintf(stdout, \"\\n\");\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_from",
          "args": [
            "pw"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "721-778",
          "snippet": "static void\ndo_convert_from(struct passwd *pw)\n{\n\tstruct sshkey *k = NULL;\n\tint r, private = 0, ok = 0;\n\tstruct stat st;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_from_ssh2(pw, &k, &private);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_from_pkcs8(&k, &private);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_from_pem(&k, &private);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\n\tif (!private) {\n\t\tif ((r = sshkey_write(k, stdout)) == 0)\n\t\t\tok = 1;\n\t\tif (ok)\n\t\t\tfprintf(stdout, \"\\n\");\n\t} else {\n\t\tswitch (k->type) {\n\t\tcase KEY_DSA:\n\t\t\tok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA:\n\t\t\tok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA:\n\t\t\tok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unsupported key type %s\", __func__,\n\t\t\t    sshkey_type(k));\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tfatal(\"key write failed\");\n\tsshkey_free(k);\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "enum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\nextern char *__progname;\n\nstatic void\ndo_convert_from(struct passwd *pw)\n{\n\tstruct sshkey *k = NULL;\n\tint r, private = 0, ok = 0;\n\tstruct stat st;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_from_ssh2(pw, &k, &private);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_from_pkcs8(&k, &private);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_from_pem(&k, &private);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\n\tif (!private) {\n\t\tif ((r = sshkey_write(k, stdout)) == 0)\n\t\t\tok = 1;\n\t\tif (ok)\n\t\t\tfprintf(stdout, \"\\n\");\n\t} else {\n\t\tswitch (k->type) {\n\t\tcase KEY_DSA:\n\t\t\tok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA:\n\t\t\tok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA:\n\t\t\tok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unsupported key type %s\", __func__,\n\t\t\t    sshkey_type(k));\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tfatal(\"key write failed\");\n\tsshkey_free(k);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_to",
          "args": [
            "pw"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "395-422",
          "snippet": "static void\ndo_convert_to(struct passwd *pw)\n{\n\tstruct sshkey *k;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)\n\t\tk = load_identity(identity_file);\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_to_ssh2(pw, k);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_to_pkcs8(k);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_to_pem(k);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "enum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\nextern char *__progname;\n\nstatic void\ndo_convert_to(struct passwd *pw)\n{\n\tstruct sshkey *k;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)\n\t\tk = load_identity(identity_file);\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_to_ssh2(pw, k);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_to_pkcs8(k);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_to_pem(k);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_change_comment",
          "args": [
            "pw"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "do_change_comment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1466-1564",
          "snippet": "static void\ndo_change_comment(struct passwd *pw)\n{\n\tchar new_comment[1024], *comment, *passphrase;\n\tstruct sshkey *private;\n\tstruct sshkey *public;\n\tstruct stat st;\n\tFILE *f;\n\tint r, fd;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_load_private(identity_file, \"\",\n\t    &private, &comment)) == 0)\n\t\tpassphrase = xstrdup(\"\");\n\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t    identity_file, ssh_err(r));\n\telse {\n\t\tif (identity_passphrase)\n\t\t\tpassphrase = xstrdup(identity_passphrase);\n\t\telse if (identity_new_passphrase)\n\t\t\tpassphrase = xstrdup(identity_new_passphrase);\n\t\telse\n\t\t\tpassphrase = read_passphrase(\"Enter passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\t/* Try to load using the passphrase. */\n\t\tif ((r = sshkey_load_private(identity_file, passphrase,\n\t\t    &private, &comment)) != 0) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tfree(passphrase);\n\t\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t\t    identity_file, ssh_err(r));\n\t\t}\n\t}\n\n\tif (private->type != KEY_ED25519 && private->type != KEY_XMSS &&\n\t    !use_new_format) {\n\t\terror(\"Comments are only supported for keys stored in \"\n\t\t    \"the new format (-o).\");\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\texit(1);\n\t}\n\tif (comment)\n\t\tprintf(\"Key now has comment '%s'\\n\", comment);\n\telse\n\t\tprintf(\"Key now has no comment\\n\");\n\n\tif (identity_comment) {\n\t\tstrlcpy(new_comment, identity_comment, sizeof(new_comment));\n\t} else {\n\t\tprintf(\"Enter new comment: \");\n\t\tfflush(stdout);\n\t\tif (!fgets(new_comment, sizeof(new_comment), stdin)) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tsshkey_free(private);\n\t\t\texit(1);\n\t\t}\n\t\tnew_comment[strcspn(new_comment, \"\\n\")] = '\\0';\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    new_comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tfree(passphrase);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\texplicit_bzero(passphrase, strlen(passphrase));\n\tfree(passphrase);\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\tsshkey_free(private);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tfd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\tfatal(\"Could not save your public key in %s\", identity_file);\n\tf = fdopen(fd, \"w\");\n\tif (f == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\tfatal(\"write key failed: %s\", ssh_err(r));\n\tsshkey_free(public);\n\tfprintf(f, \" %s\\n\", new_comment);\n\tfclose(f);\n\n\tfree(comment);\n\n\tprintf(\"The comment in your key file has been changed.\\n\");\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *identity_passphrase = NULL;",
            "char *identity_new_passphrase = NULL;",
            "char *identity_comment = NULL;",
            "int use_new_format = 1;",
            "char *new_format_cipher = NULL;",
            "int rounds = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *identity_passphrase = NULL;\nchar *identity_new_passphrase = NULL;\nchar *identity_comment = NULL;\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\n\nstatic void\ndo_change_comment(struct passwd *pw)\n{\n\tchar new_comment[1024], *comment, *passphrase;\n\tstruct sshkey *private;\n\tstruct sshkey *public;\n\tstruct stat st;\n\tFILE *f;\n\tint r, fd;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_load_private(identity_file, \"\",\n\t    &private, &comment)) == 0)\n\t\tpassphrase = xstrdup(\"\");\n\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t    identity_file, ssh_err(r));\n\telse {\n\t\tif (identity_passphrase)\n\t\t\tpassphrase = xstrdup(identity_passphrase);\n\t\telse if (identity_new_passphrase)\n\t\t\tpassphrase = xstrdup(identity_new_passphrase);\n\t\telse\n\t\t\tpassphrase = read_passphrase(\"Enter passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\t/* Try to load using the passphrase. */\n\t\tif ((r = sshkey_load_private(identity_file, passphrase,\n\t\t    &private, &comment)) != 0) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tfree(passphrase);\n\t\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t\t    identity_file, ssh_err(r));\n\t\t}\n\t}\n\n\tif (private->type != KEY_ED25519 && private->type != KEY_XMSS &&\n\t    !use_new_format) {\n\t\terror(\"Comments are only supported for keys stored in \"\n\t\t    \"the new format (-o).\");\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\texit(1);\n\t}\n\tif (comment)\n\t\tprintf(\"Key now has comment '%s'\\n\", comment);\n\telse\n\t\tprintf(\"Key now has no comment\\n\");\n\n\tif (identity_comment) {\n\t\tstrlcpy(new_comment, identity_comment, sizeof(new_comment));\n\t} else {\n\t\tprintf(\"Enter new comment: \");\n\t\tfflush(stdout);\n\t\tif (!fgets(new_comment, sizeof(new_comment), stdin)) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tsshkey_free(private);\n\t\t\texit(1);\n\t\t}\n\t\tnew_comment[strcspn(new_comment, \"\\n\")] = '\\0';\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    new_comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tfree(passphrase);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\texplicit_bzero(passphrase, strlen(passphrase));\n\tfree(passphrase);\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\tsshkey_free(private);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tfd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\tfatal(\"Could not save your public key in %s\", identity_file);\n\tf = fdopen(fd, \"w\");\n\tif (f == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\tfatal(\"write key failed: %s\", ssh_err(r));\n\tsshkey_free(public);\n\tfprintf(f, \" %s\\n\", new_comment);\n\tfclose(f);\n\n\tfree(comment);\n\n\tprintf(\"The comment in your key file has been changed.\\n\");\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_change_passphrase",
          "args": [
            "pw"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "do_change_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1355-1434",
          "snippet": "static void\ndo_change_passphrase(struct passwd *pw)\n{\n\tchar *comment;\n\tchar *old_passphrase, *passphrase1, *passphrase2;\n\tstruct stat st;\n\tstruct sshkey *private;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t/* Try to load the file with empty passphrase. */\n\tr = sshkey_load_private(identity_file, \"\", &private, &comment);\n\tif (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tif (identity_passphrase)\n\t\t\told_passphrase = xstrdup(identity_passphrase);\n\t\telse\n\t\t\told_passphrase =\n\t\t\t    read_passphrase(\"Enter old passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\tr = sshkey_load_private(identity_file, old_passphrase,\n\t\t    &private, &comment);\n\t\texplicit_bzero(old_passphrase, strlen(old_passphrase));\n\t\tfree(old_passphrase);\n\t\tif (r != 0)\n\t\t\tgoto badkey;\n\t} else if (r != 0) {\n badkey:\n\t\tfatal(\"Failed to load key %s: %s\", identity_file, ssh_err(r));\n\t}\n\tif (comment)\n\t\tmprintf(\"Key has comment '%s'\\n\", comment);\n\n\t/* Ask the new passphrase (twice). */\n\tif (identity_new_passphrase) {\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\t\tpassphrase2 = NULL;\n\t} else {\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter new passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\n\t\t/* Verify that they are the same. */\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Pass phrases do not match.  Try again.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Destroy the other copy. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s.\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\t/* Destroy the passphrase and the copy of the key in memory. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\tsshkey_free(private);\t\t /* Destroys contents */\n\tfree(comment);\n\n\tprintf(\"Your identification has been saved with the new passphrase.\\n\");\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *identity_passphrase = NULL;",
            "char *identity_new_passphrase = NULL;",
            "int use_new_format = 1;",
            "char *new_format_cipher = NULL;",
            "int rounds = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *identity_passphrase = NULL;\nchar *identity_new_passphrase = NULL;\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\n\nstatic void\ndo_change_passphrase(struct passwd *pw)\n{\n\tchar *comment;\n\tchar *old_passphrase, *passphrase1, *passphrase2;\n\tstruct stat st;\n\tstruct sshkey *private;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t/* Try to load the file with empty passphrase. */\n\tr = sshkey_load_private(identity_file, \"\", &private, &comment);\n\tif (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tif (identity_passphrase)\n\t\t\told_passphrase = xstrdup(identity_passphrase);\n\t\telse\n\t\t\told_passphrase =\n\t\t\t    read_passphrase(\"Enter old passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\tr = sshkey_load_private(identity_file, old_passphrase,\n\t\t    &private, &comment);\n\t\texplicit_bzero(old_passphrase, strlen(old_passphrase));\n\t\tfree(old_passphrase);\n\t\tif (r != 0)\n\t\t\tgoto badkey;\n\t} else if (r != 0) {\n badkey:\n\t\tfatal(\"Failed to load key %s: %s\", identity_file, ssh_err(r));\n\t}\n\tif (comment)\n\t\tmprintf(\"Key has comment '%s'\\n\", comment);\n\n\t/* Ask the new passphrase (twice). */\n\tif (identity_new_passphrase) {\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\t\tpassphrase2 = NULL;\n\t} else {\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter new passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\n\t\t/* Verify that they are the same. */\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Pass phrases do not match.  Try again.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Destroy the other copy. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s.\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\t/* Destroy the passphrase and the copy of the key in memory. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\tsshkey_free(private);\t\t /* Destroys contents */\n\tfree(comment);\n\n\tprintf(\"Your identification has been saved with the new passphrase.\\n\");\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_fingerprint",
          "args": [
            "pw"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "do_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "904-998",
          "snippet": "static void\ndo_fingerprint(struct passwd *pw)\n{\n\tFILE *f;\n\tstruct sshkey *public = NULL;\n\tchar *comment = NULL, *cp, *ep, *line = NULL;\n\tsize_t linesize = 0;\n\tint i, invalid = 1;\n\tconst char *path;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tpath = identity_file;\n\n\tif (strcmp(identity_file, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t} else if ((f = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, path, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tcp = line;\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Input may be plain keys, private keys, authorized_keys\n\t\t * or known_hosts.\n\t\t */\n\n\t\t/*\n\t\t * Try private keys first. Assume a key is private if\n\t\t * \"SSH PRIVATE KEY\" appears on the first line and we're\n\t\t * not reading from stdin (XXX support private keys on stdin).\n\t\t */\n\t\tif (lnum == 1 && strcmp(identity_file, \"-\") != 0 &&\n\t\t    strstr(cp, \"PRIVATE KEY\") != NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(f);\n\t\t\tfingerprint_private(path);\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * If it's not a private key, then this must be prepared to\n\t\t * accept a public key prefixed with a hostname or options.\n\t\t * Try a bare key first, otherwise skip the leading stuff.\n\t\t */\n\t\tif ((public = try_read_key(&cp)) == NULL) {\n\t\t\ti = strtol(cp, &ep, 10);\n\t\t\tif (i == 0 || ep == NULL ||\n\t\t\t    (*ep != ' ' && *ep != '\\t')) {\n\t\t\t\tint quoted = 0;\n\n\t\t\t\tcomment = cp;\n\t\t\t\tfor (; *cp && (quoted || (*cp != ' ' &&\n\t\t\t\t    *cp != '\\t')); cp++) {\n\t\t\t\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\t\t\t\tcp++;\t/* Skip both */\n\t\t\t\t\telse if (*cp == '\"')\n\t\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tif (!*cp)\n\t\t\t\t\tcontinue;\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t}\n\t\t/* Retry after parsing leading hostname/key options */\n\t\tif (public == NULL && (public = try_read_key(&cp)) == NULL) {\n\t\t\tdebug(\"%s:%lu: not a public key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find trailing comment, if any */\n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp != '\\0' && *cp != '#')\n\t\t\tcomment = cp;\n\n\t\tfingerprint_one_key(public, comment);\n\t\tsshkey_free(public);\n\t\tinvalid = 0; /* One good key in the file is sufficient */\n\t}\n\tfclose(f);\n\tfree(line);\n\n\tif (invalid)\n\t\tfatal(\"%s is not a public key file.\", path);\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "extern char *__progname;",
            "char hostname[NI_MAXHOST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nextern char *__progname;\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_fingerprint(struct passwd *pw)\n{\n\tFILE *f;\n\tstruct sshkey *public = NULL;\n\tchar *comment = NULL, *cp, *ep, *line = NULL;\n\tsize_t linesize = 0;\n\tint i, invalid = 1;\n\tconst char *path;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tpath = identity_file;\n\n\tif (strcmp(identity_file, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t} else if ((f = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, path, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tcp = line;\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Input may be plain keys, private keys, authorized_keys\n\t\t * or known_hosts.\n\t\t */\n\n\t\t/*\n\t\t * Try private keys first. Assume a key is private if\n\t\t * \"SSH PRIVATE KEY\" appears on the first line and we're\n\t\t * not reading from stdin (XXX support private keys on stdin).\n\t\t */\n\t\tif (lnum == 1 && strcmp(identity_file, \"-\") != 0 &&\n\t\t    strstr(cp, \"PRIVATE KEY\") != NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(f);\n\t\t\tfingerprint_private(path);\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * If it's not a private key, then this must be prepared to\n\t\t * accept a public key prefixed with a hostname or options.\n\t\t * Try a bare key first, otherwise skip the leading stuff.\n\t\t */\n\t\tif ((public = try_read_key(&cp)) == NULL) {\n\t\t\ti = strtol(cp, &ep, 10);\n\t\t\tif (i == 0 || ep == NULL ||\n\t\t\t    (*ep != ' ' && *ep != '\\t')) {\n\t\t\t\tint quoted = 0;\n\n\t\t\t\tcomment = cp;\n\t\t\t\tfor (; *cp && (quoted || (*cp != ' ' &&\n\t\t\t\t    *cp != '\\t')); cp++) {\n\t\t\t\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\t\t\t\tcp++;\t/* Skip both */\n\t\t\t\t\telse if (*cp == '\"')\n\t\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tif (!*cp)\n\t\t\t\t\tcontinue;\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t}\n\t\t/* Retry after parsing leading hostname/key options */\n\t\tif (public == NULL && (public = try_read_key(&cp)) == NULL) {\n\t\t\tdebug(\"%s:%lu: not a public key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find trailing comment, if any */\n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp != '\\0' && *cp != '#')\n\t\t\tcomment = cp;\n\n\t\tfingerprint_one_key(public, comment);\n\t\tsshkey_free(public);\n\t\tinvalid = 0; /* One good key in the file is sufficient */\n\t}\n\tfclose(f);\n\tfree(line);\n\n\tif (invalid)\n\t\tfatal(\"%s is not a public key file.\", path);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_download",
          "args": [
            "pw"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "do_download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "800-842",
          "snippet": "static void\ndo_download(struct passwd *pw)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tint i, nkeys;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp, *ra;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tpkcs11_init(0);\n\tnkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (print_fingerprint) {\n\t\t\tfp = sshkey_fingerprint(keys[i], fptype, rep);\n\t\t\tra = sshkey_fingerprint(keys[i], fingerprint_hash,\n\t\t\t    SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tprintf(\"%u %s %s (PKCS11 key)\\n\", sshkey_size(keys[i]),\n\t\t\t    fp, sshkey_type(keys[i]));\n\t\t\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\t(void) sshkey_write(keys[i], stdout); /* XXX check */\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tpkcs11_terminate();\n\texit(0);\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int log_level = SYSLOG_LEVEL_INFO;",
            "int print_fingerprint = 0;",
            "int print_bubblebabble = 0;",
            "int fingerprint_hash = SSH_FP_HASH_DEFAULT;",
            "char *pkcs11provider = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint log_level = SYSLOG_LEVEL_INFO;\nint print_fingerprint = 0;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\nchar *pkcs11provider = NULL;\n\nstatic void\ndo_download(struct passwd *pw)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tint i, nkeys;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp, *ra;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tpkcs11_init(0);\n\tnkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (print_fingerprint) {\n\t\t\tfp = sshkey_fingerprint(keys[i], fptype, rep);\n\t\t\tra = sshkey_fingerprint(keys[i], fingerprint_hash,\n\t\t\t    SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tprintf(\"%u %s %s (PKCS11 key)\\n\", sshkey_size(keys[i]),\n\t\t\t    fp, sshkey_type(keys[i]));\n\t\t\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\t(void) sshkey_write(keys[i], stdout); /* XXX check */\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tpkcs11_terminate();\n\texit(0);\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_known_hosts",
          "args": [
            "pw",
            "rr_hostname"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "do_known_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1256-1349",
          "snippet": "static void\ndo_known_hosts(struct passwd *pw, const char *name)\n{\n\tchar *cp, tmp[PATH_MAX], old[PATH_MAX];\n\tint r, fd, oerrno, inplace = 0;\n\tstruct known_hosts_ctx ctx;\n\tu_int foreach_options;\n\n\tif (!have_identity) {\n\t\tcp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);\n\t\tif (strlcpy(identity_file, cp, sizeof(identity_file)) >=\n\t\t    sizeof(identity_file))\n\t\t\tfatal(\"Specified known hosts path too long\");\n\t\tfree(cp);\n\t\thave_identity = 1;\n\t}\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.out = stdout;\n\tctx.host = name;\n\n\t/*\n\t * Find hosts goes to stdout, hash and deletions happen in-place\n\t * A corner case is ssh-keygen -HF foo, which should go to stdout\n\t */\n\tif (!find_host && (hash_hosts || delete_host)) {\n\t\tif (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcat(tmp, \".XXXXXXXXXX\", sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||\n\t\t    strlcat(old, \".old\", sizeof(old)) >= sizeof(old))\n\t\t\tfatal(\"known_hosts path too long\");\n\t\tumask(077);\n\t\tif ((fd = mkstemp(tmp)) == -1)\n\t\t\tfatal(\"mkstemp: %s\", strerror(errno));\n\t\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\t\toerrno = errno;\n\t\t\tunlink(tmp);\n\t\t\tfatal(\"fdopen: %s\", strerror(oerrno));\n\t\t}\n\t\tinplace = 1;\n\t}\n\t/* XXX support identity_file == \"-\" for stdin */\n\tforeach_options = find_host ? HKF_WANT_MATCH : 0;\n\tforeach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;\n\tif ((r = hostkeys_foreach(identity_file, (find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash, &ctx, name, NULL,\n\t    foreach_options)) != 0) {\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t\tfatal(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (inplace)\n\t\tfclose(ctx.out);\n\n\tif (ctx.invalid) {\n\t\terror(\"%s is not a valid known_hosts file.\", identity_file);\n\t\tif (inplace) {\n\t\t\terror(\"Not replacing existing known_hosts \"\n\t\t\t    \"file because of errors\");\n\t\t\tunlink(tmp);\n\t\t}\n\t\texit(1);\n\t} else if (delete_host && !ctx.found_key) {\n\t\tlogit(\"Host %s not found in %s\", name, identity_file);\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t} else if (inplace) {\n\t\t/* Backup existing file */\n\t\tif (unlink(old) == -1 && errno != ENOENT)\n\t\t\tfatal(\"unlink %.100s: %s\", old, strerror(errno));\n\t\tif (link(identity_file, old) == -1)\n\t\t\tfatal(\"link %.100s to %.100s: %s\", identity_file, old,\n\t\t\t    strerror(errno));\n\t\t/* Move new one into place */\n\t\tif (rename(tmp, identity_file) == -1) {\n\t\t\terror(\"rename\\\"%s\\\" to \\\"%s\\\": %s\", tmp, identity_file,\n\t\t\t    strerror(errno));\n\t\t\tunlink(tmp);\n\t\t\tunlink(old);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"%s updated.\\n\", identity_file);\n\t\tprintf(\"Original contents retained as %s\\n\", old);\n\t\tif (ctx.has_unhashed) {\n\t\t\tlogit(\"WARNING: %s contains unhashed entries\", old);\n\t\t\tlogit(\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\");\n\t\t}\n\t}\n\n\texit (find_host && !ctx.found_key);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int hash_hosts = 0;",
            "int find_host = 0;",
            "int delete_host = 0;",
            "int print_fingerprint = 0;",
            "char identity_file[1024];",
            "int have_identity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint hash_hosts = 0;\nint find_host = 0;\nint delete_host = 0;\nint print_fingerprint = 0;\nchar identity_file[1024];\nint have_identity = 0;\n\nstatic void\ndo_known_hosts(struct passwd *pw, const char *name)\n{\n\tchar *cp, tmp[PATH_MAX], old[PATH_MAX];\n\tint r, fd, oerrno, inplace = 0;\n\tstruct known_hosts_ctx ctx;\n\tu_int foreach_options;\n\n\tif (!have_identity) {\n\t\tcp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);\n\t\tif (strlcpy(identity_file, cp, sizeof(identity_file)) >=\n\t\t    sizeof(identity_file))\n\t\t\tfatal(\"Specified known hosts path too long\");\n\t\tfree(cp);\n\t\thave_identity = 1;\n\t}\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.out = stdout;\n\tctx.host = name;\n\n\t/*\n\t * Find hosts goes to stdout, hash and deletions happen in-place\n\t * A corner case is ssh-keygen -HF foo, which should go to stdout\n\t */\n\tif (!find_host && (hash_hosts || delete_host)) {\n\t\tif (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcat(tmp, \".XXXXXXXXXX\", sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||\n\t\t    strlcat(old, \".old\", sizeof(old)) >= sizeof(old))\n\t\t\tfatal(\"known_hosts path too long\");\n\t\tumask(077);\n\t\tif ((fd = mkstemp(tmp)) == -1)\n\t\t\tfatal(\"mkstemp: %s\", strerror(errno));\n\t\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\t\toerrno = errno;\n\t\t\tunlink(tmp);\n\t\t\tfatal(\"fdopen: %s\", strerror(oerrno));\n\t\t}\n\t\tinplace = 1;\n\t}\n\t/* XXX support identity_file == \"-\" for stdin */\n\tforeach_options = find_host ? HKF_WANT_MATCH : 0;\n\tforeach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;\n\tif ((r = hostkeys_foreach(identity_file, (find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash, &ctx, name, NULL,\n\t    foreach_options)) != 0) {\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t\tfatal(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (inplace)\n\t\tfclose(ctx.out);\n\n\tif (ctx.invalid) {\n\t\terror(\"%s is not a valid known_hosts file.\", identity_file);\n\t\tif (inplace) {\n\t\t\terror(\"Not replacing existing known_hosts \"\n\t\t\t    \"file because of errors\");\n\t\t\tunlink(tmp);\n\t\t}\n\t\texit(1);\n\t} else if (delete_host && !ctx.found_key) {\n\t\tlogit(\"Host %s not found in %s\", name, identity_file);\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t} else if (inplace) {\n\t\t/* Backup existing file */\n\t\tif (unlink(old) == -1 && errno != ENOENT)\n\t\t\tfatal(\"unlink %.100s: %s\", old, strerror(errno));\n\t\tif (link(identity_file, old) == -1)\n\t\t\tfatal(\"link %.100s to %.100s: %s\", identity_file, old,\n\t\t\t    strerror(errno));\n\t\t/* Move new one into place */\n\t\tif (rename(tmp, identity_file) == -1) {\n\t\t\terror(\"rename\\\"%s\\\" to \\\"%s\\\": %s\", tmp, identity_file,\n\t\t\t    strerror(errno));\n\t\t\tunlink(tmp);\n\t\t\tunlink(old);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"%s updated.\\n\", identity_file);\n\t\tprintf(\"Original contents retained as %s\\n\", old);\n\t\tif (ctx.has_unhashed) {\n\t\t\tlogit(\"WARNING: %s contains unhashed entries\", old);\n\t\t\tlogit(\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\");\n\t\t}\n\t}\n\n\texit (find_host && !ctx.found_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_show_cert",
          "args": [
            "pw"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "do_show_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2041-2096",
          "snippet": "static void\ndo_show_cert(struct passwd *pw)\n{\n\tstruct sshkey *key = NULL;\n\tstruct stat st;\n\tint r, is_stdin = 0, ok = 0;\n\tFILE *f;\n\tchar *cp, *line = NULL;\n\tconst char *path;\n\tsize_t linesize = 0;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (strcmp(identity_file, \"-\") != 0 && stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tpath = identity_file;\n\tif (strcmp(path, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t\tis_stdin = 1;\n\t} else if ((f = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", identity_file, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror(\"%s:%lu: invalid key: %s\", path,\n\t\t\t    lnum, ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"%s:%lu is not a certificate\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tok = 1;\n\t\tif (!is_stdin && lnum == 1)\n\t\t\tprintf(\"%s:\\n\", path);\n\t\telse\n\t\t\tprintf(\"%s:%lu:\\n\", path, lnum);\n\t\tprint_cert(key);\n\t}\n\tfree(line);\n\tsshkey_free(key);\n\tfclose(f);\n\texit(ok ? 0 : 1);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nextern char *__progname;\n\nstatic void\ndo_show_cert(struct passwd *pw)\n{\n\tstruct sshkey *key = NULL;\n\tstruct stat st;\n\tint r, is_stdin = 0, ok = 0;\n\tFILE *f;\n\tchar *cp, *line = NULL;\n\tconst char *path;\n\tsize_t linesize = 0;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (strcmp(identity_file, \"-\") != 0 && stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tpath = identity_file;\n\tif (strcmp(path, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t\tis_stdin = 1;\n\t} else if ((f = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", identity_file, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror(\"%s:%lu: invalid key: %s\", path,\n\t\t\t    lnum, ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"%s:%lu is not a certificate\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tok = 1;\n\t\tif (!is_stdin && lnum == 1)\n\t\t\tprintf(\"%s:\\n\", path);\n\t\telse\n\t\t\tprintf(\"%s:%lu:\\n\", path, lnum);\n\t\tprint_cert(key);\n\t}\n\tfree(line);\n\tsshkey_free(key);\n\tfclose(f);\n\texit(ok ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_ca_sign",
          "args": [
            "pw",
            "argc",
            "argv"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "do_ca_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1678-1824",
          "snippet": "static void\ndo_ca_sign(struct passwd *pw, int argc, char **argv)\n{\n\tint r, i, fd, found, agent_fd = -1;\n\tu_int n;\n\tstruct sshkey *ca, *public;\n\tchar valid[64], *otmp, *tmp, *cp, *out, *comment, **plist = NULL;\n\tFILE *f;\n\tstruct ssh_identitylist *agent_ids;\n\tsize_t j;\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(1);\n#endif\n\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\tif (pkcs11provider != NULL) {\n\t\t/* If a PKCS#11 token was specified then try to use it */\n\t\tif ((ca = load_pkcs11_key(tmp)) == NULL)\n\t\t\tfatal(\"No PKCS#11 key matching %s found\", ca_key_path);\n\t} else if (prefer_agent) {\n\t\t/*\n\t\t * Agent signature requested. Try to use agent after making\n\t\t * sure the public key specified is actually present in the\n\t\t * agent.\n\t\t */\n\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0)\n\t\t\tfatal(\"Cannot use public key for CA signature: %s\",\n\t\t\t    ssh_err(r));\n\t\tif ((r = ssh_fetch_identitylist(agent_fd, &agent_ids)) != 0)\n\t\t\tfatal(\"Retrieve agent key list: %s\", ssh_err(r));\n\t\tfound = 0;\n\t\tfor (j = 0; j < agent_ids->nkeys; j++) {\n\t\t\tif (sshkey_equal(ca, agent_ids->keys[j])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tfatal(\"CA key %s not found in agent\", tmp);\n\t\tssh_free_identitylist(agent_ids);\n\t\tca->flags |= SSHKEY_FLAG_EXT;\n\t} else {\n\t\t/* CA key is assumed to be a private key on the filesystem */\n\t\tca = load_identity(tmp);\n\t}\n\tfree(tmp);\n\n\tif (key_type_name != NULL &&\n\t    sshkey_type_from_name(key_type_name) != ca->type)  {\n\t\tfatal(\"CA key type %s doesn't match specified %s\",\n\t\t    sshkey_ssh_name(ca), key_type_name);\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\t/* Split list of principals */\n\t\tn = 0;\n\t\tif (cert_principals != NULL) {\n\t\t\totmp = tmp = xstrdup(cert_principals);\n\t\t\tplist = NULL;\n\t\t\tfor (; (cp = strsep(&tmp, \",\")) != NULL; n++) {\n\t\t\t\tplist = xreallocarray(plist, n + 1, sizeof(*plist));\n\t\t\t\tif (*(plist[n] = xstrdup(cp)) == '\\0')\n\t\t\t\t\tfatal(\"Empty principal name\");\n\t\t\t}\n\t\t\tfree(otmp);\n\t\t}\n\t\tif (n > SSHKEY_CERT_MAX_PRINCIPALS)\n\t\t\tfatal(\"Too many certificate principals specified\");\n\t\n\t\ttmp = tilde_expand_filename(argv[i], pw->pw_uid);\n\t\tif ((r = sshkey_load_public(tmp, &public, &comment)) != 0)\n\t\t\tfatal(\"%s: unable to open \\\"%s\\\": %s\",\n\t\t\t    __func__, tmp, ssh_err(r));\n\t\tif (public->type != KEY_RSA && public->type != KEY_DSA &&\n\t\t    public->type != KEY_ECDSA && public->type != KEY_ED25519 &&\n\t\t    public->type != KEY_XMSS)\n\t\t\tfatal(\"%s: key \\\"%s\\\" type %s cannot be certified\",\n\t\t\t    __func__, tmp, sshkey_type(public));\n\n\t\t/* Prepare certificate to sign */\n\t\tif ((r = sshkey_to_certified(public)) != 0)\n\t\t\tfatal(\"Could not upgrade key %s to certificate: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tpublic->cert->type = cert_key_type;\n\t\tpublic->cert->serial = (u_int64_t)cert_serial;\n\t\tpublic->cert->key_id = xstrdup(cert_key_id);\n\t\tpublic->cert->nprincipals = n;\n\t\tpublic->cert->principals = plist;\n\t\tpublic->cert->valid_after = cert_valid_from;\n\t\tpublic->cert->valid_before = cert_valid_to;\n\t\tprepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);\n\t\tprepare_options_buf(public->cert->extensions,\n\t\t    OPTIONS_EXTENSIONS);\n\t\tif ((r = sshkey_from_private(ca,\n\t\t    &public->cert->signature_key)) != 0)\n\t\t\tfatal(\"sshkey_from_private (ca key): %s\", ssh_err(r));\n\n\t\tif (agent_fd != -1 && (ca->flags & SSHKEY_FLAG_EXT) != 0) {\n\t\t\tif ((r = sshkey_certify_custom(public, ca,\n\t\t\t    key_type_name, agent_signer, &agent_fd)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s via agent: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t} else {\n\t\t\tif ((sshkey_certify(public, ca, key_type_name)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t}\n\n\t\tif ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, \".pub\") == 0)\n\t\t\t*cp = '\\0';\n\t\txasprintf(&out, \"%s-cert.pub\", tmp);\n\t\tfree(tmp);\n\n\t\tif ((fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\t\tfatal(\"Could not open \\\"%s\\\" for writing: %s\", out,\n\t\t\t    strerror(errno));\n\t\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\t\tfatal(\"%s: fdopen: %s\", __func__, strerror(errno));\n\t\tif ((r = sshkey_write(public, f)) != 0)\n\t\t\tfatal(\"Could not write certified key to %s: %s\",\n\t\t\t    out, ssh_err(r));\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tfclose(f);\n\n\t\tif (!quiet) {\n\t\t\tsshkey_format_cert_validity(public->cert,\n\t\t\t    valid, sizeof(valid));\n\t\t\tlogit(\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\", sshkey_cert_type(public),\n\t\t\t    out, public->cert->key_id,\n\t\t\t    (unsigned long long)public->cert->serial,\n\t\t\t    cert_principals != NULL ? \" for \" : \"\",\n\t\t\t    cert_principals != NULL ? cert_principals : \"\",\n\t\t\t    valid);\n\t\t}\n\n\t\tsshkey_free(public);\n\t\tfree(out);\n\t}\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define OPTIONS_EXTENSIONS\t2",
            "#define OPTIONS_CRITICAL\t1"
          ],
          "globals_used": [
            "int quiet = 0;",
            "char *ca_key_path = NULL;",
            "int prefer_agent = 0;",
            "unsigned long long cert_serial = 0;",
            "u_int cert_key_type = SSH2_CERT_TYPE_USER;",
            "char *cert_key_id = NULL;",
            "char *cert_principals = NULL;",
            "u_int64_t cert_valid_from = 0;",
            "u_int64_t cert_valid_to = ~0ULL;",
            "char *key_type_name = NULL;",
            "char *pkcs11provider = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nint quiet = 0;\nchar *ca_key_path = NULL;\nint prefer_agent = 0;\nunsigned long long cert_serial = 0;\nu_int cert_key_type = SSH2_CERT_TYPE_USER;\nchar *cert_key_id = NULL;\nchar *cert_principals = NULL;\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\nchar *key_type_name = NULL;\nchar *pkcs11provider = NULL;\n\nstatic void\ndo_ca_sign(struct passwd *pw, int argc, char **argv)\n{\n\tint r, i, fd, found, agent_fd = -1;\n\tu_int n;\n\tstruct sshkey *ca, *public;\n\tchar valid[64], *otmp, *tmp, *cp, *out, *comment, **plist = NULL;\n\tFILE *f;\n\tstruct ssh_identitylist *agent_ids;\n\tsize_t j;\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(1);\n#endif\n\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\tif (pkcs11provider != NULL) {\n\t\t/* If a PKCS#11 token was specified then try to use it */\n\t\tif ((ca = load_pkcs11_key(tmp)) == NULL)\n\t\t\tfatal(\"No PKCS#11 key matching %s found\", ca_key_path);\n\t} else if (prefer_agent) {\n\t\t/*\n\t\t * Agent signature requested. Try to use agent after making\n\t\t * sure the public key specified is actually present in the\n\t\t * agent.\n\t\t */\n\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0)\n\t\t\tfatal(\"Cannot use public key for CA signature: %s\",\n\t\t\t    ssh_err(r));\n\t\tif ((r = ssh_fetch_identitylist(agent_fd, &agent_ids)) != 0)\n\t\t\tfatal(\"Retrieve agent key list: %s\", ssh_err(r));\n\t\tfound = 0;\n\t\tfor (j = 0; j < agent_ids->nkeys; j++) {\n\t\t\tif (sshkey_equal(ca, agent_ids->keys[j])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tfatal(\"CA key %s not found in agent\", tmp);\n\t\tssh_free_identitylist(agent_ids);\n\t\tca->flags |= SSHKEY_FLAG_EXT;\n\t} else {\n\t\t/* CA key is assumed to be a private key on the filesystem */\n\t\tca = load_identity(tmp);\n\t}\n\tfree(tmp);\n\n\tif (key_type_name != NULL &&\n\t    sshkey_type_from_name(key_type_name) != ca->type)  {\n\t\tfatal(\"CA key type %s doesn't match specified %s\",\n\t\t    sshkey_ssh_name(ca), key_type_name);\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\t/* Split list of principals */\n\t\tn = 0;\n\t\tif (cert_principals != NULL) {\n\t\t\totmp = tmp = xstrdup(cert_principals);\n\t\t\tplist = NULL;\n\t\t\tfor (; (cp = strsep(&tmp, \",\")) != NULL; n++) {\n\t\t\t\tplist = xreallocarray(plist, n + 1, sizeof(*plist));\n\t\t\t\tif (*(plist[n] = xstrdup(cp)) == '\\0')\n\t\t\t\t\tfatal(\"Empty principal name\");\n\t\t\t}\n\t\t\tfree(otmp);\n\t\t}\n\t\tif (n > SSHKEY_CERT_MAX_PRINCIPALS)\n\t\t\tfatal(\"Too many certificate principals specified\");\n\t\n\t\ttmp = tilde_expand_filename(argv[i], pw->pw_uid);\n\t\tif ((r = sshkey_load_public(tmp, &public, &comment)) != 0)\n\t\t\tfatal(\"%s: unable to open \\\"%s\\\": %s\",\n\t\t\t    __func__, tmp, ssh_err(r));\n\t\tif (public->type != KEY_RSA && public->type != KEY_DSA &&\n\t\t    public->type != KEY_ECDSA && public->type != KEY_ED25519 &&\n\t\t    public->type != KEY_XMSS)\n\t\t\tfatal(\"%s: key \\\"%s\\\" type %s cannot be certified\",\n\t\t\t    __func__, tmp, sshkey_type(public));\n\n\t\t/* Prepare certificate to sign */\n\t\tif ((r = sshkey_to_certified(public)) != 0)\n\t\t\tfatal(\"Could not upgrade key %s to certificate: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tpublic->cert->type = cert_key_type;\n\t\tpublic->cert->serial = (u_int64_t)cert_serial;\n\t\tpublic->cert->key_id = xstrdup(cert_key_id);\n\t\tpublic->cert->nprincipals = n;\n\t\tpublic->cert->principals = plist;\n\t\tpublic->cert->valid_after = cert_valid_from;\n\t\tpublic->cert->valid_before = cert_valid_to;\n\t\tprepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);\n\t\tprepare_options_buf(public->cert->extensions,\n\t\t    OPTIONS_EXTENSIONS);\n\t\tif ((r = sshkey_from_private(ca,\n\t\t    &public->cert->signature_key)) != 0)\n\t\t\tfatal(\"sshkey_from_private (ca key): %s\", ssh_err(r));\n\n\t\tif (agent_fd != -1 && (ca->flags & SSHKEY_FLAG_EXT) != 0) {\n\t\t\tif ((r = sshkey_certify_custom(public, ca,\n\t\t\t    key_type_name, agent_signer, &agent_fd)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s via agent: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t} else {\n\t\t\tif ((sshkey_certify(public, ca, key_type_name)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t}\n\n\t\tif ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, \".pub\") == 0)\n\t\t\t*cp = '\\0';\n\t\txasprintf(&out, \"%s-cert.pub\", tmp);\n\t\tfree(tmp);\n\n\t\tif ((fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\t\tfatal(\"Could not open \\\"%s\\\" for writing: %s\", out,\n\t\t\t    strerror(errno));\n\t\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\t\tfatal(\"%s: fdopen: %s\", __func__, strerror(errno));\n\t\tif ((r = sshkey_write(public, f)) != 0)\n\t\t\tfatal(\"Could not write certified key to %s: %s\",\n\t\t\t    out, ssh_err(r));\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tfclose(f);\n\n\t\tif (!quiet) {\n\t\t\tsshkey_format_cert_validity(public->cert,\n\t\t\t    valid, sizeof(valid));\n\t\t\tlogit(\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\", sshkey_cert_type(public),\n\t\t\t    out, public->cert->key_id,\n\t\t\t    (unsigned long long)public->cert->serial,\n\t\t\t    cert_principals != NULL ? \" for \" : \"\",\n\t\t\t    cert_principals != NULL ? cert_principals : \"\",\n\t\t\t    valid);\n\t\t}\n\n\t\tsshkey_free(public);\n\t\tfree(out);\n\t}\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_check_krl",
          "args": [
            "pw",
            "argc",
            "argv"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "do_check_krl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2363-2389",
          "snippet": "static void\ndo_check_krl(struct passwd *pw, int argc, char **argv)\n{\n\tint i, r, ret = 0;\n\tchar *comment;\n\tstruct ssh_krl *krl;\n\tstruct sshkey *k;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL checking requires an input file\");\n\tload_krl(identity_file, &krl);\n\tfor (i = 0; i < argc; i++) {\n\t\tif ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)\n\t\t\tfatal(\"Cannot load public key %s: %s\",\n\t\t\t    argv[i], ssh_err(r));\n\t\tr = ssh_krl_check_key(krl, k);\n\t\tprintf(\"%s%s%s%s: %s\\n\", argv[i],\n\t\t    *comment ? \" (\" : \"\", comment, *comment ? \")\" : \"\",\n\t\t    r == 0 ? \"ok\" : \"REVOKED\");\n\t\tif (r != 0)\n\t\t\tret = 1;\n\t\tsshkey_free(k);\n\t\tfree(comment);\n\t}\n\tssh_krl_free(krl);\n\texit(ret);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\n\nstatic void\ndo_check_krl(struct passwd *pw, int argc, char **argv)\n{\n\tint i, r, ret = 0;\n\tchar *comment;\n\tstruct ssh_krl *krl;\n\tstruct sshkey *k;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL checking requires an input file\");\n\tload_krl(identity_file, &krl);\n\tfor (i = 0; i < argc; i++) {\n\t\tif ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)\n\t\t\tfatal(\"Cannot load public key %s: %s\",\n\t\t\t    argv[i], ssh_err(r));\n\t\tr = ssh_krl_check_key(krl, k);\n\t\tprintf(\"%s%s%s%s: %s\\n\", argv[i],\n\t\t    *comment ? \" (\" : \"\", comment, *comment ? \")\" : \"\",\n\t\t    r == 0 ? \"ok\" : \"REVOKED\");\n\t\tif (r != 0)\n\t\t\tret = 1;\n\t\tsshkey_free(k);\n\t\tfree(comment);\n\t}\n\tssh_krl_free(krl);\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_gen_krl",
          "args": [
            "pw",
            "update_krl",
            "argc",
            "argv"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "do_gen_krl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2304-2361",
          "snippet": "static void\ndo_gen_krl(struct passwd *pw, int updating, int argc, char **argv)\n{\n\tstruct ssh_krl *krl;\n\tstruct stat sb;\n\tstruct sshkey *ca = NULL;\n\tint fd, i, r, wild_ca = 0;\n\tchar *tmp;\n\tstruct sshbuf *kbuf;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL generation requires an output file\");\n\tif (stat(identity_file, &sb) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tfatal(\"Cannot access KRL \\\"%s\\\": %s\",\n\t\t\t    identity_file, strerror(errno));\n\t\tif (updating)\n\t\t\tfatal(\"KRL \\\"%s\\\" does not exist\", identity_file);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (strcasecmp(ca_key_path, \"none\") == 0)\n\t\t\twild_ca = 1;\n\t\telse {\n\t\t\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\t\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tif (updating)\n\t\tload_krl(identity_file, &krl);\n\telse if ((krl = ssh_krl_init()) == NULL)\n\t\tfatal(\"couldn't create KRL\");\n\n\tif (cert_serial != 0)\n\t\tssh_krl_set_version(krl, cert_serial);\n\tif (identity_comment != NULL)\n\t\tssh_krl_set_comment(krl, identity_comment);\n\n\tfor (i = 0; i < argc; i++)\n\t\tupdate_krl_from_file(pw, argv[i], wild_ca, ca, krl);\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)\n\t\tfatal(\"Couldn't generate KRL\");\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"open %s: %s\", identity_file, strerror(errno));\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(kbuf), sshbuf_len(kbuf)) !=\n\t    sshbuf_len(kbuf))\n\t\tfatal(\"write %s: %s\", identity_file, strerror(errno));\n\tclose(fd);\n\tsshbuf_free(kbuf);\n\tssh_krl_free(krl);\n\tsshkey_free(ca);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "char *identity_comment = NULL;",
            "char *ca_key_path = NULL;",
            "unsigned long long cert_serial = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nchar *identity_comment = NULL;\nchar *ca_key_path = NULL;\nunsigned long long cert_serial = 0;\n\nstatic void\ndo_gen_krl(struct passwd *pw, int updating, int argc, char **argv)\n{\n\tstruct ssh_krl *krl;\n\tstruct stat sb;\n\tstruct sshkey *ca = NULL;\n\tint fd, i, r, wild_ca = 0;\n\tchar *tmp;\n\tstruct sshbuf *kbuf;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL generation requires an output file\");\n\tif (stat(identity_file, &sb) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tfatal(\"Cannot access KRL \\\"%s\\\": %s\",\n\t\t\t    identity_file, strerror(errno));\n\t\tif (updating)\n\t\t\tfatal(\"KRL \\\"%s\\\" does not exist\", identity_file);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (strcasecmp(ca_key_path, \"none\") == 0)\n\t\t\twild_ca = 1;\n\t\telse {\n\t\t\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\t\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tif (updating)\n\t\tload_krl(identity_file, &krl);\n\telse if ((krl = ssh_krl_init()) == NULL)\n\t\tfatal(\"couldn't create KRL\");\n\n\tif (cert_serial != 0)\n\t\tssh_krl_set_version(krl, cert_serial);\n\tif (identity_comment != NULL)\n\t\tssh_krl_set_comment(krl, identity_comment);\n\n\tfor (i = 0; i < argc; i++)\n\t\tupdate_krl_from_file(pw, argv[i], wild_ca, ca, krl);\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)\n\t\tfatal(\"Couldn't generate KRL\");\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"open %s: %s\", identity_file, strerror(errno));\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(kbuf), sshbuf_len(kbuf)) !=\n\t    sshbuf_len(kbuf))\n\t\tfatal(\"write %s: %s\", identity_file, strerror(errno));\n\tclose(fd);\n\tsshbuf_free(kbuf);\n\tssh_krl_free(krl);\n\tsshkey_free(ca);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2391-2427",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\\n\"\n\t    \"                  [-N new_passphrase] [-C comment] [-f output_keyfile]\\n\"\n\t    \"       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -i [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -e [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\");\n#ifdef ENABLE_PKCS11\n\tfprintf(stderr,\n\t    \"       ssh-keygen -D pkcs11\\n\");\n#endif\n\tfprintf(stderr,\n\t    \"       ssh-keygen -F hostname [-f known_hosts_file] [-l]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-f input_keyfile] [-g]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\\n\"\n\t    \"       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\\n\"\n\t    \"                  [-j start_line] [-K checkpt] [-W generator]\\n\"\n#endif\n\t    \"       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]\\n\"\n\t    \"                  [-D pkcs11_provider] [-n principals] [-O option]\\n\"\n\t    \"                  [-V validity_interval] [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q -f krl_file file ...\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t bits = 0;",
            "int fingerprint_hash = SSH_FP_HASH_DEFAULT;",
            "int rounds = 0;",
            "char hostname[NI_MAXHOST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t bits = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\nint rounds = 0;\nchar hostname[NI_MAXHOST];\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\\n\"\n\t    \"                  [-N new_passphrase] [-C comment] [-f output_keyfile]\\n\"\n\t    \"       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -i [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -e [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\");\n#ifdef ENABLE_PKCS11\n\tfprintf(stderr,\n\t    \"       ssh-keygen -D pkcs11\\n\");\n#endif\n\tfprintf(stderr,\n\t    \"       ssh-keygen -F hostname [-f known_hosts_file] [-l]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-f input_keyfile] [-g]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\\n\"\n\t    \"       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\\n\"\n\t    \"                  [-j start_line] [-K checkpt] [-W generator]\\n\"\n#endif\n\t    \"       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]\\n\"\n\t    \"                  [-D pkcs11_provider] [-n principals] [-O option]\\n\"\n\t    \"                  [-V validity_interval] [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q -f krl_file file ...\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "argv[0]",
            "log_level",
            "SYSLOG_FACILITY_USER",
            "1"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "optarg",
            "1",
            "UINT_MAX",
            "&errstr"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_hex2bn",
          "args": [
            "&start",
            "optarg"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "optarg"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "NULL",
            "10"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "strtoull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoull.c",
          "lines": "49-109",
          "snippet": "unsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nunsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_cert_times",
          "args": [
            "optarg"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cert_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1840-1888",
          "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int64_t cert_valid_from = 0;",
            "u_int64_t cert_valid_to = ~0ULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_cert_option",
          "args": [
            "optarg"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "add_cert_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1890-1948",
          "snippet": "static void\nadd_cert_option(char *opt)\n{\n\tchar *val, *cp;\n\tint iscrit = 0;\n\n\tif (strcasecmp(opt, \"clear\") == 0)\n\t\tcertflags_flags = 0;\n\telse if (strcasecmp(opt, \"no-x11-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"permit-x11-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"no-agent-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"permit-agent-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"no-port-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"permit-port-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"no-pty\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"permit-pty\") == 0)\n\t\tcertflags_flags |= CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"no-user-rc\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"permit-user-rc\") == 0)\n\t\tcertflags_flags |= CERTOPT_USER_RC;\n\telse if (strncasecmp(opt, \"force-command=\", 14) == 0) {\n\t\tval = opt + 14;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty force-command option\");\n\t\tif (certflags_command != NULL)\n\t\t\tfatal(\"force-command already specified\");\n\t\tcertflags_command = xstrdup(val);\n\t} else if (strncasecmp(opt, \"source-address=\", 15) == 0) {\n\t\tval = opt + 15;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty source-address option\");\n\t\tif (certflags_src_addr != NULL)\n\t\t\tfatal(\"source-address already specified\");\n\t\tif (addr_match_cidr_list(NULL, val) != 0)\n\t\t\tfatal(\"Invalid source-address list\");\n\t\tcertflags_src_addr = xstrdup(val);\n\t} else if (strncasecmp(opt, \"extension:\", 10) == 0 ||\n\t\t   (iscrit = (strncasecmp(opt, \"critical:\", 9) == 0))) {\n\t\tval = xstrdup(strchr(opt, ':') + 1);\n\t\tif ((cp = strchr(val, '=')) != NULL)\n\t\t\t*cp++ = '\\0';\n\t\tcert_userext = xreallocarray(cert_userext, ncert_userext + 1,\n\t\t    sizeof(*cert_userext));\n\t\tcert_userext[ncert_userext].key = val;\n\t\tcert_userext[ncert_userext].val = cp == NULL ?\n\t\t    NULL : xstrdup(cp);\n\t\tcert_userext[ncert_userext].crit = iscrit;\n\t\tncert_userext++;\n\t} else\n\t\tfatal(\"Unsupported certificate option \\\"%s\\\"\", opt);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CERTOPT_USER_RC\t(1<<4)",
            "#define CERTOPT_PTY\t\t(1<<3)",
            "#define CERTOPT_PORT_FWD\t(1<<2)",
            "#define CERTOPT_AGENT_FWD\t(1<<1)",
            "#define CERTOPT_X_FWD\t(1)"
          ],
          "globals_used": [
            "u_int32_t certflags_flags = CERTOPT_DEFAULT;",
            "char *certflags_command = NULL;",
            "char *certflags_src_addr = NULL;",
            "struct cert_userext *cert_userext;",
            "size_t ncert_userext;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CERTOPT_USER_RC\t(1<<4)\n#define CERTOPT_PTY\t\t(1<<3)\n#define CERTOPT_PORT_FWD\t(1<<2)\n#define CERTOPT_AGENT_FWD\t(1<<1)\n#define CERTOPT_X_FWD\t(1)\n\nu_int32_t certflags_flags = CERTOPT_DEFAULT;\nchar *certflags_command = NULL;\nchar *certflags_src_addr = NULL;\nstruct cert_userext *cert_userext;\nsize_t ncert_userext;\n\nstatic void\nadd_cert_option(char *opt)\n{\n\tchar *val, *cp;\n\tint iscrit = 0;\n\n\tif (strcasecmp(opt, \"clear\") == 0)\n\t\tcertflags_flags = 0;\n\telse if (strcasecmp(opt, \"no-x11-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"permit-x11-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"no-agent-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"permit-agent-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"no-port-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"permit-port-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"no-pty\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"permit-pty\") == 0)\n\t\tcertflags_flags |= CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"no-user-rc\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"permit-user-rc\") == 0)\n\t\tcertflags_flags |= CERTOPT_USER_RC;\n\telse if (strncasecmp(opt, \"force-command=\", 14) == 0) {\n\t\tval = opt + 14;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty force-command option\");\n\t\tif (certflags_command != NULL)\n\t\t\tfatal(\"force-command already specified\");\n\t\tcertflags_command = xstrdup(val);\n\t} else if (strncasecmp(opt, \"source-address=\", 15) == 0) {\n\t\tval = opt + 15;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty source-address option\");\n\t\tif (certflags_src_addr != NULL)\n\t\t\tfatal(\"source-address already specified\");\n\t\tif (addr_match_cidr_list(NULL, val) != 0)\n\t\t\tfatal(\"Invalid source-address list\");\n\t\tcertflags_src_addr = xstrdup(val);\n\t} else if (strncasecmp(opt, \"extension:\", 10) == 0 ||\n\t\t   (iscrit = (strncasecmp(opt, \"critical:\", 9) == 0))) {\n\t\tval = xstrdup(strchr(opt, ':') + 1);\n\t\tif ((cp = strchr(val, '=')) != NULL)\n\t\t\t*cp++ = '\\0';\n\t\tcert_userext = xreallocarray(cert_userext, ncert_userext + 1,\n\t\t    sizeof(*cert_userext));\n\t\tcert_userext[ncert_userext].key = val;\n\t\tcert_userext[ncert_userext].val = cp == NULL ?\n\t\t    NULL : xstrdup(cp);\n\t\tcert_userext[ncert_userext].crit = iscrit;\n\t\tncert_userext++;\n\t} else\n\t\tfatal(\"Unsupported certificate option \\\"%s\\\"\", opt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"PEM\""
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"PKCS8\""
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"ssh2\""
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"RFC4716\""
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_digest_alg_by_name",
          "args": [
            "optarg"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "123-133",
          "snippet": "int\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"ABHLQUXceghiklopquvxy\"\n\t    \"C:D:E:F:G:I:J:K:M:N:O:P:R:S:T:V:W:Z:\"\n\t    \"a:b:f:g:j:m:n:r:s:t:z:\""
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "hostname",
            "sizeof(hostname)"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msetlocale",
          "args": [],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "msetlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "310-340",
          "snippet": "void\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed_rng",
          "args": [],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "seed_rng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "247-250",
          "snippet": "void\nseed_rng(void)\n{\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nseed_rng(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "argv[0]"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define DEFAULT_BITS\t\t2048\n\nu_int32_t bits = 0;\nint change_passphrase = 0;\nint change_comment = 0;\nint quiet = 0;\nint log_level = SYSLOG_LEVEL_INFO;\nint hash_hosts = 0;\nint find_host = 0;\nint delete_host = 0;\nint show_cert = 0;\nint print_fingerprint = 0;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\nchar identity_file[1024];\nint have_identity = 0;\nchar *identity_passphrase = NULL;\nchar *identity_new_passphrase = NULL;\nchar *identity_comment = NULL;\nchar *ca_key_path = NULL;\nint prefer_agent = 0;\nunsigned long long cert_serial = 0;\nu_int cert_key_type = SSH2_CERT_TYPE_USER;\nchar *cert_key_id = NULL;\nchar *cert_principals = NULL;\nu_int32_t certflags_flags = CERTOPT_DEFAULT;\nint convert_to = 0;\nint convert_from = 0;\nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\nint print_public = 0;\nint print_generic = 0;\nchar *key_type_name = NULL;\nchar *pkcs11provider = NULL;\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\nextern char *__progname;\nchar hostname[NI_MAXHOST];\n\nint\nmain(int argc, char **argv)\n{\n\tchar dotsshdir[PATH_MAX], comment[1024], *passphrase1, *passphrase2;\n\tchar *rr_hostname = NULL, *ep, *fp, *ra;\n\tstruct sshkey *private, *public;\n\tstruct passwd *pw;\n\tstruct stat st;\n\tint r, opt, type, fd;\n\tint gen_all_hostkeys = 0, gen_krl = 0, update_krl = 0, check_krl = 0;\n\tFILE *f;\n\tconst char *errstr;\n#ifdef WITH_OPENSSL\n\t/* Moduli generation/screening */\n\tchar out_file[PATH_MAX], *checkpoint = NULL;\n\tu_int32_t memory = 0, generator_wanted = 0;\n\tint do_gen_candidates = 0, do_screen_candidates = 0;\n\tunsigned long start_lineno = 0, lines_to_process = 0;\n\tBIGNUM *start = NULL;\n#endif\n\n\textern int optind;\n\textern char *optarg;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(argv[0]);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\tlog_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);\n\n\tseed_rng();\n\n\tmsetlocale();\n\n\t/* we need this for the home * directory.  */\n\tpw = getpwuid(getuid());\n\tif (!pw)\n\t\tfatal(\"No user exists for uid %lu\", (u_long)getuid());\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\n\t/* Remaining characters: Ydw */\n\twhile ((opt = getopt(argc, argv, \"ABHLQUXceghiklopquvxy\"\n\t    \"C:D:E:F:G:I:J:K:M:N:O:P:R:S:T:V:W:Z:\"\n\t    \"a:b:f:g:j:m:n:r:s:t:z:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'A':\n\t\t\tgen_all_hostkeys = 1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbits = (u_int32_t)strtonum(optarg, 10, 32768, &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Bits has bad value %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfind_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\thash_hosts = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tcert_key_id = optarg;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdelete_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tshow_cert = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tprint_fingerprint = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tprint_bubblebabble = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"RFC4716\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"ssh2\") == 0) {\n\t\t\t\tconvert_format = FMT_RFC4716;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PKCS8\") == 0) {\n\t\t\t\tconvert_format = FMT_PKCS8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PEM\") == 0) {\n\t\t\t\tconvert_format = FMT_PEM;\n\t\t\t\tuse_new_format = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfatal(\"Unsupported conversion format \\\"%s\\\"\", optarg);\n\t\tcase 'n':\n\t\t\tcert_principals = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t/* no-op; new format is already the default */\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tchange_passphrase = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tchange_comment = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (strlcpy(identity_file, optarg,\n\t\t\t    sizeof(identity_file)) >= sizeof(identity_file))\n\t\t\t\tfatal(\"Identity filename too long\");\n\t\t\thave_identity = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tprint_generic = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tidentity_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tidentity_new_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcheck_krl = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tadd_cert_option(optarg);\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tnew_format_cipher = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tidentity_comment = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\tcase 'x':\n\t\t\t/* export key */\n\t\t\tconvert_to = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcert_key_type = SSH2_CERT_TYPE_HOST;\n\t\t\tcertflags_flags = 0;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tgen_krl = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\tcase 'X':\n\t\t\t/* import key */\n\t\t\tconvert_from = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tprint_public = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tca_key_path = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tkey_type_name = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tpkcs11provider = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tprefer_agent = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tupdate_krl = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (log_level == SYSLOG_LEVEL_INFO)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse {\n\t\t\t\tif (log_level >= SYSLOG_LEVEL_DEBUG1 &&\n\t\t\t\t    log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_level++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\trounds = (int)strtonum(optarg, 1, INT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Invalid number: %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tparse_cert_times(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\terrno = 0;\n\t\t\tcert_serial = strtoull(optarg, &ep, 10);\n\t\t\tif (*optarg < '0' || *optarg > '9' || *ep != '\\0' ||\n\t\t\t    (errno == ERANGE && cert_serial == ULLONG_MAX))\n\t\t\t\tfatal(\"Invalid serial number \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n#ifdef WITH_OPENSSL\n\t\t/* Moduli generation/screening */\n\t\tcase 'G':\n\t\t\tdo_gen_candidates = 1;\n\t\t\tif (strlcpy(out_file, optarg, sizeof(out_file)) >=\n\t\t\t    sizeof(out_file))\n\t\t\t\tfatal(\"Output filename too long\");\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tlines_to_process = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tstart_lineno = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tif (strlen(optarg) >= PATH_MAX)\n\t\t\t\tfatal(\"Checkpoint filename too long\");\n\t\t\tcheckpoint = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmemory = (u_int32_t)strtonum(optarg, 1, UINT_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Memory limit is %s: %s\", errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t/* XXX - also compare length against bits */\n\t\t\tif (BN_hex2bn(&start, optarg) == 0)\n\t\t\t\tfatal(\"Invalid start point.\");\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tdo_screen_candidates = 1;\n\t\t\tif (strlcpy(out_file, optarg, sizeof(out_file)) >=\n\t\t\t    sizeof(out_file))\n\t\t\t\tfatal(\"Output filename too long\");\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tgenerator_wanted = (u_int32_t)strtonum(optarg, 1,\n\t\t\t    UINT_MAX, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tfatal(\"Desired generator invalid: %s (%s)\",\n\t\t\t\t    optarg, errstr);\n\t\t\tbreak;\n#endif /* WITH_OPENSSL */\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/* reinit */\n\tlog_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);\n\n\targv += optind;\n\targc -= optind;\n\n\tif (ca_key_path != NULL) {\n\t\tif (argc < 1 && !gen_krl) {\n\t\t\terror(\"Too few arguments.\");\n\t\t\tusage();\n\t\t}\n\t} else if (argc > 0 && !gen_krl && !check_krl) {\n\t\terror(\"Too many arguments.\");\n\t\tusage();\n\t}\n\tif (change_passphrase && change_comment) {\n\t\terror(\"Can only have one of -p and -c.\");\n\t\tusage();\n\t}\n\tif (print_fingerprint && (delete_host || hash_hosts)) {\n\t\terror(\"Cannot use -l with -H or -R.\");\n\t\tusage();\n\t}\n\tif (gen_krl) {\n\t\tdo_gen_krl(pw, update_krl, argc, argv);\n\t\treturn (0);\n\t}\n\tif (check_krl) {\n\t\tdo_check_krl(pw, argc, argv);\n\t\treturn (0);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (cert_key_id == NULL)\n\t\t\tfatal(\"Must specify key id (-I) when certifying\");\n\t\tdo_ca_sign(pw, argc, argv);\n\t}\n\tif (show_cert)\n\t\tdo_show_cert(pw);\n\tif (delete_host || hash_hosts || find_host)\n\t\tdo_known_hosts(pw, rr_hostname);\n\tif (pkcs11provider != NULL)\n\t\tdo_download(pw);\n\tif (print_fingerprint || print_bubblebabble)\n\t\tdo_fingerprint(pw);\n\tif (change_passphrase)\n\t\tdo_change_passphrase(pw);\n\tif (change_comment)\n\t\tdo_change_comment(pw);\n#ifdef WITH_OPENSSL\n\tif (convert_to)\n\t\tdo_convert_to(pw);\n\tif (convert_from)\n\t\tdo_convert_from(pw);\n#endif\n\tif (print_public)\n\t\tdo_print_public(pw);\n\tif (rr_hostname != NULL) {\n\t\tunsigned int n = 0;\n\n\t\tif (have_identity) {\n\t\t\tn = do_print_resource_record(pw,\n\t\t\t    identity_file, rr_hostname);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t\t\texit(0);\n\t\t} else {\n\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_RSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_DSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ECDSA_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ED25519_KEY_FILE, rr_hostname);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_XMSS_KEY_FILE, rr_hostname);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"no keys found.\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n#ifdef WITH_OPENSSL\n\tif (do_gen_candidates) {\n\t\tFILE *out = fopen(out_file, \"w\");\n\n\t\tif (out == NULL) {\n\t\t\terror(\"Couldn't open modulus candidate file \\\"%s\\\": %s\",\n\t\t\t    out_file, strerror(errno));\n\t\t\treturn (1);\n\t\t}\n\t\tif (bits == 0)\n\t\t\tbits = DEFAULT_BITS;\n\t\tif (gen_candidates(out, memory, bits, start) != 0)\n\t\t\tfatal(\"modulus candidate generation failed\");\n\n\t\treturn (0);\n\t}\n\n\tif (do_screen_candidates) {\n\t\tFILE *in;\n\t\tFILE *out = fopen(out_file, \"a\");\n\n\t\tif (have_identity && strcmp(identity_file, \"-\") != 0) {\n\t\t\tif ((in = fopen(identity_file, \"r\")) == NULL) {\n\t\t\t\tfatal(\"Couldn't open modulus candidate \"\n\t\t\t\t    \"file \\\"%s\\\": %s\", identity_file,\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t} else\n\t\t\tin = stdin;\n\n\t\tif (out == NULL) {\n\t\t\tfatal(\"Couldn't open moduli file \\\"%s\\\": %s\",\n\t\t\t    out_file, strerror(errno));\n\t\t}\n\t\tif (prime_test(in, out, rounds == 0 ? 100 : rounds,\n\t\t    generator_wanted, checkpoint,\n\t\t    start_lineno, lines_to_process) != 0)\n\t\t\tfatal(\"modulus screening failed\");\n\t\treturn (0);\n\t}\n#endif\n\n\tif (gen_all_hostkeys) {\n\t\tdo_gen_all_hostkeys(pw);\n\t\treturn (0);\n\t}\n\n\tif (key_type_name == NULL)\n\t\tkey_type_name = DEFAULT_KEY_TYPE_NAME;\n\n\ttype = sshkey_type_from_name(key_type_name);\n\ttype_bits_valid(type, key_type_name, &bits);\n\n\tif (!quiet)\n\t\tprintf(\"Generating public/private %s key pair.\\n\",\n\t\t    key_type_name);\n\tif ((r = sshkey_generate(type, bits, &private)) != 0)\n\t\tfatal(\"sshkey_generate failed\");\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\\n\", ssh_err(r));\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which to save the key\");\n\n\t/* Create ~/.ssh directory if it doesn't already exist. */\n\tsnprintf(dotsshdir, sizeof dotsshdir, \"%s/%s\",\n\t    pw->pw_dir, _PATH_SSH_USER_DIR);\n\tif (strstr(identity_file, dotsshdir) != NULL) {\n\t\tif (stat(dotsshdir, &st) < 0) {\n\t\t\tif (errno != ENOENT) {\n\t\t\t\terror(\"Could not stat %s: %s\", dotsshdir,\n\t\t\t\t    strerror(errno));\n\t\t\t} else if (mkdir(dotsshdir, 0700) < 0) {\n\t\t\t\terror(\"Could not create directory '%s': %s\",\n\t\t\t\t    dotsshdir, strerror(errno));\n\t\t\t} else if (!quiet)\n\t\t\t\tprintf(\"Created directory '%s'.\\n\", dotsshdir);\n\t\t}\n\t}\n\t/* If the file already exists, ask the user to confirm. */\n\tif (stat(identity_file, &st) >= 0) {\n\t\tchar yesno[3];\n\t\tprintf(\"%s already exists.\\n\", identity_file);\n\t\tprintf(\"Overwrite (y/n)? \");\n\t\tfflush(stdout);\n\t\tif (fgets(yesno, sizeof(yesno), stdin) == NULL)\n\t\t\texit(1);\n\t\tif (yesno[0] != 'y' && yesno[0] != 'Y')\n\t\t\texit(1);\n\t}\n\t/* Ask for a passphrase (twice). */\n\tif (identity_passphrase)\n\t\tpassphrase1 = xstrdup(identity_passphrase);\n\telse if (identity_new_passphrase)\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\telse {\npassphrase_again:\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\t/*\n\t\t\t * The passphrases do not match.  Clear them and\n\t\t\t * retry.\n\t\t\t */\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Passphrases do not match.  Try again.\\n\");\n\t\t\tgoto passphrase_again;\n\t\t}\n\t\t/* Clear the other copy of the passphrase. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\tif (identity_comment) {\n\t\tstrlcpy(comment, identity_comment, sizeof(comment));\n\t} else {\n\t\t/* Create default comment field for the passphrase. */\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name, hostname);\n\t}\n\n\t/* Save the key with the given passphrase and comment. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\texit(1);\n\t}\n\t/* Clear the passphrase. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\n\t/* Clear the private key and the random number generator. */\n\tsshkey_free(private);\n\n\tif (!quiet)\n\t\tprintf(\"Your identification has been saved in %s.\\n\", identity_file);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"Unable to save public key to %s: %s\",\n\t\t    identity_file, strerror(errno));\n\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\terror(\"write key failed: %s\", ssh_err(r));\n\tfprintf(f, \" %s\\n\", comment);\n\tif (ferror(f) || fclose(f) != 0)\n\t\tfatal(\"write public failed: %s\", strerror(errno));\n\n\tif (!quiet) {\n\t\tfp = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tprintf(\"Your public key has been saved in %s.\\n\",\n\t\t    identity_file);\n\t\tprintf(\"The key fingerprint is:\\n\");\n\t\tprintf(\"%s %s\\n\", fp, comment);\n\t\tprintf(\"The key's randomart image is:\\n\");\n\t\tprintf(\"%s\\n\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t}\n\n\tsshkey_free(public);\n\texit(0);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2391-2427",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\\n\"\n\t    \"                  [-N new_passphrase] [-C comment] [-f output_keyfile]\\n\"\n\t    \"       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -i [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -e [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\");\n#ifdef ENABLE_PKCS11\n\tfprintf(stderr,\n\t    \"       ssh-keygen -D pkcs11\\n\");\n#endif\n\tfprintf(stderr,\n\t    \"       ssh-keygen -F hostname [-f known_hosts_file] [-l]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-f input_keyfile] [-g]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\\n\"\n\t    \"       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\\n\"\n\t    \"                  [-j start_line] [-K checkpt] [-W generator]\\n\"\n#endif\n\t    \"       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]\\n\"\n\t    \"                  [-D pkcs11_provider] [-n principals] [-O option]\\n\"\n\t    \"                  [-V validity_interval] [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q -f krl_file file ...\\n\");\n\texit(1);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t bits = 0;",
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;",
      "int rounds = 0;",
      "char hostname[NI_MAXHOST];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"       ssh-keygen -F hostname [-f known_hosts_file] [-l]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-f input_keyfile] [-g]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\\n\"\n\t    \"       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\\n\"\n\t    \"                  [-j start_line] [-K checkpt] [-W generator]\\n\"\n#endif\"       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]\\n\"\n\t    \"                  [-D pkcs11_provider] [-n principals] [-O option]\\n\"\n\t    \"                  [-V validity_interval] [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q -f krl_file file ...\\n\""
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"       ssh-keygen -D pkcs11\\n\""
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\\n\"\n\t    \"                  [-N new_passphrase] [-C comment] [-f output_keyfile]\\n\"\n\t    \"       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -i [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -e [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\""
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t bits = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\nint rounds = 0;\nchar hostname[NI_MAXHOST];\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\\n\"\n\t    \"                  [-N new_passphrase] [-C comment] [-f output_keyfile]\\n\"\n\t    \"       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -i [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -e [-m key_format] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\");\n#ifdef ENABLE_PKCS11\n\tfprintf(stderr,\n\t    \"       ssh-keygen -D pkcs11\\n\");\n#endif\n\tfprintf(stderr,\n\t    \"       ssh-keygen -F hostname [-f known_hosts_file] [-l]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-f input_keyfile] [-g]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\\n\"\n\t    \"       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\\n\"\n\t    \"                  [-j start_line] [-K checkpt] [-W generator]\\n\"\n#endif\n\t    \"       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]\\n\"\n\t    \"                  [-D pkcs11_provider] [-n principals] [-O option]\\n\"\n\t    \"                  [-V validity_interval] [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q -f krl_file file ...\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "do_check_krl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2363-2389",
    "snippet": "static void\ndo_check_krl(struct passwd *pw, int argc, char **argv)\n{\n\tint i, r, ret = 0;\n\tchar *comment;\n\tstruct ssh_krl *krl;\n\tstruct sshkey *k;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL checking requires an input file\");\n\tload_krl(identity_file, &krl);\n\tfor (i = 0; i < argc; i++) {\n\t\tif ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)\n\t\t\tfatal(\"Cannot load public key %s: %s\",\n\t\t\t    argv[i], ssh_err(r));\n\t\tr = ssh_krl_check_key(krl, k);\n\t\tprintf(\"%s%s%s%s: %s\\n\", argv[i],\n\t\t    *comment ? \" (\" : \"\", comment, *comment ? \")\" : \"\",\n\t\t    r == 0 ? \"ok\" : \"REVOKED\");\n\t\tif (r != 0)\n\t\t\tret = 1;\n\t\tsshkey_free(k);\n\t\tfree(comment);\n\t}\n\tssh_krl_free(krl);\n\texit(ret);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_free",
          "args": [
            "krl"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s%s%s%s: %s\\n\"",
            "argv[i]",
            "*comment ? \" (\" : \"\"",
            "comment",
            "*comment ? \")\" : \"\"",
            "r == 0 ? \"ok\" : \"REVOKED\""
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_check_key",
          "args": [
            "krl",
            "k"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_check_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "1316-1331",
          "snippet": "int\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"%s: checking key\", __func__));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2(\"%s: checking CA key\", __func__);\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"%s: key okay\", __func__));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Cannot load public key %s: %s\"",
            "argv[i]",
            "ssh_err(r)"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "argv[i]",
            "&k",
            "&comment"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_krl",
          "args": [
            "identity_file",
            "&krl"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "load_krl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2098-2116",
          "snippet": "static void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\n\nstatic void\ndo_check_krl(struct passwd *pw, int argc, char **argv)\n{\n\tint i, r, ret = 0;\n\tchar *comment;\n\tstruct ssh_krl *krl;\n\tstruct sshkey *k;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL checking requires an input file\");\n\tload_krl(identity_file, &krl);\n\tfor (i = 0; i < argc; i++) {\n\t\tif ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)\n\t\t\tfatal(\"Cannot load public key %s: %s\",\n\t\t\t    argv[i], ssh_err(r));\n\t\tr = ssh_krl_check_key(krl, k);\n\t\tprintf(\"%s%s%s%s: %s\\n\", argv[i],\n\t\t    *comment ? \" (\" : \"\", comment, *comment ? \")\" : \"\",\n\t\t    r == 0 ? \"ok\" : \"REVOKED\");\n\t\tif (r != 0)\n\t\t\tret = 1;\n\t\tsshkey_free(k);\n\t\tfree(comment);\n\t}\n\tssh_krl_free(krl);\n\texit(ret);\n}"
  },
  {
    "function_name": "do_gen_krl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2304-2361",
    "snippet": "static void\ndo_gen_krl(struct passwd *pw, int updating, int argc, char **argv)\n{\n\tstruct ssh_krl *krl;\n\tstruct stat sb;\n\tstruct sshkey *ca = NULL;\n\tint fd, i, r, wild_ca = 0;\n\tchar *tmp;\n\tstruct sshbuf *kbuf;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL generation requires an output file\");\n\tif (stat(identity_file, &sb) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tfatal(\"Cannot access KRL \\\"%s\\\": %s\",\n\t\t\t    identity_file, strerror(errno));\n\t\tif (updating)\n\t\t\tfatal(\"KRL \\\"%s\\\" does not exist\", identity_file);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (strcasecmp(ca_key_path, \"none\") == 0)\n\t\t\twild_ca = 1;\n\t\telse {\n\t\t\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\t\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tif (updating)\n\t\tload_krl(identity_file, &krl);\n\telse if ((krl = ssh_krl_init()) == NULL)\n\t\tfatal(\"couldn't create KRL\");\n\n\tif (cert_serial != 0)\n\t\tssh_krl_set_version(krl, cert_serial);\n\tif (identity_comment != NULL)\n\t\tssh_krl_set_comment(krl, identity_comment);\n\n\tfor (i = 0; i < argc; i++)\n\t\tupdate_krl_from_file(pw, argv[i], wild_ca, ca, krl);\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)\n\t\tfatal(\"Couldn't generate KRL\");\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"open %s: %s\", identity_file, strerror(errno));\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(kbuf), sshbuf_len(kbuf)) !=\n\t    sshbuf_len(kbuf))\n\t\tfatal(\"write %s: %s\", identity_file, strerror(errno));\n\tclose(fd);\n\tsshbuf_free(kbuf);\n\tssh_krl_free(krl);\n\tsshkey_free(ca);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "char *identity_comment = NULL;",
      "char *ca_key_path = NULL;",
      "unsigned long long cert_serial = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "ca"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_free",
          "args": [
            "krl"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "163-192",
          "snippet": "void\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "kbuf"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"write %s: %s\"",
            "identity_file",
            "strerror(errno)"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "kbuf"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fd",
            "sshbuf_mutable_ptr(kbuf)",
            "sshbuf_len(kbuf)"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "kbuf"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "identity_file",
            "O_WRONLY|O_CREAT|O_TRUNC",
            "0644"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_to_blob",
          "args": [
            "krl",
            "kbuf",
            "NULL",
            "0"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "733-827",
          "snippet": "int\nssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf,\n    const struct sshkey **sign_keys, u_int nsign_keys)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct revoked_certs *rc;\n\tstruct revoked_blob *rb;\n\tstruct sshbuf *sect;\n\tu_char *sblob = NULL;\n\tsize_t slen, i;\n\n\tif (krl->generated_date == 0)\n\t\tkrl->generated_date = time(NULL);\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header */\n\tif ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||\n\t    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||\n\t    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)\n\t\tgoto out;\n\n\t/* Store sections for revoked certificates */\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tsshbuf_reset(sect);\n\t\tif ((r = revoked_certs_generate(rc, sect)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Finally, output sections for revocations by public key/hash */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tKRL_DBG((\"%s: key len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA256)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nsign_keys; i++) {\n\t\tKRL_DBG((\"%s: signature key %s\", __func__,\n\t\t    sshkey_ssh_name(sign_keys[i])));\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_SIGNATURE)) != 0 ||\n\t\t    (r = sshkey_puts(sign_keys[i], buf)) != 0)\n\t\t\tgoto out;\n\n\t\tif ((r = sshkey_sign(sign_keys[i], &sblob, &slen,\n\t\t    sshbuf_ptr(buf), sshbuf_len(buf), NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: signature sig len %zu\", __func__, slen));\n\t\tif ((r = sshbuf_put_string(buf, sblob, slen)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tr = 0;\n out:\n\tfree(sblob);\n\tsshbuf_free(sect);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf,\n    const struct sshkey **sign_keys, u_int nsign_keys)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct revoked_certs *rc;\n\tstruct revoked_blob *rb;\n\tstruct sshbuf *sect;\n\tu_char *sblob = NULL;\n\tsize_t slen, i;\n\n\tif (krl->generated_date == 0)\n\t\tkrl->generated_date = time(NULL);\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* Store the header */\n\tif ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||\n\t    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||\n\t    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)\n\t\tgoto out;\n\n\t/* Store sections for revoked certificates */\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tsshbuf_reset(sect);\n\t\tif ((r = revoked_certs_generate(rc, sect)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Finally, output sections for revocations by public key/hash */\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tKRL_DBG((\"%s: key len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tKRL_DBG((\"%s: hash len %zu \", __func__, rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA256)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nsign_keys; i++) {\n\t\tKRL_DBG((\"%s: signature key %s\", __func__,\n\t\t    sshkey_ssh_name(sign_keys[i])));\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_SIGNATURE)) != 0 ||\n\t\t    (r = sshkey_puts(sign_keys[i], buf)) != 0)\n\t\t\tgoto out;\n\n\t\tif ((r = sshkey_sign(sign_keys[i], &sblob, &slen,\n\t\t    sshbuf_ptr(buf), sshbuf_len(buf), NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: signature sig len %zu\", __func__, slen));\n\t\tif ((r = sshbuf_put_string(buf, sblob, slen)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tr = 0;\n out:\n\tfree(sblob);\n\tsshbuf_free(sect);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_krl_from_file",
          "args": [
            "pw",
            "argv[i]",
            "wild_ca",
            "ca",
            "krl"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "update_krl_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2153-2302",
          "snippet": "static void\nupdate_krl_from_file(struct passwd *pw, const char *file, int wild_ca,\n    const struct sshkey *ca, struct ssh_krl *krl)\n{\n\tstruct sshkey *key = NULL;\n\tu_long lnum = 0;\n\tchar *path, *cp, *ep, *line = NULL;\n\tu_char *blob = NULL;\n\tsize_t blen = 0, linesize = 0;\n\tunsigned long long serial, serial2;\n\tint i, was_explicit_key, was_sha1, was_sha256, was_hash, r;\n\tFILE *krl_spec;\n\n\tpath = tilde_expand_filename(file, pw->pw_uid);\n\tif (strcmp(path, \"-\") == 0) {\n\t\tkrl_spec = stdin;\n\t\tfree(path);\n\t\tpath = xstrdup(\"(standard input)\");\n\t} else if ((krl_spec = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", path, strerror(errno));\n\n\tif (!quiet)\n\t\tprintf(\"Revoking from %s\\n\", path);\n\twhile (getline(&line, &linesize, krl_spec) != -1) {\n\t\tlnum++;\n\t\twas_explicit_key = was_sha1 = was_sha256 = was_hash = 0;\n\t\tcp = line + strspn(line, \" \\t\");\n\t\t/* Trim trailing space, comments and strip \\n */\n\t\tfor (i = 0, r = -1; cp[i] != '\\0'; i++) {\n\t\t\tif (cp[i] == '#' || cp[i] == '\\n') {\n\t\t\t\tcp[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp[i] == ' ' || cp[i] == '\\t') {\n\t\t\t\t/* Remember the start of a span of whitespace */\n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i;\n\t\t\t} else\n\t\t\t\tr = -1;\n\t\t}\n\t\tif (r != -1)\n\t\t\tcp[r] = '\\0';\n\t\tif (*cp == '\\0')\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"serial:\", 7) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by serial number \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 7;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\terrno = 0;\n\t\t\tserial = strtoull(cp, &ep, 0);\n\t\t\tif (*cp == '\\0' || (*ep != '\\0' && *ep != '-'))\n\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t    path, lnum, cp);\n\t\t\tif (errno == ERANGE && serial == ULLONG_MAX)\n\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t    path, lnum);\n\t\t\tserial2 = serial;\n\t\t\tif (*ep == '-') {\n\t\t\t\tcp = ep + 1;\n\t\t\t\terrno = 0;\n\t\t\t\tserial2 = strtoull(cp, &ep, 0);\n\t\t\t\tif (*cp == '\\0' || *ep != '\\0')\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t\t    path, lnum, cp);\n\t\t\t\tif (errno == ERANGE && serial2 == ULLONG_MAX)\n\t\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t\t    path, lnum);\n\t\t\t\tif (serial2 <= serial)\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial range \"\n\t\t\t\t\t    \"%llu:%llu\", path, lnum,\n\t\t\t\t\t    (unsigned long long)serial,\n\t\t\t\t\t    (unsigned long long)serial2);\n\t\t\t}\n\t\t\tif (ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca, serial, serial2) != 0) {\n\t\t\t\tfatal(\"%s: revoke serial failed\",\n\t\t\t\t    __func__);\n\t\t\t}\n\t\t} else if (strncasecmp(cp, \"id:\", 3) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by key ID \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 3;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\tif (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)\n\t\t\t\tfatal(\"%s: revoke key ID failed\", __func__);\n\t\t} else if (strncasecmp(cp, \"hash:\", 5) == 0) {\n\t\t\tcp += 5;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\thash_to_blob(cp, &blob, &blen, file, lnum);\n\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t} else {\n\t\t\tif (strncasecmp(cp, \"key:\", 4) == 0) {\n\t\t\t\tcp += 4;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_explicit_key = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha1:\", 5) == 0) {\n\t\t\t\tcp += 5;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha1 = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha256:\", 7) == 0) {\n\t\t\t\tcp += 7;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha256 = 1;\n\t\t\t\t/*\n\t\t\t\t * Just try to process the line as a key.\n\t\t\t\t * Parsing will fail if it isn't.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\t\tfatal(\"sshkey_new\");\n\t\t\tif ((r = sshkey_read(key, &cp)) != 0)\n\t\t\t\tfatal(\"%s:%lu: invalid key: %s\",\n\t\t\t\t    path, lnum, ssh_err(r));\n\t\t\tif (was_explicit_key)\n\t\t\t\tr = ssh_krl_revoke_key_explicit(krl, key);\n\t\t\telse if (was_sha1) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA1, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha1(krl, blob, blen);\n\t\t\t} else if (was_sha256) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA256, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\t} else\n\t\t\t\tr = ssh_krl_revoke_key(krl, key);\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: revoke key failed: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfreezero(blob, blen);\n\t\t\tblob = NULL;\n\t\t\tblen = 0;\n\t\t\tsshkey_free(key);\n\t\t}\n\t}\n\tif (strcmp(path, \"-\") != 0)\n\t\tfclose(krl_spec);\n\tfree(line);\n\tfree(path);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int quiet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\n\nstatic void\nupdate_krl_from_file(struct passwd *pw, const char *file, int wild_ca,\n    const struct sshkey *ca, struct ssh_krl *krl)\n{\n\tstruct sshkey *key = NULL;\n\tu_long lnum = 0;\n\tchar *path, *cp, *ep, *line = NULL;\n\tu_char *blob = NULL;\n\tsize_t blen = 0, linesize = 0;\n\tunsigned long long serial, serial2;\n\tint i, was_explicit_key, was_sha1, was_sha256, was_hash, r;\n\tFILE *krl_spec;\n\n\tpath = tilde_expand_filename(file, pw->pw_uid);\n\tif (strcmp(path, \"-\") == 0) {\n\t\tkrl_spec = stdin;\n\t\tfree(path);\n\t\tpath = xstrdup(\"(standard input)\");\n\t} else if ((krl_spec = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", path, strerror(errno));\n\n\tif (!quiet)\n\t\tprintf(\"Revoking from %s\\n\", path);\n\twhile (getline(&line, &linesize, krl_spec) != -1) {\n\t\tlnum++;\n\t\twas_explicit_key = was_sha1 = was_sha256 = was_hash = 0;\n\t\tcp = line + strspn(line, \" \\t\");\n\t\t/* Trim trailing space, comments and strip \\n */\n\t\tfor (i = 0, r = -1; cp[i] != '\\0'; i++) {\n\t\t\tif (cp[i] == '#' || cp[i] == '\\n') {\n\t\t\t\tcp[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp[i] == ' ' || cp[i] == '\\t') {\n\t\t\t\t/* Remember the start of a span of whitespace */\n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i;\n\t\t\t} else\n\t\t\t\tr = -1;\n\t\t}\n\t\tif (r != -1)\n\t\t\tcp[r] = '\\0';\n\t\tif (*cp == '\\0')\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"serial:\", 7) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by serial number \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 7;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\terrno = 0;\n\t\t\tserial = strtoull(cp, &ep, 0);\n\t\t\tif (*cp == '\\0' || (*ep != '\\0' && *ep != '-'))\n\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t    path, lnum, cp);\n\t\t\tif (errno == ERANGE && serial == ULLONG_MAX)\n\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t    path, lnum);\n\t\t\tserial2 = serial;\n\t\t\tif (*ep == '-') {\n\t\t\t\tcp = ep + 1;\n\t\t\t\terrno = 0;\n\t\t\t\tserial2 = strtoull(cp, &ep, 0);\n\t\t\t\tif (*cp == '\\0' || *ep != '\\0')\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t\t    path, lnum, cp);\n\t\t\t\tif (errno == ERANGE && serial2 == ULLONG_MAX)\n\t\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t\t    path, lnum);\n\t\t\t\tif (serial2 <= serial)\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial range \"\n\t\t\t\t\t    \"%llu:%llu\", path, lnum,\n\t\t\t\t\t    (unsigned long long)serial,\n\t\t\t\t\t    (unsigned long long)serial2);\n\t\t\t}\n\t\t\tif (ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca, serial, serial2) != 0) {\n\t\t\t\tfatal(\"%s: revoke serial failed\",\n\t\t\t\t    __func__);\n\t\t\t}\n\t\t} else if (strncasecmp(cp, \"id:\", 3) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by key ID \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 3;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\tif (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)\n\t\t\t\tfatal(\"%s: revoke key ID failed\", __func__);\n\t\t} else if (strncasecmp(cp, \"hash:\", 5) == 0) {\n\t\t\tcp += 5;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\thash_to_blob(cp, &blob, &blen, file, lnum);\n\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t} else {\n\t\t\tif (strncasecmp(cp, \"key:\", 4) == 0) {\n\t\t\t\tcp += 4;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_explicit_key = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha1:\", 5) == 0) {\n\t\t\t\tcp += 5;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha1 = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha256:\", 7) == 0) {\n\t\t\t\tcp += 7;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha256 = 1;\n\t\t\t\t/*\n\t\t\t\t * Just try to process the line as a key.\n\t\t\t\t * Parsing will fail if it isn't.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\t\tfatal(\"sshkey_new\");\n\t\t\tif ((r = sshkey_read(key, &cp)) != 0)\n\t\t\t\tfatal(\"%s:%lu: invalid key: %s\",\n\t\t\t\t    path, lnum, ssh_err(r));\n\t\t\tif (was_explicit_key)\n\t\t\t\tr = ssh_krl_revoke_key_explicit(krl, key);\n\t\t\telse if (was_sha1) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA1, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha1(krl, blob, blen);\n\t\t\t} else if (was_sha256) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA256, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\t} else\n\t\t\t\tr = ssh_krl_revoke_key(krl, key);\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: revoke key failed: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfreezero(blob, blen);\n\t\t\tblob = NULL;\n\t\t\tblen = 0;\n\t\t\tsshkey_free(key);\n\t\t}\n\t}\n\tif (strcmp(path, \"-\") != 0)\n\t\tfclose(krl_spec);\n\tfree(line);\n\tfree(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_set_comment",
          "args": [
            "krl",
            "identity_comment"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_set_comment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "200-207",
          "snippet": "int\nssh_krl_set_comment(struct ssh_krl *krl, const char *comment)\n{\n\tfree(krl->comment);\n\tif ((krl->comment = strdup(comment)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_set_comment(struct ssh_krl *krl, const char *comment)\n{\n\tfree(krl->comment);\n\tif ((krl->comment = strdup(comment)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_set_version",
          "args": [
            "krl",
            "cert_serial"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "194-198",
          "snippet": "void\nssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)\n{\n\tkrl->krl_version = version;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)\n{\n\tkrl->krl_version = version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_init",
          "args": [],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "131-143",
          "snippet": "struct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_krl",
          "args": [
            "identity_file",
            "&krl"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "load_krl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2098-2116",
          "snippet": "static void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "tmp",
            "&ca",
            "NULL"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "ca_key_path",
            "pw->pw_uid"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ca_key_path",
            "\"none\""
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"KRL \\\"%s\\\" does not exist\"",
            "identity_file"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&sb"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nchar *identity_comment = NULL;\nchar *ca_key_path = NULL;\nunsigned long long cert_serial = 0;\n\nstatic void\ndo_gen_krl(struct passwd *pw, int updating, int argc, char **argv)\n{\n\tstruct ssh_krl *krl;\n\tstruct stat sb;\n\tstruct sshkey *ca = NULL;\n\tint fd, i, r, wild_ca = 0;\n\tchar *tmp;\n\tstruct sshbuf *kbuf;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL generation requires an output file\");\n\tif (stat(identity_file, &sb) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tfatal(\"Cannot access KRL \\\"%s\\\": %s\",\n\t\t\t    identity_file, strerror(errno));\n\t\tif (updating)\n\t\t\tfatal(\"KRL \\\"%s\\\" does not exist\", identity_file);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (strcasecmp(ca_key_path, \"none\") == 0)\n\t\t\twild_ca = 1;\n\t\telse {\n\t\t\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\t\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tif (updating)\n\t\tload_krl(identity_file, &krl);\n\telse if ((krl = ssh_krl_init()) == NULL)\n\t\tfatal(\"couldn't create KRL\");\n\n\tif (cert_serial != 0)\n\t\tssh_krl_set_version(krl, cert_serial);\n\tif (identity_comment != NULL)\n\t\tssh_krl_set_comment(krl, identity_comment);\n\n\tfor (i = 0; i < argc; i++)\n\t\tupdate_krl_from_file(pw, argv[i], wild_ca, ca, krl);\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)\n\t\tfatal(\"Couldn't generate KRL\");\n\tif ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\tfatal(\"open %s: %s\", identity_file, strerror(errno));\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(kbuf), sshbuf_len(kbuf)) !=\n\t    sshbuf_len(kbuf))\n\t\tfatal(\"write %s: %s\", identity_file, strerror(errno));\n\tclose(fd);\n\tsshbuf_free(kbuf);\n\tssh_krl_free(krl);\n\tsshkey_free(ca);\n}"
  },
  {
    "function_name": "update_krl_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2153-2302",
    "snippet": "static void\nupdate_krl_from_file(struct passwd *pw, const char *file, int wild_ca,\n    const struct sshkey *ca, struct ssh_krl *krl)\n{\n\tstruct sshkey *key = NULL;\n\tu_long lnum = 0;\n\tchar *path, *cp, *ep, *line = NULL;\n\tu_char *blob = NULL;\n\tsize_t blen = 0, linesize = 0;\n\tunsigned long long serial, serial2;\n\tint i, was_explicit_key, was_sha1, was_sha256, was_hash, r;\n\tFILE *krl_spec;\n\n\tpath = tilde_expand_filename(file, pw->pw_uid);\n\tif (strcmp(path, \"-\") == 0) {\n\t\tkrl_spec = stdin;\n\t\tfree(path);\n\t\tpath = xstrdup(\"(standard input)\");\n\t} else if ((krl_spec = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", path, strerror(errno));\n\n\tif (!quiet)\n\t\tprintf(\"Revoking from %s\\n\", path);\n\twhile (getline(&line, &linesize, krl_spec) != -1) {\n\t\tlnum++;\n\t\twas_explicit_key = was_sha1 = was_sha256 = was_hash = 0;\n\t\tcp = line + strspn(line, \" \\t\");\n\t\t/* Trim trailing space, comments and strip \\n */\n\t\tfor (i = 0, r = -1; cp[i] != '\\0'; i++) {\n\t\t\tif (cp[i] == '#' || cp[i] == '\\n') {\n\t\t\t\tcp[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp[i] == ' ' || cp[i] == '\\t') {\n\t\t\t\t/* Remember the start of a span of whitespace */\n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i;\n\t\t\t} else\n\t\t\t\tr = -1;\n\t\t}\n\t\tif (r != -1)\n\t\t\tcp[r] = '\\0';\n\t\tif (*cp == '\\0')\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"serial:\", 7) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by serial number \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 7;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\terrno = 0;\n\t\t\tserial = strtoull(cp, &ep, 0);\n\t\t\tif (*cp == '\\0' || (*ep != '\\0' && *ep != '-'))\n\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t    path, lnum, cp);\n\t\t\tif (errno == ERANGE && serial == ULLONG_MAX)\n\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t    path, lnum);\n\t\t\tserial2 = serial;\n\t\t\tif (*ep == '-') {\n\t\t\t\tcp = ep + 1;\n\t\t\t\terrno = 0;\n\t\t\t\tserial2 = strtoull(cp, &ep, 0);\n\t\t\t\tif (*cp == '\\0' || *ep != '\\0')\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t\t    path, lnum, cp);\n\t\t\t\tif (errno == ERANGE && serial2 == ULLONG_MAX)\n\t\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t\t    path, lnum);\n\t\t\t\tif (serial2 <= serial)\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial range \"\n\t\t\t\t\t    \"%llu:%llu\", path, lnum,\n\t\t\t\t\t    (unsigned long long)serial,\n\t\t\t\t\t    (unsigned long long)serial2);\n\t\t\t}\n\t\t\tif (ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca, serial, serial2) != 0) {\n\t\t\t\tfatal(\"%s: revoke serial failed\",\n\t\t\t\t    __func__);\n\t\t\t}\n\t\t} else if (strncasecmp(cp, \"id:\", 3) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by key ID \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 3;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\tif (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)\n\t\t\t\tfatal(\"%s: revoke key ID failed\", __func__);\n\t\t} else if (strncasecmp(cp, \"hash:\", 5) == 0) {\n\t\t\tcp += 5;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\thash_to_blob(cp, &blob, &blen, file, lnum);\n\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t} else {\n\t\t\tif (strncasecmp(cp, \"key:\", 4) == 0) {\n\t\t\t\tcp += 4;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_explicit_key = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha1:\", 5) == 0) {\n\t\t\t\tcp += 5;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha1 = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha256:\", 7) == 0) {\n\t\t\t\tcp += 7;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha256 = 1;\n\t\t\t\t/*\n\t\t\t\t * Just try to process the line as a key.\n\t\t\t\t * Parsing will fail if it isn't.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\t\tfatal(\"sshkey_new\");\n\t\t\tif ((r = sshkey_read(key, &cp)) != 0)\n\t\t\t\tfatal(\"%s:%lu: invalid key: %s\",\n\t\t\t\t    path, lnum, ssh_err(r));\n\t\t\tif (was_explicit_key)\n\t\t\t\tr = ssh_krl_revoke_key_explicit(krl, key);\n\t\t\telse if (was_sha1) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA1, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha1(krl, blob, blen);\n\t\t\t} else if (was_sha256) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA256, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\t} else\n\t\t\t\tr = ssh_krl_revoke_key(krl, key);\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: revoke key failed: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfreezero(blob, blen);\n\t\t\tblob = NULL;\n\t\t\tblen = 0;\n\t\t\tsshkey_free(key);\n\t\t}\n\t}\n\tif (strcmp(path, \"-\") != 0)\n\t\tfclose(krl_spec);\n\tfree(line);\n\tfree(path);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int quiet = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "krl_spec"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "\"-\""
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "blob",
            "blen"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: revoke key failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_key",
          "args": [
            "krl",
            "key"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "453-469",
          "snippet": "int\nssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\t/* XXX replace with SHA256? */\n\tif (!sshkey_is_cert(key))\n\t\treturn ssh_krl_revoke_key_explicit(krl, key);\n\n\tif (key->cert->serial == 0) {\n\t\treturn ssh_krl_revoke_cert_by_key_id(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->key_id);\n\t} else {\n\t\treturn ssh_krl_revoke_cert_by_serial(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->serial);\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\t/* XXX replace with SHA256? */\n\tif (!sshkey_is_cert(key))\n\t\treturn ssh_krl_revoke_key_explicit(krl, key);\n\n\tif (key->cert->serial == 0) {\n\t\treturn ssh_krl_revoke_cert_by_key_id(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->key_id);\n\t} else {\n\t\treturn ssh_krl_revoke_cert_by_serial(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->serial);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_key_sha256",
          "args": [
            "krl",
            "blob",
            "blen"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_key_sha256",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "444-451",
          "snippet": "int\nssh_krl_revoke_key_sha256(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha256\", __func__);\n\tif (len != 32)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha256s, p, len);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_sha256(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha256\", __func__);\n\tif (len != 32)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha256s, p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint_raw",
          "args": [
            "key",
            "SSH_DIGEST_SHA256",
            "&blob",
            "&blen"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "892-933",
          "snippet": "int\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_key_sha1",
          "args": [
            "krl",
            "blob",
            "blen"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_key_sha1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "435-442",
          "snippet": "int\nssh_krl_revoke_key_sha1(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha1\", __func__);\n\tif (len != 20)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha1s, p, len);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_sha1(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3(\"%s: revoke by sha1\", __func__);\n\tif (len != 20)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha1s, p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_key_explicit",
          "args": [
            "krl",
            "key"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_key_explicit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "405-416",
          "snippet": "int\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: revoke type %s\", __func__, sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_read",
          "args": [
            "key",
            "&cp"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1219-1379",
          "snippet": "int\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"sha256:\"",
            "7"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"sha1:\"",
            "5"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"key:\"",
            "4"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_to_blob",
          "args": [
            "cp",
            "&blob",
            "&blen",
            "file",
            "lnum"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "hash_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "2118-2151",
          "snippet": "static void\nhash_to_blob(const char *cp, u_char **blobp, size_t *lenp,\n    const char *file, u_long lnum)\n{\n\tchar *tmp;\n\tsize_t tlen;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif (strncmp(cp, \"SHA256:\", 7) != 0)\n\t\tfatal(\"%s:%lu: unsupported hash algorithm\", file, lnum);\n\tcp += 7;\n\n\t/*\n\t * OpenSSH base64 hashes omit trailing '='\n\t * characters; put them back for decode.\n\t */\n\ttlen = strlen(cp);\n\ttmp = xmalloc(tlen + 4 + 1);\n\tstrlcpy(tmp, cp, tlen + 1);\n\twhile ((tlen % 4) != 0) {\n\t\ttmp[tlen++] = '=';\n\t\ttmp[tlen] = '\\0';\n\t}\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_b64tod(b, tmp)) != 0)\n\t\tfatal(\"%s:%lu: decode hash failed: %s\", file, lnum, ssh_err(r));\n\tfree(tmp);\n\t*lenp = sshbuf_len(b);\n\t*blobp = xmalloc(*lenp);\n\tmemcpy(*blobp, sshbuf_ptr(b), *lenp);\n\tsshbuf_free(b);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhash_to_blob(const char *cp, u_char **blobp, size_t *lenp,\n    const char *file, u_long lnum)\n{\n\tchar *tmp;\n\tsize_t tlen;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif (strncmp(cp, \"SHA256:\", 7) != 0)\n\t\tfatal(\"%s:%lu: unsupported hash algorithm\", file, lnum);\n\tcp += 7;\n\n\t/*\n\t * OpenSSH base64 hashes omit trailing '='\n\t * characters; put them back for decode.\n\t */\n\ttlen = strlen(cp);\n\ttmp = xmalloc(tlen + 4 + 1);\n\tstrlcpy(tmp, cp, tlen + 1);\n\twhile ((tlen % 4) != 0) {\n\t\ttmp[tlen++] = '=';\n\t\ttmp[tlen] = '\\0';\n\t}\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_b64tod(b, tmp)) != 0)\n\t\tfatal(\"%s:%lu: decode hash failed: %s\", file, lnum, ssh_err(r));\n\tfree(tmp);\n\t*lenp = sshbuf_len(b);\n\t*blobp = xmalloc(*lenp);\n\tmemcpy(*blobp, sshbuf_ptr(b), *lenp);\n\tsshbuf_free(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"hash:\"",
            "5"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: revoke key ID failed\"",
            "__func__"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_key_id",
          "args": [
            "krl",
            "ca",
            "cp"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_key_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "342-365",
          "snippet": "int\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"%s: revoke %s\", __func__, key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"id:\"",
            "3"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_krl_revoke_cert_by_serial_range",
          "args": [
            "krl",
            "ca",
            "serial",
            "serial2"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_revoke_cert_by_serial_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "328-340",
          "snippet": "int\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "cp",
            "&ep",
            "0"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "strtoull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoull.c",
          "lines": "49-109",
          "snippet": "unsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nunsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cp",
            "\" \\t\""
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "cp",
            "\"serial:\"",
            "7"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "line",
            "\" \\t\""
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "krl_spec"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Revoking from %s\\n\"",
            "path"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"(standard input)\""
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "file",
            "pw->pw_uid"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\n\nstatic void\nupdate_krl_from_file(struct passwd *pw, const char *file, int wild_ca,\n    const struct sshkey *ca, struct ssh_krl *krl)\n{\n\tstruct sshkey *key = NULL;\n\tu_long lnum = 0;\n\tchar *path, *cp, *ep, *line = NULL;\n\tu_char *blob = NULL;\n\tsize_t blen = 0, linesize = 0;\n\tunsigned long long serial, serial2;\n\tint i, was_explicit_key, was_sha1, was_sha256, was_hash, r;\n\tFILE *krl_spec;\n\n\tpath = tilde_expand_filename(file, pw->pw_uid);\n\tif (strcmp(path, \"-\") == 0) {\n\t\tkrl_spec = stdin;\n\t\tfree(path);\n\t\tpath = xstrdup(\"(standard input)\");\n\t} else if ((krl_spec = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", path, strerror(errno));\n\n\tif (!quiet)\n\t\tprintf(\"Revoking from %s\\n\", path);\n\twhile (getline(&line, &linesize, krl_spec) != -1) {\n\t\tlnum++;\n\t\twas_explicit_key = was_sha1 = was_sha256 = was_hash = 0;\n\t\tcp = line + strspn(line, \" \\t\");\n\t\t/* Trim trailing space, comments and strip \\n */\n\t\tfor (i = 0, r = -1; cp[i] != '\\0'; i++) {\n\t\t\tif (cp[i] == '#' || cp[i] == '\\n') {\n\t\t\t\tcp[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp[i] == ' ' || cp[i] == '\\t') {\n\t\t\t\t/* Remember the start of a span of whitespace */\n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i;\n\t\t\t} else\n\t\t\t\tr = -1;\n\t\t}\n\t\tif (r != -1)\n\t\t\tcp[r] = '\\0';\n\t\tif (*cp == '\\0')\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"serial:\", 7) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by serial number \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 7;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\terrno = 0;\n\t\t\tserial = strtoull(cp, &ep, 0);\n\t\t\tif (*cp == '\\0' || (*ep != '\\0' && *ep != '-'))\n\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t    path, lnum, cp);\n\t\t\tif (errno == ERANGE && serial == ULLONG_MAX)\n\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t    path, lnum);\n\t\t\tserial2 = serial;\n\t\t\tif (*ep == '-') {\n\t\t\t\tcp = ep + 1;\n\t\t\t\terrno = 0;\n\t\t\t\tserial2 = strtoull(cp, &ep, 0);\n\t\t\t\tif (*cp == '\\0' || *ep != '\\0')\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t\t    path, lnum, cp);\n\t\t\t\tif (errno == ERANGE && serial2 == ULLONG_MAX)\n\t\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t\t    path, lnum);\n\t\t\t\tif (serial2 <= serial)\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial range \"\n\t\t\t\t\t    \"%llu:%llu\", path, lnum,\n\t\t\t\t\t    (unsigned long long)serial,\n\t\t\t\t\t    (unsigned long long)serial2);\n\t\t\t}\n\t\t\tif (ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca, serial, serial2) != 0) {\n\t\t\t\tfatal(\"%s: revoke serial failed\",\n\t\t\t\t    __func__);\n\t\t\t}\n\t\t} else if (strncasecmp(cp, \"id:\", 3) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by key ID \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 3;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\tif (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)\n\t\t\t\tfatal(\"%s: revoke key ID failed\", __func__);\n\t\t} else if (strncasecmp(cp, \"hash:\", 5) == 0) {\n\t\t\tcp += 5;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\thash_to_blob(cp, &blob, &blen, file, lnum);\n\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t} else {\n\t\t\tif (strncasecmp(cp, \"key:\", 4) == 0) {\n\t\t\t\tcp += 4;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_explicit_key = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha1:\", 5) == 0) {\n\t\t\t\tcp += 5;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha1 = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha256:\", 7) == 0) {\n\t\t\t\tcp += 7;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha256 = 1;\n\t\t\t\t/*\n\t\t\t\t * Just try to process the line as a key.\n\t\t\t\t * Parsing will fail if it isn't.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\t\tfatal(\"sshkey_new\");\n\t\t\tif ((r = sshkey_read(key, &cp)) != 0)\n\t\t\t\tfatal(\"%s:%lu: invalid key: %s\",\n\t\t\t\t    path, lnum, ssh_err(r));\n\t\t\tif (was_explicit_key)\n\t\t\t\tr = ssh_krl_revoke_key_explicit(krl, key);\n\t\t\telse if (was_sha1) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA1, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha1(krl, blob, blen);\n\t\t\t} else if (was_sha256) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA256, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\t} else\n\t\t\t\tr = ssh_krl_revoke_key(krl, key);\n\t\t\tif (r != 0)\n\t\t\t\tfatal(\"%s: revoke key failed: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfreezero(blob, blen);\n\t\t\tblob = NULL;\n\t\t\tblen = 0;\n\t\t\tsshkey_free(key);\n\t\t}\n\t}\n\tif (strcmp(path, \"-\") != 0)\n\t\tfclose(krl_spec);\n\tfree(line);\n\tfree(path);\n}"
  },
  {
    "function_name": "hash_to_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2118-2151",
    "snippet": "static void\nhash_to_blob(const char *cp, u_char **blobp, size_t *lenp,\n    const char *file, u_long lnum)\n{\n\tchar *tmp;\n\tsize_t tlen;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif (strncmp(cp, \"SHA256:\", 7) != 0)\n\t\tfatal(\"%s:%lu: unsupported hash algorithm\", file, lnum);\n\tcp += 7;\n\n\t/*\n\t * OpenSSH base64 hashes omit trailing '='\n\t * characters; put them back for decode.\n\t */\n\ttlen = strlen(cp);\n\ttmp = xmalloc(tlen + 4 + 1);\n\tstrlcpy(tmp, cp, tlen + 1);\n\twhile ((tlen % 4) != 0) {\n\t\ttmp[tlen++] = '=';\n\t\ttmp[tlen] = '\\0';\n\t}\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_b64tod(b, tmp)) != 0)\n\t\tfatal(\"%s:%lu: decode hash failed: %s\", file, lnum, ssh_err(r));\n\tfree(tmp);\n\t*lenp = sshbuf_len(b);\n\t*blobp = xmalloc(*lenp);\n\tmemcpy(*blobp, sshbuf_ptr(b), *lenp);\n\tsshbuf_free(b);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*blobp",
            "sshbuf_ptr(b)",
            "*lenp"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "*lenp"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s:%lu: decode hash failed: %s\"",
            "file",
            "lnum",
            "ssh_err(r)"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_b64tod",
          "args": [
            "b",
            "tmp"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_b64tod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "113-137",
          "snippet": "int\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\texplicit_bzero(p, plen);\n\t\tfree(p);\n\t\treturn r;\n\t}\n\texplicit_bzero(p, plen);\n\tfree(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "tmp",
            "cp",
            "tlen + 1"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "\"SHA256:\"",
            "7"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhash_to_blob(const char *cp, u_char **blobp, size_t *lenp,\n    const char *file, u_long lnum)\n{\n\tchar *tmp;\n\tsize_t tlen;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif (strncmp(cp, \"SHA256:\", 7) != 0)\n\t\tfatal(\"%s:%lu: unsupported hash algorithm\", file, lnum);\n\tcp += 7;\n\n\t/*\n\t * OpenSSH base64 hashes omit trailing '='\n\t * characters; put them back for decode.\n\t */\n\ttlen = strlen(cp);\n\ttmp = xmalloc(tlen + 4 + 1);\n\tstrlcpy(tmp, cp, tlen + 1);\n\twhile ((tlen % 4) != 0) {\n\t\ttmp[tlen++] = '=';\n\t\ttmp[tlen] = '\\0';\n\t}\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_b64tod(b, tmp)) != 0)\n\t\tfatal(\"%s:%lu: decode hash failed: %s\", file, lnum, ssh_err(r));\n\tfree(tmp);\n\t*lenp = sshbuf_len(b);\n\t*blobp = xmalloc(*lenp);\n\tmemcpy(*blobp, sshbuf_ptr(b), *lenp);\n\tsshbuf_free(b);\n}"
  },
  {
    "function_name": "load_krl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2098-2116",
    "snippet": "static void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "krlbuf"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid KRL file: %s\"",
            "ssh_err(r)"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_krl_from_blob",
          "args": [
            "krlbuf",
            "krlp",
            "NULL",
            "0"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krl_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/krl.c",
          "lines": "983-1216",
          "snippet": "int\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"bitmap.h\"",
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <openbsd-compat/sys-queue.h>",
            "#include <openbsd-compat/sys-tree.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"bitmap.h\"\n#include \"digest.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <openbsd-compat/sys-queue.h>\n#include <openbsd-compat/sys-tree.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,\n    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR, sig_seen;\n\tstruct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t i, j, sig_off, sects_off, blen, nca_used;\n\tu_int format_version;\n\n\tnca_used = 0;\n\t*krlp = NULL;\n\tif (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||\n\t    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {\n\t\tdebug3(\"%s: not a KRL\", __func__);\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\t/* Take a copy of the KRL buffer so we can verify its signature later */\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)\n\t\tgoto out;\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)\n\t\tgoto out;\n\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t/*\n\t * 1st pass: verify signatures, if any. This is done to avoid\n\t * detailed parsing of data whose provenance is unverified.\n\t */\n\tsig_seen = 0;\n\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tsects_off = sshbuf_len(buf) - sshbuf_len(copy);\n\twhile (sshbuf_len(copy) > 0) {\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: first pass, section 0x%02x\", __func__, type));\n\t\tif (type != KRL_SECTION_SIGNATURE) {\n\t\t\tif (sig_seen) {\n\t\t\t\terror(\"KRL contains non-signature section \"\n\t\t\t\t    \"after signature\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Not interested for now. */\n\t\t\tcontinue;\n\t\t}\n\t\tsig_seen = 1;\n\t\t/* First string component is the signing key */\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(buf) < sshbuf_len(copy)) {\n\t\t\t/* Shouldn't happen */\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tsig_off = sshbuf_len(buf) - sshbuf_len(copy);\n\t\t/* Second string component is the signature itself */\n\t\tif ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Check signature over entire KRL up to this point */\n\t\tif ((r = sshkey_verify(key, blob, blen,\n\t\t    sshbuf_ptr(buf), sig_off, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t\t/* Check if this key has already signed this KRL */\n\t\tfor (i = 0; i < nca_used; i++) {\n\t\t\tif (sshkey_equal(ca_used[i], key)) {\n\t\t\t\terror(\"KRL signed more than once with \"\n\t\t\t\t    \"the same key\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Record keys used to sign the KRL */\n\t\ttmp_ca_used = recallocarray(ca_used, nca_used, nca_used + 1,\n\t\t    sizeof(*ca_used));\n\t\tif (tmp_ca_used == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tca_used = tmp_ca_used;\n\t\tca_used[nca_used++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (sshbuf_len(copy) != 0) {\n\t\t/* Shouldn't happen */\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2nd pass: parse and load the KRL, skipping the header to the point\n\t * where the section start.\n\t */\n\tsshbuf_free(copy);\n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sects_off)) != 0)\n\t\tgoto out;\n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"%s: second pass, section 0x%02x\", __func__, type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t/* Handled above, but still need to stay in synch */\n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check that the key(s) used to sign the KRL weren't revoked */\n\tsig_seen = 0;\n\tfor (i = 0; i < nca_used; i++) {\n\t\tif (ssh_krl_check_key(krl, ca_used[i]) == 0)\n\t\t\tsig_seen = 1;\n\t\telse {\n\t\t\tsshkey_free(ca_used[i]);\n\t\t\tca_used[i] = NULL;\n\t\t}\n\t}\n\tif (nca_used && !sig_seen) {\n\t\terror(\"All keys used to sign KRL were revoked\");\n\t\tr = SSH_ERR_KEY_REVOKED;\n\t\tgoto out;\n\t}\n\n\t/* If we have CA keys, then verify that one was used to sign the KRL */\n\tif (sig_seen && nsign_ca_keys != 0) {\n\t\tsig_seen = 0;\n\t\tfor (i = 0; !sig_seen && i < nsign_ca_keys; i++) {\n\t\t\tfor (j = 0; j < nca_used; j++) {\n\t\t\t\tif (ca_used[j] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sshkey_equal(ca_used[j], sign_ca_keys[i])) {\n\t\t\t\t\tsig_seen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!sig_seen) {\n\t\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\t\terror(\"KRL not signed with any trusted key\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tfor (i = 0; i < nca_used; i++)\n\t\tsshkey_free(ca_used[i]);\n\tfree(ca_used);\n\tsshkey_free(key);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_file",
          "args": [
            "fd",
            "krlbuf"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "96-135",
          "snippet": "int\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_FILE_SIZE\t(1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\nint\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"open %s: %s\"",
            "path",
            "strerror(errno)"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r, fd;\n\n\tif ((krlbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tfatal(\"open %s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_file(fd, krlbuf)) != 0)\n\t\tfatal(\"Unable to load KRL: %s\", ssh_err(r));\n\tclose(fd);\n\t/* XXX check sigs */\n\tif ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal(\"Invalid KRL file: %s\", ssh_err(r));\n\tsshbuf_free(krlbuf);\n}"
  },
  {
    "function_name": "do_show_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "2041-2096",
    "snippet": "static void\ndo_show_cert(struct passwd *pw)\n{\n\tstruct sshkey *key = NULL;\n\tstruct stat st;\n\tint r, is_stdin = 0, ok = 0;\n\tFILE *f;\n\tchar *cp, *line = NULL;\n\tconst char *path;\n\tsize_t linesize = 0;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (strcmp(identity_file, \"-\") != 0 && stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tpath = identity_file;\n\tif (strcmp(path, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t\tis_stdin = 1;\n\t} else if ((f = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", identity_file, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror(\"%s:%lu: invalid key: %s\", path,\n\t\t\t    lnum, ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"%s:%lu is not a certificate\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tok = 1;\n\t\tif (!is_stdin && lnum == 1)\n\t\t\tprintf(\"%s:\\n\", path);\n\t\telse\n\t\t\tprintf(\"%s:%lu:\\n\", path, lnum);\n\t\tprint_cert(key);\n\t}\n\tfree(line);\n\tsshkey_free(key);\n\tfclose(f);\n\texit(ok ? 0 : 1);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ok ? 0 : 1"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cert",
          "args": [
            "key"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "print_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1994-2039",
          "snippet": "static void\nprint_cert(struct sshkey *key)\n{\n\tchar valid[64], *key_fp, *ca_fp;\n\tu_int i;\n\n\tkey_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);\n\tca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    fingerprint_hash, SSH_FP_DEFAULT);\n\tif (key_fp == NULL || ca_fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\tsshkey_format_cert_validity(key->cert, valid, sizeof(valid));\n\n\tprintf(\"        Type: %s %s certificate\\n\", sshkey_ssh_name(key),\n\t    sshkey_cert_type(key));\n\tprintf(\"        Public key: %s %s\\n\", sshkey_type(key), key_fp);\n\tprintf(\"        Signing CA: %s %s (using %s)\\n\",\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    key->cert->signature_type);\n\tprintf(\"        Key ID: \\\"%s\\\"\\n\", key->cert->key_id);\n\tprintf(\"        Serial: %llu\\n\", (unsigned long long)key->cert->serial);\n\tprintf(\"        Valid: %s\\n\", valid);\n\tprintf(\"        Principals: \");\n\tif (key->cert->nprincipals == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tfor (i = 0; i < key->cert->nprincipals; i++)\n\t\t\tprintf(\"\\n                %s\",\n\t\t\t    key->cert->principals[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"        Critical Options: \");\n\tif (sshbuf_len(key->cert->critical) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->critical, 1);\n\t}\n\tprintf(\"        Extensions: \");\n\tif (sshbuf_len(key->cert->extensions) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->extensions, 0);\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nprint_cert(struct sshkey *key)\n{\n\tchar valid[64], *key_fp, *ca_fp;\n\tu_int i;\n\n\tkey_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);\n\tca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    fingerprint_hash, SSH_FP_DEFAULT);\n\tif (key_fp == NULL || ca_fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\tsshkey_format_cert_validity(key->cert, valid, sizeof(valid));\n\n\tprintf(\"        Type: %s %s certificate\\n\", sshkey_ssh_name(key),\n\t    sshkey_cert_type(key));\n\tprintf(\"        Public key: %s %s\\n\", sshkey_type(key), key_fp);\n\tprintf(\"        Signing CA: %s %s (using %s)\\n\",\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    key->cert->signature_type);\n\tprintf(\"        Key ID: \\\"%s\\\"\\n\", key->cert->key_id);\n\tprintf(\"        Serial: %llu\\n\", (unsigned long long)key->cert->serial);\n\tprintf(\"        Valid: %s\\n\", valid);\n\tprintf(\"        Principals: \");\n\tif (key->cert->nprincipals == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tfor (i = 0; i < key->cert->nprincipals; i++)\n\t\t\tprintf(\"\\n                %s\",\n\t\t\t    key->cert->principals[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"        Critical Options: \");\n\tif (sshbuf_len(key->cert->critical) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->critical, 1);\n\t}\n\tprintf(\"        Extensions: \");\n\tif (sshbuf_len(key->cert->extensions) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->extensions, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%lu:\\n\"",
            "path",
            "lnum"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s:%lu is not a certificate\"",
            "path",
            "lnum"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_read",
          "args": [
            "key",
            "&cp"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1219-1379",
          "snippet": "int\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_new\""
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "line",
            "\" \\t\""
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "identity_file",
            "\"r\""
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "\"-\""
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nextern char *__progname;\n\nstatic void\ndo_show_cert(struct passwd *pw)\n{\n\tstruct sshkey *key = NULL;\n\tstruct stat st;\n\tint r, is_stdin = 0, ok = 0;\n\tFILE *f;\n\tchar *cp, *line = NULL;\n\tconst char *path;\n\tsize_t linesize = 0;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (strcmp(identity_file, \"-\") != 0 && stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tpath = identity_file;\n\tif (strcmp(path, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t\tis_stdin = 1;\n\t} else if ((f = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", identity_file, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror(\"%s:%lu: invalid key: %s\", path,\n\t\t\t    lnum, ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"%s:%lu is not a certificate\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tok = 1;\n\t\tif (!is_stdin && lnum == 1)\n\t\t\tprintf(\"%s:\\n\", path);\n\t\telse\n\t\t\tprintf(\"%s:%lu:\\n\", path, lnum);\n\t\tprint_cert(key);\n\t}\n\tfree(line);\n\tsshkey_free(key);\n\tfclose(f);\n\texit(ok ? 0 : 1);\n}"
  },
  {
    "function_name": "print_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1994-2039",
    "snippet": "static void\nprint_cert(struct sshkey *key)\n{\n\tchar valid[64], *key_fp, *ca_fp;\n\tu_int i;\n\n\tkey_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);\n\tca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    fingerprint_hash, SSH_FP_DEFAULT);\n\tif (key_fp == NULL || ca_fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\tsshkey_format_cert_validity(key->cert, valid, sizeof(valid));\n\n\tprintf(\"        Type: %s %s certificate\\n\", sshkey_ssh_name(key),\n\t    sshkey_cert_type(key));\n\tprintf(\"        Public key: %s %s\\n\", sshkey_type(key), key_fp);\n\tprintf(\"        Signing CA: %s %s (using %s)\\n\",\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    key->cert->signature_type);\n\tprintf(\"        Key ID: \\\"%s\\\"\\n\", key->cert->key_id);\n\tprintf(\"        Serial: %llu\\n\", (unsigned long long)key->cert->serial);\n\tprintf(\"        Valid: %s\\n\", valid);\n\tprintf(\"        Principals: \");\n\tif (key->cert->nprincipals == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tfor (i = 0; i < key->cert->nprincipals; i++)\n\t\t\tprintf(\"\\n                %s\",\n\t\t\t    key->cert->principals[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"        Critical Options: \");\n\tif (sshbuf_len(key->cert->critical) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->critical, 1);\n\t}\n\tprintf(\"        Extensions: \");\n\tif (sshbuf_len(key->cert->extensions) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->extensions, 0);\n\t}\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_options",
          "args": [
            "key->cert->extensions",
            "0"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "show_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1950-1992",
          "snippet": "static void\nshow_options(struct sshbuf *optbuf, int in_critical)\n{\n\tchar *name, *arg;\n\tstruct sshbuf *options, *option = NULL;\n\tint r;\n\n\tif ((options = sshbuf_fromb(optbuf)) == NULL)\n\t\tfatal(\"%s: sshbuf_fromb failed\", __func__);\n\twhile (sshbuf_len(options) != 0) {\n\t\tsshbuf_free(option);\n\t\toption = NULL;\n\t\tif ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(options, &option)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tprintf(\"                %s\", name);\n\t\tif (!in_critical &&\n\t\t    (strcmp(name, \"permit-X11-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-agent-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-port-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-pty\") == 0 ||\n\t\t    strcmp(name, \"permit-user-rc\") == 0))\n\t\t\tprintf(\"\\n\");\n\t\telse if (in_critical &&\n\t\t    (strcmp(name, \"force-command\") == 0 ||\n\t\t    strcmp(name, \"source-address\") == 0)) {\n\t\t\tif ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tprintf(\" %s\\n\", arg);\n\t\t\tfree(arg);\n\t\t} else {\n\t\t\tprintf(\" UNKNOWN OPTION (len %zu)\\n\",\n\t\t\t    sshbuf_len(option));\n\t\t\tsshbuf_reset(option);\n\t\t}\n\t\tfree(name);\n\t\tif (sshbuf_len(option) != 0)\n\t\t\tfatal(\"Option corrupt: extra data at end\");\n\t}\n\tsshbuf_free(option);\n\tsshbuf_free(options);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nshow_options(struct sshbuf *optbuf, int in_critical)\n{\n\tchar *name, *arg;\n\tstruct sshbuf *options, *option = NULL;\n\tint r;\n\n\tif ((options = sshbuf_fromb(optbuf)) == NULL)\n\t\tfatal(\"%s: sshbuf_fromb failed\", __func__);\n\twhile (sshbuf_len(options) != 0) {\n\t\tsshbuf_free(option);\n\t\toption = NULL;\n\t\tif ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(options, &option)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tprintf(\"                %s\", name);\n\t\tif (!in_critical &&\n\t\t    (strcmp(name, \"permit-X11-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-agent-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-port-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-pty\") == 0 ||\n\t\t    strcmp(name, \"permit-user-rc\") == 0))\n\t\t\tprintf(\"\\n\");\n\t\telse if (in_critical &&\n\t\t    (strcmp(name, \"force-command\") == 0 ||\n\t\t    strcmp(name, \"source-address\") == 0)) {\n\t\t\tif ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tprintf(\" %s\\n\", arg);\n\t\t\tfree(arg);\n\t\t} else {\n\t\t\tprintf(\" UNKNOWN OPTION (len %zu)\\n\",\n\t\t\t    sshbuf_len(option));\n\t\t\tsshbuf_reset(option);\n\t\t}\n\t\tfree(name);\n\t\tif (sshbuf_len(option) != 0)\n\t\t\tfatal(\"Option corrupt: extra data at end\");\n\t}\n\tsshbuf_free(option);\n\tsshbuf_free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "key->cert->extensions"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n                %s\"",
            "key->cert->principals[i]"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key->cert->signature_key"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_type",
          "args": [
            "key"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1451-1462",
          "snippet": "const char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_format_cert_validity",
          "args": [
            "key->cert",
            "valid",
            "sizeof(valid)"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_format_cert_validity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2730-2765",
          "snippet": "size_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint fail\"",
            "__func__"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key->cert->signature_key",
            "fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nprint_cert(struct sshkey *key)\n{\n\tchar valid[64], *key_fp, *ca_fp;\n\tu_int i;\n\n\tkey_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);\n\tca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    fingerprint_hash, SSH_FP_DEFAULT);\n\tif (key_fp == NULL || ca_fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\tsshkey_format_cert_validity(key->cert, valid, sizeof(valid));\n\n\tprintf(\"        Type: %s %s certificate\\n\", sshkey_ssh_name(key),\n\t    sshkey_cert_type(key));\n\tprintf(\"        Public key: %s %s\\n\", sshkey_type(key), key_fp);\n\tprintf(\"        Signing CA: %s %s (using %s)\\n\",\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    key->cert->signature_type);\n\tprintf(\"        Key ID: \\\"%s\\\"\\n\", key->cert->key_id);\n\tprintf(\"        Serial: %llu\\n\", (unsigned long long)key->cert->serial);\n\tprintf(\"        Valid: %s\\n\", valid);\n\tprintf(\"        Principals: \");\n\tif (key->cert->nprincipals == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tfor (i = 0; i < key->cert->nprincipals; i++)\n\t\t\tprintf(\"\\n                %s\",\n\t\t\t    key->cert->principals[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"        Critical Options: \");\n\tif (sshbuf_len(key->cert->critical) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->critical, 1);\n\t}\n\tprintf(\"        Extensions: \");\n\tif (sshbuf_len(key->cert->extensions) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->extensions, 0);\n\t}\n}"
  },
  {
    "function_name": "show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1950-1992",
    "snippet": "static void\nshow_options(struct sshbuf *optbuf, int in_critical)\n{\n\tchar *name, *arg;\n\tstruct sshbuf *options, *option = NULL;\n\tint r;\n\n\tif ((options = sshbuf_fromb(optbuf)) == NULL)\n\t\tfatal(\"%s: sshbuf_fromb failed\", __func__);\n\twhile (sshbuf_len(options) != 0) {\n\t\tsshbuf_free(option);\n\t\toption = NULL;\n\t\tif ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(options, &option)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tprintf(\"                %s\", name);\n\t\tif (!in_critical &&\n\t\t    (strcmp(name, \"permit-X11-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-agent-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-port-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-pty\") == 0 ||\n\t\t    strcmp(name, \"permit-user-rc\") == 0))\n\t\t\tprintf(\"\\n\");\n\t\telse if (in_critical &&\n\t\t    (strcmp(name, \"force-command\") == 0 ||\n\t\t    strcmp(name, \"source-address\") == 0)) {\n\t\t\tif ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tprintf(\" %s\\n\", arg);\n\t\t\tfree(arg);\n\t\t} else {\n\t\t\tprintf(\" UNKNOWN OPTION (len %zu)\\n\",\n\t\t\t    sshbuf_len(option));\n\t\t\tsshbuf_reset(option);\n\t\t}\n\t\tfree(name);\n\t\tif (sshbuf_len(option) != 0)\n\t\t\tfatal(\"Option corrupt: extra data at end\");\n\t}\n\tsshbuf_free(option);\n\tsshbuf_free(options);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "options"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Option corrupt: extra data at end\""
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "option"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "option"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" UNKNOWN OPTION (len %zu)\\n\"",
            "sshbuf_len(option)"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "option",
            "&arg",
            "NULL"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"source-address\""
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "options",
            "&option"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_fromb failed\"",
            "__func__"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_fromb",
          "args": [
            "optbuf"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "117-131",
          "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nshow_options(struct sshbuf *optbuf, int in_critical)\n{\n\tchar *name, *arg;\n\tstruct sshbuf *options, *option = NULL;\n\tint r;\n\n\tif ((options = sshbuf_fromb(optbuf)) == NULL)\n\t\tfatal(\"%s: sshbuf_fromb failed\", __func__);\n\twhile (sshbuf_len(options) != 0) {\n\t\tsshbuf_free(option);\n\t\toption = NULL;\n\t\tif ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(options, &option)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tprintf(\"                %s\", name);\n\t\tif (!in_critical &&\n\t\t    (strcmp(name, \"permit-X11-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-agent-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-port-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-pty\") == 0 ||\n\t\t    strcmp(name, \"permit-user-rc\") == 0))\n\t\t\tprintf(\"\\n\");\n\t\telse if (in_critical &&\n\t\t    (strcmp(name, \"force-command\") == 0 ||\n\t\t    strcmp(name, \"source-address\") == 0)) {\n\t\t\tif ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tprintf(\" %s\\n\", arg);\n\t\t\tfree(arg);\n\t\t} else {\n\t\t\tprintf(\" UNKNOWN OPTION (len %zu)\\n\",\n\t\t\t    sshbuf_len(option));\n\t\t\tsshbuf_reset(option);\n\t\t}\n\t\tfree(name);\n\t\tif (sshbuf_len(option) != 0)\n\t\t\tfatal(\"Option corrupt: extra data at end\");\n\t}\n\tsshbuf_free(option);\n\tsshbuf_free(options);\n}"
  },
  {
    "function_name": "add_cert_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1890-1948",
    "snippet": "static void\nadd_cert_option(char *opt)\n{\n\tchar *val, *cp;\n\tint iscrit = 0;\n\n\tif (strcasecmp(opt, \"clear\") == 0)\n\t\tcertflags_flags = 0;\n\telse if (strcasecmp(opt, \"no-x11-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"permit-x11-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"no-agent-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"permit-agent-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"no-port-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"permit-port-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"no-pty\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"permit-pty\") == 0)\n\t\tcertflags_flags |= CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"no-user-rc\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"permit-user-rc\") == 0)\n\t\tcertflags_flags |= CERTOPT_USER_RC;\n\telse if (strncasecmp(opt, \"force-command=\", 14) == 0) {\n\t\tval = opt + 14;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty force-command option\");\n\t\tif (certflags_command != NULL)\n\t\t\tfatal(\"force-command already specified\");\n\t\tcertflags_command = xstrdup(val);\n\t} else if (strncasecmp(opt, \"source-address=\", 15) == 0) {\n\t\tval = opt + 15;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty source-address option\");\n\t\tif (certflags_src_addr != NULL)\n\t\t\tfatal(\"source-address already specified\");\n\t\tif (addr_match_cidr_list(NULL, val) != 0)\n\t\t\tfatal(\"Invalid source-address list\");\n\t\tcertflags_src_addr = xstrdup(val);\n\t} else if (strncasecmp(opt, \"extension:\", 10) == 0 ||\n\t\t   (iscrit = (strncasecmp(opt, \"critical:\", 9) == 0))) {\n\t\tval = xstrdup(strchr(opt, ':') + 1);\n\t\tif ((cp = strchr(val, '=')) != NULL)\n\t\t\t*cp++ = '\\0';\n\t\tcert_userext = xreallocarray(cert_userext, ncert_userext + 1,\n\t\t    sizeof(*cert_userext));\n\t\tcert_userext[ncert_userext].key = val;\n\t\tcert_userext[ncert_userext].val = cp == NULL ?\n\t\t    NULL : xstrdup(cp);\n\t\tcert_userext[ncert_userext].crit = iscrit;\n\t\tncert_userext++;\n\t} else\n\t\tfatal(\"Unsupported certificate option \\\"%s\\\"\", opt);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CERTOPT_USER_RC\t(1<<4)",
      "#define CERTOPT_PTY\t\t(1<<3)",
      "#define CERTOPT_PORT_FWD\t(1<<2)",
      "#define CERTOPT_AGENT_FWD\t(1<<1)",
      "#define CERTOPT_X_FWD\t(1)"
    ],
    "globals_used": [
      "u_int32_t certflags_flags = CERTOPT_DEFAULT;",
      "char *certflags_command = NULL;",
      "char *certflags_src_addr = NULL;",
      "struct cert_userext *cert_userext;",
      "size_t ncert_userext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unsupported certificate option \\\"%s\\\"\"",
            "opt"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cp"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "cert_userext",
            "ncert_userext + 1",
            "sizeof(*cert_userext)"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "val",
            "'='"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opt",
            "\"critical:\"",
            "9"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opt",
            "\"extension:\"",
            "10"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid source-address list\""
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_match_cidr_list",
          "args": [
            "NULL",
            "val"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "addr_match_cidr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "435-498",
          "snippet": "int\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\nint\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opt",
            "\"source-address=\"",
            "15"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opt",
            "\"force-command=\"",
            "14"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"permit-user-rc\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"no-user-rc\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"permit-pty\""
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"no-pty\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"permit-port-forwarding\""
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"no-port-forwarding\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"permit-agent-forwarding\""
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"no-agent-forwarding\""
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"permit-x11-forwarding\""
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"no-x11-forwarding\""
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "opt",
            "\"clear\""
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CERTOPT_USER_RC\t(1<<4)\n#define CERTOPT_PTY\t\t(1<<3)\n#define CERTOPT_PORT_FWD\t(1<<2)\n#define CERTOPT_AGENT_FWD\t(1<<1)\n#define CERTOPT_X_FWD\t(1)\n\nu_int32_t certflags_flags = CERTOPT_DEFAULT;\nchar *certflags_command = NULL;\nchar *certflags_src_addr = NULL;\nstruct cert_userext *cert_userext;\nsize_t ncert_userext;\n\nstatic void\nadd_cert_option(char *opt)\n{\n\tchar *val, *cp;\n\tint iscrit = 0;\n\n\tif (strcasecmp(opt, \"clear\") == 0)\n\t\tcertflags_flags = 0;\n\telse if (strcasecmp(opt, \"no-x11-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"permit-x11-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"no-agent-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"permit-agent-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"no-port-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"permit-port-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"no-pty\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"permit-pty\") == 0)\n\t\tcertflags_flags |= CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"no-user-rc\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"permit-user-rc\") == 0)\n\t\tcertflags_flags |= CERTOPT_USER_RC;\n\telse if (strncasecmp(opt, \"force-command=\", 14) == 0) {\n\t\tval = opt + 14;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty force-command option\");\n\t\tif (certflags_command != NULL)\n\t\t\tfatal(\"force-command already specified\");\n\t\tcertflags_command = xstrdup(val);\n\t} else if (strncasecmp(opt, \"source-address=\", 15) == 0) {\n\t\tval = opt + 15;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty source-address option\");\n\t\tif (certflags_src_addr != NULL)\n\t\t\tfatal(\"source-address already specified\");\n\t\tif (addr_match_cidr_list(NULL, val) != 0)\n\t\t\tfatal(\"Invalid source-address list\");\n\t\tcertflags_src_addr = xstrdup(val);\n\t} else if (strncasecmp(opt, \"extension:\", 10) == 0 ||\n\t\t   (iscrit = (strncasecmp(opt, \"critical:\", 9) == 0))) {\n\t\tval = xstrdup(strchr(opt, ':') + 1);\n\t\tif ((cp = strchr(val, '=')) != NULL)\n\t\t\t*cp++ = '\\0';\n\t\tcert_userext = xreallocarray(cert_userext, ncert_userext + 1,\n\t\t    sizeof(*cert_userext));\n\t\tcert_userext[ncert_userext].key = val;\n\t\tcert_userext[ncert_userext].val = cp == NULL ?\n\t\t    NULL : xstrdup(cp);\n\t\tcert_userext[ncert_userext].crit = iscrit;\n\t\tncert_userext++;\n\t} else\n\t\tfatal(\"Unsupported certificate option \\\"%s\\\"\", opt);\n}"
  },
  {
    "function_name": "parse_cert_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1840-1888",
    "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int64_t cert_valid_from = 0;",
      "u_int64_t cert_valid_to = ~0ULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "from"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Empty certificate validity interval\""
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid to time \\\"%s\\\"\"",
            "to"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_absolute_time",
          "args": [
            "to",
            "&cert_valid_to"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "parse_absolute_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1988-2029",
          "snippet": "int\nparse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\n\t*tp = 0;\n\n\t/*\n\t * POSIX strptime says \"The application shall ensure that there\n\t * is white-space or other non-alphanumeric characters between\n\t * any two conversion specifications\" so arrange things this way.\n\t */\n\tswitch (strlen(s)) {\n\tcase 8: /* YYYYMMDD */\n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12: /* YYYYMMDDHHMM */\n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14: /* YYYYMMDDHHMMSS */\n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (strptime(buf, fmt, &tm) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((tt = mktime(&tm)) < 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/* success */\n\t*tp = (uint64_t)tt;\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\n\t*tp = 0;\n\n\t/*\n\t * POSIX strptime says \"The application shall ensure that there\n\t * is white-space or other non-alphanumeric characters between\n\t * any two conversion specifications\" so arrange things this way.\n\t */\n\tswitch (strlen(s)) {\n\tcase 8: /* YYYYMMDD */\n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12: /* YYYYMMDDHHMM */\n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14: /* YYYYMMDDHHMMSS */\n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (strptime(buf, fmt, &tm) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((tt = mktime(&tm)) < 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/* success */\n\t*tp = (uint64_t)tt;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "to",
            "\"forever\""
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_relative_time",
          "args": [
            "to",
            "now"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "parse_relative_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1826-1838",
          "snippet": "static u_int64_t\nparse_relative_time(const char *s, time_t now)\n{\n\tint64_t mul, secs;\n\n\tmul = *s == '-' ? -1 : 1;\n\n\tif ((secs = convtime(s + 1)) == -1)\n\t\tfatal(\"Invalid relative certificate time %s\", s);\n\tif (mul == -1 && secs > now)\n\t\tfatal(\"Certificate time %s cannot be represented\", s);\n\treturn now + (u_int64_t)(secs * mul);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int64_t\nparse_relative_time(const char *s, time_t now)\n{\n\tint64_t mul, secs;\n\n\tmul = *s == '-' ? -1 : 1;\n\n\tif ((secs = convtime(s + 1)) == -1)\n\t\tfatal(\"Invalid relative certificate time %s\", s);\n\tif (mul == -1 && secs > now)\n\t\tfatal(\"Certificate time %s cannot be represented\", s);\n\treturn now + (u_int64_t)(secs * mul);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "from",
            "':'"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "timespec"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "timespec + 1"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cert_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1840-1888",
          "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}"
  },
  {
    "function_name": "parse_relative_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1826-1838",
    "snippet": "static u_int64_t\nparse_relative_time(const char *s, time_t now)\n{\n\tint64_t mul, secs;\n\n\tmul = *s == '-' ? -1 : 1;\n\n\tif ((secs = convtime(s + 1)) == -1)\n\t\tfatal(\"Invalid relative certificate time %s\", s);\n\tif (mul == -1 && secs > now)\n\t\tfatal(\"Certificate time %s cannot be represented\", s);\n\treturn now + (u_int64_t)(secs * mul);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "secs * mul"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Certificate time %s cannot be represented\"",
            "s"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "s + 1"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int64_t\nparse_relative_time(const char *s, time_t now)\n{\n\tint64_t mul, secs;\n\n\tmul = *s == '-' ? -1 : 1;\n\n\tif ((secs = convtime(s + 1)) == -1)\n\t\tfatal(\"Invalid relative certificate time %s\", s);\n\tif (mul == -1 && secs > now)\n\t\tfatal(\"Certificate time %s cannot be represented\", s);\n\treturn now + (u_int64_t)(secs * mul);\n}"
  },
  {
    "function_name": "do_ca_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1678-1824",
    "snippet": "static void\ndo_ca_sign(struct passwd *pw, int argc, char **argv)\n{\n\tint r, i, fd, found, agent_fd = -1;\n\tu_int n;\n\tstruct sshkey *ca, *public;\n\tchar valid[64], *otmp, *tmp, *cp, *out, *comment, **plist = NULL;\n\tFILE *f;\n\tstruct ssh_identitylist *agent_ids;\n\tsize_t j;\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(1);\n#endif\n\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\tif (pkcs11provider != NULL) {\n\t\t/* If a PKCS#11 token was specified then try to use it */\n\t\tif ((ca = load_pkcs11_key(tmp)) == NULL)\n\t\t\tfatal(\"No PKCS#11 key matching %s found\", ca_key_path);\n\t} else if (prefer_agent) {\n\t\t/*\n\t\t * Agent signature requested. Try to use agent after making\n\t\t * sure the public key specified is actually present in the\n\t\t * agent.\n\t\t */\n\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0)\n\t\t\tfatal(\"Cannot use public key for CA signature: %s\",\n\t\t\t    ssh_err(r));\n\t\tif ((r = ssh_fetch_identitylist(agent_fd, &agent_ids)) != 0)\n\t\t\tfatal(\"Retrieve agent key list: %s\", ssh_err(r));\n\t\tfound = 0;\n\t\tfor (j = 0; j < agent_ids->nkeys; j++) {\n\t\t\tif (sshkey_equal(ca, agent_ids->keys[j])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tfatal(\"CA key %s not found in agent\", tmp);\n\t\tssh_free_identitylist(agent_ids);\n\t\tca->flags |= SSHKEY_FLAG_EXT;\n\t} else {\n\t\t/* CA key is assumed to be a private key on the filesystem */\n\t\tca = load_identity(tmp);\n\t}\n\tfree(tmp);\n\n\tif (key_type_name != NULL &&\n\t    sshkey_type_from_name(key_type_name) != ca->type)  {\n\t\tfatal(\"CA key type %s doesn't match specified %s\",\n\t\t    sshkey_ssh_name(ca), key_type_name);\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\t/* Split list of principals */\n\t\tn = 0;\n\t\tif (cert_principals != NULL) {\n\t\t\totmp = tmp = xstrdup(cert_principals);\n\t\t\tplist = NULL;\n\t\t\tfor (; (cp = strsep(&tmp, \",\")) != NULL; n++) {\n\t\t\t\tplist = xreallocarray(plist, n + 1, sizeof(*plist));\n\t\t\t\tif (*(plist[n] = xstrdup(cp)) == '\\0')\n\t\t\t\t\tfatal(\"Empty principal name\");\n\t\t\t}\n\t\t\tfree(otmp);\n\t\t}\n\t\tif (n > SSHKEY_CERT_MAX_PRINCIPALS)\n\t\t\tfatal(\"Too many certificate principals specified\");\n\t\n\t\ttmp = tilde_expand_filename(argv[i], pw->pw_uid);\n\t\tif ((r = sshkey_load_public(tmp, &public, &comment)) != 0)\n\t\t\tfatal(\"%s: unable to open \\\"%s\\\": %s\",\n\t\t\t    __func__, tmp, ssh_err(r));\n\t\tif (public->type != KEY_RSA && public->type != KEY_DSA &&\n\t\t    public->type != KEY_ECDSA && public->type != KEY_ED25519 &&\n\t\t    public->type != KEY_XMSS)\n\t\t\tfatal(\"%s: key \\\"%s\\\" type %s cannot be certified\",\n\t\t\t    __func__, tmp, sshkey_type(public));\n\n\t\t/* Prepare certificate to sign */\n\t\tif ((r = sshkey_to_certified(public)) != 0)\n\t\t\tfatal(\"Could not upgrade key %s to certificate: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tpublic->cert->type = cert_key_type;\n\t\tpublic->cert->serial = (u_int64_t)cert_serial;\n\t\tpublic->cert->key_id = xstrdup(cert_key_id);\n\t\tpublic->cert->nprincipals = n;\n\t\tpublic->cert->principals = plist;\n\t\tpublic->cert->valid_after = cert_valid_from;\n\t\tpublic->cert->valid_before = cert_valid_to;\n\t\tprepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);\n\t\tprepare_options_buf(public->cert->extensions,\n\t\t    OPTIONS_EXTENSIONS);\n\t\tif ((r = sshkey_from_private(ca,\n\t\t    &public->cert->signature_key)) != 0)\n\t\t\tfatal(\"sshkey_from_private (ca key): %s\", ssh_err(r));\n\n\t\tif (agent_fd != -1 && (ca->flags & SSHKEY_FLAG_EXT) != 0) {\n\t\t\tif ((r = sshkey_certify_custom(public, ca,\n\t\t\t    key_type_name, agent_signer, &agent_fd)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s via agent: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t} else {\n\t\t\tif ((sshkey_certify(public, ca, key_type_name)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t}\n\n\t\tif ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, \".pub\") == 0)\n\t\t\t*cp = '\\0';\n\t\txasprintf(&out, \"%s-cert.pub\", tmp);\n\t\tfree(tmp);\n\n\t\tif ((fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\t\tfatal(\"Could not open \\\"%s\\\" for writing: %s\", out,\n\t\t\t    strerror(errno));\n\t\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\t\tfatal(\"%s: fdopen: %s\", __func__, strerror(errno));\n\t\tif ((r = sshkey_write(public, f)) != 0)\n\t\t\tfatal(\"Could not write certified key to %s: %s\",\n\t\t\t    out, ssh_err(r));\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tfclose(f);\n\n\t\tif (!quiet) {\n\t\t\tsshkey_format_cert_validity(public->cert,\n\t\t\t    valid, sizeof(valid));\n\t\t\tlogit(\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\", sshkey_cert_type(public),\n\t\t\t    out, public->cert->key_id,\n\t\t\t    (unsigned long long)public->cert->serial,\n\t\t\t    cert_principals != NULL ? \" for \" : \"\",\n\t\t\t    cert_principals != NULL ? cert_principals : \"\",\n\t\t\t    valid);\n\t\t}\n\n\t\tsshkey_free(public);\n\t\tfree(out);\n\t}\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPTIONS_EXTENSIONS\t2",
      "#define OPTIONS_CRITICAL\t1"
    ],
    "globals_used": [
      "int quiet = 0;",
      "char *ca_key_path = NULL;",
      "int prefer_agent = 0;",
      "unsigned long long cert_serial = 0;",
      "u_int cert_key_type = SSH2_CERT_TYPE_USER;",
      "char *cert_key_id = NULL;",
      "char *cert_principals = NULL;",
      "u_int64_t cert_valid_from = 0;",
      "u_int64_t cert_valid_to = ~0ULL;",
      "char *key_type_name = NULL;",
      "char *pkcs11provider = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_terminate",
          "args": [],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "108-113",
          "snippet": "void\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\"",
            "sshkey_cert_type(public)",
            "out",
            "public->cert->key_id",
            "(unsigned long long)public->cert->serial",
            "cert_principals != NULL ? \" for \" : \"\"",
            "cert_principals != NULL ? cert_principals : \"\"",
            "valid"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_cert_type",
          "args": [
            "public"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_cert_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1451-1462",
          "snippet": "const char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_format_cert_validity",
          "args": [
            "public->cert",
            "valid",
            "sizeof(valid)"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_format_cert_validity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2730-2765",
          "snippet": "size_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[64];\n\ttime_t tt;\n\tstruct tm *tm;\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_after > INT_MAX ?\n\t\t    INT_MAX : cert->valid_after;\n\t\ttm = localtime(&tt);\n\t\tstrftime(from, sizeof(from), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\tif (cert->valid_before != 0xffffffffffffffffULL) {\n\t\t/* XXX revisit INT_MAX in 2038 :) */\n\t\ttt = cert->valid_before > INT_MAX ?\n\t\t    INT_MAX : cert->valid_before;\n\t\ttm = localtime(&tt);\n\t\tstrftime(to, sizeof(to), \"%Y-%m-%dT%H:%M:%S\", tm);\n\t}\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\\n\"",
            "comment"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Could not write certified key to %s: %s\"",
            "out",
            "ssh_err(r)"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "public",
            "f"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"w\""
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "out",
            "O_WRONLY|O_CREAT|O_TRUNC",
            "0644"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&out",
            "\"%s-cert.pub\"",
            "tmp"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "\".pub\""
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "tmp",
            "'.'"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_certify",
          "args": [
            "public",
            "ca",
            "key_type_name"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_certify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2667-2671",
          "snippet": "int\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_certify_custom",
          "args": [
            "public",
            "ca",
            "key_type_name",
            "agent_signer",
            "&agent_fd"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_certify_custom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2509-2655",
          "snippet": "int\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n#endif /* WITH_OPENSSL */\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\t/*\n\t * If no alg specified as argument but a signature_type was set,\n\t * then prefer that. If both were specified, then they must match.\n\t */\n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob; /* for readability */\n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t/* -v01 certs put nonce first */\n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t/* XXX this substantially duplicates to_blob(); refactor */\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, dsa_pub_key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\t\tif ((ret = sshbuf_put_cstring(cert,\n\t\t    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||\n\t\t    (ret = sshbuf_put_ec(cert,\n\t\t    EC_KEY_get0_public_key(k->ecdsa),\n\t\t    EC_KEY_get0_group(k->ecdsa))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||\n\t\t    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_CERT:\n\t\tif ((ret = sshbuf_put_string(cert,\n\t\t    k->ed25519_pk, ED25519_PK_SZ)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS_CERT:\n\t\tif (k->xmss_name == NULL) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_put_cstring(cert, k->xmss_name)) ||\n\t\t    (ret = sshbuf_put_string(cert,\n\t\t    k->xmss_pk, sshkey_xmss_pklen(k))) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 || /* Reserved */\n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t/* Sign the whole mess */\n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t/* Check and update signature_type against what was actually used */\n\tif ((ret = get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t/* Append signature and we are done */\n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_from_private (ca key): %s\"",
            "ssh_err(r)"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "ca",
            "&public->cert->signature_key"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_options_buf",
          "args": [
            "public->cert->extensions",
            "OPTIONS_EXTENSIONS"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_options_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1596-1634",
          "snippet": "static void\nprepare_options_buf(struct sshbuf *c, int which)\n{\n\tsize_t i;\n\n\tsshbuf_reset(c);\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_command != NULL)\n\t\tadd_string_option(c, \"force-command\", certflags_command);\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_X_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-X11-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_AGENT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-agent-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PORT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-port-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PTY) != 0)\n\t\tadd_flag_option(c, \"permit-pty\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_USER_RC) != 0)\n\t\tadd_flag_option(c, \"permit-user-rc\");\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_src_addr != NULL)\n\t\tadd_string_option(c, \"source-address\", certflags_src_addr);\n\tfor (i = 0; i < ncert_userext; i++) {\n\t\tif ((cert_userext[i].crit && (which & OPTIONS_EXTENSIONS)) ||\n\t\t    (!cert_userext[i].crit && (which & OPTIONS_CRITICAL)))\n\t\t\tcontinue;\n\t\tif (cert_userext[i].val == NULL)\n\t\t\tadd_flag_option(c, cert_userext[i].key);\n\t\telse {\n\t\t\tadd_string_option(c, cert_userext[i].key,\n\t\t\t    cert_userext[i].val);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define OPTIONS_EXTENSIONS\t2",
            "#define OPTIONS_CRITICAL\t1",
            "#define CERTOPT_USER_RC\t(1<<4)",
            "#define CERTOPT_PTY\t\t(1<<3)",
            "#define CERTOPT_PORT_FWD\t(1<<2)",
            "#define CERTOPT_AGENT_FWD\t(1<<1)",
            "#define CERTOPT_X_FWD\t(1)"
          ],
          "globals_used": [
            "u_int32_t certflags_flags = CERTOPT_DEFAULT;",
            "char *certflags_command = NULL;",
            "char *certflags_src_addr = NULL;",
            "struct cert_userext *cert_userext;",
            "size_t ncert_userext;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n#define CERTOPT_USER_RC\t(1<<4)\n#define CERTOPT_PTY\t\t(1<<3)\n#define CERTOPT_PORT_FWD\t(1<<2)\n#define CERTOPT_AGENT_FWD\t(1<<1)\n#define CERTOPT_X_FWD\t(1)\n\nu_int32_t certflags_flags = CERTOPT_DEFAULT;\nchar *certflags_command = NULL;\nchar *certflags_src_addr = NULL;\nstruct cert_userext *cert_userext;\nsize_t ncert_userext;\n\nstatic void\nprepare_options_buf(struct sshbuf *c, int which)\n{\n\tsize_t i;\n\n\tsshbuf_reset(c);\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_command != NULL)\n\t\tadd_string_option(c, \"force-command\", certflags_command);\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_X_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-X11-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_AGENT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-agent-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PORT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-port-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PTY) != 0)\n\t\tadd_flag_option(c, \"permit-pty\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_USER_RC) != 0)\n\t\tadd_flag_option(c, \"permit-user-rc\");\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_src_addr != NULL)\n\t\tadd_string_option(c, \"source-address\", certflags_src_addr);\n\tfor (i = 0; i < ncert_userext; i++) {\n\t\tif ((cert_userext[i].crit && (which & OPTIONS_EXTENSIONS)) ||\n\t\t    (!cert_userext[i].crit && (which & OPTIONS_CRITICAL)))\n\t\t\tcontinue;\n\t\tif (cert_userext[i].val == NULL)\n\t\t\tadd_flag_option(c, cert_userext[i].key);\n\t\telse {\n\t\t\tadd_string_option(c, cert_userext[i].key,\n\t\t\t    cert_userext[i].val);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cert_key_id"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_certified",
          "args": [
            "public"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_certified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2462-2494",
          "snippet": "int\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "public"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "tmp",
            "&public",
            "&comment"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "argv[i]",
            "pw->pw_uid"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "plist",
            "n + 1",
            "sizeof(*plist)"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&tmp",
            "\",\""
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "ca"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "key_type_name"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_identity",
          "args": [
            "tmp"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "load_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "303-324",
          "snippet": "static struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *identity_passphrase = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\n\nstatic struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_free_identitylist",
          "args": [
            "agent_ids"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "ca",
            "agent_ids->keys[j]"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_fetch_identitylist",
          "args": [
            "agent_fd",
            "&agent_ids"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_fetch_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "228-300",
          "snippet": "int\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */\n\nint\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&agent_fd"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_pkcs11_key",
          "args": [
            "tmp"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "load_pkcs11_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1636-1664",
          "snippet": "static struct sshkey *\nload_pkcs11_key(char *path)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL, *public, *private = NULL;\n\tint r, i, nkeys;\n\n\tif ((r = sshkey_load_public(path, &public, NULL)) != 0)\n\t\tfatal(\"Couldn't load CA public key \\\"%s\\\": %s\",\n\t\t    path, ssh_err(r));\n\n\tnkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase, &keys);\n\tdebug3(\"%s: %d keys\", __func__, nkeys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (sshkey_equal_public(public, keys[i])) {\n\t\t\tprivate = keys[i];\n\t\t\tcontinue;\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tsshkey_free(public);\n\treturn private;\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *identity_passphrase = NULL;",
            "char *pkcs11provider = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\nchar *pkcs11provider = NULL;\n\nstatic struct sshkey *\nload_pkcs11_key(char *path)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL, *public, *private = NULL;\n\tint r, i, nkeys;\n\n\tif ((r = sshkey_load_public(path, &public, NULL)) != 0)\n\t\tfatal(\"Couldn't load CA public key \\\"%s\\\": %s\",\n\t\t    path, ssh_err(r));\n\n\tnkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase, &keys);\n\tdebug3(\"%s: %d keys\", __func__, nkeys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (sshkey_equal_public(public, keys[i])) {\n\t\t\tprivate = keys[i];\n\t\t\tcontinue;\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tsshkey_free(public);\n\treturn private;\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_init",
          "args": [
            "1"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "102-106",
          "snippet": "int\npkcs11_init(int interactive)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_init(int interactive)\n{\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nint quiet = 0;\nchar *ca_key_path = NULL;\nint prefer_agent = 0;\nunsigned long long cert_serial = 0;\nu_int cert_key_type = SSH2_CERT_TYPE_USER;\nchar *cert_key_id = NULL;\nchar *cert_principals = NULL;\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\nchar *key_type_name = NULL;\nchar *pkcs11provider = NULL;\n\nstatic void\ndo_ca_sign(struct passwd *pw, int argc, char **argv)\n{\n\tint r, i, fd, found, agent_fd = -1;\n\tu_int n;\n\tstruct sshkey *ca, *public;\n\tchar valid[64], *otmp, *tmp, *cp, *out, *comment, **plist = NULL;\n\tFILE *f;\n\tstruct ssh_identitylist *agent_ids;\n\tsize_t j;\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(1);\n#endif\n\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\tif (pkcs11provider != NULL) {\n\t\t/* If a PKCS#11 token was specified then try to use it */\n\t\tif ((ca = load_pkcs11_key(tmp)) == NULL)\n\t\t\tfatal(\"No PKCS#11 key matching %s found\", ca_key_path);\n\t} else if (prefer_agent) {\n\t\t/*\n\t\t * Agent signature requested. Try to use agent after making\n\t\t * sure the public key specified is actually present in the\n\t\t * agent.\n\t\t */\n\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\tfatal(\"Cannot load CA public key %s: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0)\n\t\t\tfatal(\"Cannot use public key for CA signature: %s\",\n\t\t\t    ssh_err(r));\n\t\tif ((r = ssh_fetch_identitylist(agent_fd, &agent_ids)) != 0)\n\t\t\tfatal(\"Retrieve agent key list: %s\", ssh_err(r));\n\t\tfound = 0;\n\t\tfor (j = 0; j < agent_ids->nkeys; j++) {\n\t\t\tif (sshkey_equal(ca, agent_ids->keys[j])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tfatal(\"CA key %s not found in agent\", tmp);\n\t\tssh_free_identitylist(agent_ids);\n\t\tca->flags |= SSHKEY_FLAG_EXT;\n\t} else {\n\t\t/* CA key is assumed to be a private key on the filesystem */\n\t\tca = load_identity(tmp);\n\t}\n\tfree(tmp);\n\n\tif (key_type_name != NULL &&\n\t    sshkey_type_from_name(key_type_name) != ca->type)  {\n\t\tfatal(\"CA key type %s doesn't match specified %s\",\n\t\t    sshkey_ssh_name(ca), key_type_name);\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\t/* Split list of principals */\n\t\tn = 0;\n\t\tif (cert_principals != NULL) {\n\t\t\totmp = tmp = xstrdup(cert_principals);\n\t\t\tplist = NULL;\n\t\t\tfor (; (cp = strsep(&tmp, \",\")) != NULL; n++) {\n\t\t\t\tplist = xreallocarray(plist, n + 1, sizeof(*plist));\n\t\t\t\tif (*(plist[n] = xstrdup(cp)) == '\\0')\n\t\t\t\t\tfatal(\"Empty principal name\");\n\t\t\t}\n\t\t\tfree(otmp);\n\t\t}\n\t\tif (n > SSHKEY_CERT_MAX_PRINCIPALS)\n\t\t\tfatal(\"Too many certificate principals specified\");\n\t\n\t\ttmp = tilde_expand_filename(argv[i], pw->pw_uid);\n\t\tif ((r = sshkey_load_public(tmp, &public, &comment)) != 0)\n\t\t\tfatal(\"%s: unable to open \\\"%s\\\": %s\",\n\t\t\t    __func__, tmp, ssh_err(r));\n\t\tif (public->type != KEY_RSA && public->type != KEY_DSA &&\n\t\t    public->type != KEY_ECDSA && public->type != KEY_ED25519 &&\n\t\t    public->type != KEY_XMSS)\n\t\t\tfatal(\"%s: key \\\"%s\\\" type %s cannot be certified\",\n\t\t\t    __func__, tmp, sshkey_type(public));\n\n\t\t/* Prepare certificate to sign */\n\t\tif ((r = sshkey_to_certified(public)) != 0)\n\t\t\tfatal(\"Could not upgrade key %s to certificate: %s\",\n\t\t\t    tmp, ssh_err(r));\n\t\tpublic->cert->type = cert_key_type;\n\t\tpublic->cert->serial = (u_int64_t)cert_serial;\n\t\tpublic->cert->key_id = xstrdup(cert_key_id);\n\t\tpublic->cert->nprincipals = n;\n\t\tpublic->cert->principals = plist;\n\t\tpublic->cert->valid_after = cert_valid_from;\n\t\tpublic->cert->valid_before = cert_valid_to;\n\t\tprepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);\n\t\tprepare_options_buf(public->cert->extensions,\n\t\t    OPTIONS_EXTENSIONS);\n\t\tif ((r = sshkey_from_private(ca,\n\t\t    &public->cert->signature_key)) != 0)\n\t\t\tfatal(\"sshkey_from_private (ca key): %s\", ssh_err(r));\n\n\t\tif (agent_fd != -1 && (ca->flags & SSHKEY_FLAG_EXT) != 0) {\n\t\t\tif ((r = sshkey_certify_custom(public, ca,\n\t\t\t    key_type_name, agent_signer, &agent_fd)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s via agent: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t} else {\n\t\t\tif ((sshkey_certify(public, ca, key_type_name)) != 0)\n\t\t\t\tfatal(\"Couldn't certify key %s: %s\",\n\t\t\t\t    tmp, ssh_err(r));\n\t\t}\n\n\t\tif ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, \".pub\") == 0)\n\t\t\t*cp = '\\0';\n\t\txasprintf(&out, \"%s-cert.pub\", tmp);\n\t\tfree(tmp);\n\n\t\tif ((fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\t\tfatal(\"Could not open \\\"%s\\\" for writing: %s\", out,\n\t\t\t    strerror(errno));\n\t\tif ((f = fdopen(fd, \"w\")) == NULL)\n\t\t\tfatal(\"%s: fdopen: %s\", __func__, strerror(errno));\n\t\tif ((r = sshkey_write(public, f)) != 0)\n\t\t\tfatal(\"Could not write certified key to %s: %s\",\n\t\t\t    out, ssh_err(r));\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tfclose(f);\n\n\t\tif (!quiet) {\n\t\t\tsshkey_format_cert_validity(public->cert,\n\t\t\t    valid, sizeof(valid));\n\t\t\tlogit(\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\", sshkey_cert_type(public),\n\t\t\t    out, public->cert->key_id,\n\t\t\t    (unsigned long long)public->cert->serial,\n\t\t\t    cert_principals != NULL ? \" for \" : \"\",\n\t\t\t    cert_principals != NULL ? cert_principals : \"\",\n\t\t\t    valid);\n\t\t}\n\n\t\tsshkey_free(public);\n\t\tfree(out);\n\t}\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\texit(0);\n}"
  },
  {
    "function_name": "agent_signer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1667-1676",
    "snippet": "static int\nagent_signer(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tint *agent_fdp = (int *)ctx;\n\n\treturn ssh_agent_sign(*agent_fdp, key, sigp, lenp,\n\t    data, datalen, alg, compat);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_agent_sign",
          "args": [
            "*agent_fdp",
            "key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "alg",
            "compat"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_agent_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "340-390",
          "snippet": "int\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nagent_signer(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, u_int compat, void *ctx)\n{\n\tint *agent_fdp = (int *)ctx;\n\n\treturn ssh_agent_sign(*agent_fdp, key, sigp, lenp,\n\t    data, datalen, alg, compat);\n}"
  },
  {
    "function_name": "load_pkcs11_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1636-1664",
    "snippet": "static struct sshkey *\nload_pkcs11_key(char *path)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL, *public, *private = NULL;\n\tint r, i, nkeys;\n\n\tif ((r = sshkey_load_public(path, &public, NULL)) != 0)\n\t\tfatal(\"Couldn't load CA public key \\\"%s\\\": %s\",\n\t\t    path, ssh_err(r));\n\n\tnkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase, &keys);\n\tdebug3(\"%s: %d keys\", __func__, nkeys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (sshkey_equal_public(public, keys[i])) {\n\t\t\tprivate = keys[i];\n\t\t\tcontinue;\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tsshkey_free(public);\n\treturn private;\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *identity_passphrase = NULL;",
      "char *pkcs11provider = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"no pkcs11 support\""
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keys"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "public",
            "keys[i]"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %d keys\"",
            "__func__",
            "nkeys"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_add_provider",
          "args": [
            "pkcs11provider",
            "identity_passphrase",
            "&keys"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_add_provider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "203-246",
          "snippet": "int\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "path",
            "&public",
            "NULL"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\nchar *pkcs11provider = NULL;\n\nstatic struct sshkey *\nload_pkcs11_key(char *path)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL, *public, *private = NULL;\n\tint r, i, nkeys;\n\n\tif ((r = sshkey_load_public(path, &public, NULL)) != 0)\n\t\tfatal(\"Couldn't load CA public key \\\"%s\\\": %s\",\n\t\t    path, ssh_err(r));\n\n\tnkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase, &keys);\n\tdebug3(\"%s: %d keys\", __func__, nkeys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (sshkey_equal_public(public, keys[i])) {\n\t\t\tprivate = keys[i];\n\t\t\tcontinue;\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tsshkey_free(public);\n\treturn private;\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}"
  },
  {
    "function_name": "prepare_options_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1596-1634",
    "snippet": "static void\nprepare_options_buf(struct sshbuf *c, int which)\n{\n\tsize_t i;\n\n\tsshbuf_reset(c);\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_command != NULL)\n\t\tadd_string_option(c, \"force-command\", certflags_command);\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_X_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-X11-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_AGENT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-agent-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PORT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-port-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PTY) != 0)\n\t\tadd_flag_option(c, \"permit-pty\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_USER_RC) != 0)\n\t\tadd_flag_option(c, \"permit-user-rc\");\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_src_addr != NULL)\n\t\tadd_string_option(c, \"source-address\", certflags_src_addr);\n\tfor (i = 0; i < ncert_userext; i++) {\n\t\tif ((cert_userext[i].crit && (which & OPTIONS_EXTENSIONS)) ||\n\t\t    (!cert_userext[i].crit && (which & OPTIONS_CRITICAL)))\n\t\t\tcontinue;\n\t\tif (cert_userext[i].val == NULL)\n\t\t\tadd_flag_option(c, cert_userext[i].key);\n\t\telse {\n\t\t\tadd_string_option(c, cert_userext[i].key,\n\t\t\t    cert_userext[i].val);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPTIONS_EXTENSIONS\t2",
      "#define OPTIONS_CRITICAL\t1",
      "#define CERTOPT_USER_RC\t(1<<4)",
      "#define CERTOPT_PTY\t\t(1<<3)",
      "#define CERTOPT_PORT_FWD\t(1<<2)",
      "#define CERTOPT_AGENT_FWD\t(1<<1)",
      "#define CERTOPT_X_FWD\t(1)"
    ],
    "globals_used": [
      "u_int32_t certflags_flags = CERTOPT_DEFAULT;",
      "char *certflags_command = NULL;",
      "char *certflags_src_addr = NULL;",
      "struct cert_userext *cert_userext;",
      "size_t ncert_userext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_string_option",
          "args": [
            "c",
            "cert_userext[i].key",
            "cert_userext[i].val"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "add_string_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1577-1592",
          "snippet": "static void\nadd_string_option(struct sshbuf *c, const char *name, const char *value)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tdebug3(\"%s: %s=%s\", __func__, name, value);\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_cstring(b, value)) != 0 ||\n\t    (r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_stringb(c, b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(b);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nadd_string_option(struct sshbuf *c, const char *name, const char *value)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tdebug3(\"%s: %s=%s\", __func__, name, value);\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_cstring(b, value)) != 0 ||\n\t    (r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_stringb(c, b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_flag_option",
          "args": [
            "c",
            "cert_userext[i].key"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "add_flag_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1566-1575",
          "snippet": "static void\nadd_flag_option(struct sshbuf *c, const char *name)\n{\n\tint r;\n\n\tdebug3(\"%s: %s\", __func__, name);\n\tif ((r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_string(c, NULL, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nadd_flag_option(struct sshbuf *c, const char *name)\n{\n\tint r;\n\n\tdebug3(\"%s: %s\", __func__, name);\n\tif ((r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_string(c, NULL, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "c"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n#define CERTOPT_USER_RC\t(1<<4)\n#define CERTOPT_PTY\t\t(1<<3)\n#define CERTOPT_PORT_FWD\t(1<<2)\n#define CERTOPT_AGENT_FWD\t(1<<1)\n#define CERTOPT_X_FWD\t(1)\n\nu_int32_t certflags_flags = CERTOPT_DEFAULT;\nchar *certflags_command = NULL;\nchar *certflags_src_addr = NULL;\nstruct cert_userext *cert_userext;\nsize_t ncert_userext;\n\nstatic void\nprepare_options_buf(struct sshbuf *c, int which)\n{\n\tsize_t i;\n\n\tsshbuf_reset(c);\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_command != NULL)\n\t\tadd_string_option(c, \"force-command\", certflags_command);\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_X_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-X11-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_AGENT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-agent-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PORT_FWD) != 0)\n\t\tadd_flag_option(c, \"permit-port-forwarding\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_PTY) != 0)\n\t\tadd_flag_option(c, \"permit-pty\");\n\tif ((which & OPTIONS_EXTENSIONS) != 0 &&\n\t    (certflags_flags & CERTOPT_USER_RC) != 0)\n\t\tadd_flag_option(c, \"permit-user-rc\");\n\tif ((which & OPTIONS_CRITICAL) != 0 &&\n\t    certflags_src_addr != NULL)\n\t\tadd_string_option(c, \"source-address\", certflags_src_addr);\n\tfor (i = 0; i < ncert_userext; i++) {\n\t\tif ((cert_userext[i].crit && (which & OPTIONS_EXTENSIONS)) ||\n\t\t    (!cert_userext[i].crit && (which & OPTIONS_CRITICAL)))\n\t\t\tcontinue;\n\t\tif (cert_userext[i].val == NULL)\n\t\t\tadd_flag_option(c, cert_userext[i].key);\n\t\telse {\n\t\t\tadd_string_option(c, cert_userext[i].key,\n\t\t\t    cert_userext[i].val);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_string_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1577-1592",
    "snippet": "static void\nadd_string_option(struct sshbuf *c, const char *name, const char *value)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tdebug3(\"%s: %s=%s\", __func__, name, value);\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_cstring(b, value)) != 0 ||\n\t    (r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_stringb(c, b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(b);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "c",
            "b"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "c",
            "name"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s=%s\"",
            "__func__",
            "name",
            "value"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nadd_string_option(struct sshbuf *c, const char *name, const char *value)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tdebug3(\"%s: %s=%s\", __func__, name, value);\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_cstring(b, value)) != 0 ||\n\t    (r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_stringb(c, b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(b);\n}"
  },
  {
    "function_name": "add_flag_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1566-1575",
    "snippet": "static void\nadd_flag_option(struct sshbuf *c, const char *name)\n{\n\tint r;\n\n\tdebug3(\"%s: %s\", __func__, name);\n\tif ((r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_string(c, NULL, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "c",
            "NULL",
            "0"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "c",
            "name"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "name"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nadd_flag_option(struct sshbuf *c, const char *name)\n{\n\tint r;\n\n\tdebug3(\"%s: %s\", __func__, name);\n\tif ((r = sshbuf_put_cstring(c, name)) != 0 ||\n\t    (r = sshbuf_put_string(c, NULL, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "do_change_comment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1466-1564",
    "snippet": "static void\ndo_change_comment(struct passwd *pw)\n{\n\tchar new_comment[1024], *comment, *passphrase;\n\tstruct sshkey *private;\n\tstruct sshkey *public;\n\tstruct stat st;\n\tFILE *f;\n\tint r, fd;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_load_private(identity_file, \"\",\n\t    &private, &comment)) == 0)\n\t\tpassphrase = xstrdup(\"\");\n\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t    identity_file, ssh_err(r));\n\telse {\n\t\tif (identity_passphrase)\n\t\t\tpassphrase = xstrdup(identity_passphrase);\n\t\telse if (identity_new_passphrase)\n\t\t\tpassphrase = xstrdup(identity_new_passphrase);\n\t\telse\n\t\t\tpassphrase = read_passphrase(\"Enter passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\t/* Try to load using the passphrase. */\n\t\tif ((r = sshkey_load_private(identity_file, passphrase,\n\t\t    &private, &comment)) != 0) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tfree(passphrase);\n\t\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t\t    identity_file, ssh_err(r));\n\t\t}\n\t}\n\n\tif (private->type != KEY_ED25519 && private->type != KEY_XMSS &&\n\t    !use_new_format) {\n\t\terror(\"Comments are only supported for keys stored in \"\n\t\t    \"the new format (-o).\");\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\texit(1);\n\t}\n\tif (comment)\n\t\tprintf(\"Key now has comment '%s'\\n\", comment);\n\telse\n\t\tprintf(\"Key now has no comment\\n\");\n\n\tif (identity_comment) {\n\t\tstrlcpy(new_comment, identity_comment, sizeof(new_comment));\n\t} else {\n\t\tprintf(\"Enter new comment: \");\n\t\tfflush(stdout);\n\t\tif (!fgets(new_comment, sizeof(new_comment), stdin)) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tsshkey_free(private);\n\t\t\texit(1);\n\t\t}\n\t\tnew_comment[strcspn(new_comment, \"\\n\")] = '\\0';\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    new_comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tfree(passphrase);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\texplicit_bzero(passphrase, strlen(passphrase));\n\tfree(passphrase);\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\tsshkey_free(private);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tfd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\tfatal(\"Could not save your public key in %s\", identity_file);\n\tf = fdopen(fd, \"w\");\n\tif (f == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\tfatal(\"write key failed: %s\", ssh_err(r));\n\tsshkey_free(public);\n\tfprintf(f, \" %s\\n\", new_comment);\n\tfclose(f);\n\n\tfree(comment);\n\n\tprintf(\"The comment in your key file has been changed.\\n\");\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "char *identity_passphrase = NULL;",
      "char *identity_new_passphrase = NULL;",
      "char *identity_comment = NULL;",
      "int use_new_format = 1;",
      "char *new_format_cipher = NULL;",
      "int rounds = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"The comment in your key file has been changed.\\n\""
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\\n\"",
            "new_comment"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"write key failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "public",
            "f"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"fdopen %s failed: %s\"",
            "identity_file",
            "strerror(errno)"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"w\""
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "identity_file",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "0644"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "identity_file",
            "\".pub\"",
            "sizeof(identity_file)"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "private",
            "&public"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passphrase",
            "strlen(passphrase)"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Saving key \\\"%s\\\" failed: %s\"",
            "identity_file",
            "ssh_err(r)"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_save_private",
          "args": [
            "private",
            "identity_file",
            "passphrase",
            "new_comment",
            "use_new_format",
            "new_format_cipher",
            "rounds"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_save_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "74-93",
          "snippet": "int\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "new_comment",
            "\"\\n\""
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "new_comment",
            "sizeof(new_comment)",
            "stdin"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "new_comment",
            "identity_comment",
            "sizeof(new_comment)"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Key now has comment '%s'\\n\"",
            "comment"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_private",
          "args": [
            "identity_file",
            "passphrase",
            "&private",
            "&comment"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "227-262",
          "snippet": "int\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"Enter passphrase: \"",
            "RP_ALLOW_STDIN"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "identity_new_passphrase"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *identity_passphrase = NULL;\nchar *identity_new_passphrase = NULL;\nchar *identity_comment = NULL;\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\n\nstatic void\ndo_change_comment(struct passwd *pw)\n{\n\tchar new_comment[1024], *comment, *passphrase;\n\tstruct sshkey *private;\n\tstruct sshkey *public;\n\tstruct stat st;\n\tFILE *f;\n\tint r, fd;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_load_private(identity_file, \"\",\n\t    &private, &comment)) == 0)\n\t\tpassphrase = xstrdup(\"\");\n\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t    identity_file, ssh_err(r));\n\telse {\n\t\tif (identity_passphrase)\n\t\t\tpassphrase = xstrdup(identity_passphrase);\n\t\telse if (identity_new_passphrase)\n\t\t\tpassphrase = xstrdup(identity_new_passphrase);\n\t\telse\n\t\t\tpassphrase = read_passphrase(\"Enter passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\t/* Try to load using the passphrase. */\n\t\tif ((r = sshkey_load_private(identity_file, passphrase,\n\t\t    &private, &comment)) != 0) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tfree(passphrase);\n\t\t\tfatal(\"Cannot load private key \\\"%s\\\": %s.\",\n\t\t\t    identity_file, ssh_err(r));\n\t\t}\n\t}\n\n\tif (private->type != KEY_ED25519 && private->type != KEY_XMSS &&\n\t    !use_new_format) {\n\t\terror(\"Comments are only supported for keys stored in \"\n\t\t    \"the new format (-o).\");\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\texit(1);\n\t}\n\tif (comment)\n\t\tprintf(\"Key now has comment '%s'\\n\", comment);\n\telse\n\t\tprintf(\"Key now has no comment\\n\");\n\n\tif (identity_comment) {\n\t\tstrlcpy(new_comment, identity_comment, sizeof(new_comment));\n\t} else {\n\t\tprintf(\"Enter new comment: \");\n\t\tfflush(stdout);\n\t\tif (!fgets(new_comment, sizeof(new_comment), stdin)) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tsshkey_free(private);\n\t\t\texit(1);\n\t\t}\n\t\tnew_comment[strcspn(new_comment, \"\\n\")] = '\\0';\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    new_comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tfree(passphrase);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\texplicit_bzero(passphrase, strlen(passphrase));\n\tfree(passphrase);\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\tsshkey_free(private);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tfd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\tfatal(\"Could not save your public key in %s\", identity_file);\n\tf = fdopen(fd, \"w\");\n\tif (f == NULL)\n\t\tfatal(\"fdopen %s failed: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_write(public, f)) != 0)\n\t\tfatal(\"write key failed: %s\", ssh_err(r));\n\tsshkey_free(public);\n\tfprintf(f, \" %s\\n\", new_comment);\n\tfclose(f);\n\n\tfree(comment);\n\n\tprintf(\"The comment in your key file has been changed.\\n\");\n\texit(0);\n}"
  },
  {
    "function_name": "do_print_resource_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1439-1461",
    "snippet": "static int\ndo_print_resource_record(struct passwd *pw, char *fname, char *hname)\n{\n\tstruct sshkey *public;\n\tchar *comment = NULL;\n\tstruct stat st;\n\tint r;\n\n\tif (fname == NULL)\n\t\tfatal(\"%s: no filename\", __func__);\n\tif (stat(fname, &st) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tfatal(\"%s: %s\", fname, strerror(errno));\n\t}\n\tif ((r = sshkey_load_public(fname, &public, &comment)) != 0)\n\t\tfatal(\"Failed to read v2 public key from \\\"%s\\\": %s.\",\n\t\t    fname, ssh_err(r));\n\texport_dns_rr(hname, public, stdout, print_generic);\n\tsshkey_free(public);\n\tfree(comment);\n\treturn 1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int print_generic = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "export_dns_rr",
          "args": [
            "hname",
            "public",
            "stdout",
            "print_generic"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "export_dns_rr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "319-356",
          "snippet": "int\nexport_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic)\n{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;\n\tu_int8_t dtype;\n\tu_char *rdata_digest;\n\tsize_t i, rdata_digest_len;\n\tint success = 0;\n\n\tfor (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {\n\t\trdata_digest_type = dtype;\n\t\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t\t    &rdata_digest, &rdata_digest_len, key)) {\n\t\t\tif (generic) {\n\t\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %zu %02x %02x \",\n\t\t\t\t    hostname, DNS_RDATATYPE_SSHFP,\n\t\t\t\t    2 + rdata_digest_len,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t}\n\t\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\t\tfprintf(f, \"\\n\");\n\t\t\tfree(rdata_digest); /* from sshkey_fingerprint_raw() */\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\t/* No SSHFP record was generated at all */\n\tif (success == 0) {\n\t\terror(\"%s: unsupported algorithm and/or digest_type\", __func__);\n\t}\n\n\treturn success;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nexport_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic)\n{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;\n\tu_int8_t dtype;\n\tu_char *rdata_digest;\n\tsize_t i, rdata_digest_len;\n\tint success = 0;\n\n\tfor (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {\n\t\trdata_digest_type = dtype;\n\t\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t\t    &rdata_digest, &rdata_digest_len, key)) {\n\t\t\tif (generic) {\n\t\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %zu %02x %02x \",\n\t\t\t\t    hostname, DNS_RDATATYPE_SSHFP,\n\t\t\t\t    2 + rdata_digest_len,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t}\n\t\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\t\tfprintf(f, \"\\n\");\n\t\t\tfree(rdata_digest); /* from sshkey_fingerprint_raw() */\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\t/* No SSHFP record was generated at all */\n\tif (success == 0) {\n\t\terror(\"%s: unsupported algorithm and/or digest_type\", __func__);\n\t}\n\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to read v2 public key from \\\"%s\\\": %s.\"",
            "fname",
            "ssh_err(r)"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "fname",
            "&public",
            "&comment"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&st"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no filename\"",
            "__func__"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint print_generic = 0;\n\nstatic int\ndo_print_resource_record(struct passwd *pw, char *fname, char *hname)\n{\n\tstruct sshkey *public;\n\tchar *comment = NULL;\n\tstruct stat st;\n\tint r;\n\n\tif (fname == NULL)\n\t\tfatal(\"%s: no filename\", __func__);\n\tif (stat(fname, &st) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tfatal(\"%s: %s\", fname, strerror(errno));\n\t}\n\tif ((r = sshkey_load_public(fname, &public, &comment)) != 0)\n\t\tfatal(\"Failed to read v2 public key from \\\"%s\\\": %s.\",\n\t\t    fname, ssh_err(r));\n\texport_dns_rr(hname, public, stdout, print_generic);\n\tsshkey_free(public);\n\tfree(comment);\n\treturn 1;\n}"
  },
  {
    "function_name": "do_change_passphrase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1355-1434",
    "snippet": "static void\ndo_change_passphrase(struct passwd *pw)\n{\n\tchar *comment;\n\tchar *old_passphrase, *passphrase1, *passphrase2;\n\tstruct stat st;\n\tstruct sshkey *private;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t/* Try to load the file with empty passphrase. */\n\tr = sshkey_load_private(identity_file, \"\", &private, &comment);\n\tif (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tif (identity_passphrase)\n\t\t\told_passphrase = xstrdup(identity_passphrase);\n\t\telse\n\t\t\told_passphrase =\n\t\t\t    read_passphrase(\"Enter old passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\tr = sshkey_load_private(identity_file, old_passphrase,\n\t\t    &private, &comment);\n\t\texplicit_bzero(old_passphrase, strlen(old_passphrase));\n\t\tfree(old_passphrase);\n\t\tif (r != 0)\n\t\t\tgoto badkey;\n\t} else if (r != 0) {\n badkey:\n\t\tfatal(\"Failed to load key %s: %s\", identity_file, ssh_err(r));\n\t}\n\tif (comment)\n\t\tmprintf(\"Key has comment '%s'\\n\", comment);\n\n\t/* Ask the new passphrase (twice). */\n\tif (identity_new_passphrase) {\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\t\tpassphrase2 = NULL;\n\t} else {\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter new passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\n\t\t/* Verify that they are the same. */\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Pass phrases do not match.  Try again.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Destroy the other copy. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s.\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\t/* Destroy the passphrase and the copy of the key in memory. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\tsshkey_free(private);\t\t /* Destroys contents */\n\tfree(comment);\n\n\tprintf(\"Your identification has been saved with the new passphrase.\\n\");\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "char *identity_passphrase = NULL;",
      "char *identity_new_passphrase = NULL;",
      "int use_new_format = 1;",
      "char *new_format_cipher = NULL;",
      "int rounds = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Your identification has been saved with the new passphrase.\\n\""
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "private"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passphrase1",
            "strlen(passphrase1)"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Saving key \\\"%s\\\" failed: %s.\"",
            "identity_file",
            "ssh_err(r)"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_save_private",
          "args": [
            "private",
            "identity_file",
            "passphrase1",
            "comment",
            "use_new_format",
            "new_format_cipher",
            "rounds"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_save_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "74-93",
          "snippet": "int\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase2"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase2"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase1"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "passphrase1",
            "passphrase2"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"Enter same passphrase again: \"",
            "RP_ALLOW_STDIN"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "identity_new_passphrase"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to load key %s: %s\"",
            "identity_file",
            "ssh_err(r)"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "old_passphrase"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_private",
          "args": [
            "identity_file",
            "old_passphrase",
            "&private",
            "&comment"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "227-262",
          "snippet": "int\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *identity_passphrase = NULL;\nchar *identity_new_passphrase = NULL;\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\n\nstatic void\ndo_change_passphrase(struct passwd *pw)\n{\n\tchar *comment;\n\tchar *old_passphrase, *passphrase1, *passphrase2;\n\tstruct stat st;\n\tstruct sshkey *private;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t/* Try to load the file with empty passphrase. */\n\tr = sshkey_load_private(identity_file, \"\", &private, &comment);\n\tif (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tif (identity_passphrase)\n\t\t\told_passphrase = xstrdup(identity_passphrase);\n\t\telse\n\t\t\told_passphrase =\n\t\t\t    read_passphrase(\"Enter old passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\tr = sshkey_load_private(identity_file, old_passphrase,\n\t\t    &private, &comment);\n\t\texplicit_bzero(old_passphrase, strlen(old_passphrase));\n\t\tfree(old_passphrase);\n\t\tif (r != 0)\n\t\t\tgoto badkey;\n\t} else if (r != 0) {\n badkey:\n\t\tfatal(\"Failed to load key %s: %s\", identity_file, ssh_err(r));\n\t}\n\tif (comment)\n\t\tmprintf(\"Key has comment '%s'\\n\", comment);\n\n\t/* Ask the new passphrase (twice). */\n\tif (identity_new_passphrase) {\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\t\tpassphrase2 = NULL;\n\t} else {\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter new passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\n\t\t/* Verify that they are the same. */\n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Pass phrases do not match.  Try again.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Destroy the other copy. */\n\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\tfree(passphrase2);\n\t}\n\n\t/* Save the file using the new passphrase. */\n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\terror(\"Saving key \\\"%s\\\" failed: %s.\",\n\t\t    identity_file, ssh_err(r));\n\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\tfree(passphrase1);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\t/* Destroy the passphrase and the copy of the key in memory. */\n\texplicit_bzero(passphrase1, strlen(passphrase1));\n\tfree(passphrase1);\n\tsshkey_free(private);\t\t /* Destroys contents */\n\tfree(comment);\n\n\tprintf(\"Your identification has been saved with the new passphrase.\\n\");\n\texit(0);\n}"
  },
  {
    "function_name": "do_known_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1256-1349",
    "snippet": "static void\ndo_known_hosts(struct passwd *pw, const char *name)\n{\n\tchar *cp, tmp[PATH_MAX], old[PATH_MAX];\n\tint r, fd, oerrno, inplace = 0;\n\tstruct known_hosts_ctx ctx;\n\tu_int foreach_options;\n\n\tif (!have_identity) {\n\t\tcp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);\n\t\tif (strlcpy(identity_file, cp, sizeof(identity_file)) >=\n\t\t    sizeof(identity_file))\n\t\t\tfatal(\"Specified known hosts path too long\");\n\t\tfree(cp);\n\t\thave_identity = 1;\n\t}\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.out = stdout;\n\tctx.host = name;\n\n\t/*\n\t * Find hosts goes to stdout, hash and deletions happen in-place\n\t * A corner case is ssh-keygen -HF foo, which should go to stdout\n\t */\n\tif (!find_host && (hash_hosts || delete_host)) {\n\t\tif (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcat(tmp, \".XXXXXXXXXX\", sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||\n\t\t    strlcat(old, \".old\", sizeof(old)) >= sizeof(old))\n\t\t\tfatal(\"known_hosts path too long\");\n\t\tumask(077);\n\t\tif ((fd = mkstemp(tmp)) == -1)\n\t\t\tfatal(\"mkstemp: %s\", strerror(errno));\n\t\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\t\toerrno = errno;\n\t\t\tunlink(tmp);\n\t\t\tfatal(\"fdopen: %s\", strerror(oerrno));\n\t\t}\n\t\tinplace = 1;\n\t}\n\t/* XXX support identity_file == \"-\" for stdin */\n\tforeach_options = find_host ? HKF_WANT_MATCH : 0;\n\tforeach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;\n\tif ((r = hostkeys_foreach(identity_file, (find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash, &ctx, name, NULL,\n\t    foreach_options)) != 0) {\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t\tfatal(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (inplace)\n\t\tfclose(ctx.out);\n\n\tif (ctx.invalid) {\n\t\terror(\"%s is not a valid known_hosts file.\", identity_file);\n\t\tif (inplace) {\n\t\t\terror(\"Not replacing existing known_hosts \"\n\t\t\t    \"file because of errors\");\n\t\t\tunlink(tmp);\n\t\t}\n\t\texit(1);\n\t} else if (delete_host && !ctx.found_key) {\n\t\tlogit(\"Host %s not found in %s\", name, identity_file);\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t} else if (inplace) {\n\t\t/* Backup existing file */\n\t\tif (unlink(old) == -1 && errno != ENOENT)\n\t\t\tfatal(\"unlink %.100s: %s\", old, strerror(errno));\n\t\tif (link(identity_file, old) == -1)\n\t\t\tfatal(\"link %.100s to %.100s: %s\", identity_file, old,\n\t\t\t    strerror(errno));\n\t\t/* Move new one into place */\n\t\tif (rename(tmp, identity_file) == -1) {\n\t\t\terror(\"rename\\\"%s\\\" to \\\"%s\\\": %s\", tmp, identity_file,\n\t\t\t    strerror(errno));\n\t\t\tunlink(tmp);\n\t\t\tunlink(old);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"%s updated.\\n\", identity_file);\n\t\tprintf(\"Original contents retained as %s\\n\", old);\n\t\tif (ctx.has_unhashed) {\n\t\t\tlogit(\"WARNING: %s contains unhashed entries\", old);\n\t\t\tlogit(\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\");\n\t\t}\n\t}\n\n\texit (find_host && !ctx.found_key);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int hash_hosts = 0;",
      "int find_host = 0;",
      "int delete_host = 0;",
      "int print_fingerprint = 0;",
      "char identity_file[1024];",
      "int have_identity = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "find_host && !ctx.found_key"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\""
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Original contents retained as %s\\n\"",
            "old"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "old"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"rename\\\"%s\\\" to \\\"%s\\\": %s\"",
            "tmp",
            "identity_file",
            "strerror(errno)"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tmp",
            "identity_file"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"link %.100s to %.100s: %s\"",
            "identity_file",
            "old",
            "strerror(errno)"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link",
          "args": [
            "identity_file",
            "old"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "do_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1026-1079",
          "snippet": "char *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "old"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "ctx.out"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostkeys_foreach",
          "args": [
            "identity_file",
            "(find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash",
            "&ctx",
            "name",
            "NULL",
            "foreach_options"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "661-834",
          "snippet": "int\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"fdopen: %s\"",
            "strerror(oerrno)"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"w\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "120-124",
          "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_FILE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "old",
            "\".old\"",
            "sizeof(old)"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "old",
            "identity_file",
            "sizeof(old)"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "_PATH_SSH_USER_HOSTFILE",
            "pw->pw_uid"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint hash_hosts = 0;\nint find_host = 0;\nint delete_host = 0;\nint print_fingerprint = 0;\nchar identity_file[1024];\nint have_identity = 0;\n\nstatic void\ndo_known_hosts(struct passwd *pw, const char *name)\n{\n\tchar *cp, tmp[PATH_MAX], old[PATH_MAX];\n\tint r, fd, oerrno, inplace = 0;\n\tstruct known_hosts_ctx ctx;\n\tu_int foreach_options;\n\n\tif (!have_identity) {\n\t\tcp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);\n\t\tif (strlcpy(identity_file, cp, sizeof(identity_file)) >=\n\t\t    sizeof(identity_file))\n\t\t\tfatal(\"Specified known hosts path too long\");\n\t\tfree(cp);\n\t\thave_identity = 1;\n\t}\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.out = stdout;\n\tctx.host = name;\n\n\t/*\n\t * Find hosts goes to stdout, hash and deletions happen in-place\n\t * A corner case is ssh-keygen -HF foo, which should go to stdout\n\t */\n\tif (!find_host && (hash_hosts || delete_host)) {\n\t\tif (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcat(tmp, \".XXXXXXXXXX\", sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||\n\t\t    strlcat(old, \".old\", sizeof(old)) >= sizeof(old))\n\t\t\tfatal(\"known_hosts path too long\");\n\t\tumask(077);\n\t\tif ((fd = mkstemp(tmp)) == -1)\n\t\t\tfatal(\"mkstemp: %s\", strerror(errno));\n\t\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\t\toerrno = errno;\n\t\t\tunlink(tmp);\n\t\t\tfatal(\"fdopen: %s\", strerror(oerrno));\n\t\t}\n\t\tinplace = 1;\n\t}\n\t/* XXX support identity_file == \"-\" for stdin */\n\tforeach_options = find_host ? HKF_WANT_MATCH : 0;\n\tforeach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;\n\tif ((r = hostkeys_foreach(identity_file, (find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash, &ctx, name, NULL,\n\t    foreach_options)) != 0) {\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t\tfatal(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t}\n\n\tif (inplace)\n\t\tfclose(ctx.out);\n\n\tif (ctx.invalid) {\n\t\terror(\"%s is not a valid known_hosts file.\", identity_file);\n\t\tif (inplace) {\n\t\t\terror(\"Not replacing existing known_hosts \"\n\t\t\t    \"file because of errors\");\n\t\t\tunlink(tmp);\n\t\t}\n\t\texit(1);\n\t} else if (delete_host && !ctx.found_key) {\n\t\tlogit(\"Host %s not found in %s\", name, identity_file);\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t} else if (inplace) {\n\t\t/* Backup existing file */\n\t\tif (unlink(old) == -1 && errno != ENOENT)\n\t\t\tfatal(\"unlink %.100s: %s\", old, strerror(errno));\n\t\tif (link(identity_file, old) == -1)\n\t\t\tfatal(\"link %.100s to %.100s: %s\", identity_file, old,\n\t\t\t    strerror(errno));\n\t\t/* Move new one into place */\n\t\tif (rename(tmp, identity_file) == -1) {\n\t\t\terror(\"rename\\\"%s\\\" to \\\"%s\\\": %s\", tmp, identity_file,\n\t\t\t    strerror(errno));\n\t\t\tunlink(tmp);\n\t\t\tunlink(old);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"%s updated.\\n\", identity_file);\n\t\tprintf(\"Original contents retained as %s\\n\", old);\n\t\tif (ctx.has_unhashed) {\n\t\t\tlogit(\"WARNING: %s contains unhashed entries\", old);\n\t\t\tlogit(\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\");\n\t\t}\n\t}\n\n\texit (find_host && !ctx.found_key);\n}"
  },
  {
    "function_name": "known_hosts_find_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1198-1254",
    "snippet": "static int\nknown_hosts_find_delete(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tif (l->status == HKF_STATUS_MATCHED) {\n\t\tif (delete_host) {\n\t\t\tif (l->marker != MRK_NONE) {\n\t\t\t\t/* Don't remove CA and revocation lines */\n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Hostname matches and has no CA/revoke\n\t\t\t\t * marker, delete it by *not* writing the\n\t\t\t\t * line to ctx->out.\n\t\t\t\t */\n\t\t\t\tctx->found_key = 1;\n\t\t\t\tif (!quiet)\n\t\t\t\t\tprintf(\"# Host %s found: line %lu\\n\",\n\t\t\t\t\t    ctx->host, l->linenum);\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (find_host) {\n\t\t\tctx->found_key = 1;\n\t\t\tif (!quiet) {\n\t\t\t\tprintf(\"# Host %s found: line %lu %s\\n\",\n\t\t\t\t    ctx->host,\n\t\t\t\t    l->linenum, l->marker == MRK_CA ? \"CA\" :\n\t\t\t\t    (l->marker == MRK_REVOKE ? \"REVOKED\" : \"\"));\n\t\t\t}\n\t\t\tif (hash_hosts)\n\t\t\t\tknown_hosts_hash(l, ctx);\n\t\t\telse if (print_fingerprint) {\n\t\t\t\tfp = sshkey_fingerprint(l->key, fptype, rep);\n\t\t\t\tmprintf(\"%s %s %s %s\\n\", ctx->host,\n\t\t\t\t    sshkey_type(l->key), fp, l->comment);\n\t\t\t\tfree(fp);\n\t\t\t} else\n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\treturn 0;\n\t\t}\n\t} else if (delete_host) {\n\t\t/* Retain non-matching hosts when deleting */\n\t\tif (l->status == HKF_STATUS_INVALID) {\n\t\t\tctx->invalid = 1;\n\t\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t}\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int quiet = 0;",
      "int hash_hosts = 0;",
      "int find_host = 0;",
      "int delete_host = 0;",
      "int print_fingerprint = 0;",
      "int print_bubblebabble = 0;",
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s\\n\"",
            "l->line"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s:%lu: invalid line\"",
            "l->path",
            "l->linenum"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s\\n\"",
            "l->line"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"%s %s %s %s\\n\"",
            "ctx->host",
            "sshkey_type(l->key)",
            "fp",
            "l->comment"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "l->key"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "l->key",
            "fptype",
            "rep"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "known_hosts_hash",
          "args": [
            "l",
            "ctx"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "known_hosts_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1147-1196",
          "snippet": "static int\nknown_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tchar *hashed, *cp, *hosts, *ohosts;\n\tint has_wild = l->hosts && strcspn(l->hosts, \"*?!\") != strlen(l->hosts);\n\tint was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;\n\n\tswitch (l->status) {\n\tcase HKF_STATUS_OK:\n\tcase HKF_STATUS_MATCHED:\n\t\t/*\n\t\t * Don't hash hosts already already hashed, with wildcard\n\t\t * characters or a CA/revocation marker.\n\t\t */\n\t\tif (was_hashed || has_wild || l->marker != MRK_NONE) {\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tif (has_wild && !find_host) {\n\t\t\t\tlogit(\"%s:%lu: ignoring host name \"\n\t\t\t\t    \"with wildcard: %.64s\", l->path,\n\t\t\t\t    l->linenum, l->hosts);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Split any comma-separated hostnames from the host list,\n\t\t * hash and store separately.\n\t\t */\n\t\tohosts = hosts = xstrdup(l->hosts);\n\t\twhile ((cp = strsep(&hosts, \",\")) != NULL && *cp != '\\0') {\n\t\t\tlowercase(cp);\n\t\t\tif ((hashed = host_hash(cp, NULL, 0)) == NULL)\n\t\t\t\tfatal(\"hash_host failed\");\n\t\t\tfprintf(ctx->out, \"%s %s\\n\", hashed, l->rawkey);\n\t\t\tctx->has_unhashed = 1;\n\t\t}\n\t\tfree(ohosts);\n\t\treturn 0;\n\tcase HKF_STATUS_INVALID:\n\t\t/* Retain invalid lines, but mark file as invalid. */\n\t\tctx->invalid = 1;\n\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int find_host = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint find_host = 0;\n\nstatic int\nknown_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tchar *hashed, *cp, *hosts, *ohosts;\n\tint has_wild = l->hosts && strcspn(l->hosts, \"*?!\") != strlen(l->hosts);\n\tint was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;\n\n\tswitch (l->status) {\n\tcase HKF_STATUS_OK:\n\tcase HKF_STATUS_MATCHED:\n\t\t/*\n\t\t * Don't hash hosts already already hashed, with wildcard\n\t\t * characters or a CA/revocation marker.\n\t\t */\n\t\tif (was_hashed || has_wild || l->marker != MRK_NONE) {\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tif (has_wild && !find_host) {\n\t\t\t\tlogit(\"%s:%lu: ignoring host name \"\n\t\t\t\t    \"with wildcard: %.64s\", l->path,\n\t\t\t\t    l->linenum, l->hosts);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Split any comma-separated hostnames from the host list,\n\t\t * hash and store separately.\n\t\t */\n\t\tohosts = hosts = xstrdup(l->hosts);\n\t\twhile ((cp = strsep(&hosts, \",\")) != NULL && *cp != '\\0') {\n\t\t\tlowercase(cp);\n\t\t\tif ((hashed = host_hash(cp, NULL, 0)) == NULL)\n\t\t\t\tfatal(\"hash_host failed\");\n\t\t\tfprintf(ctx->out, \"%s %s\\n\", hashed, l->rawkey);\n\t\t\tctx->has_unhashed = 1;\n\t\t}\n\t\tfree(ohosts);\n\t\treturn 0;\n\tcase HKF_STATUS_INVALID:\n\t\t/* Retain invalid lines, but mark file as invalid. */\n\t\tctx->invalid = 1;\n\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"# Host %s found: line %lu %s\\n\"",
            "ctx->host",
            "l->linenum",
            "l->marker == MRK_CA ? \"CA\" :\n\t\t\t\t    (l->marker == MRK_REVOKE ? \"REVOKED\" : \"\")"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s\\n\"",
            "l->line"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint quiet = 0;\nint hash_hosts = 0;\nint find_host = 0;\nint delete_host = 0;\nint print_fingerprint = 0;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic int\nknown_hosts_find_delete(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tif (l->status == HKF_STATUS_MATCHED) {\n\t\tif (delete_host) {\n\t\t\tif (l->marker != MRK_NONE) {\n\t\t\t\t/* Don't remove CA and revocation lines */\n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Hostname matches and has no CA/revoke\n\t\t\t\t * marker, delete it by *not* writing the\n\t\t\t\t * line to ctx->out.\n\t\t\t\t */\n\t\t\t\tctx->found_key = 1;\n\t\t\t\tif (!quiet)\n\t\t\t\t\tprintf(\"# Host %s found: line %lu\\n\",\n\t\t\t\t\t    ctx->host, l->linenum);\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (find_host) {\n\t\t\tctx->found_key = 1;\n\t\t\tif (!quiet) {\n\t\t\t\tprintf(\"# Host %s found: line %lu %s\\n\",\n\t\t\t\t    ctx->host,\n\t\t\t\t    l->linenum, l->marker == MRK_CA ? \"CA\" :\n\t\t\t\t    (l->marker == MRK_REVOKE ? \"REVOKED\" : \"\"));\n\t\t\t}\n\t\t\tif (hash_hosts)\n\t\t\t\tknown_hosts_hash(l, ctx);\n\t\t\telse if (print_fingerprint) {\n\t\t\t\tfp = sshkey_fingerprint(l->key, fptype, rep);\n\t\t\t\tmprintf(\"%s %s %s %s\\n\", ctx->host,\n\t\t\t\t    sshkey_type(l->key), fp, l->comment);\n\t\t\t\tfree(fp);\n\t\t\t} else\n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\treturn 0;\n\t\t}\n\t} else if (delete_host) {\n\t\t/* Retain non-matching hosts when deleting */\n\t\tif (l->status == HKF_STATUS_INVALID) {\n\t\t\tctx->invalid = 1;\n\t\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t}\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "known_hosts_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1147-1196",
    "snippet": "static int\nknown_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tchar *hashed, *cp, *hosts, *ohosts;\n\tint has_wild = l->hosts && strcspn(l->hosts, \"*?!\") != strlen(l->hosts);\n\tint was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;\n\n\tswitch (l->status) {\n\tcase HKF_STATUS_OK:\n\tcase HKF_STATUS_MATCHED:\n\t\t/*\n\t\t * Don't hash hosts already already hashed, with wildcard\n\t\t * characters or a CA/revocation marker.\n\t\t */\n\t\tif (was_hashed || has_wild || l->marker != MRK_NONE) {\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tif (has_wild && !find_host) {\n\t\t\t\tlogit(\"%s:%lu: ignoring host name \"\n\t\t\t\t    \"with wildcard: %.64s\", l->path,\n\t\t\t\t    l->linenum, l->hosts);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Split any comma-separated hostnames from the host list,\n\t\t * hash and store separately.\n\t\t */\n\t\tohosts = hosts = xstrdup(l->hosts);\n\t\twhile ((cp = strsep(&hosts, \",\")) != NULL && *cp != '\\0') {\n\t\t\tlowercase(cp);\n\t\t\tif ((hashed = host_hash(cp, NULL, 0)) == NULL)\n\t\t\t\tfatal(\"hash_host failed\");\n\t\t\tfprintf(ctx->out, \"%s %s\\n\", hashed, l->rawkey);\n\t\t\tctx->has_unhashed = 1;\n\t\t}\n\t\tfree(ohosts);\n\t\treturn 0;\n\tcase HKF_STATUS_INVALID:\n\t\t/* Retain invalid lines, but mark file as invalid. */\n\t\tctx->invalid = 1;\n\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n\treturn -1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int find_host = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s\\n\"",
            "l->line"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s:%lu: invalid line\"",
            "l->path",
            "l->linenum"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ohosts"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s %s\\n\"",
            "hashed",
            "l->rawkey"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"hash_host failed\""
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "host_hash",
          "args": [
            "cp",
            "NULL",
            "0"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "host_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "119-155",
          "snippet": "char *\nhost_hash(const char *host, const char *name_from_hostfile, u_int src_len)\n{\n\tstruct ssh_hmac_ctx *ctx;\n\tu_char salt[256], result[256];\n\tchar uu_salt[512], uu_result[512];\n\tstatic char encoded[1024];\n\tu_int len;\n\n\tlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\n\tif (name_from_hostfile == NULL) {\n\t\t/* Create new salt */\n\t\tarc4random_buf(salt, len);\n\t} else {\n\t\t/* Extract salt from known host entry */\n\t\tif (extract_salt(name_from_hostfile, src_len, salt,\n\t\t    sizeof(salt)) == -1)\n\t\t\treturn (NULL);\n\t}\n\n\tif ((ctx = ssh_hmac_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_hmac_init(ctx, salt, len) < 0 ||\n\t    ssh_hmac_update(ctx, host, strlen(host)) < 0 ||\n\t    ssh_hmac_final(ctx, result, sizeof(result)))\n\t\tfatal(\"%s: ssh_hmac failed\", __func__);\n\tssh_hmac_free(ctx);\n\n\tif (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 ||\n\t    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)\n\t\tfatal(\"%s: __b64_ntop failed\", __func__);\n\n\tsnprintf(encoded, sizeof(encoded), \"%s%s%c%s\", HASH_MAGIC, uu_salt,\n\t    HASH_DELIM, uu_result);\n\n\treturn (encoded);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nhost_hash(const char *host, const char *name_from_hostfile, u_int src_len)\n{\n\tstruct ssh_hmac_ctx *ctx;\n\tu_char salt[256], result[256];\n\tchar uu_salt[512], uu_result[512];\n\tstatic char encoded[1024];\n\tu_int len;\n\n\tlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\n\tif (name_from_hostfile == NULL) {\n\t\t/* Create new salt */\n\t\tarc4random_buf(salt, len);\n\t} else {\n\t\t/* Extract salt from known host entry */\n\t\tif (extract_salt(name_from_hostfile, src_len, salt,\n\t\t    sizeof(salt)) == -1)\n\t\t\treturn (NULL);\n\t}\n\n\tif ((ctx = ssh_hmac_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_hmac_init(ctx, salt, len) < 0 ||\n\t    ssh_hmac_update(ctx, host, strlen(host)) < 0 ||\n\t    ssh_hmac_final(ctx, result, sizeof(result)))\n\t\tfatal(\"%s: ssh_hmac failed\", __func__);\n\tssh_hmac_free(ctx);\n\n\tif (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 ||\n\t    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)\n\t\tfatal(\"%s: __b64_ntop failed\", __func__);\n\n\tsnprintf(encoded, sizeof(encoded), \"%s%s%c%s\", HASH_MAGIC, uu_salt,\n\t    HASH_DELIM, uu_result);\n\n\treturn (encoded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "cp"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&hosts",
            "\",\""
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "l->hosts"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ctx->out",
            "\"%s\\n\"",
            "l->line"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "l->hosts"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "l->hosts",
            "\"*?!\""
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint find_host = 0;\n\nstatic int\nknown_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tchar *hashed, *cp, *hosts, *ohosts;\n\tint has_wild = l->hosts && strcspn(l->hosts, \"*?!\") != strlen(l->hosts);\n\tint was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;\n\n\tswitch (l->status) {\n\tcase HKF_STATUS_OK:\n\tcase HKF_STATUS_MATCHED:\n\t\t/*\n\t\t * Don't hash hosts already already hashed, with wildcard\n\t\t * characters or a CA/revocation marker.\n\t\t */\n\t\tif (was_hashed || has_wild || l->marker != MRK_NONE) {\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tif (has_wild && !find_host) {\n\t\t\t\tlogit(\"%s:%lu: ignoring host name \"\n\t\t\t\t    \"with wildcard: %.64s\", l->path,\n\t\t\t\t    l->linenum, l->hosts);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Split any comma-separated hostnames from the host list,\n\t\t * hash and store separately.\n\t\t */\n\t\tohosts = hosts = xstrdup(l->hosts);\n\t\twhile ((cp = strsep(&hosts, \",\")) != NULL && *cp != '\\0') {\n\t\t\tlowercase(cp);\n\t\t\tif ((hashed = host_hash(cp, NULL, 0)) == NULL)\n\t\t\t\tfatal(\"hash_host failed\");\n\t\t\tfprintf(ctx->out, \"%s %s\\n\", hashed, l->rawkey);\n\t\t\tctx->has_unhashed = 1;\n\t\t}\n\t\tfree(ohosts);\n\t\treturn 0;\n\tcase HKF_STATUS_INVALID:\n\t\t/* Retain invalid lines, but mark file as invalid. */\n\t\tctx->invalid = 1;\n\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n\treturn -1;\n}"
  },
  {
    "function_name": "do_gen_all_hostkeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "1000-1137",
    "snippet": "static void\ndo_gen_all_hostkeys(struct passwd *pw)\n{\n\tstruct {\n\t\tchar *key_type;\n\t\tchar *key_type_display;\n\t\tchar *path;\n\t} key_types[] = {\n#ifdef WITH_OPENSSL\n\t\t{ \"rsa\", \"RSA\" ,_PATH_HOST_RSA_KEY_FILE },\n\t\t{ \"dsa\", \"DSA\", _PATH_HOST_DSA_KEY_FILE },\n#ifdef OPENSSL_HAS_ECC\n\t\t{ \"ecdsa\", \"ECDSA\",_PATH_HOST_ECDSA_KEY_FILE },\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t\t{ \"ed25519\", \"ED25519\",_PATH_HOST_ED25519_KEY_FILE },\n#ifdef WITH_XMSS\n\t\t{ \"xmss\", \"XMSS\",_PATH_HOST_XMSS_KEY_FILE },\n#endif /* WITH_XMSS */\n\t\t{ NULL, NULL, NULL }\n\t};\n\n\tint first = 0;\n\tstruct stat st;\n\tstruct sshkey *private, *public;\n\tchar comment[1024], *prv_tmp, *pub_tmp, *prv_file, *pub_file;\n\tint i, type, fd, r;\n\tFILE *f;\n\n\tfor (i = 0; key_types[i].key_type; i++) {\n\t\tpublic = private = NULL;\n\t\tprv_tmp = pub_tmp = prv_file = pub_file = NULL;\n\n\t\txasprintf(&prv_file, \"%s%s\",\n\t\t    identity_file, key_types[i].path);\n\n\t\t/* Check whether private key exists and is not zero-length */\n\t\tif (stat(prv_file, &st) == 0) {\n\t\t\tif (st.st_size != 0)\n\t\t\t\tgoto next;\n\t\t} else if (errno != ENOENT) {\n\t\t\terror(\"Could not stat %s: %s\", key_types[i].path,\n\t\t\t    strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/*\n\t\t * Private key doesn't exist or is invalid; proceed with\n\t\t * key generation.\n\t\t */\n\t\txasprintf(&prv_tmp, \"%s%s.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_tmp, \"%s%s.pub.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_file, \"%s%s.pub\",\n\t\t    identity_file, key_types[i].path);\n\n\t\tif (first == 0) {\n\t\t\tfirst = 1;\n\t\t\tprintf(\"%s: generating new host keys: \", __progname);\n\t\t}\n\t\tprintf(\"%s \", key_types[i].key_type_display);\n\t\tfflush(stdout);\n\t\ttype = sshkey_type_from_name(key_types[i].key_type);\n\t\tif ((fd = mkstemp(prv_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    prv_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tclose(fd); /* just using mkstemp() to generate/reserve a name */\n\t\tbits = 0;\n\t\ttype_bits_valid(type, NULL, &bits);\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0) {\n\t\t\terror(\"sshkey_generate failed: %s\", ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name,\n\t\t    hostname);\n\t\tif ((r = sshkey_save_private(private, prv_tmp, \"\",\n\t\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t\t    prv_tmp, ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((fd = mkstemp(pub_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    pub_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)fchmod(fd, 0644);\n\t\tf = fdopen(fd, \"w\");\n\t\tif (f == NULL) {\n\t\t\terror(\"fdopen %s failed: %s\", pub_tmp, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_write(public, f)) != 0) {\n\t\t\terror(\"write key failed: %s\", ssh_err(r));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tif (ferror(f) != 0) {\n\t\t\terror(\"write key failed: %s\", strerror(errno));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (fclose(f) != 0) {\n\t\t\terror(\"key close failed: %s\", strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/* Rename temporary files to their permanent locations. */\n\t\tif (rename(pub_tmp, pub_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    pub_file, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (rename(prv_tmp, prv_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    key_types[i].path, strerror(errno));\n failnext:\n\t\t\tfirst = 0;\n\t\t\tgoto next;\n\t\t}\n next:\n\t\tsshkey_free(private);\n\t\tsshkey_free(public);\n\t\tfree(prv_tmp);\n\t\tfree(pub_tmp);\n\t\tfree(prv_file);\n\t\tfree(pub_file);\n\t}\n\tif (first != 0)\n\t\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t bits = 0;",
      "char identity_file[1024];",
      "int use_new_format = 1;",
      "char *new_format_cipher = NULL;",
      "int rounds = 0;",
      "extern char *__progname;",
      "char hostname[NI_MAXHOST];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pub_file"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to move %s into position: %s\"",
            "key_types[i].path",
            "strerror(errno)"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "prv_tmp",
            "prv_file"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "pub_tmp",
            "pub_file"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "f"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\\n\"",
            "comment"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "public",
            "f"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"w\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "0644"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "pub_tmp"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "120-124",
          "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_FILE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_save_private",
          "args": [
            "private",
            "prv_tmp",
            "\"\"",
            "comment",
            "use_new_format",
            "new_format_cipher",
            "rounds"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_save_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "74-93",
          "snippet": "int\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "comment",
            "sizeof comment",
            "\"%s@%s\"",
            "pw->pw_name",
            "hostname"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_from_private failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "private",
            "&public"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_generate",
          "args": [
            "type",
            "bits",
            "&private"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1605-1654",
          "snippet": "int\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_bits_valid",
          "args": [
            "type",
            "NULL",
            "&bits"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "type_bits_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "205-253",
          "snippet": "static void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DEFAULT_BITS_ECDSA\t256",
            "#define DEFAULT_BITS_DSA\t1024",
            "#define DEFAULT_BITS\t\t2048"
          ],
          "globals_used": [
            "u_int32_t bits = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define DEFAULT_BITS_ECDSA\t256\n#define DEFAULT_BITS_DSA\t1024\n#define DEFAULT_BITS\t\t2048\n\nu_int32_t bits = 0;\nchar *key_type_name = NULL;\n\nstatic void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "key_types[i].key_type"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s \"",
            "key_types[i].key_type_display"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "prv_file",
            "&st"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t bits = 0;\nchar identity_file[1024];\nint use_new_format = 1;\nchar *new_format_cipher = NULL;\nint rounds = 0;\nextern char *__progname;\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_gen_all_hostkeys(struct passwd *pw)\n{\n\tstruct {\n\t\tchar *key_type;\n\t\tchar *key_type_display;\n\t\tchar *path;\n\t} key_types[] = {\n#ifdef WITH_OPENSSL\n\t\t{ \"rsa\", \"RSA\" ,_PATH_HOST_RSA_KEY_FILE },\n\t\t{ \"dsa\", \"DSA\", _PATH_HOST_DSA_KEY_FILE },\n#ifdef OPENSSL_HAS_ECC\n\t\t{ \"ecdsa\", \"ECDSA\",_PATH_HOST_ECDSA_KEY_FILE },\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t\t{ \"ed25519\", \"ED25519\",_PATH_HOST_ED25519_KEY_FILE },\n#ifdef WITH_XMSS\n\t\t{ \"xmss\", \"XMSS\",_PATH_HOST_XMSS_KEY_FILE },\n#endif /* WITH_XMSS */\n\t\t{ NULL, NULL, NULL }\n\t};\n\n\tint first = 0;\n\tstruct stat st;\n\tstruct sshkey *private, *public;\n\tchar comment[1024], *prv_tmp, *pub_tmp, *prv_file, *pub_file;\n\tint i, type, fd, r;\n\tFILE *f;\n\n\tfor (i = 0; key_types[i].key_type; i++) {\n\t\tpublic = private = NULL;\n\t\tprv_tmp = pub_tmp = prv_file = pub_file = NULL;\n\n\t\txasprintf(&prv_file, \"%s%s\",\n\t\t    identity_file, key_types[i].path);\n\n\t\t/* Check whether private key exists and is not zero-length */\n\t\tif (stat(prv_file, &st) == 0) {\n\t\t\tif (st.st_size != 0)\n\t\t\t\tgoto next;\n\t\t} else if (errno != ENOENT) {\n\t\t\terror(\"Could not stat %s: %s\", key_types[i].path,\n\t\t\t    strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/*\n\t\t * Private key doesn't exist or is invalid; proceed with\n\t\t * key generation.\n\t\t */\n\t\txasprintf(&prv_tmp, \"%s%s.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_tmp, \"%s%s.pub.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_file, \"%s%s.pub\",\n\t\t    identity_file, key_types[i].path);\n\n\t\tif (first == 0) {\n\t\t\tfirst = 1;\n\t\t\tprintf(\"%s: generating new host keys: \", __progname);\n\t\t}\n\t\tprintf(\"%s \", key_types[i].key_type_display);\n\t\tfflush(stdout);\n\t\ttype = sshkey_type_from_name(key_types[i].key_type);\n\t\tif ((fd = mkstemp(prv_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    prv_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tclose(fd); /* just using mkstemp() to generate/reserve a name */\n\t\tbits = 0;\n\t\ttype_bits_valid(type, NULL, &bits);\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0) {\n\t\t\terror(\"sshkey_generate failed: %s\", ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\t\tfatal(\"sshkey_from_private failed: %s\", ssh_err(r));\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name,\n\t\t    hostname);\n\t\tif ((r = sshkey_save_private(private, prv_tmp, \"\",\n\t\t    comment, use_new_format, new_format_cipher, rounds)) != 0) {\n\t\t\terror(\"Saving key \\\"%s\\\" failed: %s\",\n\t\t\t    prv_tmp, ssh_err(r));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((fd = mkstemp(pub_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    pub_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)fchmod(fd, 0644);\n\t\tf = fdopen(fd, \"w\");\n\t\tif (f == NULL) {\n\t\t\terror(\"fdopen %s failed: %s\", pub_tmp, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_write(public, f)) != 0) {\n\t\t\terror(\"write key failed: %s\", ssh_err(r));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tfprintf(f, \" %s\\n\", comment);\n\t\tif (ferror(f) != 0) {\n\t\t\terror(\"write key failed: %s\", strerror(errno));\n\t\t\tfclose(f);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (fclose(f) != 0) {\n\t\t\terror(\"key close failed: %s\", strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t/* Rename temporary files to their permanent locations. */\n\t\tif (rename(pub_tmp, pub_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    pub_file, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (rename(prv_tmp, prv_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    key_types[i].path, strerror(errno));\n failnext:\n\t\t\tfirst = 0;\n\t\t\tgoto next;\n\t\t}\n next:\n\t\tsshkey_free(private);\n\t\tsshkey_free(public);\n\t\tfree(prv_tmp);\n\t\tfree(pub_tmp);\n\t\tfree(prv_file);\n\t\tfree(pub_file);\n\t}\n\tif (first != 0)\n\t\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "do_fingerprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "904-998",
    "snippet": "static void\ndo_fingerprint(struct passwd *pw)\n{\n\tFILE *f;\n\tstruct sshkey *public = NULL;\n\tchar *comment = NULL, *cp, *ep, *line = NULL;\n\tsize_t linesize = 0;\n\tint i, invalid = 1;\n\tconst char *path;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tpath = identity_file;\n\n\tif (strcmp(identity_file, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t} else if ((f = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, path, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tcp = line;\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Input may be plain keys, private keys, authorized_keys\n\t\t * or known_hosts.\n\t\t */\n\n\t\t/*\n\t\t * Try private keys first. Assume a key is private if\n\t\t * \"SSH PRIVATE KEY\" appears on the first line and we're\n\t\t * not reading from stdin (XXX support private keys on stdin).\n\t\t */\n\t\tif (lnum == 1 && strcmp(identity_file, \"-\") != 0 &&\n\t\t    strstr(cp, \"PRIVATE KEY\") != NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(f);\n\t\t\tfingerprint_private(path);\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * If it's not a private key, then this must be prepared to\n\t\t * accept a public key prefixed with a hostname or options.\n\t\t * Try a bare key first, otherwise skip the leading stuff.\n\t\t */\n\t\tif ((public = try_read_key(&cp)) == NULL) {\n\t\t\ti = strtol(cp, &ep, 10);\n\t\t\tif (i == 0 || ep == NULL ||\n\t\t\t    (*ep != ' ' && *ep != '\\t')) {\n\t\t\t\tint quoted = 0;\n\n\t\t\t\tcomment = cp;\n\t\t\t\tfor (; *cp && (quoted || (*cp != ' ' &&\n\t\t\t\t    *cp != '\\t')); cp++) {\n\t\t\t\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\t\t\t\tcp++;\t/* Skip both */\n\t\t\t\t\telse if (*cp == '\"')\n\t\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tif (!*cp)\n\t\t\t\t\tcontinue;\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t}\n\t\t/* Retry after parsing leading hostname/key options */\n\t\tif (public == NULL && (public = try_read_key(&cp)) == NULL) {\n\t\t\tdebug(\"%s:%lu: not a public key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find trailing comment, if any */\n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp != '\\0' && *cp != '#')\n\t\t\tcomment = cp;\n\n\t\tfingerprint_one_key(public, comment);\n\t\tsshkey_free(public);\n\t\tinvalid = 0; /* One good key in the file is sufficient */\n\t}\n\tfclose(f);\n\tfree(line);\n\n\tif (invalid)\n\t\tfatal(\"%s is not a public key file.\", path);\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "extern char *__progname;",
      "char hostname[NI_MAXHOST];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s is not a public key file.\"",
            "path"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_one_key",
          "args": [
            "public",
            "comment"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_one_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "859-878",
          "snippet": "static void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int log_level = SYSLOG_LEVEL_INFO;",
            "int print_bubblebabble = 0;",
            "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint log_level = SYSLOG_LEVEL_INFO;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s:%lu: not a public key\"",
            "path",
            "lnum"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_read_key",
          "args": [
            "&cp"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "try_read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "844-857",
          "snippet": "static struct sshkey *\ntry_read_key(char **cpp)\n{\n\tstruct sshkey *ret;\n\tint r;\n\n\tif ((ret = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tif ((r = sshkey_read(ret, cpp)) == 0)\n\t\treturn ret;\n\t/* Not a key */\n\tsshkey_free(ret);\n\treturn NULL;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey *\ntry_read_key(char **cpp)\n{\n\tstruct sshkey *ret;\n\tint r;\n\n\tif ((ret = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tif ((r = sshkey_read(ret, cpp)) == 0)\n\t\treturn ret;\n\t/* Not a key */\n\tsshkey_free(ret);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "cp",
            "&ep",
            "10"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_private",
          "args": [
            "path"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "880-902",
          "snippet": "static void\nfingerprint_private(const char *path)\n{\n\tstruct stat st;\n\tchar *comment = NULL;\n\tstruct sshkey *public = NULL;\n\tint r;\n\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_public(path, &public, &comment)) != 0) {\n\t\tdebug(\"load public \\\"%s\\\": %s\", path, ssh_err(r));\n\t\tif ((r = sshkey_load_private(path, NULL,\n\t\t    &public, &comment)) != 0) {\n\t\t\tdebug(\"load private \\\"%s\\\": %s\", path, ssh_err(r));\n\t\t\tfatal(\"%s is not a key file.\", path);\n\t\t}\n\t}\n\n\tfingerprint_one_key(public, comment);\n\tsshkey_free(public);\n\tfree(comment);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\n\nstatic void\nfingerprint_private(const char *path)\n{\n\tstruct stat st;\n\tchar *comment = NULL;\n\tstruct sshkey *public = NULL;\n\tint r;\n\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_public(path, &public, &comment)) != 0) {\n\t\tdebug(\"load public \\\"%s\\\": %s\", path, ssh_err(r));\n\t\tif ((r = sshkey_load_private(path, NULL,\n\t\t    &public, &comment)) != 0) {\n\t\t\tdebug(\"load private \\\"%s\\\": %s\", path, ssh_err(r));\n\t\t\tfatal(\"%s is not a key file.\", path);\n\t\t}\n\t}\n\n\tfingerprint_one_key(public, comment);\n\tsshkey_free(public);\n\tfree(comment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "\"PRIVATE KEY\""
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "identity_file",
            "\"-\""
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "line",
            "\" \\t\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "cp",
            "\"\\n\""
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s: %s\"",
            "__progname",
            "path",
            "strerror(errno)"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nextern char *__progname;\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_fingerprint(struct passwd *pw)\n{\n\tFILE *f;\n\tstruct sshkey *public = NULL;\n\tchar *comment = NULL, *cp, *ep, *line = NULL;\n\tsize_t linesize = 0;\n\tint i, invalid = 1;\n\tconst char *path;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tpath = identity_file;\n\n\tif (strcmp(identity_file, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t} else if ((f = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, path, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tcp = line;\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\t\t/* Trim leading space and comments */\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Input may be plain keys, private keys, authorized_keys\n\t\t * or known_hosts.\n\t\t */\n\n\t\t/*\n\t\t * Try private keys first. Assume a key is private if\n\t\t * \"SSH PRIVATE KEY\" appears on the first line and we're\n\t\t * not reading from stdin (XXX support private keys on stdin).\n\t\t */\n\t\tif (lnum == 1 && strcmp(identity_file, \"-\") != 0 &&\n\t\t    strstr(cp, \"PRIVATE KEY\") != NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(f);\n\t\t\tfingerprint_private(path);\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * If it's not a private key, then this must be prepared to\n\t\t * accept a public key prefixed with a hostname or options.\n\t\t * Try a bare key first, otherwise skip the leading stuff.\n\t\t */\n\t\tif ((public = try_read_key(&cp)) == NULL) {\n\t\t\ti = strtol(cp, &ep, 10);\n\t\t\tif (i == 0 || ep == NULL ||\n\t\t\t    (*ep != ' ' && *ep != '\\t')) {\n\t\t\t\tint quoted = 0;\n\n\t\t\t\tcomment = cp;\n\t\t\t\tfor (; *cp && (quoted || (*cp != ' ' &&\n\t\t\t\t    *cp != '\\t')); cp++) {\n\t\t\t\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\t\t\t\tcp++;\t/* Skip both */\n\t\t\t\t\telse if (*cp == '\"')\n\t\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tif (!*cp)\n\t\t\t\t\tcontinue;\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t}\n\t\t/* Retry after parsing leading hostname/key options */\n\t\tif (public == NULL && (public = try_read_key(&cp)) == NULL) {\n\t\t\tdebug(\"%s:%lu: not a public key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find trailing comment, if any */\n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp != '\\0' && *cp != '#')\n\t\t\tcomment = cp;\n\n\t\tfingerprint_one_key(public, comment);\n\t\tsshkey_free(public);\n\t\tinvalid = 0; /* One good key in the file is sufficient */\n\t}\n\tfclose(f);\n\tfree(line);\n\n\tif (invalid)\n\t\tfatal(\"%s is not a public key file.\", path);\n\texit(0);\n}"
  },
  {
    "function_name": "fingerprint_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "880-902",
    "snippet": "static void\nfingerprint_private(const char *path)\n{\n\tstruct stat st;\n\tchar *comment = NULL;\n\tstruct sshkey *public = NULL;\n\tint r;\n\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_public(path, &public, &comment)) != 0) {\n\t\tdebug(\"load public \\\"%s\\\": %s\", path, ssh_err(r));\n\t\tif ((r = sshkey_load_private(path, NULL,\n\t\t    &public, &comment)) != 0) {\n\t\t\tdebug(\"load private \\\"%s\\\": %s\", path, ssh_err(r));\n\t\t\tfatal(\"%s is not a key file.\", path);\n\t\t}\n\t}\n\n\tfingerprint_one_key(public, comment);\n\tsshkey_free(public);\n\tfree(comment);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "public"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fingerprint_one_key",
          "args": [
            "public",
            "comment"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "fingerprint_one_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "859-878",
          "snippet": "static void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int log_level = SYSLOG_LEVEL_INFO;",
            "int print_bubblebabble = 0;",
            "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint log_level = SYSLOG_LEVEL_INFO;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s is not a key file.\"",
            "path"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"load private \\\"%s\\\": %s\"",
            "path",
            "ssh_err(r)"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_private",
          "args": [
            "path",
            "NULL",
            "&public",
            "&comment"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "227-262",
          "snippet": "int\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "path",
            "&public",
            "&comment"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "path",
            "strerror(errno)"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\n\nstatic void\nfingerprint_private(const char *path)\n{\n\tstruct stat st;\n\tchar *comment = NULL;\n\tstruct sshkey *public = NULL;\n\tint r;\n\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_public(path, &public, &comment)) != 0) {\n\t\tdebug(\"load public \\\"%s\\\": %s\", path, ssh_err(r));\n\t\tif ((r = sshkey_load_private(path, NULL,\n\t\t    &public, &comment)) != 0) {\n\t\t\tdebug(\"load private \\\"%s\\\": %s\", path, ssh_err(r));\n\t\t\tfatal(\"%s is not a key file.\", path);\n\t\t}\n\t}\n\n\tfingerprint_one_key(public, comment);\n\tsshkey_free(public);\n\tfree(comment);\n}"
  },
  {
    "function_name": "fingerprint_one_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "859-878",
    "snippet": "static void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int log_level = SYSLOG_LEVEL_INFO;",
      "int print_bubblebabble = 0;",
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "ra"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"%u %s %s (%s)\\n\"",
            "sshkey_size(public)",
            "fp",
            "comment ? comment : \"no comment\"",
            "sshkey_type(public)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "public"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_size",
          "args": [
            "public"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "283-315",
          "snippet": "u_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint failed\"",
            "__func__"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "public",
            "fingerprint_hash",
            "SSH_FP_RANDOMART"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint log_level = SYSLOG_LEVEL_INFO;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}"
  },
  {
    "function_name": "try_read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "844-857",
    "snippet": "static struct sshkey *\ntry_read_key(char **cpp)\n{\n\tstruct sshkey *ret;\n\tint r;\n\n\tif ((ret = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tif ((r = sshkey_read(ret, cpp)) == 0)\n\t\treturn ret;\n\t/* Not a key */\n\tsshkey_free(ret);\n\treturn NULL;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "ret"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_read",
          "args": [
            "ret",
            "cpp"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1219-1379",
          "snippet": "int\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tswitch (ret->type) {\n\tcase KEY_UNSPEC:\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_ED25519:\n\tcase KEY_DSA_CERT:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_RSA_CERT:\n\tcase KEY_ED25519_CERT:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n#endif /* WITH_XMSS */\n\t\tbreak; /* ok */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\n\t/* Decode type */\n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t/* skip whitespace */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t/* find end of keyblob and decode */\n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t/* skip whitespace and leave cp at start of comment */\n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t/* ensure type of blob matches type at start of line */\n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t/* Fill in ret from parsed key */\n\tret->type = type;\n\tif (sshkey_is_cert(ret)) {\n\t\tif (!sshkey_is_cert(k)) {\n\t\t\tsshkey_free(k);\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\t}\n\t\tif (ret->cert != NULL)\n\t\t\tcert_free(ret->cert);\n\t\tret->cert = k->cert;\n\t\tk->cert = NULL;\n\t}\n\tswitch (sshkey_type_plain(ret->type)) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tRSA_free(ret->rsa);\n\t\tret->rsa = k->rsa;\n\t\tk->rsa = NULL;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, ret->rsa, 8);\n#endif\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tDSA_free(ret->dsa);\n\t\tret->dsa = k->dsa;\n\t\tk->dsa = NULL;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, ret->dsa, 8);\n#endif\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tEC_KEY_free(ret->ecdsa);\n\t\tret->ecdsa = k->ecdsa;\n\t\tret->ecdsa_nid = k->ecdsa_nid;\n\t\tk->ecdsa = NULL;\n\t\tk->ecdsa_nid = -1;\n#ifdef DEBUG_PK\n\t\tsshkey_dump_ec_key(ret->ecdsa);\n#endif\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tfreezero(ret->ed25519_pk, ED25519_PK_SZ);\n\t\tret->ed25519_pk = k->ed25519_pk;\n\t\tk->ed25519_pk = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tfree(ret->xmss_pk);\n\t\tret->xmss_pk = k->xmss_pk;\n\t\tk->xmss_pk = NULL;\n\t\tfree(ret->xmss_state);\n\t\tret->xmss_state = k->xmss_state;\n\t\tk->xmss_state = NULL;\n\t\tfree(ret->xmss_name);\n\t\tret->xmss_name = k->xmss_name;\n\t\tk->xmss_name = NULL;\n\t\tfree(ret->xmss_filename);\n\t\tret->xmss_filename = k->xmss_filename;\n\t\tk->xmss_filename = NULL;\n#ifdef DEBUG_PK\n\t\t/* XXX */\n#endif\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tsshkey_free(k);\n\n\t/* success */\n\t*cpp = cp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_new failed\""
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey *\ntry_read_key(char **cpp)\n{\n\tstruct sshkey *ret;\n\tint r;\n\n\tif ((ret = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tif ((r = sshkey_read(ret, cpp)) == 0)\n\t\treturn ret;\n\t/* Not a key */\n\tsshkey_free(ret);\n\treturn NULL;\n}"
  },
  {
    "function_name": "do_download",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "800-842",
    "snippet": "static void\ndo_download(struct passwd *pw)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tint i, nkeys;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp, *ra;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tpkcs11_init(0);\n\tnkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (print_fingerprint) {\n\t\t\tfp = sshkey_fingerprint(keys[i], fptype, rep);\n\t\t\tra = sshkey_fingerprint(keys[i], fingerprint_hash,\n\t\t\t    SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tprintf(\"%u %s %s (PKCS11 key)\\n\", sshkey_size(keys[i]),\n\t\t\t    fp, sshkey_type(keys[i]));\n\t\t\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\t(void) sshkey_write(keys[i], stdout); /* XXX check */\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tpkcs11_terminate();\n\texit(0);\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int log_level = SYSLOG_LEVEL_INFO;",
      "int print_fingerprint = 0;",
      "int print_bubblebabble = 0;",
      "int fingerprint_hash = SSH_FP_HASH_DEFAULT;",
      "char *pkcs11provider = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"no pkcs11 support\""
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_terminate",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "108-113",
          "snippet": "void\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keys"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "keys[i]"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "keys[i]",
            "stdout"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "ra"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "keys[i]"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_size",
          "args": [
            "keys[i]"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "283-315",
          "snippet": "u_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint fail\"",
            "__func__"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "keys[i]",
            "fingerprint_hash",
            "SSH_FP_RANDOMART"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_add_provider",
          "args": [
            "pkcs11provider",
            "NULL",
            "&keys"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_add_provider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "203-246",
          "snippet": "int\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_init",
          "args": [
            "0"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "102-106",
          "snippet": "int\npkcs11_init(int interactive)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_init(int interactive)\n{\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint log_level = SYSLOG_LEVEL_INFO;\nint print_fingerprint = 0;\nint print_bubblebabble = 0;\nint fingerprint_hash = SSH_FP_HASH_DEFAULT;\nchar *pkcs11provider = NULL;\n\nstatic void\ndo_download(struct passwd *pw)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tint i, nkeys;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp, *ra;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tpkcs11_init(0);\n\tnkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (print_fingerprint) {\n\t\t\tfp = sshkey_fingerprint(keys[i], fptype, rep);\n\t\t\tra = sshkey_fingerprint(keys[i], fingerprint_hash,\n\t\t\t    SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tprintf(\"%u %s %s (PKCS11 key)\\n\", sshkey_size(keys[i]),\n\t\t\t    fp, sshkey_type(keys[i]));\n\t\t\tif (log_level >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\t(void) sshkey_write(keys[i], stdout); /* XXX check */\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tpkcs11_terminate();\n\texit(0);\n#else\n\tfatal(\"no pkcs11 support\");\n#endif /* ENABLE_PKCS11 */\n}"
  },
  {
    "function_name": "do_print_public",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "781-798",
    "snippet": "static void\ndo_print_public(struct passwd *pw)\n{\n\tstruct sshkey *prv;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tprv = load_identity(identity_file);\n\tif ((r = sshkey_write(prv, stdout)) != 0)\n\t\terror(\"sshkey_write failed: %s\", ssh_err(r));\n\tsshkey_free(prv);\n\tfprintf(stdout, \"\\n\");\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "prv"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"sshkey_write failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "prv",
            "stdout"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_identity",
          "args": [
            "identity_file"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "load_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "303-324",
          "snippet": "static struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *identity_passphrase = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\n\nstatic struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "identity_file",
            "strerror(errno)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\n\nstatic void\ndo_print_public(struct passwd *pw)\n{\n\tstruct sshkey *prv;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tprv = load_identity(identity_file);\n\tif ((r = sshkey_write(prv, stdout)) != 0)\n\t\terror(\"sshkey_write failed: %s\", ssh_err(r));\n\tsshkey_free(prv);\n\tfprintf(stdout, \"\\n\");\n\texit(0);\n}"
  },
  {
    "function_name": "do_convert_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "721-778",
    "snippet": "static void\ndo_convert_from(struct passwd *pw)\n{\n\tstruct sshkey *k = NULL;\n\tint r, private = 0, ok = 0;\n\tstruct stat st;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_from_ssh2(pw, &k, &private);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_from_pkcs8(&k, &private);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_from_pem(&k, &private);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\n\tif (!private) {\n\t\tif ((r = sshkey_write(k, stdout)) == 0)\n\t\t\tok = 1;\n\t\tif (ok)\n\t\t\tfprintf(stdout, \"\\n\");\n\t} else {\n\t\tswitch (k->type) {\n\t\tcase KEY_DSA:\n\t\t\tok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA:\n\t\t\tok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA:\n\t\t\tok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unsupported key type %s\", __func__,\n\t\t\t    sshkey_type(k));\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tfatal(\"key write failed\");\n\tsshkey_free(k);\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "enum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"key write failed\""
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEM_write_RSAPrivateKey",
          "args": [
            "stdout",
            "k->rsa",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_ECPrivateKey",
          "args": [
            "stdout",
            "k->ecdsa",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_DSAPrivateKey",
          "args": [
            "stdout",
            "k->dsa",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_write",
          "args": [
            "k",
            "stdout"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1428-1449",
          "snippet": "int\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t/* Success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_from_pem",
          "args": [
            "&k",
            "&private"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_from_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "702-719",
          "snippet": "static void\ndo_convert_from_pem(struct sshkey **k, int *private)\n{\n\tFILE *fp;\n\tRSA *rsa;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = rsa;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfatal(\"%s: unrecognised raw private key format\", __func__);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_pem(struct sshkey **k, int *private)\n{\n\tFILE *fp;\n\tRSA *rsa;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = rsa;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfatal(\"%s: unrecognised raw private key format\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_from_pkcs8",
          "args": [
            "&k",
            "&private"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_from_pkcs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "659-700",
          "snippet": "static void\ndo_convert_from_pkcs8(struct sshkey **k, int *private)\n{\n\tEVP_PKEY *pubkey;\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {\n\t\tfatal(\"%s: %s is not a recognised public key format\", __func__,\n\t\t    identity_file);\n\t}\n\tfclose(fp);\n\tswitch (EVP_PKEY_base_id(pubkey)) {\n\tcase EVP_PKEY_RSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);\n\t\tbreak;\n\tcase EVP_PKEY_DSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_DSA;\n\t\t(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase EVP_PKEY_EC:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_ECDSA;\n\t\t(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);\n\t\t(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported pubkey type %d\", __func__,\n\t\t    EVP_PKEY_base_id(pubkey));\n\t}\n\tEVP_PKEY_free(pubkey);\n\treturn;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_pkcs8(struct sshkey **k, int *private)\n{\n\tEVP_PKEY *pubkey;\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {\n\t\tfatal(\"%s: %s is not a recognised public key format\", __func__,\n\t\t    identity_file);\n\t}\n\tfclose(fp);\n\tswitch (EVP_PKEY_base_id(pubkey)) {\n\tcase EVP_PKEY_RSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);\n\t\tbreak;\n\tcase EVP_PKEY_DSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_DSA;\n\t\t(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase EVP_PKEY_EC:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_ECDSA;\n\t\t(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);\n\t\t(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported pubkey type %d\", __func__,\n\t\t    EVP_PKEY_base_id(pubkey));\n\t}\n\tEVP_PKEY_free(pubkey);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_from_ssh2",
          "args": [
            "pw",
            "&k",
            "&private"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_from_ssh2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "610-657",
          "snippet": "static void\ndo_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)\n{\n\tint r, blen, escaped = 0;\n\tu_int len;\n\tchar line[1024];\n\tu_char blob[8096];\n\tchar encoded[8096];\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tencoded[0] = '\\0';\n\twhile ((blen = get_line(fp, line, sizeof(line))) != -1) {\n\t\tif (blen > 0 && line[blen - 1] == '\\\\')\n\t\t\tescaped++;\n\t\tif (strncmp(line, \"----\", 4) == 0 ||\n\t\t    strstr(line, \": \") != NULL) {\n\t\t\tif (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)\n\t\t\t\t*private = 1;\n\t\t\tif (strstr(line, \" END \") != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fprintf(stderr, \"ignore: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tif (escaped) {\n\t\t\tescaped--;\n\t\t\t/* fprintf(stderr, \"escaped: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tstrlcat(encoded, line, sizeof(encoded));\n\t}\n\tlen = strlen(encoded);\n\tif (((len % 4) == 3) &&\n\t    (encoded[len-1] == '=') &&\n\t    (encoded[len-2] == '=') &&\n\t    (encoded[len-3] == '='))\n\t\tencoded[len-3] = '\\0';\n\tblen = uudecode(encoded, blob, sizeof(blob));\n\tif (blen < 0)\n\t\tfatal(\"uudecode failed.\");\n\tif (*private)\n\t\t*k = do_convert_private_ssh2_from_blob(blob, blen);\n\telse if ((r = sshkey_from_blob(blob, blen, k)) != 0)\n\t\tfatal(\"decode blob failed: %s\", ssh_err(r));\n\tfclose(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_COM_PRIVATE_BEGIN\t\t\"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----\""
          ],
          "globals_used": [
            "char identity_file[1024];",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_COM_PRIVATE_BEGIN\t\t\"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)\n{\n\tint r, blen, escaped = 0;\n\tu_int len;\n\tchar line[1024];\n\tu_char blob[8096];\n\tchar encoded[8096];\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tencoded[0] = '\\0';\n\twhile ((blen = get_line(fp, line, sizeof(line))) != -1) {\n\t\tif (blen > 0 && line[blen - 1] == '\\\\')\n\t\t\tescaped++;\n\t\tif (strncmp(line, \"----\", 4) == 0 ||\n\t\t    strstr(line, \": \") != NULL) {\n\t\t\tif (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)\n\t\t\t\t*private = 1;\n\t\t\tif (strstr(line, \" END \") != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fprintf(stderr, \"ignore: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tif (escaped) {\n\t\t\tescaped--;\n\t\t\t/* fprintf(stderr, \"escaped: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tstrlcat(encoded, line, sizeof(encoded));\n\t}\n\tlen = strlen(encoded);\n\tif (((len % 4) == 3) &&\n\t    (encoded[len-1] == '=') &&\n\t    (encoded[len-2] == '=') &&\n\t    (encoded[len-3] == '='))\n\t\tencoded[len-3] = '\\0';\n\tblen = uudecode(encoded, blob, sizeof(blob));\n\tif (blen < 0)\n\t\tfatal(\"uudecode failed.\");\n\tif (*private)\n\t\t*k = do_convert_private_ssh2_from_blob(blob, blen);\n\telse if ((r = sshkey_from_blob(blob, blen, k)) != 0)\n\t\tfatal(\"decode blob failed: %s\", ssh_err(r));\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\nextern char *__progname;\n\nstatic void\ndo_convert_from(struct passwd *pw)\n{\n\tstruct sshkey *k = NULL;\n\tint r, private = 0, ok = 0;\n\tstruct stat st;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_from_ssh2(pw, &k, &private);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_from_pkcs8(&k, &private);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_from_pem(&k, &private);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\n\tif (!private) {\n\t\tif ((r = sshkey_write(k, stdout)) == 0)\n\t\t\tok = 1;\n\t\tif (ok)\n\t\t\tfprintf(stdout, \"\\n\");\n\t} else {\n\t\tswitch (k->type) {\n\t\tcase KEY_DSA:\n\t\t\tok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA:\n\t\t\tok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA:\n\t\t\tok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: unsupported key type %s\", __func__,\n\t\t\t    sshkey_type(k));\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tfatal(\"key write failed\");\n\tsshkey_free(k);\n\texit(0);\n}"
  },
  {
    "function_name": "do_convert_from_pem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "702-719",
    "snippet": "static void\ndo_convert_from_pem(struct sshkey **k, int *private)\n{\n\tFILE *fp;\n\tRSA *rsa;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = rsa;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfatal(\"%s: unrecognised raw private key format\", __func__);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unrecognised raw private key format\"",
            "__func__"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_new failed\""
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEM_read_RSAPublicKey",
          "args": [
            "fp",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "identity_file",
            "\"r\""
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_pem(struct sshkey **k, int *private)\n{\n\tFILE *fp;\n\tRSA *rsa;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = rsa;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfatal(\"%s: unrecognised raw private key format\", __func__);\n}"
  },
  {
    "function_name": "do_convert_from_pkcs8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "659-700",
    "snippet": "static void\ndo_convert_from_pkcs8(struct sshkey **k, int *private)\n{\n\tEVP_PKEY *pubkey;\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {\n\t\tfatal(\"%s: %s is not a recognised public key format\", __func__,\n\t\t    identity_file);\n\t}\n\tfclose(fp);\n\tswitch (EVP_PKEY_base_id(pubkey)) {\n\tcase EVP_PKEY_RSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);\n\t\tbreak;\n\tcase EVP_PKEY_DSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_DSA;\n\t\t(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase EVP_PKEY_EC:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_ECDSA;\n\t\t(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);\n\t\t(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported pubkey type %d\", __func__,\n\t\t    EVP_PKEY_base_id(pubkey));\n\t}\n\tEVP_PKEY_free(pubkey);\n\treturn;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pubkey"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unsupported pubkey type %d\"",
            "__func__",
            "EVP_PKEY_base_id(pubkey)"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_base_id",
          "args": [
            "pubkey"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_key_to_nid",
          "args": [
            "(*k)->ecdsa"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_key_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1525-1573",
          "snippet": "int\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif /* OPENSSL_HAS_NISTP521 */\n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tBN_CTX *bnctx;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t/*\n\t * The group may be stored in a ASN.1 encoded private key in one of two\n\t * ways: as a \"named group\", which is reconstituted by ASN.1 object ID\n\t * or explicit group parameters encoded into the key blob. Only the\n\t * \"named group\" case sets the group NID for us, but we can figure\n\t * it out for the other case by comparing against all the groups that\n\t * are supported.\n\t */\n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\treturn -1;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn -1;\n\t\t}\n\t\tif (EC_GROUP_cmp(g, eg, bnctx) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tBN_CTX_free(bnctx);\n\tif (nids[i] != -1) {\n\t\t/* Use the group with the NID attached */\n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_EC_KEY",
          "args": [
            "pubkey"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_UNSPEC"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_DSA",
          "args": [
            "pubkey"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_get1_RSA",
          "args": [
            "pubkey"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_base_id",
          "args": [
            "pubkey"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_PUBKEY",
          "args": [
            "fp",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "identity_file",
            "\"r\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_pkcs8(struct sshkey **k, int *private)\n{\n\tEVP_PKEY *pubkey;\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {\n\t\tfatal(\"%s: %s is not a recognised public key format\", __func__,\n\t\t    identity_file);\n\t}\n\tfclose(fp);\n\tswitch (EVP_PKEY_base_id(pubkey)) {\n\tcase EVP_PKEY_RSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);\n\t\tbreak;\n\tcase EVP_PKEY_DSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_DSA;\n\t\t(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase EVP_PKEY_EC:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_ECDSA;\n\t\t(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);\n\t\t(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported pubkey type %d\", __func__,\n\t\t    EVP_PKEY_base_id(pubkey));\n\t}\n\tEVP_PKEY_free(pubkey);\n\treturn;\n}"
  },
  {
    "function_name": "do_convert_from_ssh2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "610-657",
    "snippet": "static void\ndo_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)\n{\n\tint r, blen, escaped = 0;\n\tu_int len;\n\tchar line[1024];\n\tu_char blob[8096];\n\tchar encoded[8096];\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tencoded[0] = '\\0';\n\twhile ((blen = get_line(fp, line, sizeof(line))) != -1) {\n\t\tif (blen > 0 && line[blen - 1] == '\\\\')\n\t\t\tescaped++;\n\t\tif (strncmp(line, \"----\", 4) == 0 ||\n\t\t    strstr(line, \": \") != NULL) {\n\t\t\tif (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)\n\t\t\t\t*private = 1;\n\t\t\tif (strstr(line, \" END \") != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fprintf(stderr, \"ignore: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tif (escaped) {\n\t\t\tescaped--;\n\t\t\t/* fprintf(stderr, \"escaped: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tstrlcat(encoded, line, sizeof(encoded));\n\t}\n\tlen = strlen(encoded);\n\tif (((len % 4) == 3) &&\n\t    (encoded[len-1] == '=') &&\n\t    (encoded[len-2] == '=') &&\n\t    (encoded[len-3] == '='))\n\t\tencoded[len-3] = '\\0';\n\tblen = uudecode(encoded, blob, sizeof(blob));\n\tif (blen < 0)\n\t\tfatal(\"uudecode failed.\");\n\tif (*private)\n\t\t*k = do_convert_private_ssh2_from_blob(blob, blen);\n\telse if ((r = sshkey_from_blob(blob, blen, k)) != 0)\n\t\tfatal(\"decode blob failed: %s\", ssh_err(r));\n\tfclose(fp);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_COM_PRIVATE_BEGIN\t\t\"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----\""
    ],
    "globals_used": [
      "char identity_file[1024];",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"decode blob failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "k"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_private_ssh2_from_blob",
          "args": [
            "blob",
            "blen"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_private_ssh2_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "446-582",
          "snippet": "static struct sshkey *\ndo_convert_private_ssh2_from_blob(u_char *blob, u_int blen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *type, *cipher;\n\tu_char e1, e2, e3, *sig = NULL, data[] = \"abcde12345\";\n\tint r, rlen, ktype;\n\tu_int magic, i1, i2, i3, i4;\n\tsize_t slen;\n\tu_long e;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\tif ((r = sshbuf_get_u32(b, &magic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (magic != SSH_COM_PRIVATE_KEY_MAGIC) {\n\t\terror(\"bad magic 0x%x != 0x%x\", magic,\n\t\t    SSH_COM_PRIVATE_KEY_MAGIC);\n\t\tsshbuf_free(b);\n\t\treturn NULL;\n\t}\n\tif ((r = sshbuf_get_u32(b, &i1)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i2)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i3)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i4)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug(\"ignore (%d %d %d %d)\", i1, i2, i3, i4);\n\tif (strcmp(cipher, \"none\") != 0) {\n\t\terror(\"unsupported cipher %s\", cipher);\n\t\tfree(cipher);\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tfree(cipher);\n\n\tif (strstr(type, \"dsa\")) {\n\t\tktype = KEY_DSA;\n\t} else if (strstr(type, \"rsa\")) {\n\t\tktype = KEY_RSA;\n\t} else {\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tif ((key = sshkey_new(ktype)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tfree(type);\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, dsa_p);\n\t\tbuffer_get_bignum_bits(b, dsa_g);\n\t\tbuffer_get_bignum_bits(b, dsa_q);\n\t\tbuffer_get_bignum_bits(b, dsa_pub_key);\n\t\tbuffer_get_bignum_bits(b, dsa_priv_key);\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))\n\t\t\tfatal(\"%s: DSA_set0_pqg failed\", __func__);\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))\n\t\t\tfatal(\"%s: DSA_set0_key failed\", __func__);\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif ((r = sshbuf_get_u8(b, &e1)) != 0 ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\te = e1;\n\t\tdebug(\"e %lx\", e);\n\t\tif (e < 30) {\n\t\t\te <<= 8;\n\t\t\te += e2;\n\t\t\tdebug(\"e %lx\", e);\n\t\t\te <<= 8;\n\t\t\te += e3;\n\t\t\tdebug(\"e %lx\", e);\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tif (!BN_set_word(rsa_e, e)) {\n\t\t\tBN_clear_free(rsa_e);\n\t\t\tsshbuf_free(b);\n\t\t\tsshkey_free(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, rsa_d);\n\t\tbuffer_get_bignum_bits(b, rsa_n);\n\t\tbuffer_get_bignum_bits(b, rsa_iqmp);\n\t\tbuffer_get_bignum_bits(b, rsa_q);\n\t\tbuffer_get_bignum_bits(b, rsa_p);\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))\n\t\t\tfatal(\"%s: RSA_set0_key failed\", __func__);\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))\n\t\t\tfatal(\"%s: RSA_set0_factors failed\", __func__);\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\t\tfatal(\"generate RSA parameters failed: %s\", ssh_err(r));\n\t\tBN_clear_free(rsa_iqmp);\n\t\tbreak;\n\t}\n\trlen = sshbuf_len(b);\n\tif (rlen != 0)\n\t\terror(\"do_convert_private_ssh2_from_blob: \"\n\t\t    \"remaining bytes in key blob %d\", rlen);\n\tsshbuf_free(b);\n\n\t/* try the key */\n\tif (sshkey_sign(key, &sig, &slen, data, sizeof(data), NULL, 0) != 0 ||\n\t    sshkey_verify(key, sig, slen, data, sizeof(data), NULL, 0) != 0) {\n\t\tsshkey_free(key);\n\t\tfree(sig);\n\t\treturn NULL;\n\t}\n\tfree(sig);\n\treturn key;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSSH_COM_PRIVATE_KEY_MAGIC\t0x3f6ff9eb"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tSSH_COM_PRIVATE_KEY_MAGIC\t0x3f6ff9eb\n\nstatic struct sshkey *\ndo_convert_private_ssh2_from_blob(u_char *blob, u_int blen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *type, *cipher;\n\tu_char e1, e2, e3, *sig = NULL, data[] = \"abcde12345\";\n\tint r, rlen, ktype;\n\tu_int magic, i1, i2, i3, i4;\n\tsize_t slen;\n\tu_long e;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\tif ((r = sshbuf_get_u32(b, &magic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (magic != SSH_COM_PRIVATE_KEY_MAGIC) {\n\t\terror(\"bad magic 0x%x != 0x%x\", magic,\n\t\t    SSH_COM_PRIVATE_KEY_MAGIC);\n\t\tsshbuf_free(b);\n\t\treturn NULL;\n\t}\n\tif ((r = sshbuf_get_u32(b, &i1)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i2)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i3)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i4)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug(\"ignore (%d %d %d %d)\", i1, i2, i3, i4);\n\tif (strcmp(cipher, \"none\") != 0) {\n\t\terror(\"unsupported cipher %s\", cipher);\n\t\tfree(cipher);\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tfree(cipher);\n\n\tif (strstr(type, \"dsa\")) {\n\t\tktype = KEY_DSA;\n\t} else if (strstr(type, \"rsa\")) {\n\t\tktype = KEY_RSA;\n\t} else {\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tif ((key = sshkey_new(ktype)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tfree(type);\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, dsa_p);\n\t\tbuffer_get_bignum_bits(b, dsa_g);\n\t\tbuffer_get_bignum_bits(b, dsa_q);\n\t\tbuffer_get_bignum_bits(b, dsa_pub_key);\n\t\tbuffer_get_bignum_bits(b, dsa_priv_key);\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))\n\t\t\tfatal(\"%s: DSA_set0_pqg failed\", __func__);\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))\n\t\t\tfatal(\"%s: DSA_set0_key failed\", __func__);\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif ((r = sshbuf_get_u8(b, &e1)) != 0 ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\te = e1;\n\t\tdebug(\"e %lx\", e);\n\t\tif (e < 30) {\n\t\t\te <<= 8;\n\t\t\te += e2;\n\t\t\tdebug(\"e %lx\", e);\n\t\t\te <<= 8;\n\t\t\te += e3;\n\t\t\tdebug(\"e %lx\", e);\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tif (!BN_set_word(rsa_e, e)) {\n\t\t\tBN_clear_free(rsa_e);\n\t\t\tsshbuf_free(b);\n\t\t\tsshkey_free(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, rsa_d);\n\t\tbuffer_get_bignum_bits(b, rsa_n);\n\t\tbuffer_get_bignum_bits(b, rsa_iqmp);\n\t\tbuffer_get_bignum_bits(b, rsa_q);\n\t\tbuffer_get_bignum_bits(b, rsa_p);\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))\n\t\t\tfatal(\"%s: RSA_set0_key failed\", __func__);\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))\n\t\t\tfatal(\"%s: RSA_set0_factors failed\", __func__);\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\t\tfatal(\"generate RSA parameters failed: %s\", ssh_err(r));\n\t\tBN_clear_free(rsa_iqmp);\n\t\tbreak;\n\t}\n\trlen = sshbuf_len(b);\n\tif (rlen != 0)\n\t\terror(\"do_convert_private_ssh2_from_blob: \"\n\t\t    \"remaining bytes in key blob %d\", rlen);\n\tsshbuf_free(b);\n\n\t/* try the key */\n\tif (sshkey_sign(key, &sig, &slen, data, sizeof(data), NULL, 0) != 0 ||\n\t    sshkey_verify(key, sig, slen, data, sizeof(data), NULL, 0) != 0) {\n\t\tsshkey_free(key);\n\t\tfree(sig);\n\t\treturn NULL;\n\t}\n\tfree(sig);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"uudecode failed.\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uudecode",
          "args": [
            "encoded",
            "blob",
            "sizeof(blob)"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "uudecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uuencode.c",
          "lines": "55-73",
          "snippet": "int\nuudecode(const char *src, u_char *target, size_t targsize)\n{\n\tint len;\n\tchar *encoded, *p;\n\n\t/* copy the 'readonly' source */\n\tencoded = xstrdup(src);\n\t/* skip whitespace and data */\n\tfor (p = encoded; *p == ' ' || *p == '\\t'; p++)\n\t\t;\n\tfor (; *p != '\\0' && *p != ' ' && *p != '\\t'; p++)\n\t\t;\n\t/* and remove trailing whitespace because __b64_pton needs this */\n\t*p = '\\0';\n\tlen = __b64_pton(encoded, target, targsize);\n\tfree(encoded);\n\treturn len;\n}",
          "includes": [
            "#include \"uuencode.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <resolv.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuencode.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <resolv.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nuudecode(const char *src, u_char *target, size_t targsize)\n{\n\tint len;\n\tchar *encoded, *p;\n\n\t/* copy the 'readonly' source */\n\tencoded = xstrdup(src);\n\t/* skip whitespace and data */\n\tfor (p = encoded; *p == ' ' || *p == '\\t'; p++)\n\t\t;\n\tfor (; *p != '\\0' && *p != ' ' && *p != '\\t'; p++)\n\t\t;\n\t/* and remove trailing whitespace because __b64_pton needs this */\n\t*p = '\\0';\n\tlen = __b64_pton(encoded, target, targsize);\n\tfree(encoded);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "encoded"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "encoded",
            "line",
            "sizeof(encoded)"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\" END \""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "SSH_COM_PRIVATE_BEGIN"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\": \""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"----\"",
            "4"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_line",
          "args": [
            "fp",
            "line",
            "sizeof(line)"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "get_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "584-608",
          "snippet": "static int\nget_line(FILE *fp, char *line, size_t len)\n{\n\tint c;\n\tsize_t pos = 0;\n\n\tline[0] = '\\0';\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (pos >= len - 1)\n\t\t\tfatal(\"input line too long.\");\n\t\tswitch (c) {\n\t\tcase '\\r':\n\t\t\tc = fgetc(fp);\n\t\t\tif (c != EOF && c != '\\n' && ungetc(c, fp) == EOF)\n\t\t\t\tfatal(\"unget: %s\", strerror(errno));\n\t\t\treturn pos;\n\t\tcase '\\n':\n\t\t\treturn pos;\n\t\t}\n\t\tline[pos++] = c;\n\t\tline[pos] = '\\0';\n\t}\n\t/* We reached EOF */\n\treturn -1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_line(FILE *fp, char *line, size_t len)\n{\n\tint c;\n\tsize_t pos = 0;\n\n\tline[0] = '\\0';\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (pos >= len - 1)\n\t\t\tfatal(\"input line too long.\");\n\t\tswitch (c) {\n\t\tcase '\\r':\n\t\t\tc = fgetc(fp);\n\t\t\tif (c != EOF && c != '\\n' && ungetc(c, fp) == EOF)\n\t\t\t\tfatal(\"unget: %s\", strerror(errno));\n\t\t\treturn pos;\n\t\tcase '\\n':\n\t\t\treturn pos;\n\t\t}\n\t\tline[pos++] = c;\n\t\tline[pos] = '\\0';\n\t}\n\t/* We reached EOF */\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "identity_file",
            "\"r\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_COM_PRIVATE_BEGIN\t\t\"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----\"\n\nchar identity_file[1024];\nextern char *__progname;\n\nstatic void\ndo_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)\n{\n\tint r, blen, escaped = 0;\n\tu_int len;\n\tchar line[1024];\n\tu_char blob[8096];\n\tchar encoded[8096];\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tencoded[0] = '\\0';\n\twhile ((blen = get_line(fp, line, sizeof(line))) != -1) {\n\t\tif (blen > 0 && line[blen - 1] == '\\\\')\n\t\t\tescaped++;\n\t\tif (strncmp(line, \"----\", 4) == 0 ||\n\t\t    strstr(line, \": \") != NULL) {\n\t\t\tif (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)\n\t\t\t\t*private = 1;\n\t\t\tif (strstr(line, \" END \") != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fprintf(stderr, \"ignore: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tif (escaped) {\n\t\t\tescaped--;\n\t\t\t/* fprintf(stderr, \"escaped: %s\", line); */\n\t\t\tcontinue;\n\t\t}\n\t\tstrlcat(encoded, line, sizeof(encoded));\n\t}\n\tlen = strlen(encoded);\n\tif (((len % 4) == 3) &&\n\t    (encoded[len-1] == '=') &&\n\t    (encoded[len-2] == '=') &&\n\t    (encoded[len-3] == '='))\n\t\tencoded[len-3] = '\\0';\n\tblen = uudecode(encoded, blob, sizeof(blob));\n\tif (blen < 0)\n\t\tfatal(\"uudecode failed.\");\n\tif (*private)\n\t\t*k = do_convert_private_ssh2_from_blob(blob, blen);\n\telse if ((r = sshkey_from_blob(blob, blen, k)) != 0)\n\t\tfatal(\"decode blob failed: %s\", ssh_err(r));\n\tfclose(fp);\n}"
  },
  {
    "function_name": "get_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "584-608",
    "snippet": "static int\nget_line(FILE *fp, char *line, size_t len)\n{\n\tint c;\n\tsize_t pos = 0;\n\n\tline[0] = '\\0';\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (pos >= len - 1)\n\t\t\tfatal(\"input line too long.\");\n\t\tswitch (c) {\n\t\tcase '\\r':\n\t\t\tc = fgetc(fp);\n\t\t\tif (c != EOF && c != '\\n' && ungetc(c, fp) == EOF)\n\t\t\t\tfatal(\"unget: %s\", strerror(errno));\n\t\t\treturn pos;\n\t\tcase '\\n':\n\t\t\treturn pos;\n\t\t}\n\t\tline[pos++] = c;\n\t\tline[pos] = '\\0';\n\t}\n\t/* We reached EOF */\n\treturn -1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"unget: %s\"",
            "strerror(errno)"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ungetc",
          "args": [
            "c",
            "fp"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "fp"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input line too long.\""
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "fp"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_line(FILE *fp, char *line, size_t len)\n{\n\tint c;\n\tsize_t pos = 0;\n\n\tline[0] = '\\0';\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (pos >= len - 1)\n\t\t\tfatal(\"input line too long.\");\n\t\tswitch (c) {\n\t\tcase '\\r':\n\t\t\tc = fgetc(fp);\n\t\t\tif (c != EOF && c != '\\n' && ungetc(c, fp) == EOF)\n\t\t\t\tfatal(\"unget: %s\", strerror(errno));\n\t\t\treturn pos;\n\t\tcase '\\n':\n\t\t\treturn pos;\n\t\t}\n\t\tline[pos++] = c;\n\t\tline[pos] = '\\0';\n\t}\n\t/* We reached EOF */\n\treturn -1;\n}"
  },
  {
    "function_name": "do_convert_private_ssh2_from_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "446-582",
    "snippet": "static struct sshkey *\ndo_convert_private_ssh2_from_blob(u_char *blob, u_int blen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *type, *cipher;\n\tu_char e1, e2, e3, *sig = NULL, data[] = \"abcde12345\";\n\tint r, rlen, ktype;\n\tu_int magic, i1, i2, i3, i4;\n\tsize_t slen;\n\tu_long e;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\tif ((r = sshbuf_get_u32(b, &magic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (magic != SSH_COM_PRIVATE_KEY_MAGIC) {\n\t\terror(\"bad magic 0x%x != 0x%x\", magic,\n\t\t    SSH_COM_PRIVATE_KEY_MAGIC);\n\t\tsshbuf_free(b);\n\t\treturn NULL;\n\t}\n\tif ((r = sshbuf_get_u32(b, &i1)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i2)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i3)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i4)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug(\"ignore (%d %d %d %d)\", i1, i2, i3, i4);\n\tif (strcmp(cipher, \"none\") != 0) {\n\t\terror(\"unsupported cipher %s\", cipher);\n\t\tfree(cipher);\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tfree(cipher);\n\n\tif (strstr(type, \"dsa\")) {\n\t\tktype = KEY_DSA;\n\t} else if (strstr(type, \"rsa\")) {\n\t\tktype = KEY_RSA;\n\t} else {\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tif ((key = sshkey_new(ktype)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tfree(type);\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, dsa_p);\n\t\tbuffer_get_bignum_bits(b, dsa_g);\n\t\tbuffer_get_bignum_bits(b, dsa_q);\n\t\tbuffer_get_bignum_bits(b, dsa_pub_key);\n\t\tbuffer_get_bignum_bits(b, dsa_priv_key);\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))\n\t\t\tfatal(\"%s: DSA_set0_pqg failed\", __func__);\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))\n\t\t\tfatal(\"%s: DSA_set0_key failed\", __func__);\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif ((r = sshbuf_get_u8(b, &e1)) != 0 ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\te = e1;\n\t\tdebug(\"e %lx\", e);\n\t\tif (e < 30) {\n\t\t\te <<= 8;\n\t\t\te += e2;\n\t\t\tdebug(\"e %lx\", e);\n\t\t\te <<= 8;\n\t\t\te += e3;\n\t\t\tdebug(\"e %lx\", e);\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tif (!BN_set_word(rsa_e, e)) {\n\t\t\tBN_clear_free(rsa_e);\n\t\t\tsshbuf_free(b);\n\t\t\tsshkey_free(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, rsa_d);\n\t\tbuffer_get_bignum_bits(b, rsa_n);\n\t\tbuffer_get_bignum_bits(b, rsa_iqmp);\n\t\tbuffer_get_bignum_bits(b, rsa_q);\n\t\tbuffer_get_bignum_bits(b, rsa_p);\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))\n\t\t\tfatal(\"%s: RSA_set0_key failed\", __func__);\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))\n\t\t\tfatal(\"%s: RSA_set0_factors failed\", __func__);\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\t\tfatal(\"generate RSA parameters failed: %s\", ssh_err(r));\n\t\tBN_clear_free(rsa_iqmp);\n\t\tbreak;\n\t}\n\trlen = sshbuf_len(b);\n\tif (rlen != 0)\n\t\terror(\"do_convert_private_ssh2_from_blob: \"\n\t\t    \"remaining bytes in key blob %d\", rlen);\n\tsshbuf_free(b);\n\n\t/* try the key */\n\tif (sshkey_sign(key, &sig, &slen, data, sizeof(data), NULL, 0) != 0 ||\n\t    sshkey_verify(key, sig, slen, data, sizeof(data), NULL, 0) != 0) {\n\t\tsshkey_free(key);\n\t\tfree(sig);\n\t\treturn NULL;\n\t}\n\tfree(sig);\n\treturn key;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tSSH_COM_PRIVATE_KEY_MAGIC\t0x3f6ff9eb"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "key",
            "sig",
            "slen",
            "data",
            "sizeof(data)",
            "NULL",
            "0"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "key",
            "&sig",
            "&slen",
            "data",
            "sizeof(data)",
            "NULL",
            "0"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"do_convert_private_ssh2_from_blob: \"\n\t\t    \"remaining bytes in key blob %d\"",
            "rlen"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_iqmp"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"generate RSA parameters failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_rsa_complete_crt_parameters",
          "args": [
            "key",
            "rsa_iqmp"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_rsa_complete_crt_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-rsa.c",
          "lines": "108-160",
          "snippet": "int\nssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)\n{\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_d;\n\tBIGNUM *aux = NULL, *d_consttime = NULL;\n\tBIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;\n\tBN_CTX *ctx = NULL;\n\tint r;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((aux = BN_new()) == NULL ||\n\t    (rsa_dmq1 = BN_new()) == NULL ||\n\t    (rsa_dmp1 = BN_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((d_consttime = BN_dup(rsa_d)) == NULL ||\n\t    (rsa_iqmp = BN_dup(iqmp)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tBN_set_flags(aux, BN_FLG_CONSTTIME);\n\tBN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n\tif ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||\n\t    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL; /* transferred */\n\t/* success */\n\tr = 0;\n out:\n\tBN_clear_free(aux);\n\tBN_clear_free(d_consttime);\n\tBN_clear_free(rsa_dmp1);\n\tBN_clear_free(rsa_dmq1);\n\tBN_clear_free(rsa_iqmp);\n\tBN_CTX_free(ctx);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"digest.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"digest.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)\n{\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_d;\n\tBIGNUM *aux = NULL, *d_consttime = NULL;\n\tBIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;\n\tBN_CTX *ctx = NULL;\n\tint r;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((aux = BN_new()) == NULL ||\n\t    (rsa_dmq1 = BN_new()) == NULL ||\n\t    (rsa_dmp1 = BN_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((d_consttime = BN_dup(rsa_d)) == NULL ||\n\t    (rsa_iqmp = BN_dup(iqmp)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tBN_set_flags(aux, BN_FLG_CONSTTIME);\n\tBN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n\tif ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||\n\t    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL; /* transferred */\n\t/* success */\n\tr = 0;\n out:\n\tBN_clear_free(aux);\n\tBN_clear_free(d_consttime);\n\tBN_clear_free(rsa_dmp1);\n\tBN_clear_free(rsa_dmq1);\n\tBN_clear_free(rsa_iqmp);\n\tBN_CTX_free(ctx);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_set0_factors",
          "args": [
            "key->rsa",
            "rsa_p",
            "rsa_q"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_factors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "318-334",
          "snippet": "int\nRSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)\n{\n\tif ((r->p == NULL && p == NULL) || (r->q == NULL && q == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(r->p);\n\t\tr->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(r->q);\n\t\tr->q = q;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)\n{\n\tif ((r->p == NULL && p == NULL) || (r->q == NULL && q == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(r->p);\n\t\tr->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(r->q);\n\t\tr->q = q;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_set0_key",
          "args": [
            "key->rsa",
            "rsa_n",
            "rsa_e",
            "rsa_d"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "243-263",
          "snippet": "int\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)\n{\n\tif ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))\n\t\treturn 0;\n\n\tif (n != NULL) {\n\t\tBN_free(r->n);\n\t\tr->n = n;\n\t}\n\tif (e != NULL) {\n\t\tBN_free(r->e);\n\t\tr->e = e;\n\t}\n\tif (d != NULL) {\n\t\tBN_free(r->d);\n\t\tr->d = d;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_get_bignum_bits",
          "args": [
            "b",
            "rsa_p"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_get_bignum_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "428-444",
          "snippet": "static void\nbuffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)\n{\n\tu_int bytes, bignum_bits;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tbytes = (bignum_bits + 7) / 8;\n\tif (sshbuf_len(b) < bytes)\n\t\tfatal(\"%s: input buffer too small: need %d have %zu\",\n\t\t    __func__, bytes, sshbuf_len(b));\n\tif (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)\n\t\tfatal(\"%s: BN_bin2bn failed\", __func__);\n\tif ((r = sshbuf_consume(b, bytes)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbuffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)\n{\n\tu_int bytes, bignum_bits;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tbytes = (bignum_bits + 7) / 8;\n\tif (sshbuf_len(b) < bytes)\n\t\tfatal(\"%s: input buffer too small: need %d have %zu\",\n\t\t    __func__, bytes, sshbuf_len(b));\n\tif (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)\n\t\tfatal(\"%s: BN_bin2bn failed\", __func__);\n\tif ((r = sshbuf_consume(b, bytes)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "rsa_e"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_set_word",
          "args": [
            "rsa_e",
            "e"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"e %lx\"",
            "e"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&e3"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_set0_key",
          "args": [
            "key->dsa",
            "dsa_pub_key",
            "dsa_priv_key"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "210-226",
          "snippet": "int\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n\tif (d->pub_key == NULL && pub_key == NULL)\n\t\treturn 0;\n\n\tif (pub_key != NULL) {\n\t\tBN_free(d->pub_key);\n\t\td->pub_key = pub_key;\n\t}\n\tif (priv_key != NULL) {\n\t\tBN_free(d->priv_key);\n\t\td->priv_key = priv_key;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_set0_pqg",
          "args": [
            "key->dsa",
            "dsa_p",
            "dsa_q",
            "dsa_g"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "DSA_set0_pqg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "174-195",
          "snippet": "int\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nDSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\tif ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) ||\n\t    (d->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(d->p);\n\t\td->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(d->q);\n\t\td->q = q;\n\t}\n\tif (g != NULL) {\n\t\tBN_free(d->g);\n\t\td->g = g;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "ktype"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"rsa\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"dsa\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"none\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "&i4"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&cipher",
            "NULL"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "blob",
            "blen"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tSSH_COM_PRIVATE_KEY_MAGIC\t0x3f6ff9eb\n\nstatic struct sshkey *\ndo_convert_private_ssh2_from_blob(u_char *blob, u_int blen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *type, *cipher;\n\tu_char e1, e2, e3, *sig = NULL, data[] = \"abcde12345\";\n\tint r, rlen, ktype;\n\tu_int magic, i1, i2, i3, i4;\n\tsize_t slen;\n\tu_long e;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\tif ((r = sshbuf_get_u32(b, &magic)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (magic != SSH_COM_PRIVATE_KEY_MAGIC) {\n\t\terror(\"bad magic 0x%x != 0x%x\", magic,\n\t\t    SSH_COM_PRIVATE_KEY_MAGIC);\n\t\tsshbuf_free(b);\n\t\treturn NULL;\n\t}\n\tif ((r = sshbuf_get_u32(b, &i1)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i2)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i3)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i4)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug(\"ignore (%d %d %d %d)\", i1, i2, i3, i4);\n\tif (strcmp(cipher, \"none\") != 0) {\n\t\terror(\"unsupported cipher %s\", cipher);\n\t\tfree(cipher);\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tfree(cipher);\n\n\tif (strstr(type, \"dsa\")) {\n\t\tktype = KEY_DSA;\n\t} else if (strstr(type, \"rsa\")) {\n\t\tktype = KEY_RSA;\n\t} else {\n\t\tsshbuf_free(b);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tif ((key = sshkey_new(ktype)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tfree(type);\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, dsa_p);\n\t\tbuffer_get_bignum_bits(b, dsa_g);\n\t\tbuffer_get_bignum_bits(b, dsa_q);\n\t\tbuffer_get_bignum_bits(b, dsa_pub_key);\n\t\tbuffer_get_bignum_bits(b, dsa_priv_key);\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))\n\t\t\tfatal(\"%s: DSA_set0_pqg failed\", __func__);\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))\n\t\t\tfatal(\"%s: DSA_set0_key failed\", __func__);\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif ((r = sshbuf_get_u8(b, &e1)) != 0 ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\te = e1;\n\t\tdebug(\"e %lx\", e);\n\t\tif (e < 30) {\n\t\t\te <<= 8;\n\t\t\te += e2;\n\t\t\tdebug(\"e %lx\", e);\n\t\t\te <<= 8;\n\t\t\te += e3;\n\t\t\tdebug(\"e %lx\", e);\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tif (!BN_set_word(rsa_e, e)) {\n\t\t\tBN_clear_free(rsa_e);\n\t\t\tsshbuf_free(b);\n\t\t\tsshkey_free(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL)\n\t\t\tfatal(\"%s: BN_new\", __func__);\n\t\tbuffer_get_bignum_bits(b, rsa_d);\n\t\tbuffer_get_bignum_bits(b, rsa_n);\n\t\tbuffer_get_bignum_bits(b, rsa_iqmp);\n\t\tbuffer_get_bignum_bits(b, rsa_q);\n\t\tbuffer_get_bignum_bits(b, rsa_p);\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))\n\t\t\tfatal(\"%s: RSA_set0_key failed\", __func__);\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))\n\t\t\tfatal(\"%s: RSA_set0_factors failed\", __func__);\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\t\tfatal(\"generate RSA parameters failed: %s\", ssh_err(r));\n\t\tBN_clear_free(rsa_iqmp);\n\t\tbreak;\n\t}\n\trlen = sshbuf_len(b);\n\tif (rlen != 0)\n\t\terror(\"do_convert_private_ssh2_from_blob: \"\n\t\t    \"remaining bytes in key blob %d\", rlen);\n\tsshbuf_free(b);\n\n\t/* try the key */\n\tif (sshkey_sign(key, &sig, &slen, data, sizeof(data), NULL, 0) != 0 ||\n\t    sshkey_verify(key, sig, slen, data, sizeof(data), NULL, 0) != 0) {\n\t\tsshkey_free(key);\n\t\tfree(sig);\n\t\treturn NULL;\n\t}\n\tfree(sig);\n\treturn key;\n}"
  },
  {
    "function_name": "buffer_get_bignum_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "428-444",
    "snippet": "static void\nbuffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)\n{\n\tu_int bytes, bignum_bits;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tbytes = (bignum_bits + 7) / 8;\n\tif (sshbuf_len(b) < bytes)\n\t\tfatal(\"%s: input buffer too small: need %d have %zu\",\n\t\t    __func__, bytes, sshbuf_len(b));\n\tif (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)\n\t\tfatal(\"%s: BN_bin2bn failed\", __func__);\n\tif ((r = sshbuf_consume(b, bytes)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "b",
            "bytes"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: BN_bin2bn failed\"",
            "__func__"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_bin2bn",
          "args": [
            "sshbuf_ptr(b)",
            "bytes",
            "value"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "&bignum_bits"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbuffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)\n{\n\tu_int bytes, bignum_bits;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tbytes = (bignum_bits + 7) / 8;\n\tif (sshbuf_len(b) < bytes)\n\t\tfatal(\"%s: input buffer too small: need %d have %zu\",\n\t\t    __func__, bytes, sshbuf_len(b));\n\tif (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)\n\t\tfatal(\"%s: BN_bin2bn failed\", __func__);\n\tif ((r = sshbuf_consume(b, bytes)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "do_convert_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "395-422",
    "snippet": "static void\ndo_convert_to(struct passwd *pw)\n{\n\tstruct sshkey *k;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)\n\t\tk = load_identity(identity_file);\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_to_ssh2(pw, k);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_to_pkcs8(k);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_to_pem(k);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "enum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;",
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unknown key format %d\"",
            "__func__",
            "convert_format"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_to_pem",
          "args": [
            "k"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_to_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "381-393",
          "snippet": "static void\ndo_convert_to_pem(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSAPublicKey(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSAPublicKey failed\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_convert_to_pem(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSAPublicKey(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSAPublicKey failed\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_to_pkcs8",
          "args": [
            "k"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_to_pkcs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "357-379",
          "snippet": "static void\ndo_convert_to_pkcs8(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSA_PUBKEY(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSA_PUBKEY failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_convert_to_pkcs8(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSA_PUBKEY(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSA_PUBKEY failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_to_ssh2",
          "args": [
            "pw",
            "k"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_to_ssh2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "332-355",
          "snippet": "static void\ndo_convert_to_ssh2(struct passwd *pw, struct sshkey *k)\n{\n\tsize_t len;\n\tu_char *blob;\n\tchar comment[61];\n\tint r;\n\n\tif ((r = sshkey_to_blob(k, &blob, &len)) != 0)\n\t\tfatal(\"key_to_blob failed: %s\", ssh_err(r));\n\t/* Comment + surrounds must fit into 72 chars (RFC 4716 sec 3.3) */\n\tsnprintf(comment, sizeof(comment),\n\t    \"%u-bit %s, converted by %s@%s from OpenSSH\",\n\t    sshkey_size(k), sshkey_type(k),\n\t    pw->pw_name, hostname);\n\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_BEGIN);\n\tfprintf(stdout, \"Comment: \\\"%s\\\"\\n\", comment);\n\tdump_base64(stdout, blob, len);\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_END);\n\tsshkey_free(k);\n\tfree(blob);\n\texit(0);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_COM_PUBLIC_END\t\t\"---- END SSH2 PUBLIC KEY ----\"",
            "#define SSH_COM_PUBLIC_BEGIN\t\t\"---- BEGIN SSH2 PUBLIC KEY ----\""
          ],
          "globals_used": [
            "char hostname[NI_MAXHOST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_COM_PUBLIC_END\t\t\"---- END SSH2 PUBLIC KEY ----\"\n#define SSH_COM_PUBLIC_BEGIN\t\t\"---- BEGIN SSH2 PUBLIC KEY ----\"\n\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_convert_to_ssh2(struct passwd *pw, struct sshkey *k)\n{\n\tsize_t len;\n\tu_char *blob;\n\tchar comment[61];\n\tint r;\n\n\tif ((r = sshkey_to_blob(k, &blob, &len)) != 0)\n\t\tfatal(\"key_to_blob failed: %s\", ssh_err(r));\n\t/* Comment + surrounds must fit into 72 chars (RFC 4716 sec 3.3) */\n\tsnprintf(comment, sizeof(comment),\n\t    \"%u-bit %s, converted by %s@%s from OpenSSH\",\n\t    sshkey_size(k), sshkey_type(k),\n\t    pw->pw_name, hostname);\n\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_BEGIN);\n\tfprintf(stdout, \"Comment: \\\"%s\\\"\\n\", comment);\n\tdump_base64(stdout, blob, len);\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_END);\n\tsshkey_free(k);\n\tfree(blob);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_identity",
          "args": [
            "identity_file"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "load_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "303-324",
          "snippet": "static struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *identity_passphrase = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\n\nstatic struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "identity_file",
            "&k",
            "NULL"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "identity_file",
            "&st"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_filename",
          "args": [
            "pw",
            "\"Enter file in which the key is\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ask_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "255-301",
          "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char identity_file[1024];",
            "int have_identity = 0;",
            "char *key_type_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\nextern char *__progname;\n\nstatic void\ndo_convert_to(struct passwd *pw)\n{\n\tstruct sshkey *k;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) < 0)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)\n\t\tk = load_identity(identity_file);\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_to_ssh2(pw, k);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_to_pkcs8(k);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_to_pem(k);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unknown key format %d\", __func__, convert_format);\n\t}\n\texit(0);\n}"
  },
  {
    "function_name": "do_convert_to_pem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "381-393",
    "snippet": "static void\ndo_convert_to_pem(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSAPublicKey(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSAPublicKey failed\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unsupported key type %s\"",
            "__func__",
            "sshkey_type(k)"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEM_write_RSAPublicKey",
          "args": [
            "stdout",
            "k->rsa"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_convert_to_pem(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSAPublicKey(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSAPublicKey failed\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}"
  },
  {
    "function_name": "do_convert_to_pkcs8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "357-379",
    "snippet": "static void\ndo_convert_to_pkcs8(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSA_PUBKEY(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSA_PUBKEY failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unsupported key type %s\"",
            "__func__",
            "sshkey_type(k)"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEM_write_EC_PUBKEY",
          "args": [
            "stdout",
            "k->ecdsa"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_DSA_PUBKEY",
          "args": [
            "stdout",
            "k->dsa"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_RSA_PUBKEY",
          "args": [
            "stdout",
            "k->rsa"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_convert_to_pkcs8(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSA_PUBKEY(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSA_PUBKEY failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal(\"%s: unsupported key type %s\", __func__, sshkey_type(k));\n\t}\n\texit(0);\n}"
  },
  {
    "function_name": "do_convert_to_ssh2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "332-355",
    "snippet": "static void\ndo_convert_to_ssh2(struct passwd *pw, struct sshkey *k)\n{\n\tsize_t len;\n\tu_char *blob;\n\tchar comment[61];\n\tint r;\n\n\tif ((r = sshkey_to_blob(k, &blob, &len)) != 0)\n\t\tfatal(\"key_to_blob failed: %s\", ssh_err(r));\n\t/* Comment + surrounds must fit into 72 chars (RFC 4716 sec 3.3) */\n\tsnprintf(comment, sizeof(comment),\n\t    \"%u-bit %s, converted by %s@%s from OpenSSH\",\n\t    sshkey_size(k), sshkey_type(k),\n\t    pw->pw_name, hostname);\n\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_BEGIN);\n\tfprintf(stdout, \"Comment: \\\"%s\\\"\\n\", comment);\n\tdump_base64(stdout, blob, len);\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_END);\n\tsshkey_free(k);\n\tfree(blob);\n\texit(0);\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_COM_PUBLIC_END\t\t\"---- END SSH2 PUBLIC KEY ----\"",
      "#define SSH_COM_PUBLIC_BEGIN\t\t\"---- BEGIN SSH2 PUBLIC KEY ----\""
    ],
    "globals_used": [
      "char hostname[NI_MAXHOST];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "SSH_COM_PUBLIC_END"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_base64",
          "args": [
            "stdout",
            "blob",
            "len"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "dump_base64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uuencode.c",
          "lines": "75-95",
          "snippet": "void\ndump_base64(FILE *fp, const u_char *data, u_int len)\n{\n\tchar *buf;\n\tint i, n;\n\n\tif (len > 65536) {\n\t\tfprintf(fp, \"dump_base64: len > 65536\\n\");\n\t\treturn;\n\t}\n\tbuf = xreallocarray(NULL, 2, len);\n\tn = uuencode(data, len, buf, 2*len);\n\tfor (i = 0; i < n; i++) {\n\t\tfprintf(fp, \"%c\", buf[i]);\n\t\tif (i % 70 == 69)\n\t\t\tfprintf(fp, \"\\n\");\n\t}\n\tif (i % 70 != 69)\n\t\tfprintf(fp, \"\\n\");\n\tfree(buf);\n}",
          "includes": [
            "#include \"uuencode.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <resolv.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuencode.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <resolv.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndump_base64(FILE *fp, const u_char *data, u_int len)\n{\n\tchar *buf;\n\tint i, n;\n\n\tif (len > 65536) {\n\t\tfprintf(fp, \"dump_base64: len > 65536\\n\");\n\t\treturn;\n\t}\n\tbuf = xreallocarray(NULL, 2, len);\n\tn = uuencode(data, len, buf, 2*len);\n\tfor (i = 0; i < n; i++) {\n\t\tfprintf(fp, \"%c\", buf[i]);\n\t\tif (i % 70 == 69)\n\t\t\tfprintf(fp, \"\\n\");\n\t}\n\tif (i % 70 != 69)\n\t\tfprintf(fp, \"\\n\");\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Comment: \\\"%s\\\"\\n\"",
            "comment"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "SSH_COM_PUBLIC_BEGIN"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "comment",
            "sizeof(comment)",
            "\"%u-bit %s, converted by %s@%s from OpenSSH\"",
            "sshkey_size(k)",
            "sshkey_type(k)",
            "pw->pw_name",
            "hostname"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_size",
          "args": [
            "k"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "283-315",
          "snippet": "u_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *dsa_p;\n#endif /* WITH_OPENSSL */\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (k->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\t\treturn BN_num_bits(rsa_n);\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif (k->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);\n\t\treturn BN_num_bits(dsa_p);\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\treturn sshkey_curve_nid_to_bits(k->ecdsa_nid);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn 256;\t/* XXX */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"key_to_blob failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "k",
            "&blob",
            "&len"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_COM_PUBLIC_END\t\t\"---- END SSH2 PUBLIC KEY ----\"\n#define SSH_COM_PUBLIC_BEGIN\t\t\"---- BEGIN SSH2 PUBLIC KEY ----\"\n\nchar hostname[NI_MAXHOST];\n\nstatic void\ndo_convert_to_ssh2(struct passwd *pw, struct sshkey *k)\n{\n\tsize_t len;\n\tu_char *blob;\n\tchar comment[61];\n\tint r;\n\n\tif ((r = sshkey_to_blob(k, &blob, &len)) != 0)\n\t\tfatal(\"key_to_blob failed: %s\", ssh_err(r));\n\t/* Comment + surrounds must fit into 72 chars (RFC 4716 sec 3.3) */\n\tsnprintf(comment, sizeof(comment),\n\t    \"%u-bit %s, converted by %s@%s from OpenSSH\",\n\t    sshkey_size(k), sshkey_type(k),\n\t    pw->pw_name, hostname);\n\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_BEGIN);\n\tfprintf(stdout, \"Comment: \\\"%s\\\"\\n\", comment);\n\tdump_base64(stdout, blob, len);\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_END);\n\tsshkey_free(k);\n\tfree(blob);\n\texit(0);\n}"
  },
  {
    "function_name": "load_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "303-324",
    "snippet": "static struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *identity_passphrase = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Load key \\\"%s\\\": %s\"",
            "filename",
            "ssh_err(r)"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pass"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "pass",
            "strlen(pass)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_private",
          "args": [
            "filename",
            "pass",
            "&prv",
            "NULL"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "227-262",
          "snippet": "int\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"Enter passphrase: \"",
            "RP_ALLOW_STDIN"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "identity_passphrase"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *identity_passphrase = NULL;\n\nstatic struct sshkey *\nload_identity(char *filename)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif ((r = sshkey_load_private(filename, \"\", &prv, NULL)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, NULL);\n\texplicit_bzero(pass, strlen(pass));\n\tfree(pass);\n\tif (r != 0)\n\t\tfatal(\"Load key \\\"%s\\\": %s\", filename, ssh_err(r));\n\treturn prv;\n}"
  },
  {
    "function_name": "ask_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "255-301",
    "snippet": "static void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char identity_file[1024];",
      "int have_identity = 0;",
      "char *key_type_name = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "identity_file",
            "buf",
            "sizeof(identity_file)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"\""
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "stdin"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s (%s): \"",
            "prompt",
            "identity_file"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "identity_file",
            "sizeof(identity_file)",
            "\"%s/%s\"",
            "pw->pw_dir",
            "name"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"bad key type\""
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "key_type_name"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar identity_file[1024];\nint have_identity = 0;\nchar *key_type_name = NULL;\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}"
  },
  {
    "function_name": "type_bits_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
    "lines": "205-253",
    "snippet": "static void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}",
    "includes": [
      "#include \"authfd.h\"",
      "#include \"utf8.h\"",
      "#include \"digest.h\"",
      "#include \"krl.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"dns.h\"",
      "#include \"hostfile.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"sshbuf.h\"",
      "#include \"uuencode.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <time.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/pem.h>",
      "#include <openssl/evp.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define DEFAULT_BITS_ECDSA\t256",
      "#define DEFAULT_BITS_DSA\t1024",
      "#define DEFAULT_BITS\t\t2048"
    ],
    "globals_used": [
      "u_int32_t bits = 0;",
      "char *key_type_name = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_bits_to_nid",
          "args": [
            "*bitsp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_bits_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "394-409",
          "snippet": "int\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid RSA key length: minimum is %d bits\"",
            "SSH_RSA_MINIMUM_MODULUS_SIZE"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_curve_nid_to_bits",
          "args": [
            "nid"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_curve_nid_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "377-392",
          "snippet": "u_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif /* OPENSSL_HAS_NISTP521 */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ecdsa_nid_from_name",
          "args": [
            "name"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ecdsa_nid_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "204-216",
          "snippet": "int\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)\n\t\t\tcontinue;\n\t\tif (kt->name != NULL && strcmp(name, kt->name) == 0)\n\t\t\treturn kt->nid;\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define DEFAULT_BITS_ECDSA\t256\n#define DEFAULT_BITS_DSA\t1024\n#define DEFAULT_BITS\t\t2048\n\nu_int32_t bits = 0;\nchar *key_type_name = NULL;\n\nstatic void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n#ifdef WITH_OPENSSL\n\tu_int maxbits, nid;\n#endif\n\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tif (type == KEY_DSA)\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\telse if (type == KEY_ECDSA) {\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t} else\n#endif\n\t\t\t*bitsp = DEFAULT_BITS;\n\t}\n#ifdef WITH_OPENSSL\n\tmaxbits = (type == KEY_DSA) ?\n\t    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;\n\tif (*bitsp > maxbits)\n\t\tfatal(\"key bits exceeds maximum %d\", maxbits);\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}"
  }
]