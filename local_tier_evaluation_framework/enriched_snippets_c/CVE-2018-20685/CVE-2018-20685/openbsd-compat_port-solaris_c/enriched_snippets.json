[
  {
    "function_name": "solaris_basic_privset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "234-252",
    "snippet": "priv_set_t *\nsolaris_basic_privset(void)\n{\n\tpriv_set_t *pset;\n\n#ifdef HAVE_PRIV_BASICSET\n\tif ((pset = priv_allocset()) == NULL) {\n\t\terror(\"priv_allocset: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tpriv_basicset(pset);\n#else\n\tif ((pset = priv_str_to_set(\"basic\", \",\", NULL)) == NULL) {\n\t\terror(\"priv_str_to_set: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n#endif\n\treturn pset;\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "priv_set_t *pset = NULL, *npset = NULL;",
      "priv_set_t *pset = NULL;",
      "priv_set_t *pset = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"priv_str_to_set: %s\"",
            "strerror(errno)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "priv_str_to_set",
          "args": [
            "\"basic\"",
            "\",\"",
            "NULL"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv_basicset",
          "args": [
            "pset"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv_allocset",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\npriv_set_t *pset = NULL, *npset = NULL;\npriv_set_t *pset = NULL;\npriv_set_t *pset = NULL;\n\npriv_set_t *\nsolaris_basic_privset(void)\n{\n\tpriv_set_t *pset;\n\n#ifdef HAVE_PRIV_BASICSET\n\tif ((pset = priv_allocset()) == NULL) {\n\t\terror(\"priv_allocset: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tpriv_basicset(pset);\n#else\n\tif ((pset = priv_str_to_set(\"basic\", \",\", NULL)) == NULL) {\n\t\terror(\"priv_str_to_set: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n#endif\n\treturn pset;\n}"
  },
  {
    "function_name": "solaris_set_default_project",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "207-226",
    "snippet": "void\nsolaris_set_default_project(struct passwd *pw)\n{\n\tstruct project  *defaultproject;\n\tstruct project   tempproject;\n\tchar buf[1024];\n\n\t/* get default project, if we fail just return gracefully  */\n\tif ((defaultproject = getdefaultproj(pw->pw_name, &tempproject, &buf,\n\t    sizeof(buf))) != NULL) {\n\t\t/* set default project */\n\t\tif (setproject(defaultproject->pj_name, pw->pw_name,\n\t\t    TASK_NORMAL) != 0)\n\t\t\tdebug(\"setproject(%s): %s\", defaultproject->pj_name,\n\t\t\t    strerror(errno));\n\t} else {\n\t\t/* debug on getdefaultproj() error */\n\t\tdebug(\"getdefaultproj(%s): %s\", pw->pw_name, strerror(errno));\n\t}\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getdefaultproj(%s): %s\"",
            "pw->pw_name",
            "strerror(errno)"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproject",
          "args": [
            "defaultproject->pj_name",
            "pw->pw_name",
            "TASK_NORMAL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdefaultproj",
          "args": [
            "pw->pw_name",
            "&tempproject",
            "&buf",
            "sizeof(buf)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_set_default_project(struct passwd *pw)\n{\n\tstruct project  *defaultproject;\n\tstruct project   tempproject;\n\tchar buf[1024];\n\n\t/* get default project, if we fail just return gracefully  */\n\tif ((defaultproject = getdefaultproj(pw->pw_name, &tempproject, &buf,\n\t    sizeof(buf))) != NULL) {\n\t\t/* set default project */\n\t\tif (setproject(defaultproject->pj_name, pw->pw_name,\n\t\t    TASK_NORMAL) != 0)\n\t\t\tdebug(\"setproject(%s): %s\", defaultproject->pj_name,\n\t\t\t    strerror(errno));\n\t} else {\n\t\t/* debug on getdefaultproj() error */\n\t\tdebug(\"getdefaultproj(%s): %s\", pw->pw_name, strerror(errno));\n\t}\n}"
  },
  {
    "function_name": "solaris_contract_post_fork_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "139-196",
    "snippet": "void\nsolaris_contract_post_fork_parent(pid_t pid)\n{\n\tctid_t ctid;\n\tchar ctl_path[256];\n\tint r, ctl_fd = -1, stat_fd = -1;\n\n\tdebug2(\"%s: clearing template (fd %d)\", __func__, tmpl_fd);\n\n\tif (tmpl_fd == -1)\n\t\treturn;\n\n\t/* First clear the active template. */\n\tif ((r = ct_tmpl_clear(tmpl_fd)) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n\n\t/*\n\t * If either the fork didn't succeed (pid < 0), or clearing\n\t * th active contract failed (r != 0), then we have nothing\n\t * more do.\n\t */\n\tif (r != 0 || pid <= 0)\n\t\treturn;\n\n\t/* Now lookup and abandon the contract we've created. */\n\tctid = get_active_process_contract_id();\n\n\tdebug2(\"%s: abandoning contract id %ld\", __func__, ctid);\n\n\tsnprintf(ctl_path, sizeof(ctl_path),\n\t    CTFS_ROOT \"/process/%ld/ctl\", ctid);\n\tif ((ctl_fd = open64(ctl_path, O_WRONLY)) < 0) {\n\t\terror(\"%s: Error opening process contract \"\n\t\t    \"ctl file: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_ctl_abandon(ctl_fd) < 0) {\n\t\terror(\"%s: Error abandoning process contract: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tclose(ctl_fd);\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n\tif (stat_fd != -1)\n\t\tclose(stat_fd);\n\tif (ctl_fd != -1)\n\t\tclose(ctl_fd);\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ctl_fd"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Error abandoning process contract: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_ctl_abandon",
          "args": [
            "ctl_fd"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open64",
          "args": [
            "ctl_path",
            "O_WRONLY"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ctl_path",
            "sizeof(ctl_path)",
            "CTFS_ROOT \"/process/%ld/ctl\"",
            "ctid"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: abandoning contract id %ld\"",
            "__func__",
            "ctid"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_active_process_contract_id",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "get_active_process_contract_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "46-73",
          "snippet": "static ctid_t\nget_active_process_contract_id(void)\n{\n\tint stat_fd;\n\tctid_t ctid = -1;\n\tct_stathdl_t stathdl;\n\n\tif ((stat_fd = open64(CT_LATEST, O_RDONLY)) == -1) {\n\t\terror(\"%s: Error opening 'latest' process \"\n\t\t    \"contract: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (ct_status_read(stat_fd, CTD_COMMON, &stathdl) != 0) {\n\t\terror(\"%s: Error reading process contract \"\n\t\t    \"status: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((ctid = ct_status_get_id(stathdl)) < 0) {\n\t\terror(\"%s: Error getting process contract id: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tct_status_free(stathdl);\n out:\n\tclose(stat_fd);\n\treturn ctid;\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CT_LATEST\tCTFS_ROOT \"/process/latest\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\n#define CT_LATEST\tCTFS_ROOT \"/process/latest\"\n\nstatic ctid_t\nget_active_process_contract_id(void)\n{\n\tint stat_fd;\n\tctid_t ctid = -1;\n\tct_stathdl_t stathdl;\n\n\tif ((stat_fd = open64(CT_LATEST, O_RDONLY)) == -1) {\n\t\terror(\"%s: Error opening 'latest' process \"\n\t\t    \"contract: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (ct_status_read(stat_fd, CTD_COMMON, &stathdl) != 0) {\n\t\terror(\"%s: Error reading process contract \"\n\t\t    \"status: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((ctid = ct_status_get_id(stathdl)) < 0) {\n\t\terror(\"%s: Error getting process contract id: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tct_status_free(stathdl);\n out:\n\tclose(stat_fd);\n\treturn ctid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_tmpl_clear",
          "args": [
            "tmpl_fd"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_contract_post_fork_parent(pid_t pid)\n{\n\tctid_t ctid;\n\tchar ctl_path[256];\n\tint r, ctl_fd = -1, stat_fd = -1;\n\n\tdebug2(\"%s: clearing template (fd %d)\", __func__, tmpl_fd);\n\n\tif (tmpl_fd == -1)\n\t\treturn;\n\n\t/* First clear the active template. */\n\tif ((r = ct_tmpl_clear(tmpl_fd)) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n\n\t/*\n\t * If either the fork didn't succeed (pid < 0), or clearing\n\t * th active contract failed (r != 0), then we have nothing\n\t * more do.\n\t */\n\tif (r != 0 || pid <= 0)\n\t\treturn;\n\n\t/* Now lookup and abandon the contract we've created. */\n\tctid = get_active_process_contract_id();\n\n\tdebug2(\"%s: abandoning contract id %ld\", __func__, ctid);\n\n\tsnprintf(ctl_path, sizeof(ctl_path),\n\t    CTFS_ROOT \"/process/%ld/ctl\", ctid);\n\tif ((ctl_fd = open64(ctl_path, O_WRONLY)) < 0) {\n\t\terror(\"%s: Error opening process contract \"\n\t\t    \"ctl file: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_ctl_abandon(ctl_fd) < 0) {\n\t\terror(\"%s: Error abandoning process contract: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tclose(ctl_fd);\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n\tif (stat_fd != -1)\n\t\tclose(stat_fd);\n\tif (ctl_fd != -1)\n\t\tclose(ctl_fd);\n}"
  },
  {
    "function_name": "solaris_contract_post_fork_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "124-137",
    "snippet": "void\nsolaris_contract_post_fork_child()\n{\n\tdebug2(\"%s: clearing process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* Clear the active template. */\n\tif (ct_tmpl_clear(tmpl_fd) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmpl_fd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_tmpl_clear",
          "args": [
            "tmpl_fd"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: clearing process contract template on fd %d\"",
            "__func__",
            "tmpl_fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\nvoid\nsolaris_contract_post_fork_child()\n{\n\tdebug2(\"%s: clearing process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* Clear the active template. */\n\tif (ct_tmpl_clear(tmpl_fd) != 0)\n\t\terror(\"%s: Error clearing active process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\n\tclose(tmpl_fd);\n\ttmpl_fd = -1;\n}"
  },
  {
    "function_name": "solaris_contract_pre_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "75-122",
    "snippet": "void\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmpl_fd"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Error activating process contract \"\n\t\t    \"template: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_tmpl_activate",
          "args": [
            "tmpl_fd"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_tmpl_set_informative",
          "args": [
            "tmpl_fd",
            "CT_PR_EV_HWERR"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_tmpl_set_critical",
          "args": [
            "tmpl_fd",
            "0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_pr_tmpl_set_fatal",
          "args": [
            "tmpl_fd",
            "CT_PR_EV_HWERR"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_pr_tmpl_set_param",
          "args": [
            "tmpl_fd",
            "CT_PR_PGRPONLY"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: setting up process contract template on fd %d\"",
            "__func__",
            "tmpl_fd"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open64",
          "args": [
            "CT_TEMPLATE",
            "O_RDWR"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\n#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\"\n\nvoid\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}"
  },
  {
    "function_name": "get_active_process_contract_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
    "lines": "46-73",
    "snippet": "static ctid_t\nget_active_process_contract_id(void)\n{\n\tint stat_fd;\n\tctid_t ctid = -1;\n\tct_stathdl_t stathdl;\n\n\tif ((stat_fd = open64(CT_LATEST, O_RDONLY)) == -1) {\n\t\terror(\"%s: Error opening 'latest' process \"\n\t\t    \"contract: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (ct_status_read(stat_fd, CTD_COMMON, &stathdl) != 0) {\n\t\terror(\"%s: Error reading process contract \"\n\t\t    \"status: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((ctid = ct_status_get_id(stathdl)) < 0) {\n\t\terror(\"%s: Error getting process contract id: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tct_status_free(stathdl);\n out:\n\tclose(stat_fd);\n\treturn ctid;\n}",
    "includes": [
      "#  include <priv.h>",
      "#include <project.h>",
      "#include <sys/task.h>",
      "#include \"log.h\"",
      "#include <sys/ctfs.h>",
      "#include <sys/contract/process.h>",
      "#include <libcontract.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "# include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CT_LATEST\tCTFS_ROOT \"/process/latest\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "stat_fd"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_status_free",
          "args": [
            "stathdl"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Error getting process contract id: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct_status_get_id",
          "args": [
            "stathdl"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_status_read",
          "args": [
            "stat_fd",
            "CTD_COMMON",
            "&stathdl"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open64",
          "args": [
            "CT_LATEST",
            "O_RDONLY"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\n#define CT_LATEST\tCTFS_ROOT \"/process/latest\"\n\nstatic ctid_t\nget_active_process_contract_id(void)\n{\n\tint stat_fd;\n\tctid_t ctid = -1;\n\tct_stathdl_t stathdl;\n\n\tif ((stat_fd = open64(CT_LATEST, O_RDONLY)) == -1) {\n\t\terror(\"%s: Error opening 'latest' process \"\n\t\t    \"contract: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (ct_status_read(stat_fd, CTD_COMMON, &stathdl) != 0) {\n\t\terror(\"%s: Error reading process contract \"\n\t\t    \"status: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((ctid = ct_status_get_id(stathdl)) < 0) {\n\t\terror(\"%s: Error getting process contract id: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tct_status_free(stathdl);\n out:\n\tclose(stat_fd);\n\treturn ctid;\n}"
  }
]