[
  {
    "function_name": "fopen_cloexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "256-298",
    "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "mode"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "open_mode",
            "0666"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"a\"",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"a+\"",
            "2"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"w\"",
            "1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"w+\"",
            "2"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"r\"",
            "1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mode",
            "\"r+\"",
            "2"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "remove_trailing_slashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "249-254",
    "snippet": "extern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}"
  },
  {
    "function_name": "lxc_global_config_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "88-247",
    "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "user_lxc_path"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option_name",
            "\"lxc.cgroup.pattern\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option_name",
            "\"lxc.default_config\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_trailing_slashes",
          "args": [
            "user_lxc_path"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "249-254",
          "snippet": "extern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option_name",
            "\"lxc.lxcpath\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_global_config_value",
          "args": [
            "p"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "copy_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "70-86",
          "snippet": "static char *copy_global_config_value(char *p)\n{\n\tint len = strlen(p);\n\tchar *retbuf;\n\n\tif (len < 1)\n\t\treturn NULL;\n\tif (p[len-1] == '\\n') {\n\t\tp[len-1] = '\\0';\n\t\tlen--;\n\t}\n\tretbuf = malloc(len+1);\n\tif (!retbuf)\n\t\treturn NULL;\n\tstrcpy(retbuf, p);\n\treturn retbuf;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nstatic char *copy_global_config_value(char *p)\n{\n\tint len = strlen(p);\n\tchar *retbuf;\n\n\tif (len < 1)\n\t\treturn NULL;\n\tif (p[len-1] == '\\n') {\n\t\tp[len-1] = '\\0';\n\t\tlen--;\n\t}\n\tretbuf = malloc(len+1);\n\tif (!retbuf)\n\t\treturn NULL;\n\tstrcpy(retbuf, p);\n\treturn retbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option_name",
            "\"lxc.lxcpath\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "option_name"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "option_name"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "1024",
            "fin"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "user_config_path",
            "\"r\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option_name",
            "(*ptr)[0]"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "DEFAULT_CGROUP_PATTERN"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "LXCPATH"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "LXC_DEFAULT_CONFIG"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "LXC_GLOBAL_CONF"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"lxc/%n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "user_lxc_path",
            "\"%s/.local/share/lxc/\"",
            "user_home"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "user_default_config_path",
            "\"%s/.config/lxc/default.conf\"",
            "user_home"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "user_config_path",
            "\"%s/.config/lxc/lxc.conf\"",
            "user_home"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (19 + strlen(user_home))"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user_home"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (26 + strlen(user_home))"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user_home"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (22 + strlen(user_home))"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user_home"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"HOME\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
  },
  {
    "function_name": "copy_global_config_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "70-86",
    "snippet": "static char *copy_global_config_value(char *p)\n{\n\tint len = strlen(p);\n\tchar *retbuf;\n\n\tif (len < 1)\n\t\treturn NULL;\n\tif (p[len-1] == '\\n') {\n\t\tp[len-1] = '\\0';\n\t\tlen--;\n\t}\n\tretbuf = malloc(len+1);\n\tif (!retbuf)\n\t\treturn NULL;\n\tstrcpy(retbuf, p);\n\treturn retbuf;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "retbuf",
            "p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nstatic char *copy_global_config_value(char *p)\n{\n\tint len = strlen(p);\n\tchar *retbuf;\n\n\tif (len < 1)\n\t\treturn NULL;\n\tif (p[len-1] == '\\n') {\n\t\tp[len-1] = '\\0';\n\t\tlen--;\n\t}\n\tretbuf = malloc(len+1);\n\tif (!retbuf)\n\t\treturn NULL;\n\tstrcpy(retbuf, p);\n\treturn retbuf;\n}"
  },
  {
    "function_name": "lxc_setup_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "45-68",
    "snippet": "extern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to mount /dev/mqueue\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_fs",
          "args": [
            "\"mqueue\"",
            "\"/dev/mqueue\"",
            "\"mqueue\""
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "mount_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "29-43",
          "snippet": "static int mount_fs(const char *source, const char *target, const char *type)\n{\n\t/* the umount may fail */\n\tif (umount(target))\n\t\tWARN(\"failed to unmount %s : %s\", target, strerror(errno));\n\n\tif (mount(source, target, type, 0, NULL)) {\n\t\tERROR(\"failed to mount %s : %s\", target, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"'%s' mounted on '%s'\", source, target);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nstatic int mount_fs(const char *source, const char *target, const char *type)\n{\n\t/* the umount may fail */\n\tif (umount(target))\n\t\tWARN(\"failed to unmount %s : %s\", target, strerror(errno));\n\n\tif (mount(source, target, type, 0, NULL)) {\n\t\tERROR(\"failed to mount %s : %s\", target, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"'%s' mounted on '%s'\", source, target);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"failed to create '/dev/mqueue'\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "\"/dev/mqueue\"",
            "0666"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/dev/mqueue\"",
            "F_OK"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to mount /dev/shm\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to create /dev/shm\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/dev/shm\"",
            "F_OK"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to remount proc\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}"
  },
  {
    "function_name": "mount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
    "lines": "29-43",
    "snippet": "static int mount_fs(const char *source, const char *target, const char *type)\n{\n\t/* the umount may fail */\n\tif (umount(target))\n\t\tWARN(\"failed to unmount %s : %s\", target, strerror(errno));\n\n\tif (mount(source, target, type, 0, NULL)) {\n\t\tERROR(\"failed to mount %s : %s\", target, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"'%s' mounted on '%s'\", source, target);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"initutils.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"'%s' mounted on '%s'\"",
            "source",
            "target"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to mount %s : %s\"",
            "target",
            "strerror(errno)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "source",
            "target",
            "type",
            "0",
            "NULL"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to unmount %s : %s\"",
            "target",
            "strerror(errno)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "target"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "rbd_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrbd.c",
          "lines": "174-181",
          "snippet": "int rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nstatic int mount_fs(const char *source, const char *target, const char *type)\n{\n\t/* the umount may fail */\n\tif (umount(target))\n\t\tWARN(\"failed to unmount %s : %s\", target, strerror(errno));\n\n\tif (mount(source, target, type, 0, NULL)) {\n\t\tERROR(\"failed to mount %s : %s\", target, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"'%s' mounted on '%s'\", source, target);\n\n\treturn 0;\n}"
  }
]