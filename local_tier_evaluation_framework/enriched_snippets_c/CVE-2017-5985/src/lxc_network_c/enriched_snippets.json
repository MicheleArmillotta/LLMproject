[
  {
    "function_name": "setup_private_host_hw_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1568-1592",
    "snippet": "int setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sockfd"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sockfd",
            "SIOCSIFHWADDR",
            "&ifr"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sockfd",
            "SIOCGIFHWADDR",
            "&ifr"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "(char *)ifr.ifr_name",
            "IFNAMSIZ",
            "\"%s\"",
            "veth1"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_mkifname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1507-1566",
    "snippet": "char *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddr"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "name"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "padchar"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "padchar"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_r",
          "args": [
            "&seed"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "template"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "seed"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "urandom"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&seed",
            "sizeof(seed)",
            "1",
            "urandom"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/dev/urandom\"",
            "\"r\""
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddr"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "getifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "548-588",
          "snippet": "int getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nint getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nchar *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}"
  },
  {
    "function_name": "lxc_net_type_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1497-1502",
    "snippet": "const char *lxc_net_type_to_str(int type)\n{\n\tif (type < 0 || type > LXC_NET_MAXCONFTYPE)\n\t\treturn NULL;\n\treturn lxc_network_types[type];\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* const lxc_network_types[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_EMPTY]   = \"empty\",\n\t[LXC_NET_VETH]    = \"veth\",\n\t[LXC_NET_MACVLAN] = \"macvlan\",\n\t[LXC_NET_PHYS]    = \"phys\",\n\t[LXC_NET_VLAN]    = \"vlan\",\n\t[LXC_NET_NONE]    = \"none\",\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* const lxc_network_types[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_EMPTY]   = \"empty\",\n\t[LXC_NET_VETH]    = \"veth\",\n\t[LXC_NET_MACVLAN] = \"macvlan\",\n\t[LXC_NET_PHYS]    = \"phys\",\n\t[LXC_NET_VLAN]    = \"vlan\",\n\t[LXC_NET_NONE]    = \"none\",\n};\n\nconst char *lxc_net_type_to_str(int type)\n{\n\tif (type < 0 || type > LXC_NET_MAXCONFTYPE)\n\t\treturn NULL;\n\treturn lxc_network_types[type];\n}"
  },
  {
    "function_name": "lxc_bridge_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1458-1486",
    "snippet": "int lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCBRADDIF",
            "&ifr"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "bridge",
            "IFNAMSIZ-1"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_to_ovs_bridge",
          "args": [
            "lxcpath",
            "name",
            "bridge",
            "ifname"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "attach_to_ovs_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1421-1452",
          "snippet": "static int attach_to_ovs_bridge(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tpid_t pid;\n\tchar *cmd;\n\tint ret;\n\n\tcmd = on_path(\"ovs-vsctl\", NULL);\n\tif (!cmd)\n\t\treturn -1;\n\tfree(cmd);\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpid = fork();\n\t\tif (pid < 0)\n\t\t\treturn -1;  // how to properly recover?\n\t\tif (pid > 0)\n\t\t\treturn 0;\n\t\tovs_cleanup_nic(lxcpath, name, bridge, nic);\n\t\texit(0);\n\t}\n\n\tif (execlp(\"ovs-vsctl\", \"ovs-vsctl\", \"add-port\", bridge, nic, (char *)NULL))\n\t\texit(1);\n\t// not reached\n\texit(1);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int attach_to_ovs_bridge(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tpid_t pid;\n\tchar *cmd;\n\tint ret;\n\n\tcmd = on_path(\"ovs-vsctl\", NULL);\n\tif (!cmd)\n\t\treturn -1;\n\tfree(cmd);\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpid = fork();\n\t\tif (pid < 0)\n\t\t\treturn -1;  // how to properly recover?\n\t\tif (pid > 0)\n\t\t\treturn 0;\n\t\tovs_cleanup_nic(lxcpath, name, bridge, nic);\n\t\texit(0);\n\t}\n\n\tif (execlp(\"ovs-vsctl\", \"ovs-vsctl\", \"add-port\", bridge, nic, (char *)NULL))\n\t\texit(1);\n\t// not reached\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ovs_bridge",
          "args": [
            "bridge"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "is_ovs_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1396-1405",
          "snippet": "static bool is_ovs_bridge(const char *bridge)\n{\n\tchar brdirname[22 + IFNAMSIZ + 1] = {0};\n\tstruct stat sb;\n\n\tsnprintf(brdirname, 22 +IFNAMSIZ + 1, \"/sys/class/net/%s/bridge\", bridge);\n\tif (stat(brdirname, &sb) == -1 && errno == ENOENT)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool is_ovs_bridge(const char *bridge)\n{\n\tchar brdirname[22 + IFNAMSIZ + 1] = {0};\n\tstruct stat sb;\n\n\tsnprintf(brdirname, 22 +IFNAMSIZ + 1, \"/sys/class/net/%s/bridge\", bridge);\n\tif (stat(brdirname, &sb) == -1 && errno == ENOENT)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "ifname"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}"
  },
  {
    "function_name": "attach_to_ovs_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1421-1452",
    "snippet": "static int attach_to_ovs_bridge(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tpid_t pid;\n\tchar *cmd;\n\tint ret;\n\n\tcmd = on_path(\"ovs-vsctl\", NULL);\n\tif (!cmd)\n\t\treturn -1;\n\tfree(cmd);\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpid = fork();\n\t\tif (pid < 0)\n\t\t\treturn -1;  // how to properly recover?\n\t\tif (pid > 0)\n\t\t\treturn 0;\n\t\tovs_cleanup_nic(lxcpath, name, bridge, nic);\n\t\texit(0);\n\t}\n\n\tif (execlp(\"ovs-vsctl\", \"ovs-vsctl\", \"add-port\", bridge, nic, (char *)NULL))\n\t\texit(1);\n\t// not reached\n\texit(1);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"ovs-vsctl\"",
            "\"ovs-vsctl\"",
            "\"add-port\"",
            "bridge",
            "nic",
            "(char *)NULL"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovs_cleanup_nic",
          "args": [
            "lxcpath",
            "name",
            "bridge",
            "nic"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "ovs_cleanup_nic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1411-1419",
          "snippet": "static void ovs_cleanup_nic(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tif (lxc_check_inherited(NULL, true, -1) < 0)\n\t\treturn;\n\tif (lxc_wait(name, \"STOPPED\", -1, lxcpath) < 0)\n\t\treturn;\n\texeclp(\"ovs-vsctl\", \"ovs-vsctl\", \"del-port\", bridge, nic, (char *)NULL);\n\texit(1); /* not reached */\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void ovs_cleanup_nic(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tif (lxc_check_inherited(NULL, true, -1) < 0)\n\t\treturn;\n\tif (lxc_wait(name, \"STOPPED\", -1, lxcpath) < 0)\n\t\treturn;\n\texeclp(\"ovs-vsctl\", \"ovs-vsctl\", \"del-port\", bridge, nic, (char *)NULL);\n\texit(1); /* not reached */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"ovs-vsctl\"",
            "NULL"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int attach_to_ovs_bridge(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tpid_t pid;\n\tchar *cmd;\n\tint ret;\n\n\tcmd = on_path(\"ovs-vsctl\", NULL);\n\tif (!cmd)\n\t\treturn -1;\n\tfree(cmd);\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpid = fork();\n\t\tif (pid < 0)\n\t\t\treturn -1;  // how to properly recover?\n\t\tif (pid > 0)\n\t\t\treturn 0;\n\t\tovs_cleanup_nic(lxcpath, name, bridge, nic);\n\t\texit(0);\n\t}\n\n\tif (execlp(\"ovs-vsctl\", \"ovs-vsctl\", \"add-port\", bridge, nic, (char *)NULL))\n\t\texit(1);\n\t// not reached\n\texit(1);\n}"
  },
  {
    "function_name": "ovs_cleanup_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1411-1419",
    "snippet": "static void ovs_cleanup_nic(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tif (lxc_check_inherited(NULL, true, -1) < 0)\n\t\treturn;\n\tif (lxc_wait(name, \"STOPPED\", -1, lxcpath) < 0)\n\t\treturn;\n\texeclp(\"ovs-vsctl\", \"ovs-vsctl\", \"del-port\", bridge, nic, (char *)NULL);\n\texit(1); /* not reached */\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"ovs-vsctl\"",
            "\"ovs-vsctl\"",
            "\"del-port\"",
            "bridge",
            "nic",
            "(char *)NULL"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_wait",
          "args": [
            "name",
            "\"STOPPED\"",
            "-1",
            "lxcpath"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "108-197",
          "snippet": "extern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_check_inherited",
          "args": [
            "NULL",
            "true",
            "-1"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_check_inherited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "198-257",
          "snippet": "int lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nint lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void ovs_cleanup_nic(const char *lxcpath, const char *name, const char *bridge, const char *nic)\n{\n\tif (lxc_check_inherited(NULL, true, -1) < 0)\n\t\treturn;\n\tif (lxc_wait(name, \"STOPPED\", -1, lxcpath) < 0)\n\t\treturn;\n\texeclp(\"ovs-vsctl\", \"ovs-vsctl\", \"del-port\", bridge, nic, (char *)NULL);\n\texit(1); /* not reached */\n}"
  },
  {
    "function_name": "is_ovs_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1396-1405",
    "snippet": "static bool is_ovs_bridge(const char *bridge)\n{\n\tchar brdirname[22 + IFNAMSIZ + 1] = {0};\n\tstruct stat sb;\n\n\tsnprintf(brdirname, 22 +IFNAMSIZ + 1, \"/sys/class/net/%s/bridge\", bridge);\n\tif (stat(brdirname, &sb) == -1 && errno == ENOENT)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "brdirname",
            "&sb"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "brdirname",
            "22 +IFNAMSIZ + 1",
            "\"/sys/class/net/%s/bridge\"",
            "bridge"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool is_ovs_bridge(const char *bridge)\n{\n\tchar brdirname[22 + IFNAMSIZ + 1] = {0};\n\tstruct stat sb;\n\n\tsnprintf(brdirname, 22 +IFNAMSIZ + 1, \"/sys/class/net/%s/bridge\", bridge);\n\tif (stat(brdirname, &sb) == -1 && errno == ENOENT)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "lxc_ipv6_dest_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1391-1394",
    "snippet": "int lxc_ipv6_dest_add(int ifindex, struct in6_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET6, ifindex, dest);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_route_dest_add",
          "args": [
            "AF_INET6",
            "ifindex",
            "dest"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ip_route_dest_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1335-1384",
          "snippet": "static int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_dest_add(int ifindex, struct in6_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET6, ifindex, dest);\n}"
  },
  {
    "function_name": "lxc_ipv4_dest_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1386-1389",
    "snippet": "int lxc_ipv4_dest_add(int ifindex, struct in_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET, ifindex, dest);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_route_dest_add",
          "args": [
            "AF_INET",
            "ifindex",
            "dest"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "ip_route_dest_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1335-1384",
          "snippet": "static int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_dest_add(int ifindex, struct in_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET, ifindex, dest);\n}"
  },
  {
    "function_name": "ip_route_dest_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1335-1384",
    "snippet": "static int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "RTA_OIF",
            "ifindex"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_buffer",
          "args": [
            "nlmsg",
            "RTA_DST",
            "dest",
            "addrlen"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "69-73",
          "snippet": "extern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct rtmsg)"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_route_dest_add(int family, int ifindex, void *dest)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_LINK;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\trt->rtm_dst_len = addrlen*8;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_DST, dest, addrlen))\n\t\tgoto out;\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_ipv6_gateway_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1330-1333",
    "snippet": "int lxc_ipv6_gateway_add(int ifindex, struct in6_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET6, ifindex, gw);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_gateway_add",
          "args": [
            "AF_INET6",
            "ifindex",
            "gw"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "ip_gateway_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1269-1323",
          "snippet": "static int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_gateway_add(int ifindex, struct in6_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET6, ifindex, gw);\n}"
  },
  {
    "function_name": "lxc_ipv4_gateway_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1325-1328",
    "snippet": "int lxc_ipv4_gateway_add(int ifindex, struct in_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET, ifindex, gw);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_gateway_add",
          "args": [
            "AF_INET",
            "ifindex",
            "gw"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ip_gateway_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1269-1323",
          "snippet": "static int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_gateway_add(int ifindex, struct in_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET, ifindex, gw);\n}"
  },
  {
    "function_name": "ip_gateway_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1269-1323",
    "snippet": "static int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "RTA_OIF",
            "ifindex"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_buffer",
          "args": [
            "nlmsg",
            "RTA_GATEWAY",
            "gw",
            "addrlen"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "69-73",
          "snippet": "extern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct rtmsg)"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_gateway_add(int family, int ifindex, void *gw)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct rtmsg *rt;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWROUTE;\n\n\trt = nlmsg_reserve(nlmsg, sizeof(struct rtmsg));\n\tif (!rt)\n\t\tgoto out;\n\trt->rtm_family = family;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_type = RTN_UNICAST;\n\t/* \"default\" destination */\n\trt->rtm_dst_len = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, RTA_GATEWAY, gw, addrlen))\n\t\tgoto out;\n\n\t/* Adding the interface index enables the use of link-local\n\t * addresses for the gateway */\n\tif (nla_put_u32(nlmsg, RTA_OIF, ifindex))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_ipv4_addr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1264-1267",
    "snippet": "int lxc_ipv4_addr_get(int ifindex, struct in_addr** res)\n{\n\treturn ip_addr_get(AF_INET, ifindex, (void**)res);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_addr_get",
          "args": [
            "AF_INET",
            "ifindex",
            "(void**)res"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ip_addr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1150-1257",
          "snippet": "static int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_addr_get(int ifindex, struct in_addr** res)\n{\n\treturn ip_addr_get(AF_INET, ifindex, (void**)res);\n}"
  },
  {
    "function_name": "lxc_ipv6_addr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1259-1262",
    "snippet": "int lxc_ipv6_addr_get(int ifindex, struct in6_addr **res)\n{\n\treturn ip_addr_get(AF_INET6, ifindex, (void**)res);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_addr_get",
          "args": [
            "AF_INET6",
            "ifindex",
            "(void**)res"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "ip_addr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1150-1257",
          "snippet": "static int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_addr_get(int ifindex, struct in6_addr **res)\n{\n\treturn ip_addr_get(AF_INET6, ifindex, (void**)res);\n}"
  },
  {
    "function_name": "ip_addr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1150-1257",
    "snippet": "static int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "msg",
            "recv_len"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifa_get_local_ip",
          "args": [
            "family",
            "msg",
            "res"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ifa_get_local_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1109-1148",
          "snippet": "static int ifa_get_local_ip(int family, struct nlmsghdr *msg, void** res) {\n\tstruct ifaddrmsg *ifa = NLMSG_DATA(msg);\n\tstruct rtattr *rta = IFA_RTA(ifa);\n\tint attr_len = NLMSG_PAYLOAD(msg, sizeof(struct ifaddrmsg));\n\tint addrlen;\n\n\tif (ifa->ifa_family != family)\n\t\treturn 0;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\t/* Loop over the rtattr's in this message */\n\twhile(RTA_OK(rta, attr_len)) {\n\t\t/* Found a local address for the requested interface,\n\t\t * return it. */\n\t\tif (rta->rta_type == IFA_LOCAL || rta->rta_type == IFA_ADDRESS) {\n\t\t\t/* Sanity check. The family check above should\n\t\t\t * make sure the address length is correct, but\n\t\t\t * check here just in case */\n\t\t\tif (RTA_PAYLOAD(rta) != addrlen)\n\t\t\t\treturn -1;\n\n\t\t\t/* We might have found an IFA_ADDRESS before,\n\t\t\t * which we now overwrite with an IFA_LOCAL. */\n\t\t\tif (!*res) {\n\t\t\t\t*res = malloc(addrlen);\n\t\t\t\tif (!*res)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(*res, RTA_DATA(rta), addrlen);\n\n\t\t\tif (rta->rta_type == IFA_LOCAL)\n\t\t\t\tbreak;\n\t\t}\n\t\trta = RTA_NEXT(rta, attr_len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ifa_get_local_ip(int family, struct nlmsghdr *msg, void** res) {\n\tstruct ifaddrmsg *ifa = NLMSG_DATA(msg);\n\tstruct rtattr *rta = IFA_RTA(ifa);\n\tint attr_len = NLMSG_PAYLOAD(msg, sizeof(struct ifaddrmsg));\n\tint addrlen;\n\n\tif (ifa->ifa_family != family)\n\t\treturn 0;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\t/* Loop over the rtattr's in this message */\n\twhile(RTA_OK(rta, attr_len)) {\n\t\t/* Found a local address for the requested interface,\n\t\t * return it. */\n\t\tif (rta->rta_type == IFA_LOCAL || rta->rta_type == IFA_ADDRESS) {\n\t\t\t/* Sanity check. The family check above should\n\t\t\t * make sure the address length is correct, but\n\t\t\t * check here just in case */\n\t\t\tif (RTA_PAYLOAD(rta) != addrlen)\n\t\t\t\treturn -1;\n\n\t\t\t/* We might have found an IFA_ADDRESS before,\n\t\t\t * which we now overwrite with an IFA_LOCAL. */\n\t\t\tif (!*res) {\n\t\t\t\t*res = malloc(addrlen);\n\t\t\t\tif (!*res)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(*res, RTA_DATA(rta), addrlen);\n\n\t\t\tif (rta->rta_type == IFA_LOCAL)\n\t\t\t\tbreak;\n\t\t}\n\t\trta = RTA_NEXT(rta, attr_len);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "msg"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "msg"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "msg",
            "recv_len"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_rcv",
          "args": [
            "&nlh",
            "answer"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_rcv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "45-48",
          "snippet": "extern int rtnetlink_rcv(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\treturn netlink_rcv(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_rcv(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\treturn netlink_rcv(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_send",
          "args": [
            "&nlh",
            "nlmsg"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "50-54",
          "snippet": "extern int rtnetlink_send(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\n\treturn netlink_send(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_send(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\n\treturn netlink_send(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_get(int family, int ifindex, void **res)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tstruct nlmsghdr *msg;\n\tint err;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ROOT;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_family = family;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (msg->nlmsg_type != RTM_NEWADDR) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tifa = (struct ifaddrmsg *)NLMSG_DATA(msg);\n\t\t\tif (ifa->ifa_index == ifindex) {\n\t\t\t\tif (ifa_get_local_ip(family, msg, res) < 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* Found a result, stop searching */\n\t\t\t\tif (*res)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "ifa_get_local_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1109-1148",
    "snippet": "static int ifa_get_local_ip(int family, struct nlmsghdr *msg, void** res) {\n\tstruct ifaddrmsg *ifa = NLMSG_DATA(msg);\n\tstruct rtattr *rta = IFA_RTA(ifa);\n\tint attr_len = NLMSG_PAYLOAD(msg, sizeof(struct ifaddrmsg));\n\tint addrlen;\n\n\tif (ifa->ifa_family != family)\n\t\treturn 0;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\t/* Loop over the rtattr's in this message */\n\twhile(RTA_OK(rta, attr_len)) {\n\t\t/* Found a local address for the requested interface,\n\t\t * return it. */\n\t\tif (rta->rta_type == IFA_LOCAL || rta->rta_type == IFA_ADDRESS) {\n\t\t\t/* Sanity check. The family check above should\n\t\t\t * make sure the address length is correct, but\n\t\t\t * check here just in case */\n\t\t\tif (RTA_PAYLOAD(rta) != addrlen)\n\t\t\t\treturn -1;\n\n\t\t\t/* We might have found an IFA_ADDRESS before,\n\t\t\t * which we now overwrite with an IFA_LOCAL. */\n\t\t\tif (!*res) {\n\t\t\t\t*res = malloc(addrlen);\n\t\t\t\tif (!*res)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(*res, RTA_DATA(rta), addrlen);\n\n\t\t\tif (rta->rta_type == IFA_LOCAL)\n\t\t\t\tbreak;\n\t\t}\n\t\trta = RTA_NEXT(rta, attr_len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "rta",
            "attr_len"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*res",
            "RTA_DATA(rta)",
            "addrlen"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "addrlen"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "rta"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "rta",
            "attr_len"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "msg",
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFA_RTA",
          "args": [
            "ifa"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "msg"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ifa_get_local_ip(int family, struct nlmsghdr *msg, void** res) {\n\tstruct ifaddrmsg *ifa = NLMSG_DATA(msg);\n\tstruct rtattr *rta = IFA_RTA(ifa);\n\tint attr_len = NLMSG_PAYLOAD(msg, sizeof(struct ifaddrmsg));\n\tint addrlen;\n\n\tif (ifa->ifa_family != family)\n\t\treturn 0;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\t/* Loop over the rtattr's in this message */\n\twhile(RTA_OK(rta, attr_len)) {\n\t\t/* Found a local address for the requested interface,\n\t\t * return it. */\n\t\tif (rta->rta_type == IFA_LOCAL || rta->rta_type == IFA_ADDRESS) {\n\t\t\t/* Sanity check. The family check above should\n\t\t\t * make sure the address length is correct, but\n\t\t\t * check here just in case */\n\t\t\tif (RTA_PAYLOAD(rta) != addrlen)\n\t\t\t\treturn -1;\n\n\t\t\t/* We might have found an IFA_ADDRESS before,\n\t\t\t * which we now overwrite with an IFA_LOCAL. */\n\t\t\tif (!*res) {\n\t\t\t\t*res = malloc(addrlen);\n\t\t\t\tif (!*res)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(*res, RTA_DATA(rta), addrlen);\n\n\t\t\tif (rta->rta_type == IFA_LOCAL)\n\t\t\t\tbreak;\n\t\t}\n\t\trta = RTA_NEXT(rta, attr_len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_ipv4_addr_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1098-1102",
    "snippet": "int lxc_ipv4_addr_add(int ifindex, struct in_addr *addr,\n\t\t      struct in_addr *bcast, int prefix)\n{\n\treturn ip_addr_add(AF_INET, ifindex, addr, bcast, NULL, prefix);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_addr_add",
          "args": [
            "AF_INET",
            "ifindex",
            "addr",
            "bcast",
            "NULL",
            "prefix"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ip_addr_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1029-1089",
          "snippet": "static int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_addr_add(int ifindex, struct in_addr *addr,\n\t\t      struct in_addr *bcast, int prefix)\n{\n\treturn ip_addr_add(AF_INET, ifindex, addr, bcast, NULL, prefix);\n}"
  },
  {
    "function_name": "lxc_ipv6_addr_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1091-1096",
    "snippet": "int lxc_ipv6_addr_add(int ifindex, struct in6_addr *addr,\n\t\t      struct in6_addr *mcast,\n\t\t      struct in6_addr *acast, int prefix)\n{\n\treturn ip_addr_add(AF_INET6, ifindex, addr, mcast, acast, prefix);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_addr_add",
          "args": [
            "AF_INET6",
            "ifindex",
            "addr",
            "mcast",
            "acast",
            "prefix"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ip_addr_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1029-1089",
          "snippet": "static int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_addr_add(int ifindex, struct in6_addr *addr,\n\t\t      struct in6_addr *mcast,\n\t\t      struct in6_addr *acast, int prefix)\n{\n\treturn ip_addr_add(AF_INET6, ifindex, addr, mcast, acast, prefix);\n}"
  },
  {
    "function_name": "ip_addr_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "1029-1089",
    "snippet": "static int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "acast",
            "&in6addr_any",
            "sizeof(in6addr_any)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "bcast",
            "&in6addr_any",
            "sizeof(in6addr_any)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_buffer",
          "args": [
            "nlmsg",
            "IFA_BROADCAST",
            "bcast",
            "addrlen"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "69-73",
          "snippet": "extern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_buffer(struct nlmsg *nlmsg, int attr,\n\t\t\t  const void *data, size_t size)\n{\n\treturn nla_put(nlmsg, attr, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_addr_add(int family, int ifindex,\n\t\t       void *addr, void *bcast, void *acast, int prefix)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifaddrmsg *ifa;\n\tint addrlen;\n\tint err;\n\n\taddrlen = family == AF_INET ? sizeof(struct in_addr) :\n\t\tsizeof(struct in6_addr);\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_ACK|NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWADDR;\n\n\tifa = nlmsg_reserve(nlmsg, sizeof(struct ifaddrmsg));\n\tif (!ifa)\n\t\tgoto out;\n\tifa->ifa_prefixlen = prefix;\n\tifa->ifa_index = ifindex;\n\tifa->ifa_family = family;\n\tifa->ifa_scope = 0;\n\n\terr = -EINVAL;\n\tif (nla_put_buffer(nlmsg, IFA_LOCAL, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_ADDRESS, addr, addrlen))\n\t\tgoto out;\n\n\tif (nla_put_buffer(nlmsg, IFA_BROADCAST, bcast, addrlen))\n\t\tgoto out;\n\n\t/* TODO : multicast, anycast with ipv6 */\n\terr = -EPROTONOSUPPORT;\n\tif (family == AF_INET6 &&\n\t    (memcmp(bcast, &in6addr_any, sizeof(in6addr_any)) ||\n\t     memcmp(acast, &in6addr_any, sizeof(in6addr_any))))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_convert_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "982-1027",
    "snippet": "int lxc_convert_mac(char *macaddr, struct sockaddr *sockaddr)\n{\n\tunsigned char *data;\n\tchar c;\n\tint i = 0;\n\tunsigned val;\n\n\tsockaddr->sa_family = ARPHRD_ETHER;\n\tdata = (unsigned char *)sockaddr->sa_data;\n\n\twhile ((*macaddr != '\\0') && (i < ETH_ALEN)) {\n\t    val = 0;\n\t    c = *macaddr++;\n\t    if (isdigit(c))\n\t\t    val = c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val = c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val = c - 'A' + 10;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    val <<= 4;\n\t    c = *macaddr;\n\t    if (isdigit(c))\n\t\t    val |= c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val |= c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val |= c - 'A' + 10;\n\t    else if (c == ':' || c == 0)\n\t\t    val >>= 4;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    if (c != 0)\n\t\t    macaddr++;\n\t    *data++ = (unsigned char) (val & 0377);\n\t    i++;\n\n\t    if (*macaddr == ':')\n\t\t    macaddr++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_convert_mac(char *macaddr, struct sockaddr *sockaddr)\n{\n\tunsigned char *data;\n\tchar c;\n\tint i = 0;\n\tunsigned val;\n\n\tsockaddr->sa_family = ARPHRD_ETHER;\n\tdata = (unsigned char *)sockaddr->sa_data;\n\n\twhile ((*macaddr != '\\0') && (i < ETH_ALEN)) {\n\t    val = 0;\n\t    c = *macaddr++;\n\t    if (isdigit(c))\n\t\t    val = c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val = c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val = c - 'A' + 10;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    val <<= 4;\n\t    c = *macaddr;\n\t    if (isdigit(c))\n\t\t    val |= c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val |= c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val |= c - 'A' + 10;\n\t    else if (c == ':' || c == 0)\n\t\t    val >>= 4;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    if (c != 0)\n\t\t    macaddr++;\n\t    *data++ = (unsigned char) (val & 0377);\n\t    i++;\n\n\t    if (*macaddr == ':')\n\t\t    macaddr++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_neigh_proxy_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "977-980",
    "snippet": "int lxc_neigh_proxy_off(const char *name, int family)\n{\n\treturn neigh_proxy_set(name, family, 0);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "neigh_proxy_set",
          "args": [
            "name",
            "family",
            "0"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "neigh_proxy_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "955-970",
          "snippet": "static int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_neigh_proxy_off(const char *name, int family)\n{\n\treturn neigh_proxy_set(name, family, 0);\n}"
  },
  {
    "function_name": "lxc_neigh_proxy_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "972-975",
    "snippet": "int lxc_neigh_proxy_on(const char *name, int family)\n{\n\treturn neigh_proxy_set(name, family, 1);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "neigh_proxy_set",
          "args": [
            "name",
            "family",
            "1"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "neigh_proxy_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "955-970",
          "snippet": "static int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_neigh_proxy_on(const char *name, int family)\n{\n\treturn neigh_proxy_set(name, family, 1);\n}"
  },
  {
    "function_name": "neigh_proxy_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "955-970",
    "snippet": "static int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_net_write",
          "args": [
            "path",
            "flag?\"1\":\"0\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_net_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "914-927",
          "snippet": "static int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/sys/net/%s/conf/%s/%s\"",
            "family == AF_INET?\"ipv4\":\"ipv6\"",
            "ifname",
            "family == AF_INET?\"proxy_arp\":\"proxy_ndp\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int neigh_proxy_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/%s\",\n\t\tfamily == AF_INET?\"ipv4\":\"ipv6\" , ifname,\n\t\tfamily == AF_INET?\"proxy_arp\":\"proxy_ndp\");\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
  },
  {
    "function_name": "lxc_ip_forward_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "950-953",
    "snippet": "int lxc_ip_forward_off(const char *ifname, int family)\n{\n\treturn ip_forward_set(ifname, family, 0);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_forward_set",
          "args": [
            "ifname",
            "family",
            "0"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ip_forward_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "929-943",
          "snippet": "static int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ip_forward_off(const char *ifname, int family)\n{\n\treturn ip_forward_set(ifname, family, 0);\n}"
  },
  {
    "function_name": "lxc_ip_forward_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "945-948",
    "snippet": "int lxc_ip_forward_on(const char *ifname, int family)\n{\n\treturn ip_forward_set(ifname, family, 1);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_forward_set",
          "args": [
            "ifname",
            "family",
            "1"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ip_forward_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "929-943",
          "snippet": "static int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ip_forward_on(const char *ifname, int family)\n{\n\treturn ip_forward_set(ifname, family, 1);\n}"
  },
  {
    "function_name": "ip_forward_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "929-943",
    "snippet": "static int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_net_write",
          "args": [
            "path",
            "flag?\"1\":\"0\""
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_net_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "914-927",
          "snippet": "static int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/sys/net/%s/conf/%s/forwarding\"",
            "family == AF_INET?\"ipv4\":\"ipv6\"",
            "ifname"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int ip_forward_set(const char *ifname, int family, int flag)\n{\n\tchar path[MAXPATHLEN];\n\tint rc;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\trc = snprintf(path, MAXPATHLEN, \"/proc/sys/net/%s/conf/%s/forwarding\",\n\t\t family == AF_INET?\"ipv4\":\"ipv6\" , ifname);\n\tif (rc >= MAXPATHLEN)\n\t\treturn -E2BIG;\n\n\treturn proc_sys_net_write(path, flag?\"1\":\"0\");\n}"
  },
  {
    "function_name": "proc_sys_net_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "914-927",
    "snippet": "static int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "value",
            "strlen(value)"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int proc_sys_net_write(const char *path, const char *value)\n{\n\tint fd, err = 0;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (write(fd, value, strlen(value)) < 0)\n\t\terr = -errno;\n\n\tclose(fd);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_macvlan_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "834-912",
    "snippet": "int lxc_macvlan_create(const char *master, const char *name, int mode)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(master);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"macvlan\"))\n\t\tgoto out;\n\n\tif (mode) {\n\t\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\t\tif (!nest2)\n\t\t\tgoto out;\n\n\t\tif (nla_put_u32(nlmsg, IFLA_MACVLAN_MODE, mode))\n\t\t\tgoto out;\n\n\t\tnla_end_nested(nlmsg, nest2);\n\t}\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, index))\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_string",
          "args": [
            "nlmsg",
            "IFLA_IFNAME",
            "name"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "75-78",
          "snippet": "extern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "IFLA_LINK",
            "index"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_end_nested",
          "args": [
            "nlmsg",
            "nest"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "nla_end_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "105-108",
          "snippet": "void nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nvoid nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_begin_nested",
          "args": [
            "nlmsg",
            "IFLA_INFO_DATA"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "nla_begin_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "95-103",
          "snippet": "struct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nstruct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "master"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "master"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_macvlan_create(const char *master, const char *name, int mode)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(master);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"macvlan\"))\n\t\tgoto out;\n\n\tif (mode) {\n\t\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\t\tif (!nest2)\n\t\t\tgoto out;\n\n\t\tif (nla_put_u32(nlmsg, IFLA_MACVLAN_MODE, mode))\n\t\t\tgoto out;\n\n\t\tnla_end_nested(nlmsg, nest2);\n\t}\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, index))\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_vlan_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "754-832",
    "snippet": "int lxc_vlan_create(const char *master, const char *name, unsigned short vlanid)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint lindex, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto err3;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto err2;\n\n\terr = -EINVAL;\n\tlindex = if_nametoindex(master);\n\tif (!lindex)\n\t\tgoto err1;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"vlan\"))\n\t\tgoto err1;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto err1;\n\n\tif (nla_put_u16(nlmsg, IFLA_VLAN_ID, vlanid))\n\t\tgoto err1;\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, lindex))\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto err1;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nerr1:\n\tnlmsg_free(answer);\nerr2:\n\tnlmsg_free(nlmsg);\nerr3:\n\tnetlink_close(&nlh);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_string",
          "args": [
            "nlmsg",
            "IFLA_IFNAME",
            "name"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "75-78",
          "snippet": "extern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "IFLA_LINK",
            "lindex"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_end_nested",
          "args": [
            "nlmsg",
            "nest"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "nla_end_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "105-108",
          "snippet": "void nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nvoid nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u16",
          "args": [
            "nlmsg",
            "IFLA_VLAN_ID",
            "vlanid"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "85-88",
          "snippet": "extern int nla_put_u16(struct nlmsg *nlmsg, int attr, unsigned short value)\n{\n\treturn nla_put(nlmsg, attr, &value, 2);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u16(struct nlmsg *nlmsg, int attr, unsigned short value)\n{\n\treturn nla_put(nlmsg, attr, &value, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_begin_nested",
          "args": [
            "nlmsg",
            "IFLA_INFO_DATA"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "nla_begin_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "95-103",
          "snippet": "struct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nstruct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "master"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "master"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_vlan_create(const char *master, const char *name, unsigned short vlanid)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint lindex, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto err3;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto err2;\n\n\terr = -EINVAL;\n\tlindex = if_nametoindex(master);\n\tif (!lindex)\n\t\tgoto err1;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"vlan\"))\n\t\tgoto err1;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto err1;\n\n\tif (nla_put_u16(nlmsg, IFLA_VLAN_ID, vlanid))\n\t\tgoto err1;\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, lindex))\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto err1;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nerr1:\n\tnlmsg_free(answer);\nerr2:\n\tnlmsg_free(nlmsg);\nerr3:\n\tnetlink_close(&nlh);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_veth_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "672-751",
    "snippet": "int lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_string",
          "args": [
            "nlmsg",
            "IFLA_IFNAME",
            "name1"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "75-78",
          "snippet": "extern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_end_nested",
          "args": [
            "nlmsg",
            "nest1"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "nla_end_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "105-108",
          "snippet": "void nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nvoid nla_end_nested(struct nlmsg *nlmsg, struct rtattr *attr)\n{\n\tattr->rta_len = (void *)NLMSG_TAIL(nlmsg->nlmsghdr) - (void *)attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_begin_nested",
          "args": [
            "nlmsg",
            "VETH_INFO_PEER"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "nla_begin_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "95-103",
          "snippet": "struct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nstruct rtattr *nla_begin_nested(struct nlmsg *nlmsg, int attr)\n{\n\tstruct rtattr *rtattr = NLMSG_TAIL(nlmsg->nlmsghdr);\n\n\tif (nla_put_attr(nlmsg, attr))\n\t\treturn NULL;\n\n\treturn rtattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name2"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name1"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "667-670",
    "snippet": "int lxc_netdev_down(const char *name)\n{\n\treturn netdev_set_flag(name, 0);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_set_flag",
          "args": [
            "name",
            "0"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "365-414",
          "snippet": "int netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_down(const char *name)\n{\n\treturn netdev_set_flag(name, 0);\n}"
  },
  {
    "function_name": "lxc_netdev_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "662-665",
    "snippet": "int lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_set_flag",
          "args": [
            "name",
            "IFF_UP"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "365-414",
          "snippet": "int netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}"
  },
  {
    "function_name": "lxc_netdev_set_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "610-660",
    "snippet": "int lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "answer"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "IFLA_MTU",
            "mtu"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "name"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
  },
  {
    "function_name": "netdev_get_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "499-608",
    "snippet": "int netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "msg",
            "recv_len"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "rta",
            "attr_len"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&res",
            "RTA_DATA(rta)",
            "sizeof(int)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "rta",
            "attr_len"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*ifi)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFLA_RTA",
          "args": [
            "ifi"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "msg"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "msg"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "msg",
            "recv_len"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_rcv",
          "args": [
            "&nlh",
            "answer"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_rcv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "45-48",
          "snippet": "extern int rtnetlink_rcv(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\treturn netlink_rcv(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_rcv(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\treturn netlink_rcv(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_send",
          "args": [
            "&nlh",
            "nlmsg"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "50-54",
          "snippet": "extern int rtnetlink_send(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\n\treturn netlink_send(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_send(struct rtnl_handler *handler, struct rtnlmsg *rtnlmsg)\n{\n\n\treturn netlink_send(&handler->nlh, (struct nlmsg *)&rtnlmsg->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_isup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "484-497",
    "snippet": "int lxc_netdev_isup(const char* name)\n{\n\tint flag;\n\tint err;\n\n\terr = netdev_get_flag(name, &flag);\n\tif (err)\n\t\tgoto out;\n\tif (flag & IFF_UP)\n\t\treturn 1;\n\treturn 0;\nout:\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_get_flag",
          "args": [
            "name",
            "&flag"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_get_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "416-472",
          "snippet": "int netdev_get_flag(const char* name, int *flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\n\tif (err)\n\t\tgoto out;\n\n\tifi = NLMSG_DATA(answer->nlmsghdr);\n\n\t*flag = ifi->ifi_flags;\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_get_flag(const char* name, int *flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\n\tif (err)\n\t\tgoto out;\n\n\tifi = NLMSG_DATA(answer->nlmsghdr);\n\n\t*flag = ifi->ifi_flags;\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_isup(const char* name)\n{\n\tint flag;\n\tint err;\n\n\terr = netdev_get_flag(name, &flag);\n\tif (err)\n\t\tgoto out;\n\tif (flag & IFF_UP)\n\t\treturn 1;\n\treturn 0;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "netdev_get_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "416-472",
    "snippet": "int netdev_get_flag(const char* name, int *flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\n\tif (err)\n\t\tgoto out;\n\n\tifi = NLMSG_DATA(answer->nlmsghdr);\n\n\t*flag = ifi->ifi_flags;\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "answer"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "answer->nlmsghdr"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "name"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_get_flag(const char* name, int *flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\n\tif (err)\n\t\tgoto out;\n\n\tifi = NLMSG_DATA(answer->nlmsghdr);\n\n\t*flag = ifi->ifi_flags;\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
  },
  {
    "function_name": "netdev_set_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "365-414",
    "snippet": "int netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "answer"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_rename_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "350-363",
    "snippet": "int lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_index",
          "args": [
            "index",
            "newname"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "306-348",
          "snippet": "int lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "oldname"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldname"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}"
  },
  {
    "function_name": "lxc_netdev_rename_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "306-348",
    "snippet": "int lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_string",
          "args": [
            "nlmsg",
            "IFLA_IFNAME",
            "newname"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "75-78",
          "snippet": "extern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newname"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_delete_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "295-304",
    "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_index",
          "args": [
            "index"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "258-293",
          "snippet": "int lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
  },
  {
    "function_name": "lxc_netdev_delete_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "258-293",
    "snippet": "int lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "answer"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_reserve",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_alloc_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "151-162",
          "snippet": "extern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern struct nlmsg *nlmsg_alloc_reserve(size_t size)\n{\n\tstruct nlmsg *nlmsg;\n\n\tnlmsg = nlmsg_alloc(size);\n\tif (!nlmsg)\n\t\treturn NULL;\n\n\t// just set message length to cap directly\n\tnlmsg->nlmsghdr->nlmsg_len = nlmsg->cap;\n\treturn nlmsg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_move_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "240-256",
    "snippet": "int lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_netdev_move_by_index",
          "args": [
            "index",
            "pid",
            "newname"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "93-131",
          "snippet": "int lxc_netdev_move_by_index(int ifindex, pid_t pid, const char* ifname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_u32(nlmsg, IFLA_NET_NS_PID, pid))\n\t\tgoto out;\n\n\tif (ifname != NULL) {\n\t\tif (nla_put_string(nlmsg, IFLA_IFNAME, ifname))\n\t\t\tgoto out;\n\t}\n\n\terr = netlink_transaction(&nlh, nlmsg, nlmsg);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_index(int ifindex, pid_t pid, const char* ifname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_u32(nlmsg, IFLA_NET_NS_PID, pid))\n\t\tgoto out;\n\n\tif (ifname != NULL) {\n\t\tif (nla_put_string(nlmsg, IFLA_IFNAME, ifname))\n\t\t\tgoto out;\n\t}\n\n\terr = netlink_transaction(&nlh, nlmsg, nlmsg);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_netdev_move_wlan",
          "args": [
            "physname",
            "ifname",
            "pid",
            "newname"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_wlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "202-238",
          "snippet": "static int\nlxc_netdev_move_wlan(char *physname, const char *ifname, pid_t pid, const char* newname)\n{\n\tint err = -1;\n\tpid_t fpid;\n\tchar *cmd;\n\n\t/* Move phyN into the container.  TODO - do this using netlink.\n\t * However, IIUC this involves a bit more complicated work to\n\t * talk to the 80211 module, so for now just call out to iw\n\t */\n\tcmd = on_path(\"iw\", NULL);\n\tif (!cmd)\n\t\tgoto out1;\n\tfree(cmd);\n\n\tfpid = fork();\n\tif (fpid < 0)\n\t\tgoto out1;\n\tif (fpid == 0) {\n\t\tchar pidstr[30];\n\t\tsprintf(pidstr, \"%d\", pid);\n\t\tif (execlp(\"iw\", \"iw\", \"phy\", physname, \"set\", \"netns\", pidstr, (char *)NULL))\n\t\t\texit(1);\n\t\texit(0); // notreached\n\t}\n\tif (wait_for_pid(fpid))\n\t\tgoto out1;\n\n\terr = 0;\n\tif (newname)\n\t\terr = lxc_netdev_rename_by_name_in_netns(pid, ifname, newname);\n\nout1:\n\tfree(physname);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int\nlxc_netdev_move_wlan(char *physname, const char *ifname, pid_t pid, const char* newname)\n{\n\tint err = -1;\n\tpid_t fpid;\n\tchar *cmd;\n\n\t/* Move phyN into the container.  TODO - do this using netlink.\n\t * However, IIUC this involves a bit more complicated work to\n\t * talk to the 80211 module, so for now just call out to iw\n\t */\n\tcmd = on_path(\"iw\", NULL);\n\tif (!cmd)\n\t\tgoto out1;\n\tfree(cmd);\n\n\tfpid = fork();\n\tif (fpid < 0)\n\t\tgoto out1;\n\tif (fpid == 0) {\n\t\tchar pidstr[30];\n\t\tsprintf(pidstr, \"%d\", pid);\n\t\tif (execlp(\"iw\", \"iw\", \"phy\", physname, \"set\", \"netns\", pidstr, (char *)NULL))\n\t\t\texit(1);\n\t\texit(0); // notreached\n\t}\n\tif (wait_for_pid(fpid))\n\t\tgoto out1;\n\n\terr = 0;\n\tif (newname)\n\t\terr = lxc_netdev_rename_by_name_in_netns(pid, ifname, newname);\n\nout1:\n\tfree(physname);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_wlan",
          "args": [
            "ifname"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "is_wlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "141-186",
          "snippet": "static char * is_wlan(const char *ifname)\n{\n\tchar *path, *physname = NULL;\n\tsize_t len = strlen(ifname) + strlen(PHYSNAME) - 1;\n\tstruct stat sb;\n\tlong physlen;\n\tFILE *f;\n\tint ret, i;\n\n\tpath = alloca(len+1);\n\tret = snprintf(path, len, PHYSNAME, ifname);\n\tif (ret < 0 || ret >= len)\n\t\tgoto bad;\n\tret = stat(path, &sb);\n\tif (ret)\n\t\tgoto bad;\n\tif (!(f = fopen(path, \"r\")))\n\t\tgoto bad;\n\t// feh - sb.st_size is always 4096\n\tfseek(f, 0, SEEK_END);\n\tphyslen = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\tphysname = malloc(physlen+1);\n\tif (!physname) {\n\t\tfclose(f);\n\t\tgoto bad;\n\t}\n\tmemset(physname, 0, physlen+1);\n\tret = fread(physname, 1, physlen, f);\n\tfclose(f);\n\tif (ret < 0)\n\t\tgoto bad;\n\n\tfor (i = 0;  i < physlen; i++) {\n\t\tif (physname[i] == '\\n')\n\t\t\tphysname[i] = '\\0';\n\t\tif (physname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\n\treturn physname;\n\nbad:\n\tfree(physname);\n\treturn NULL;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define PHYSNAME \"/sys/class/net/%s/phy80211/name\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define PHYSNAME \"/sys/class/net/%s/phy80211/name\"\n\nstatic char * is_wlan(const char *ifname)\n{\n\tchar *path, *physname = NULL;\n\tsize_t len = strlen(ifname) + strlen(PHYSNAME) - 1;\n\tstruct stat sb;\n\tlong physlen;\n\tFILE *f;\n\tint ret, i;\n\n\tpath = alloca(len+1);\n\tret = snprintf(path, len, PHYSNAME, ifname);\n\tif (ret < 0 || ret >= len)\n\t\tgoto bad;\n\tret = stat(path, &sb);\n\tif (ret)\n\t\tgoto bad;\n\tif (!(f = fopen(path, \"r\")))\n\t\tgoto bad;\n\t// feh - sb.st_size is always 4096\n\tfseek(f, 0, SEEK_END);\n\tphyslen = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\tphysname = malloc(physlen+1);\n\tif (!physname) {\n\t\tfclose(f);\n\t\tgoto bad;\n\t}\n\tmemset(physname, 0, physlen+1);\n\tret = fread(physname, 1, physlen, f);\n\tfclose(f);\n\tif (ret < 0)\n\t\tgoto bad;\n\n\tfor (i = 0;  i < physlen; i++) {\n\t\tif (physname[i] == '\\n')\n\t\t\tphysname[i] = '\\0';\n\t\tif (physname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\n\treturn physname;\n\nbad:\n\tfree(physname);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "ifname"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}"
  },
  {
    "function_name": "lxc_netdev_move_wlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "202-238",
    "snippet": "static int\nlxc_netdev_move_wlan(char *physname, const char *ifname, pid_t pid, const char* newname)\n{\n\tint err = -1;\n\tpid_t fpid;\n\tchar *cmd;\n\n\t/* Move phyN into the container.  TODO - do this using netlink.\n\t * However, IIUC this involves a bit more complicated work to\n\t * talk to the 80211 module, so for now just call out to iw\n\t */\n\tcmd = on_path(\"iw\", NULL);\n\tif (!cmd)\n\t\tgoto out1;\n\tfree(cmd);\n\n\tfpid = fork();\n\tif (fpid < 0)\n\t\tgoto out1;\n\tif (fpid == 0) {\n\t\tchar pidstr[30];\n\t\tsprintf(pidstr, \"%d\", pid);\n\t\tif (execlp(\"iw\", \"iw\", \"phy\", physname, \"set\", \"netns\", pidstr, (char *)NULL))\n\t\t\texit(1);\n\t\texit(0); // notreached\n\t}\n\tif (wait_for_pid(fpid))\n\t\tgoto out1;\n\n\terr = 0;\n\tif (newname)\n\t\terr = lxc_netdev_rename_by_name_in_netns(pid, ifname, newname);\n\nout1:\n\tfree(physname);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "physname"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_name_in_netns",
          "args": [
            "pid",
            "ifname",
            "newname"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_name_in_netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "188-200",
          "snippet": "static int\nlxc_netdev_rename_by_name_in_netns(pid_t pid, const char *old, const char *new)\n{\n\tpid_t fpid = fork();\n\n\tif (fpid < 0)\n\t\treturn -1;\n\tif (fpid != 0)\n\t\treturn wait_for_pid(fpid);\n\tif (!switch_to_ns(pid, \"net\"))\n\t\treturn -1;\n\texit(lxc_netdev_rename_by_name(old, new));\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int\nlxc_netdev_rename_by_name_in_netns(pid_t pid, const char *old, const char *new)\n{\n\tpid_t fpid = fork();\n\n\tif (fpid < 0)\n\t\treturn -1;\n\tif (fpid != 0)\n\t\treturn wait_for_pid(fpid);\n\tif (!switch_to_ns(pid, \"net\"))\n\t\treturn -1;\n\texit(lxc_netdev_rename_by_name(old, new));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "fpid"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"iw\"",
            "\"iw\"",
            "\"phy\"",
            "physname",
            "\"set\"",
            "\"netns\"",
            "pidstr",
            "(char *)NULL"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pidstr",
            "\"%d\"",
            "pid"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"iw\"",
            "NULL"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int\nlxc_netdev_move_wlan(char *physname, const char *ifname, pid_t pid, const char* newname)\n{\n\tint err = -1;\n\tpid_t fpid;\n\tchar *cmd;\n\n\t/* Move phyN into the container.  TODO - do this using netlink.\n\t * However, IIUC this involves a bit more complicated work to\n\t * talk to the 80211 module, so for now just call out to iw\n\t */\n\tcmd = on_path(\"iw\", NULL);\n\tif (!cmd)\n\t\tgoto out1;\n\tfree(cmd);\n\n\tfpid = fork();\n\tif (fpid < 0)\n\t\tgoto out1;\n\tif (fpid == 0) {\n\t\tchar pidstr[30];\n\t\tsprintf(pidstr, \"%d\", pid);\n\t\tif (execlp(\"iw\", \"iw\", \"phy\", physname, \"set\", \"netns\", pidstr, (char *)NULL))\n\t\t\texit(1);\n\t\texit(0); // notreached\n\t}\n\tif (wait_for_pid(fpid))\n\t\tgoto out1;\n\n\terr = 0;\n\tif (newname)\n\t\terr = lxc_netdev_rename_by_name_in_netns(pid, ifname, newname);\n\nout1:\n\tfree(physname);\n\treturn err;\n}"
  },
  {
    "function_name": "lxc_netdev_rename_by_name_in_netns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "188-200",
    "snippet": "static int\nlxc_netdev_rename_by_name_in_netns(pid_t pid, const char *old, const char *new)\n{\n\tpid_t fpid = fork();\n\n\tif (fpid < 0)\n\t\treturn -1;\n\tif (fpid != 0)\n\t\treturn wait_for_pid(fpid);\n\tif (!switch_to_ns(pid, \"net\"))\n\t\treturn -1;\n\texit(lxc_netdev_rename_by_name(old, new));\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "lxc_netdev_rename_by_name(old, new)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_name",
          "args": [
            "old",
            "new"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "350-363",
          "snippet": "int lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_to_ns",
          "args": [
            "pid",
            "\"net\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1134-1157",
          "snippet": "bool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\n\t/* Switch to new ns */\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\n\t/* Switch to new ns */\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "fpid"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int\nlxc_netdev_rename_by_name_in_netns(pid_t pid, const char *old, const char *new)\n{\n\tpid_t fpid = fork();\n\n\tif (fpid < 0)\n\t\treturn -1;\n\tif (fpid != 0)\n\t\treturn wait_for_pid(fpid);\n\tif (!switch_to_ns(pid, \"net\"))\n\t\treturn -1;\n\texit(lxc_netdev_rename_by_name(old, new));\n}"
  },
  {
    "function_name": "is_wlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "141-186",
    "snippet": "static char * is_wlan(const char *ifname)\n{\n\tchar *path, *physname = NULL;\n\tsize_t len = strlen(ifname) + strlen(PHYSNAME) - 1;\n\tstruct stat sb;\n\tlong physlen;\n\tFILE *f;\n\tint ret, i;\n\n\tpath = alloca(len+1);\n\tret = snprintf(path, len, PHYSNAME, ifname);\n\tif (ret < 0 || ret >= len)\n\t\tgoto bad;\n\tret = stat(path, &sb);\n\tif (ret)\n\t\tgoto bad;\n\tif (!(f = fopen(path, \"r\")))\n\t\tgoto bad;\n\t// feh - sb.st_size is always 4096\n\tfseek(f, 0, SEEK_END);\n\tphyslen = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\tphysname = malloc(physlen+1);\n\tif (!physname) {\n\t\tfclose(f);\n\t\tgoto bad;\n\t}\n\tmemset(physname, 0, physlen+1);\n\tret = fread(physname, 1, physlen, f);\n\tfclose(f);\n\tif (ret < 0)\n\t\tgoto bad;\n\n\tfor (i = 0;  i < physlen; i++) {\n\t\tif (physname[i] == '\\n')\n\t\t\tphysname[i] = '\\0';\n\t\tif (physname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\n\treturn physname;\n\nbad:\n\tfree(physname);\n\treturn NULL;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define PHYSNAME \"/sys/class/net/%s/phy80211/name\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "physname"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "physname",
            "1",
            "physlen",
            "f"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "physname",
            "0",
            "physlen+1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "physlen+1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_SET"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "f"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_END"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "PHYSNAME",
            "ifname"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len+1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "PHYSNAME"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define PHYSNAME \"/sys/class/net/%s/phy80211/name\"\n\nstatic char * is_wlan(const char *ifname)\n{\n\tchar *path, *physname = NULL;\n\tsize_t len = strlen(ifname) + strlen(PHYSNAME) - 1;\n\tstruct stat sb;\n\tlong physlen;\n\tFILE *f;\n\tint ret, i;\n\n\tpath = alloca(len+1);\n\tret = snprintf(path, len, PHYSNAME, ifname);\n\tif (ret < 0 || ret >= len)\n\t\tgoto bad;\n\tret = stat(path, &sb);\n\tif (ret)\n\t\tgoto bad;\n\tif (!(f = fopen(path, \"r\")))\n\t\tgoto bad;\n\t// feh - sb.st_size is always 4096\n\tfseek(f, 0, SEEK_END);\n\tphyslen = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\tphysname = malloc(physlen+1);\n\tif (!physname) {\n\t\tfclose(f);\n\t\tgoto bad;\n\t}\n\tmemset(physname, 0, physlen+1);\n\tret = fread(physname, 1, physlen, f);\n\tfclose(f);\n\tif (ret < 0)\n\t\tgoto bad;\n\n\tfor (i = 0;  i < physlen; i++) {\n\t\tif (physname[i] == '\\n')\n\t\t\tphysname[i] = '\\0';\n\t\tif (physname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\n\treturn physname;\n\nbad:\n\tfree(physname);\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_netdev_move_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
    "lines": "93-131",
    "snippet": "int lxc_netdev_move_by_index(int ifindex, pid_t pid, const char* ifname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_u32(nlmsg, IFLA_NET_NS_PID, pid))\n\t\tgoto out;\n\n\tif (ifname != NULL) {\n\t\tif (nla_put_string(nlmsg, IFLA_IFNAME, ifname))\n\t\t\tgoto out;\n\t}\n\n\terr = netlink_transaction(&nlh, nlmsg, nlmsg);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
    "includes": [
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"network.h\"",
      "#include \"nl.h\"",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/ethernet.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <sys/inotify.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "70-73",
          "snippet": "extern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern void rtnlmsg_free(struct rtnlmsg *rtnlmsg)\n{\n\tfree(rtnlmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_close",
          "args": [
            "&nlh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "40-43",
          "snippet": "extern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_close(struct rtnl_handler *handler)\n{\n\treturn netlink_close(&handler->nlh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_transaction",
          "args": [
            "&nlh",
            "nlmsg",
            "nlmsg"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rtnetlink_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "56-61",
          "snippet": "extern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int rtnetlink_transaction(struct rtnl_handler *handler,\n\t\t\t  struct rtnlmsg *request, struct rtnlmsg *answer)\n{\n\treturn netlink_transaction(&handler->nlh, (struct nlmsg *)&request->nlmsghdr,\n\t\t\t\t   (struct nlmsg *)&answer->nlmsghdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_string",
          "args": [
            "nlmsg",
            "IFLA_IFNAME",
            "ifname"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "75-78",
          "snippet": "extern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_string(struct nlmsg *nlmsg, int attr, const char *string)\n{\n\treturn nla_put(nlmsg, attr, string, strlen(string) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "IFLA_NET_NS_PID",
            "pid"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "nla_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "80-83",
          "snippet": "extern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern int nla_put_u32(struct nlmsg *nlmsg, int attr, int value)\n{\n\treturn nla_put(nlmsg, attr, &value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_reserve",
          "args": [
            "nlmsg",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsg_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/nl.c",
          "lines": "133-149",
          "snippet": "extern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n\nextern void *nlmsg_reserve(struct nlmsg *nlmsg, size_t len)\n{\n\tvoid *buf;\n\tsize_t nlmsg_len = nlmsg->nlmsghdr->nlmsg_len;\n\tsize_t tlen = NLMSG_ALIGN(len);\n\n\tif (nlmsg_len + tlen > nlmsg->cap)\n\t\treturn NULL;\n\n\tbuf = ((char *)(nlmsg->nlmsghdr)) + nlmsg_len;\n\tnlmsg->nlmsghdr->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc",
          "args": [
            "NLMSG_GOOD_SIZE"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "rtnlmsg_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/rtnl.c",
          "lines": "63-68",
          "snippet": "extern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}",
          "includes": [
            "#include \"rtnl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtnl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern struct rtnlmsg *rtnlmsg_alloc(size_t size)\n{\n/* \tsize_t len = NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct rtnlmsghdr))) + size; */\n/* \treturn  (struct rtnlmsg *)nlmsg_alloc(len); */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_open",
          "args": [
            "&nlh",
            "NETLINK_ROUTE"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_index(int ifindex, pid_t pid, const char* ifname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_u32(nlmsg, IFLA_NET_NS_PID, pid))\n\t\tgoto out;\n\n\tif (ifname != NULL) {\n\t\tif (nla_put_string(nlmsg, IFLA_IFNAME, ifname))\n\t\t\tgoto out;\n\t}\n\n\terr = netlink_transaction(&nlh, nlmsg, nlmsg);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
  }
]