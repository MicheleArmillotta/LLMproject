[
  {
    "function_name": "find_free_loopdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "310-328",
    "snippet": "static int find_free_loopdev(int *retfd, char *namep)\n{\n\tint rc, fd = -1;\n\tint ctl = open(\"/dev/loop-control\", O_RDWR);\n\tif (ctl < 0)\n\t\treturn find_free_loopdev_no_control(retfd, namep);\n\trc = ioctl(ctl, LOOP_CTL_GET_FREE);\n\tif (rc >= 0) {\n\t\tsnprintf(namep, 100, \"/dev/loop%d\", rc);\n\t\tfd = open(namep, O_RDWR);\n\t}\n\tclose(ctl);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\t*retfd = fd;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define LOOP_CTL_GET_FREE 0x4C82"
    ],
    "globals_used": [
      "static int find_free_loopdev_no_control(int *retfd, char *namep);",
      "static int find_free_loopdev(int *retfd, char *namep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No loop device found\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ctl"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "namep",
            "O_RDWR"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "namep",
            "100",
            "\"/dev/loop%d\"",
            "rc"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "ctl",
            "LOOP_CTL_GET_FREE"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_loopdev_no_control",
          "args": [
            "retfd",
            "namep"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_loopdev_no_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
          "lines": "270-308",
          "snippet": "static int find_free_loopdev_no_control(int *retfd, char *namep)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 lo;\n\tDIR *dir;\n\tint fd = -1;\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"Error opening /dev\");\n\t\treturn -1;\n\t}\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\t\tif (strncmp(direntp->d_name, \"loop\", 4) != 0)\n\t\t\tcontinue;\n\t\tfd = openat(dirfd(dir), direntp->d_name, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &lo) == 0 || errno != ENXIO) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\t// We can use this fd\n\t\tsnprintf(namep, 100, \"/dev/%s\", direntp->d_name);\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\n\t*retfd = fd;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcloop.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <linux/loop.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_free_loopdev_no_control(int *retfd, char *namep);",
            "static int find_free_loopdev(int *retfd, char *namep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep);\nstatic int find_free_loopdev(int *retfd, char *namep);\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 lo;\n\tDIR *dir;\n\tint fd = -1;\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"Error opening /dev\");\n\t\treturn -1;\n\t}\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\t\tif (strncmp(direntp->d_name, \"loop\", 4) != 0)\n\t\t\tcontinue;\n\t\tfd = openat(dirfd(dir), direntp->d_name, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &lo) == 0 || errno != ENXIO) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\t// We can use this fd\n\t\tsnprintf(namep, 100, \"/dev/%s\", direntp->d_name);\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\n\t*retfd = fd;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\n#define LOOP_CTL_GET_FREE 0x4C82\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep);\nstatic int find_free_loopdev(int *retfd, char *namep);\n\nstatic int find_free_loopdev(int *retfd, char *namep)\n{\n\tint rc, fd = -1;\n\tint ctl = open(\"/dev/loop-control\", O_RDWR);\n\tif (ctl < 0)\n\t\treturn find_free_loopdev_no_control(retfd, namep);\n\trc = ioctl(ctl, LOOP_CTL_GET_FREE);\n\tif (rc >= 0) {\n\t\tsnprintf(namep, 100, \"/dev/loop%d\", rc);\n\t\tfd = open(namep, O_RDWR);\n\t}\n\tclose(ctl);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\t*retfd = fd;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_free_loopdev_no_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "270-308",
    "snippet": "static int find_free_loopdev_no_control(int *retfd, char *namep)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 lo;\n\tDIR *dir;\n\tint fd = -1;\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"Error opening /dev\");\n\t\treturn -1;\n\t}\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\t\tif (strncmp(direntp->d_name, \"loop\", 4) != 0)\n\t\t\tcontinue;\n\t\tfd = openat(dirfd(dir), direntp->d_name, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &lo) == 0 || errno != ENXIO) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\t// We can use this fd\n\t\tsnprintf(namep, 100, \"/dev/%s\", direntp->d_name);\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\n\t*retfd = fd;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int find_free_loopdev_no_control(int *retfd, char *namep);",
      "static int find_free_loopdev(int *retfd, char *namep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No loop device found\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "namep",
            "100",
            "\"/dev/%s\"",
            "direntp->d_name"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "LOOP_GET_STATUS64",
            "&lo"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd(dir)",
            "direntp->d_name",
            "O_RDWR"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_openat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "90-123",
          "snippet": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirfd",
          "args": [
            "dir"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "direntp->d_name",
            "\"loop\"",
            "4"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening /dev\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/dev\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep);\nstatic int find_free_loopdev(int *retfd, char *namep);\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 lo;\n\tDIR *dir;\n\tint fd = -1;\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"Error opening /dev\");\n\t\treturn -1;\n\t}\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\t\tif (strncmp(direntp->d_name, \"loop\", 4) != 0)\n\t\t\tcontinue;\n\t\tfd = openat(dirfd(dir), direntp->d_name, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &lo) == 0 || errno != ENXIO) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\t// We can use this fd\n\t\tsnprintf(namep, 100, \"/dev/%s\", direntp->d_name);\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\n\t*retfd = fd;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_loop_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "237-268",
    "snippet": "static int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_loop_create(const char *path, uint64_t size, const char *fstype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating filesystem type %s on %s\"",
            "fstype",
            "path"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mkfs",
          "args": [
            "path",
            "fstype"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "709-726",
          "snippet": "int do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error closing new loop file\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error creating new loop file\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "\"1\"",
            "1"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error seeking to set new loop file size\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "size",
            "SEEK_SET"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "creat",
          "args": [
            "path",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "create_file_dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3045-3056",
          "snippet": "static int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype);\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "loop_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "221-235",
    "snippet": "int loop_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"loop\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\tif (bdev->lofd >= 0) {\n\t\tclose(bdev->lofd);\n\t\tbdev->lofd = -1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "bdev->lofd"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "loop_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
          "lines": "221-235",
          "snippet": "int loop_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"loop\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\tif (bdev->lofd >= 0) {\n\t\tclose(bdev->lofd);\n\t\tbdev->lofd = -1;\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"loop\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nint loop_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"loop\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\tif (bdev->lofd >= 0) {\n\t\tclose(bdev->lofd);\n\t\tbdev->lofd = -1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "loop_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "175-219",
    "snippet": "int loop_mount(struct bdev *bdev)\n{\n\tint lfd, ffd = -1, ret = -1;\n\tstruct loop_info64 lo;\n\tchar loname[100];\n\n\tif (strcmp(bdev->type, \"loop\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tif (find_free_loopdev(&lfd, loname) < 0)\n\t\treturn -22;\n\n\tffd = open(bdev->src + 5, O_RDWR);\n\tif (ffd < 0) {\n\t\tSYSERROR(\"Error opening backing file %s\", bdev->src);\n\t\tgoto out;\n\t}\n\n\tif (ioctl(lfd, LOOP_SET_FD, ffd) < 0) {\n\t\tSYSERROR(\"Error attaching backing file to loop dev\");\n\t\tgoto out;\n\t}\n\tmemset(&lo, 0, sizeof(lo));\n\tlo.lo_flags = LO_FLAGS_AUTOCLEAR;\n\tif (ioctl(lfd, LOOP_SET_STATUS64, &lo) < 0) {\n\t\tSYSERROR(\"Error setting autoclear on loop dev\");\n\t\tgoto out;\n\t}\n\n\tret = mount_unknown_fs(loname, bdev->dest, bdev->mntopts);\n\tif (ret < 0)\n\t\tERROR(\"Error mounting %s\", bdev->src);\n\telse\n\t\tbdev->lofd = lfd;\n\nout:\n\tif (ffd > -1)\n\t\tclose(ffd);\n\tif (ret < 0) {\n\t\tclose(lfd);\n\t\tbdev->lofd = -1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define LO_FLAGS_AUTOCLEAR 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lfd"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error mounting %s\"",
            "bdev->src"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "loname",
            "bdev->dest",
            "bdev->mntopts"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error setting autoclear on loop dev\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "lfd",
            "LOOP_SET_STATUS64",
            "&lo"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lo",
            "0",
            "sizeof(lo)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error attaching backing file to loop dev\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "lfd",
            "LOOP_SET_FD",
            "ffd"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening backing file %s\"",
            "bdev->src"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "bdev->src + 5",
            "O_RDWR"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_free_loopdev",
          "args": [
            "&lfd",
            "loname"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_loopdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
          "lines": "310-328",
          "snippet": "static int find_free_loopdev(int *retfd, char *namep)\n{\n\tint rc, fd = -1;\n\tint ctl = open(\"/dev/loop-control\", O_RDWR);\n\tif (ctl < 0)\n\t\treturn find_free_loopdev_no_control(retfd, namep);\n\trc = ioctl(ctl, LOOP_CTL_GET_FREE);\n\tif (rc >= 0) {\n\t\tsnprintf(namep, 100, \"/dev/loop%d\", rc);\n\t\tfd = open(namep, O_RDWR);\n\t}\n\tclose(ctl);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\t*retfd = fd;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcloop.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <linux/loop.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define LOOP_CTL_GET_FREE 0x4C82"
          ],
          "globals_used": [
            "static int find_free_loopdev_no_control(int *retfd, char *namep);",
            "static int find_free_loopdev(int *retfd, char *namep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\n#define LOOP_CTL_GET_FREE 0x4C82\n\nstatic int find_free_loopdev_no_control(int *retfd, char *namep);\nstatic int find_free_loopdev(int *retfd, char *namep);\n\nstatic int find_free_loopdev(int *retfd, char *namep)\n{\n\tint rc, fd = -1;\n\tint ctl = open(\"/dev/loop-control\", O_RDWR);\n\tif (ctl < 0)\n\t\treturn find_free_loopdev_no_control(retfd, namep);\n\trc = ioctl(ctl, LOOP_CTL_GET_FREE);\n\tif (rc >= 0) {\n\t\tsnprintf(namep, 100, \"/dev/loop%d\", rc);\n\t\tfd = open(namep, O_RDWR);\n\t}\n\tclose(ctl);\n\tif (fd == -1) {\n\t\tERROR(\"No loop device found\");\n\t\treturn -1;\n\t}\n\t*retfd = fd;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"loop\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\n#define LO_FLAGS_AUTOCLEAR 4\n\nint loop_mount(struct bdev *bdev)\n{\n\tint lfd, ffd = -1, ret = -1;\n\tstruct loop_info64 lo;\n\tchar loname[100];\n\n\tif (strcmp(bdev->type, \"loop\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tif (find_free_loopdev(&lfd, loname) < 0)\n\t\treturn -22;\n\n\tffd = open(bdev->src + 5, O_RDWR);\n\tif (ffd < 0) {\n\t\tSYSERROR(\"Error opening backing file %s\", bdev->src);\n\t\tgoto out;\n\t}\n\n\tif (ioctl(lfd, LOOP_SET_FD, ffd) < 0) {\n\t\tSYSERROR(\"Error attaching backing file to loop dev\");\n\t\tgoto out;\n\t}\n\tmemset(&lo, 0, sizeof(lo));\n\tlo.lo_flags = LO_FLAGS_AUTOCLEAR;\n\tif (ioctl(lfd, LOOP_SET_STATUS64, &lo) < 0) {\n\t\tSYSERROR(\"Error setting autoclear on loop dev\");\n\t\tgoto out;\n\t}\n\n\tret = mount_unknown_fs(loname, bdev->dest, bdev->mntopts);\n\tif (ret < 0)\n\t\tERROR(\"Error mounting %s\", bdev->src);\n\telse\n\t\tbdev->lofd = lfd;\n\nout:\n\tif (ffd > -1)\n\t\tclose(ffd);\n\tif (ret < 0) {\n\t\tclose(lfd);\n\t\tbdev->lofd = -1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "loop_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "168-173",
    "snippet": "int loop_detect(const char *path)\n{\n\tif (strncmp(path, \"loop:\", 5) == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"loop:\"",
            "5"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nint loop_detect(const char *path)\n{\n\tif (strncmp(path, \"loop:\", 5) == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "loop_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "163-166",
    "snippet": "int loop_destroy(struct bdev *orig)\n{\n\treturn unlink(orig->src + 5);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "orig->src + 5"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nint loop_destroy(struct bdev *orig)\n{\n\treturn unlink(orig->src + 5);\n}"
  },
  {
    "function_name": "loop_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "115-161",
    "snippet": "int loop_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *fstype;\n\tuint64_t sz;\n\tint ret, len;\n\tchar *srcdev;\n\n\tif (!specs)\n\t\treturn -1;\n\n\t// dest is passed in as $lxcpath / $lxcname / rootfs\n\t// srcdev will be:      $lxcpath / $lxcname / rootdev\n\t// src will be 'loop:$srcdev'\n\tlen = strlen(dest) + 2;\n\tsrcdev = alloca(len);\n\n\tret = snprintf(srcdev, len, \"%s\", dest);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\tsprintf(srcdev + len - 4, \"dev\");\n\n\tbdev->src = malloc(len + 5);\n\tif (!bdev->src)\n\t\treturn -1;\n\tret = snprintf(bdev->src, len + 5, \"loop:%s\", srcdev);\n\tif (ret < 0 || ret >= len + 5)\n\t\treturn -1;\n\n\tsz = specs->fssize;\n\tif (!sz)\n\t\tsz = DEFAULT_FS_SIZE;\n\n\tfstype = specs->fstype;\n\tif (!fstype)\n\t\tfstype = DEFAULT_FSTYPE;\n\n\tif (!(bdev->dest = strdup(dest)))\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn do_loop_create(srcdev, sz, fstype);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_loop_create(const char *path, uint64_t size, const char *fstype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_loop_create",
          "args": [
            "srcdev",
            "sz",
            "fstype"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
          "lines": "237-268",
          "snippet": "static int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcloop.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <linux/loop.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_loop_create(const char *path, uint64_t size, const char *fstype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype);\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "bdev->dest"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "bdev->dest",
            "0755"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "bdev->src",
            "len + 5",
            "\"loop:%s\"",
            "srcdev"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 5"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "srcdev + len - 4",
            "\"dev\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "srcdev",
            "len",
            "\"%s\"",
            "dest"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype);\n\nint loop_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *fstype;\n\tuint64_t sz;\n\tint ret, len;\n\tchar *srcdev;\n\n\tif (!specs)\n\t\treturn -1;\n\n\t// dest is passed in as $lxcpath / $lxcname / rootfs\n\t// srcdev will be:      $lxcpath / $lxcname / rootdev\n\t// src will be 'loop:$srcdev'\n\tlen = strlen(dest) + 2;\n\tsrcdev = alloca(len);\n\n\tret = snprintf(srcdev, len, \"%s\", dest);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\tsprintf(srcdev + len - 4, \"dev\");\n\n\tbdev->src = malloc(len + 5);\n\tif (!bdev->src)\n\t\treturn -1;\n\tret = snprintf(bdev->src, len + 5, \"loop:%s\", srcdev);\n\tif (ret < 0 || ret >= len + 5)\n\t\treturn -1;\n\n\tsz = specs->fssize;\n\tif (!sz)\n\t\tsz = DEFAULT_FS_SIZE;\n\n\tfstype = specs->fstype;\n\tif (!fstype)\n\t\tfstype = DEFAULT_FSTYPE;\n\n\tif (!(bdev->dest = strdup(dest)))\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn do_loop_create(srcdev, sz, fstype);\n}"
  },
  {
    "function_name": "loop_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
    "lines": "56-113",
    "snippet": "int loop_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tchar fstype[100];\n\tuint64_t size = newsize;\n\tint len, ret;\n\tchar *srcdev;\n\n\tif (snap) {\n\t\tERROR(\"loop devices cannot be snapshotted.\");\n\t\treturn -1;\n\t}\n\n\tif (!orig->dest || !orig->src)\n\t\treturn -1;\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootdev\") + 3;\n\tsrcdev = alloca(len);\n\tret = snprintf(srcdev, len, \"%s/%s/rootdev\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tnew->src = malloc(len + 5);\n\tif (!new->src)\n\t\treturn -1;\n\tret = snprintf(new->src, len + 5, \"loop:%s\", srcdev);\n\tif (ret < 0 || ret >= len + 5)\n\t\treturn -1;\n\n\tnew->dest = malloc(len);\n\tif (!new->dest)\n\t\treturn -1;\n\tret = snprintf(new->dest, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\t// it's tempting to say: if orig->src == loopback and !newsize, then\n\t// copy the loopback file.  However, we'd have to make sure to\n\t// correctly keep holes!  So punt for now.\n\n\tif (is_blktype(orig)) {\n\t\tif (!newsize && blk_getsize(orig, &size) < 0) {\n\t\t\tERROR(\"Error getting size of %s\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_fs(orig, fstype, 100) < 0) {\n\t\t\tINFO(\"could not find fstype for %s, using %s\", orig->src,\n\t\t\t\tDEFAULT_FSTYPE);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tsprintf(fstype, \"%s\", DEFAULT_FSTYPE);\n\t\tif (!newsize)\n\t\t\tsize = DEFAULT_FS_SIZE;\n\t}\n\treturn do_loop_create(srcdev, size, fstype);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcloop.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <linux/loop.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_loop_create(const char *path, uint64_t size, const char *fstype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_loop_create",
          "args": [
            "srcdev",
            "size",
            "fstype"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcloop.c",
          "lines": "237-268",
          "snippet": "static int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcloop.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <linux/loop.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_loop_create(const char *path, uint64_t size, const char *fstype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype);\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype)\n{\n\tint fd, ret;\n\t// create the new loopback file.\n\tfd = creat(path, S_IRUSR|S_IWUSR);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (lseek(fd, size, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to set new loop file size\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (write(fd, \"1\", 1) != 1) {\n\t\tSYSERROR(\"Error creating new loop file\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tret = close(fd);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error closing new loop file\");\n\t\treturn -1;\n\t}\n\n\t// create an fs in the loopback file\n\tif (do_mkfs(path, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tpath);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fstype",
            "\"%s\"",
            "DEFAULT_FSTYPE"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"could not find fstype for %s, using %s\"",
            "orig->src",
            "DEFAULT_FSTYPE"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detect_fs",
          "args": [
            "orig",
            "fstype",
            "100"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "detect_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "621-707",
          "snippet": "int detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nint detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting size of %s\"",
            "orig->src"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_getsize",
          "args": [
            "orig",
            "&size"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "blk_getsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "590-605",
          "snippet": "int blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define BLKGETSIZE64 _IOR(0x12, 114, size_t)"
          ],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define BLKGETSIZE64 _IOR(0x12, 114, size_t)\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\n\nint blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_blktype",
          "args": [
            "orig"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "is_blktype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "732-737",
          "snippet": "int is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->dest",
            "len",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "cname"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len + 5",
            "\"loop:%s\"",
            "srcdev"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 5"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "srcdev",
            "len",
            "\"%s/%s/rootdev\"",
            "lxcpath",
            "cname"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rootdev\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"loop devices cannot be snapshotted.\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcloop.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <linux/loop.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dirent.h>\n\nstatic int do_loop_create(const char *path, uint64_t size, const char *fstype);\n\nint loop_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tchar fstype[100];\n\tuint64_t size = newsize;\n\tint len, ret;\n\tchar *srcdev;\n\n\tif (snap) {\n\t\tERROR(\"loop devices cannot be snapshotted.\");\n\t\treturn -1;\n\t}\n\n\tif (!orig->dest || !orig->src)\n\t\treturn -1;\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootdev\") + 3;\n\tsrcdev = alloca(len);\n\tret = snprintf(srcdev, len, \"%s/%s/rootdev\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tnew->src = malloc(len + 5);\n\tif (!new->src)\n\t\treturn -1;\n\tret = snprintf(new->src, len + 5, \"loop:%s\", srcdev);\n\tif (ret < 0 || ret >= len + 5)\n\t\treturn -1;\n\n\tnew->dest = malloc(len);\n\tif (!new->dest)\n\t\treturn -1;\n\tret = snprintf(new->dest, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\t// it's tempting to say: if orig->src == loopback and !newsize, then\n\t// copy the loopback file.  However, we'd have to make sure to\n\t// correctly keep holes!  So punt for now.\n\n\tif (is_blktype(orig)) {\n\t\tif (!newsize && blk_getsize(orig, &size) < 0) {\n\t\t\tERROR(\"Error getting size of %s\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_fs(orig, fstype, 100) < 0) {\n\t\t\tINFO(\"could not find fstype for %s, using %s\", orig->src,\n\t\t\t\tDEFAULT_FSTYPE);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tsprintf(fstype, \"%s\", DEFAULT_FSTYPE);\n\t\tif (!newsize)\n\t\t\tsize = DEFAULT_FS_SIZE;\n\t}\n\treturn do_loop_create(srcdev, size, fstype);\n}"
  }
]