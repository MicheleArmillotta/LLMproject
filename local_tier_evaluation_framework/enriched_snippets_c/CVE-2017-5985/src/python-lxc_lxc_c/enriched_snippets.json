[
  {
    "function_name": "PyInit__lxc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1925-1981",
    "snippet": "PyMODINIT_FUNC\nPyInit__lxc(void)\n{\n    PyObject* m;\n    PyObject* d;\n\n    if (PyType_Ready(&_lxc_ContainerType) < 0)\n        return NULL;\n\n    m = PyModule_Create(&_lxcmodule);\n    if (m == NULL)\n        return NULL;\n\n    Py_INCREF(&_lxc_ContainerType);\n    PyModule_AddObject(m, \"Container\", (PyObject *)&_lxc_ContainerType);\n\n    /* add constants */\n    d = PyModule_GetDict(m);\n\n    #define PYLXC_EXPORT_CONST(c) \\\n        PyDict_SetItemString(d, #c, PyLong_FromLong(c))\n\n    /* namespace flags (no other python lib exports this) */\n    PYLXC_EXPORT_CONST(CLONE_NEWUTS);\n    PYLXC_EXPORT_CONST(CLONE_NEWIPC);\n    PYLXC_EXPORT_CONST(CLONE_NEWUSER);\n    PYLXC_EXPORT_CONST(CLONE_NEWPID);\n    PYLXC_EXPORT_CONST(CLONE_NEWNET);\n    PYLXC_EXPORT_CONST(CLONE_NEWNS);\n\n    /* attach: environment variable handling */\n    PYLXC_EXPORT_CONST(LXC_ATTACH_CLEAR_ENV);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_KEEP_ENV);\n\n    /* attach: attach options */\n    PYLXC_EXPORT_CONST(LXC_ATTACH_DEFAULT);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_DROP_CAPABILITIES);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_LSM_EXEC);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_LSM_NOW);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_MOVE_TO_CGROUP);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_REMOUNT_PROC_SYS);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_SET_PERSONALITY);\n\n    /* clone: clone flags */\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPBDEVTYPE);\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPMACADDR);\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPNAME);\n    PYLXC_EXPORT_CONST(LXC_CLONE_MAYBE_SNAPSHOT);\n    PYLXC_EXPORT_CONST(LXC_CLONE_SNAPSHOT);\n\n    /* create: create flags */\n    PYLXC_EXPORT_CONST(LXC_CREATE_QUIET);\n\n    #undef PYLXC_EXPORT_CONST\n\n    return m;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_attach_free_options(lxc_attach_options_t *options);",
      "static PyTypeObject _lxc_ContainerType = {\nPyVarObject_HEAD_INIT(NULL, 0)\n    \"lxc.Container\",                /* tp_name */\n    sizeof(Container),              /* tp_basicsize */\n    0,                              /* tp_itemsize */\n    (destructor)Container_dealloc,  /* tp_dealloc */\n    0,                              /* tp_print */\n    0,                              /* tp_getattr */\n    0,                              /* tp_setattr */\n    0,                              /* tp_reserved */\n    0,                              /* tp_repr */\n    0,                              /* tp_as_number */\n    0,                              /* tp_as_sequence */\n    0,                              /* tp_as_mapping */\n    0,                              /* tp_hash  */\n    0,                              /* tp_call */\n    0,                              /* tp_str */\n    0,                              /* tp_getattro */\n    0,                              /* tp_setattro */\n    0,                              /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT |\n        Py_TPFLAGS_BASETYPE,        /* tp_flags */\n    \"Container objects\",            /* tp_doc */\n    0,                              /* tp_traverse */\n    0,                              /* tp_clear */\n    0,                              /* tp_richcompare */\n    0,                              /* tp_weaklistoffset */\n    0,                              /* tp_iter */\n    0,                              /* tp_iternext */\n    Container_methods,              /* tp_methods */\n    0,                              /* tp_members */\n    Container_getseters,            /* tp_getset */\n    0,                              /* tp_base */\n    0,                              /* tp_dict */\n    0,                              /* tp_descr_get */\n    0,                              /* tp_descr_set */\n    0,                              /* tp_dictoffset */\n    (initproc)Container_init,       /* tp_init */\n    0,                              /* tp_alloc */\n    Container_new,                  /* tp_new */\n};",
      "static PyModuleDef _lxcmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_lxc\",\n    \"Binding for liblxc in python\",\n    -1,\n    LXC_methods\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CREATE_QUIET"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CLONE_SNAPSHOT"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CLONE_MAYBE_SNAPSHOT"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CLONE_KEEPNAME"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CLONE_KEEPMACADDR"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_CLONE_KEEPBDEVTYPE"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_SET_PERSONALITY"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_REMOUNT_PROC_SYS"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_MOVE_TO_CGROUP"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_LSM_NOW"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_LSM_EXEC"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_DROP_CAPABILITIES"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_DEFAULT"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_KEEP_ENV"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "LXC_ATTACH_CLEAR_ENV"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWNET"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWPID"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWUSER"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWIPC"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PYLXC_EXPORT_CONST",
          "args": [
            "CLONE_NEWUTS"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyModule_GetDict",
          "args": [
            "m"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyModule_AddObject",
          "args": [
            "m",
            "\"Container\"",
            "(PyObject *)&_lxc_ContainerType"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_INCREF",
          "args": [
            "&_lxc_ContainerType"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyModule_Create",
          "args": [
            "&_lxcmodule"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyType_Ready",
          "args": [
            "&_lxc_ContainerType"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\nstatic PyTypeObject _lxc_ContainerType = {\nPyVarObject_HEAD_INIT(NULL, 0)\n    \"lxc.Container\",                /* tp_name */\n    sizeof(Container),              /* tp_basicsize */\n    0,                              /* tp_itemsize */\n    (destructor)Container_dealloc,  /* tp_dealloc */\n    0,                              /* tp_print */\n    0,                              /* tp_getattr */\n    0,                              /* tp_setattr */\n    0,                              /* tp_reserved */\n    0,                              /* tp_repr */\n    0,                              /* tp_as_number */\n    0,                              /* tp_as_sequence */\n    0,                              /* tp_as_mapping */\n    0,                              /* tp_hash  */\n    0,                              /* tp_call */\n    0,                              /* tp_str */\n    0,                              /* tp_getattro */\n    0,                              /* tp_setattro */\n    0,                              /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT |\n        Py_TPFLAGS_BASETYPE,        /* tp_flags */\n    \"Container objects\",            /* tp_doc */\n    0,                              /* tp_traverse */\n    0,                              /* tp_clear */\n    0,                              /* tp_richcompare */\n    0,                              /* tp_weaklistoffset */\n    0,                              /* tp_iter */\n    0,                              /* tp_iternext */\n    Container_methods,              /* tp_methods */\n    0,                              /* tp_members */\n    Container_getseters,            /* tp_getset */\n    0,                              /* tp_base */\n    0,                              /* tp_dict */\n    0,                              /* tp_descr_get */\n    0,                              /* tp_descr_set */\n    0,                              /* tp_dictoffset */\n    (initproc)Container_init,       /* tp_init */\n    0,                              /* tp_alloc */\n    Container_new,                  /* tp_new */\n};\nstatic PyModuleDef _lxcmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_lxc\",\n    \"Binding for liblxc in python\",\n    -1,\n    LXC_methods\n};\n\nPyMODINIT_FUNC\nPyInit__lxc(void)\n{\n    PyObject* m;\n    PyObject* d;\n\n    if (PyType_Ready(&_lxc_ContainerType) < 0)\n        return NULL;\n\n    m = PyModule_Create(&_lxcmodule);\n    if (m == NULL)\n        return NULL;\n\n    Py_INCREF(&_lxc_ContainerType);\n    PyModule_AddObject(m, \"Container\", (PyObject *)&_lxc_ContainerType);\n\n    /* add constants */\n    d = PyModule_GetDict(m);\n\n    #define PYLXC_EXPORT_CONST(c) \\\n        PyDict_SetItemString(d, #c, PyLong_FromLong(c))\n\n    /* namespace flags (no other python lib exports this) */\n    PYLXC_EXPORT_CONST(CLONE_NEWUTS);\n    PYLXC_EXPORT_CONST(CLONE_NEWIPC);\n    PYLXC_EXPORT_CONST(CLONE_NEWUSER);\n    PYLXC_EXPORT_CONST(CLONE_NEWPID);\n    PYLXC_EXPORT_CONST(CLONE_NEWNET);\n    PYLXC_EXPORT_CONST(CLONE_NEWNS);\n\n    /* attach: environment variable handling */\n    PYLXC_EXPORT_CONST(LXC_ATTACH_CLEAR_ENV);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_KEEP_ENV);\n\n    /* attach: attach options */\n    PYLXC_EXPORT_CONST(LXC_ATTACH_DEFAULT);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_DROP_CAPABILITIES);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_LSM_EXEC);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_LSM_NOW);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_MOVE_TO_CGROUP);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_REMOUNT_PROC_SYS);\n    PYLXC_EXPORT_CONST(LXC_ATTACH_SET_PERSONALITY);\n\n    /* clone: clone flags */\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPBDEVTYPE);\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPMACADDR);\n    PYLXC_EXPORT_CONST(LXC_CLONE_KEEPNAME);\n    PYLXC_EXPORT_CONST(LXC_CLONE_MAYBE_SNAPSHOT);\n    PYLXC_EXPORT_CONST(LXC_CLONE_SNAPSHOT);\n\n    /* create: create flags */\n    PYLXC_EXPORT_CONST(LXC_CREATE_QUIET);\n\n    #undef PYLXC_EXPORT_CONST\n\n    return m;\n}"
  },
  {
    "function_name": "Container_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1565-1581",
    "snippet": "static PyObject *\nContainer_wait(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"state\", \"timeout\", NULL};\n    char *state = NULL;\n    int timeout = -1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|i\", kwlist,\n                                      &state, &timeout))\n        return NULL;\n\n    if (self->container->wait(self->container, state, timeout)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->wait",
          "args": [
            "self->container",
            "state",
            "timeout"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|i\"",
            "kwlist",
            "&state",
            "&timeout"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_wait(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"state\", \"timeout\", NULL};\n    char *state = NULL;\n    int timeout = -1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|i\", kwlist,\n                                      &state, &timeout))\n        return NULL;\n\n    if (self->container->wait(self->container, state, timeout)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1555-1563",
    "snippet": "static PyObject *\nContainer_unfreeze(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->unfreeze(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->unfreeze",
          "args": [
            "self->container"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_unfreeze(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->unfreeze(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1545-1553",
    "snippet": "static PyObject *\nContainer_stop(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->stop(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->stop",
          "args": [
            "self->container"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_stop(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->stop(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1482-1543",
    "snippet": "static PyObject *\nContainer_start(Container *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *useinit = NULL;\n    PyObject *daemonize = NULL;\n    PyObject *close_fds = NULL;\n\n    PyObject *vargs = NULL;\n    char** init_args = {NULL};\n\n    PyObject *retval = NULL;\n    int init_useinit = 0, i = 0;\n    static char *kwlist[] = {\"useinit\", \"daemonize\", \"close_fds\",\n                             \"cmd\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOOO\", kwlist,\n                                      &useinit, &daemonize, &close_fds,\n                                      &vargs))\n        return NULL;\n\n    if (useinit && useinit == Py_True) {\n        init_useinit = 1;\n    }\n\n    if (vargs && PyTuple_Check(vargs)) {\n        init_args = convert_tuple_to_char_pointer_array(vargs);\n        if (!init_args) {\n            return NULL;\n        }\n    }\n\n    if (close_fds && close_fds == Py_True) {\n        self->container->want_close_all_fds(self->container, true);\n    }\n    else {\n        self->container->want_close_all_fds(self->container, false);\n    }\n\n    if (!daemonize || daemonize == Py_True) {\n        self->container->want_daemonize(self->container, true);\n    }\n    else {\n        self->container->want_daemonize(self->container, false);\n    }\n\n    if (self->container->start(self->container, init_useinit, init_args))\n        retval = Py_True;\n    else\n        retval = Py_False;\n\n    if (vargs) {\n        /* We cannot have gotten here unless vargs was given and create_args\n         * was successfully allocated.\n         */\n        for (i = 0; i < PyTuple_GET_SIZE(vargs); i++)\n            free(init_args[i]);\n        free(init_args);\n    }\n\n    Py_INCREF(retval);\n    return retval;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_INCREF",
          "args": [
            "retval"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "init_args"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_GET_SIZE",
          "args": [
            "vargs"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->start",
          "args": [
            "self->container",
            "init_useinit",
            "init_args"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->want_daemonize",
          "args": [
            "self->container",
            "false"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->want_daemonize",
          "args": [
            "self->container",
            "true"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->want_close_all_fds",
          "args": [
            "self->container",
            "false"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->want_close_all_fds",
          "args": [
            "self->container",
            "true"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_tuple_to_char_pointer_array",
          "args": [
            "vargs"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tuple_to_char_pointer_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "113-188",
          "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_Check",
          "args": [
            "vargs"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|OOOO\"",
            "kwlist",
            "&useinit",
            "&daemonize",
            "&close_fds",
            "&vargs"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_start(Container *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *useinit = NULL;\n    PyObject *daemonize = NULL;\n    PyObject *close_fds = NULL;\n\n    PyObject *vargs = NULL;\n    char** init_args = {NULL};\n\n    PyObject *retval = NULL;\n    int init_useinit = 0, i = 0;\n    static char *kwlist[] = {\"useinit\", \"daemonize\", \"close_fds\",\n                             \"cmd\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOOO\", kwlist,\n                                      &useinit, &daemonize, &close_fds,\n                                      &vargs))\n        return NULL;\n\n    if (useinit && useinit == Py_True) {\n        init_useinit = 1;\n    }\n\n    if (vargs && PyTuple_Check(vargs)) {\n        init_args = convert_tuple_to_char_pointer_array(vargs);\n        if (!init_args) {\n            return NULL;\n        }\n    }\n\n    if (close_fds && close_fds == Py_True) {\n        self->container->want_close_all_fds(self->container, true);\n    }\n    else {\n        self->container->want_close_all_fds(self->container, false);\n    }\n\n    if (!daemonize || daemonize == Py_True) {\n        self->container->want_daemonize(self->container, true);\n    }\n    else {\n        self->container->want_daemonize(self->container, false);\n    }\n\n    if (self->container->start(self->container, init_useinit, init_args))\n        retval = Py_True;\n    else\n        retval = Py_False;\n\n    if (vargs) {\n        /* We cannot have gotten here unless vargs was given and create_args\n         * was successfully allocated.\n         */\n        for (i = 0; i < PyTuple_GET_SIZE(vargs); i++)\n            free(init_args[i]);\n        free(init_args);\n    }\n\n    Py_INCREF(retval);\n    return retval;\n}"
  },
  {
    "function_name": "Container_snapshot_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1464-1480",
    "snippet": "static PyObject *\nContainer_snapshot_restore(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *name = NULL;\n    char *newname = NULL;\n    static char *kwlist[] = {\"name\", \"newname\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|s\", kwlist,\n                                      &name, &newname))\n        return NULL;\n\n    if (self->container->snapshot_restore(self->container, name, newname)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->snapshot_restore",
          "args": [
            "self->container",
            "name",
            "newname"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|s\"",
            "kwlist",
            "&name",
            "&newname"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_snapshot_restore(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *name = NULL;\n    char *newname = NULL;\n    static char *kwlist[] = {\"name\", \"newname\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|s\", kwlist,\n                                      &name, &newname))\n        return NULL;\n\n    if (self->container->snapshot_restore(self->container, name, newname)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_snapshot_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1426-1461",
    "snippet": "static PyObject *\nContainer_snapshot_list(Container *self, PyObject *args, PyObject *kwds)\n{\n    struct lxc_snapshot *snap;\n    int snap_count = 0;\n    PyObject *list = NULL;\n    int i = 0;\n\n    snap_count = self->container->snapshot_list(self->container, &snap);\n\n    if (snap_count < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Unable to list snapshots\");\n        return NULL;\n    }\n\n    list = PyTuple_New(snap_count);\n    for (i = 0; i < snap_count; i++) {\n        PyObject *list_entry = NULL;\n\n        list_entry = PyTuple_New(4);\n        PyTuple_SET_ITEM(list_entry, 0,\n                         PyUnicode_FromString(snap[i].name));\n        PyTuple_SET_ITEM(list_entry, 1,\n                         PyUnicode_FromString(snap[i].comment_pathname));\n        PyTuple_SET_ITEM(list_entry, 2,\n                         PyUnicode_FromString(snap[i].timestamp));\n        PyTuple_SET_ITEM(list_entry, 3,\n                         PyUnicode_FromString(snap[i].lxcpath));\n\n        snap[i].free(&snap[i]);\n\n        PyTuple_SET_ITEM(list, i, list_entry);\n    }\n\n    return list;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list",
            "i",
            "list_entry"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snap[i].free",
          "args": [
            "&snap[i]"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list_entry",
            "3",
            "PyUnicode_FromString(snap[i].lxcpath)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "snap[i].lxcpath"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list_entry",
            "2",
            "PyUnicode_FromString(snap[i].timestamp)"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "snap[i].timestamp"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list_entry",
            "1",
            "PyUnicode_FromString(snap[i].comment_pathname)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "snap[i].comment_pathname"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list_entry",
            "0",
            "PyUnicode_FromString(snap[i].name)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "snap[i].name"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "4"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "snap_count"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Unable to list snapshots\""
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->snapshot_list",
          "args": [
            "self->container",
            "&snap"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_snapshot_list(Container *self, PyObject *args, PyObject *kwds)\n{\n    struct lxc_snapshot *snap;\n    int snap_count = 0;\n    PyObject *list = NULL;\n    int i = 0;\n\n    snap_count = self->container->snapshot_list(self->container, &snap);\n\n    if (snap_count < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Unable to list snapshots\");\n        return NULL;\n    }\n\n    list = PyTuple_New(snap_count);\n    for (i = 0; i < snap_count; i++) {\n        PyObject *list_entry = NULL;\n\n        list_entry = PyTuple_New(4);\n        PyTuple_SET_ITEM(list_entry, 0,\n                         PyUnicode_FromString(snap[i].name));\n        PyTuple_SET_ITEM(list_entry, 1,\n                         PyUnicode_FromString(snap[i].comment_pathname));\n        PyTuple_SET_ITEM(list_entry, 2,\n                         PyUnicode_FromString(snap[i].timestamp));\n        PyTuple_SET_ITEM(list_entry, 3,\n                         PyUnicode_FromString(snap[i].lxcpath));\n\n        snap[i].free(&snap[i]);\n\n        PyTuple_SET_ITEM(list, i, list_entry);\n    }\n\n    return list;\n}"
  },
  {
    "function_name": "Container_snapshot_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1409-1424",
    "snippet": "static PyObject *\nContainer_snapshot_destroy(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *name = NULL;\n    static char *kwlist[] = {\"name\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &name))\n        return NULL;\n\n    if (self->container->snapshot_destroy(self->container, name)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->snapshot_destroy",
          "args": [
            "self->container",
            "name"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|\"",
            "kwlist",
            "&name"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_snapshot_destroy(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *name = NULL;\n    static char *kwlist[] = {\"name\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &name))\n        return NULL;\n\n    if (self->container->snapshot_destroy(self->container, name)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1374-1407",
    "snippet": "static PyObject *\nContainer_snapshot(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *comment_path = NULL;\n    static char *kwlist[] = {\"comment_path\", NULL};\n    int retval = 0;\n    int ret = 0;\n    char newname[20];\n    PyObject *py_comment_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_comment_path))\n        return NULL;\n\n    if (py_comment_path != NULL) {\n        comment_path = PyBytes_AS_STRING(py_comment_path);\n        assert(comment_path != NULL);\n    }\n\n    retval = self->container->snapshot(self->container, comment_path);\n\n    Py_XDECREF(py_comment_path);\n\n    if (retval < 0) {\n        Py_RETURN_FALSE;\n    }\n\n    ret = snprintf(newname, 20, \"snap%d\", retval);\n    if (ret < 0 || ret >= 20)\n        return NULL;\n\n\n    return PyUnicode_FromString(newname);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "newname"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newname",
            "20",
            "\"snap%d\"",
            "retval"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_comment_path"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->snapshot",
          "args": [
            "self->container",
            "comment_path"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "comment_path != NULL"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_comment_path"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&py_comment_path"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_snapshot(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *comment_path = NULL;\n    static char *kwlist[] = {\"comment_path\", NULL};\n    int retval = 0;\n    int ret = 0;\n    char newname[20];\n    PyObject *py_comment_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_comment_path))\n        return NULL;\n\n    if (py_comment_path != NULL) {\n        comment_path = PyBytes_AS_STRING(py_comment_path);\n        assert(comment_path != NULL);\n    }\n\n    retval = self->container->snapshot(self->container, comment_path);\n\n    Py_XDECREF(py_comment_path);\n\n    if (retval < 0) {\n        Py_RETURN_FALSE;\n    }\n\n    ret = snprintf(newname, 20, \"snap%d\", retval);\n    if (ret < 0 || ret >= 20)\n        return NULL;\n\n\n    return PyUnicode_FromString(newname);\n}"
  },
  {
    "function_name": "Container_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1357-1372",
    "snippet": "static PyObject *\nContainer_shutdown(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"timeout\", NULL};\n    int timeout = -1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist,\n                                      &timeout))\n        return NULL;\n\n    if (self->container->shutdown(self->container, timeout)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->shutdown",
          "args": [
            "self->container",
            "timeout"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|i\"",
            "kwlist",
            "&timeout"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_shutdown(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"timeout\", NULL};\n    int timeout = -1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist,\n                                      &timeout))\n        return NULL;\n\n    if (self->container->shutdown(self->container, timeout)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_set_config_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1340-1355",
    "snippet": "static PyObject *\nContainer_set_config_path(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    char *path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &path))\n        return NULL;\n\n    if (self->container->set_config_path(self->container, path)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->set_config_path",
          "args": [
            "self->container",
            "path"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s\"",
            "kwlist",
            "&path"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_set_config_path(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    char *path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &path))\n        return NULL;\n\n    if (self->container->set_config_path(self->container, path)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_set_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1322-1338",
    "snippet": "static PyObject *\nContainer_set_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", \"value\", NULL};\n    char *key = NULL;\n    char *value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"ss\", kwlist,\n                                      &key, &value))\n        return NULL;\n\n    if (self->container->set_config_item(self->container, key, value)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->set_config_item",
          "args": [
            "self->container",
            "key",
            "value"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"ss\"",
            "kwlist",
            "&key",
            "&value"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_set_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", \"value\", NULL};\n    char *key = NULL;\n    char *value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"ss\", kwlist,\n                                      &key, &value))\n        return NULL;\n\n    if (self->container->set_config_item(self->container, key, value)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_set_cgroup_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1304-1320",
    "snippet": "static PyObject *\nContainer_set_cgroup_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", \"value\", NULL};\n    char *key = NULL;\n    char *value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"ss\", kwlist,\n                                      &key, &value))\n        return NULL;\n\n    if (self->container->set_cgroup_item(self->container, key, value)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->set_cgroup_item",
          "args": [
            "self->container",
            "key",
            "value"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"ss\"",
            "kwlist",
            "&key",
            "&value"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_set_cgroup_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", \"value\", NULL};\n    char *key = NULL;\n    char *value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"ss\", kwlist,\n                                      &key, &value))\n        return NULL;\n\n    if (self->container->set_cgroup_item(self->container, key, value)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_save_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1279-1302",
    "snippet": "static PyObject *\nContainer_save_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    PyObject *fs_path = NULL;\n    char* path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &fs_path))\n        return NULL;\n\n    if (fs_path != NULL) {\n        path = PyBytes_AS_STRING(fs_path);\n        assert(path != NULL);\n    }\n\n    if (self->container->save_config(self->container, path)) {\n        Py_XDECREF(fs_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(fs_path);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_path"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_path"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->save_config",
          "args": [
            "self->container",
            "path"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path != NULL"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "fs_path"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&fs_path"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_save_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    PyObject *fs_path = NULL;\n    char* path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &fs_path))\n        return NULL;\n\n    if (fs_path != NULL) {\n        path = PyBytes_AS_STRING(fs_path);\n        assert(path != NULL);\n    }\n\n    if (self->container->save_config(self->container, path)) {\n        Py_XDECREF(fs_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(fs_path);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_remove_device_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1243-1277",
    "snippet": "static PyObject *\nContainer_remove_device_node(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_path\", \"dest_path\", NULL};\n    char *src_path = NULL;\n    char *dst_path = NULL;\n    PyObject *py_src_path = NULL;\n    PyObject *py_dst_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_path,\n                                      PyUnicode_FSConverter, &py_dst_path))\n        return NULL;\n\n    if (py_src_path != NULL) {\n        src_path = PyBytes_AS_STRING(py_src_path);\n        assert(src_path != NULL);\n    }\n\n    if (py_dst_path != NULL) {\n        dst_path = PyBytes_AS_STRING(py_dst_path);\n        assert(dst_path != NULL);\n    }\n\n    if (self->container->remove_device_node(self->container, src_path,\n                                            dst_path)) {\n        Py_XDECREF(py_src_path);\n        Py_XDECREF(py_dst_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_path);\n    Py_XDECREF(py_dst_path);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_path"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_path"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_path"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_path"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->remove_device_node",
          "args": [
            "self->container",
            "src_path",
            "dst_path"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst_path != NULL"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_dst_path"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src_path != NULL"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_src_path"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"O&|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&py_src_path",
            "PyUnicode_FSConverter",
            "&py_dst_path"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_remove_device_node(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_path\", \"dest_path\", NULL};\n    char *src_path = NULL;\n    char *dst_path = NULL;\n    PyObject *py_src_path = NULL;\n    PyObject *py_dst_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_path,\n                                      PyUnicode_FSConverter, &py_dst_path))\n        return NULL;\n\n    if (py_src_path != NULL) {\n        src_path = PyBytes_AS_STRING(py_src_path);\n        assert(src_path != NULL);\n    }\n\n    if (py_dst_path != NULL) {\n        dst_path = PyBytes_AS_STRING(py_dst_path);\n        assert(dst_path != NULL);\n    }\n\n    if (self->container->remove_device_node(self->container, src_path,\n                                            dst_path)) {\n        Py_XDECREF(py_src_path);\n        Py_XDECREF(py_dst_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_path);\n    Py_XDECREF(py_dst_path);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1226-1241",
    "snippet": "static PyObject *\nContainer_rename(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *new_name = NULL;\n    static char *kwlist[] = {\"new_name\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &new_name))\n        return NULL;\n\n    if (self->container->rename(self->container, new_name)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->rename",
          "args": [
            "self->container",
            "new_name"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|\"",
            "kwlist",
            "&new_name"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_rename(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *new_name = NULL;\n    static char *kwlist[] = {\"new_name\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &new_name))\n        return NULL;\n\n    if (self->container->rename(self->container, new_name)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1216-1224",
    "snippet": "static PyObject *\nContainer_reboot(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->reboot(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->reboot",
          "args": [
            "self->container"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_reboot(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->reboot(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_load_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1191-1214",
    "snippet": "static PyObject *\nContainer_load_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    PyObject *fs_path = NULL;\n    char* path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &fs_path))\n        return NULL;\n\n    if (fs_path != NULL) {\n        path = PyBytes_AS_STRING(fs_path);\n        assert(path != NULL);\n    }\n\n    if (self->container->load_config(self->container, path)) {\n        Py_XDECREF(fs_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(fs_path);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_path"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_path"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->load_config",
          "args": [
            "self->container",
            "path"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path != NULL"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "fs_path"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&fs_path"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_load_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"path\", NULL};\n    PyObject *fs_path = NULL;\n    char* path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|O&\", kwlist,\n                                      PyUnicode_FSConverter, &fs_path))\n        return NULL;\n\n    if (fs_path != NULL) {\n        path = PyBytes_AS_STRING(fs_path);\n        assert(path != NULL);\n    }\n\n    if (self->container->load_config(self->container, path)) {\n        Py_XDECREF(fs_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(fs_path);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_get_running_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1167-1188",
    "snippet": "static PyObject *\nContainer_get_running_config_item(Container *self, PyObject *args,\n                                  PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    char* value = NULL;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    value = self->container->get_running_config_item(self->container, key);\n\n    if (!value)\n        Py_RETURN_NONE;\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "value"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_running_config_item",
          "args": [
            "self->container",
            "key"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|\"",
            "kwlist",
            "&key"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_running_config_item(Container *self, PyObject *args,\n                                  PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    char* value = NULL;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    value = self->container->get_running_config_item(self->container, key);\n\n    if (!value)\n        Py_RETURN_NONE;\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}"
  },
  {
    "function_name": "Container_get_ips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1112-1165",
    "snippet": "static PyObject *\nContainer_get_ips(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"interface\", \"family\", \"scope\", NULL};\n    char* interface = NULL;\n    char* family = NULL;\n    int scope = 0;\n\n    int i = 0;\n    char** ips = NULL;\n\n    PyObject* ret;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|ssi\", kwlist,\n                                      &interface, &family, &scope))\n        return NULL;\n\n    /* Get the IPs */\n    ips = self->container->get_ips(self->container, interface, family, scope);\n    if (!ips)\n        return PyTuple_New(0);\n\n    /* Count the entries */\n    while (ips[i])\n        i++;\n\n    /* Create the new tuple */\n    ret = PyTuple_New(i);\n    if (!ret)\n        return NULL;\n\n    /* Add the entries to the tuple and free the memory */\n    i = 0;\n    while (ips[i]) {\n        PyObject *unicode = PyUnicode_FromString(ips[i]);\n        if (!unicode) {\n            Py_DECREF(ret);\n            ret = NULL;\n            break;\n        }\n        PyTuple_SET_ITEM(ret, i, unicode);\n        i++;\n    }\n\n    /* Free the list of IPs */\n    i = 0;\n    while (ips[i]) {\n        free(ips[i]);\n        i++;\n    }\n    free(ips);\n\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ips"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "ret",
            "i",
            "unicode"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "ret"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "ips[i]"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "i"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "0"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_ips",
          "args": [
            "self->container",
            "interface",
            "family",
            "scope"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|ssi\"",
            "kwlist",
            "&interface",
            "&family",
            "&scope"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_ips(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"interface\", \"family\", \"scope\", NULL};\n    char* interface = NULL;\n    char* family = NULL;\n    int scope = 0;\n\n    int i = 0;\n    char** ips = NULL;\n\n    PyObject* ret;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|ssi\", kwlist,\n                                      &interface, &family, &scope))\n        return NULL;\n\n    /* Get the IPs */\n    ips = self->container->get_ips(self->container, interface, family, scope);\n    if (!ips)\n        return PyTuple_New(0);\n\n    /* Count the entries */\n    while (ips[i])\n        i++;\n\n    /* Create the new tuple */\n    ret = PyTuple_New(i);\n    if (!ret)\n        return NULL;\n\n    /* Add the entries to the tuple and free the memory */\n    i = 0;\n    while (ips[i]) {\n        PyObject *unicode = PyUnicode_FromString(ips[i]);\n        if (!unicode) {\n            Py_DECREF(ret);\n            ret = NULL;\n            break;\n        }\n        PyTuple_SET_ITEM(ret, i, unicode);\n        i++;\n    }\n\n    /* Free the list of IPs */\n    i = 0;\n    while (ips[i]) {\n        free(ips[i]);\n        i++;\n    }\n    free(ips);\n\n    return ret;\n}"
  },
  {
    "function_name": "Container_get_interfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1066-1110",
    "snippet": "static PyObject *\nContainer_get_interfaces(Container *self)\n{\n    int i = 0;\n    char** interfaces = NULL;\n\n    PyObject* ret;\n\n    /* Get the interfaces */\n    interfaces = self->container->get_interfaces(self->container);\n    if (!interfaces)\n        return PyTuple_New(0);\n\n    /* Count the entries */\n    while (interfaces[i])\n        i++;\n\n    /* Create the new tuple */\n    ret = PyTuple_New(i);\n    if (!ret)\n        return NULL;\n\n    /* Add the entries to the tuple and free the memory */\n    i = 0;\n    while (interfaces[i]) {\n        PyObject *unicode = PyUnicode_FromString(interfaces[i]);\n        if (!unicode) {\n            Py_DECREF(ret);\n            ret = NULL;\n            break;\n        }\n        PyTuple_SET_ITEM(ret, i, unicode);\n        i++;\n    }\n\n    /* Free the list of IPs */\n    i = 0;\n    while (interfaces[i]) {\n        free(interfaces[i]);\n        i++;\n    }\n    free(interfaces);\n\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "interfaces"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "ret",
            "i",
            "unicode"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "ret"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "interfaces[i]"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "i"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "0"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_interfaces",
          "args": [
            "self->container"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_interfaces(Container *self)\n{\n    int i = 0;\n    char** interfaces = NULL;\n\n    PyObject* ret;\n\n    /* Get the interfaces */\n    interfaces = self->container->get_interfaces(self->container);\n    if (!interfaces)\n        return PyTuple_New(0);\n\n    /* Count the entries */\n    while (interfaces[i])\n        i++;\n\n    /* Create the new tuple */\n    ret = PyTuple_New(i);\n    if (!ret)\n        return NULL;\n\n    /* Add the entries to the tuple and free the memory */\n    i = 0;\n    while (interfaces[i]) {\n        PyObject *unicode = PyUnicode_FromString(interfaces[i]);\n        if (!unicode) {\n            Py_DECREF(ret);\n            ret = NULL;\n            break;\n        }\n        PyTuple_SET_ITEM(ret, i, unicode);\n        i++;\n    }\n\n    /* Free the list of IPs */\n    i = 0;\n    while (interfaces[i]) {\n        free(interfaces[i]);\n        i++;\n    }\n    free(interfaces);\n\n    return ret;\n}"
  },
  {
    "function_name": "Container_get_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1030-1064",
    "snippet": "static PyObject *\nContainer_get_keys(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|s\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_keys(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_keys(self->container,\n                                    key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config keys\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "value"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Unable to read config keys\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_keys",
          "args": [
            "self->container",
            "key",
            "value",
            "len + 1"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_NoMemory",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Invalid configuration key\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_keys",
          "args": [
            "self->container",
            "key",
            "NULL",
            "0"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|s\"",
            "kwlist",
            "&key"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_keys(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|s\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_keys(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_keys(self->container,\n                                    key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config keys\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}"
  },
  {
    "function_name": "Container_get_config_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "1023-1028",
    "snippet": "static PyObject *\nContainer_get_config_path(Container *self, PyObject *args, PyObject *kwds)\n{\n    return PyUnicode_FromString(\n                self->container->get_config_path(self->container));\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "self->container->get_config_path(self->container)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_config_path",
          "args": [
            "self->container"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_config_path(Container *self, PyObject *args, PyObject *kwds)\n{\n    return PyUnicode_FromString(\n                self->container->get_config_path(self->container));\n}"
  },
  {
    "function_name": "Container_get_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "983-1021",
    "snippet": "static PyObject *\nContainer_get_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_config_item(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    if (len == 0) {\n        return PyUnicode_FromString(\"\");\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_config_item(self->container,\n                                            key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config value\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "value"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Unable to read config value\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_config_item",
          "args": [
            "self->container",
            "key",
            "value",
            "len + 1"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_NoMemory",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "\"\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Invalid configuration key\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_config_item",
          "args": [
            "self->container",
            "key",
            "NULL",
            "0"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|\"",
            "kwlist",
            "&key"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_config_item(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    if (len == 0) {\n        return PyUnicode_FromString(\"\");\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_config_item(self->container,\n                                            key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config value\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}"
  },
  {
    "function_name": "Container_get_cgroup_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "947-981",
    "snippet": "static PyObject *\nContainer_get_cgroup_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_cgroup_item(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid cgroup entry\");\n        return NULL;\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_cgroup_item(self->container,\n                                            key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config value\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "value"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Unable to read config value\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_cgroup_item",
          "args": [
            "self->container",
            "key",
            "value",
            "len + 1"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_NoMemory",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Invalid cgroup entry\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->get_cgroup_item",
          "args": [
            "self->container",
            "key",
            "NULL",
            "0"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s\"",
            "kwlist",
            "&key"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_get_cgroup_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    int len = 0;\n    char* value;\n    PyObject *ret = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &key))\n        return NULL;\n\n    len = self->container->get_cgroup_item(self->container, key, NULL, 0);\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid cgroup entry\");\n        return NULL;\n    }\n\n    value = (char*) malloc(sizeof(char)*len + 1);\n    if (value == NULL)\n        return PyErr_NoMemory();\n\n    if (self->container->get_cgroup_item(self->container,\n                                            key, value, len + 1) != len) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to read config value\");\n        free(value);\n        return NULL;\n    }\n\n    ret = PyUnicode_FromString(value);\n    free(value);\n    return ret;\n}"
  },
  {
    "function_name": "Container_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "937-945",
    "snippet": "static PyObject *\nContainer_freeze(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->freeze(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->freeze",
          "args": [
            "self->container"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_freeze(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->freeze(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "927-935",
    "snippet": "static PyObject *\nContainer_destroy(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->destroy(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->destroy",
          "args": [
            "self->container"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_destroy(Container *self, PyObject *args, PyObject *kwds)\n{\n    if (self->container->destroy(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "880-925",
    "snippet": "static PyObject *\nContainer_create(Container *self, PyObject *args, PyObject *kwds)\n{\n    char* template_name = NULL;\n    int flags = 0;\n    char** create_args = {NULL};\n    PyObject *retval = NULL;\n    PyObject *vargs = NULL;\n    char *bdevtype = NULL;\n    int i = 0;\n    static char *kwlist[] = {\"template\", \"flags\", \"bdevtype\", \"args\", NULL};\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|sisO\", kwlist,\n                                      &template_name, &flags, &bdevtype, &vargs))\n        return NULL;\n\n    if (vargs) {\n        if (PyTuple_Check(vargs)) {\n            create_args = convert_tuple_to_char_pointer_array(vargs);\n            if (!create_args) {\n                return NULL;\n            }\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError, \"args needs to be a tuple\");\n            return NULL;\n        }\n    }\n\n    if (self->container->create(self->container, template_name, bdevtype, NULL,\n                                flags, create_args))\n        retval = Py_True;\n    else\n        retval = Py_False;\n\n    if (vargs) {\n        /* We cannot have gotten here unless vargs was given and create_args\n         * was successfully allocated.\n         */\n        for (i = 0; i < PyTuple_GET_SIZE(vargs); i++)\n            free(create_args[i]);\n        free(create_args);\n    }\n\n    Py_INCREF(retval);\n    return retval;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_INCREF",
          "args": [
            "retval"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "create_args"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_GET_SIZE",
          "args": [
            "vargs"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->create",
          "args": [
            "self->container",
            "template_name",
            "bdevtype",
            "NULL",
            "flags",
            "create_args"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"args needs to be a tuple\""
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_tuple_to_char_pointer_array",
          "args": [
            "vargs"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tuple_to_char_pointer_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "113-188",
          "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_Check",
          "args": [
            "vargs"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|sisO\"",
            "kwlist",
            "&template_name",
            "&flags",
            "&bdevtype",
            "&vargs"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_create(Container *self, PyObject *args, PyObject *kwds)\n{\n    char* template_name = NULL;\n    int flags = 0;\n    char** create_args = {NULL};\n    PyObject *retval = NULL;\n    PyObject *vargs = NULL;\n    char *bdevtype = NULL;\n    int i = 0;\n    static char *kwlist[] = {\"template\", \"flags\", \"bdevtype\", \"args\", NULL};\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|sisO\", kwlist,\n                                      &template_name, &flags, &bdevtype, &vargs))\n        return NULL;\n\n    if (vargs) {\n        if (PyTuple_Check(vargs)) {\n            create_args = convert_tuple_to_char_pointer_array(vargs);\n            if (!create_args) {\n                return NULL;\n            }\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError, \"args needs to be a tuple\");\n            return NULL;\n        }\n    }\n\n    if (self->container->create(self->container, template_name, bdevtype, NULL,\n                                flags, create_args))\n        retval = Py_True;\n    else\n        retval = Py_False;\n\n    if (vargs) {\n        /* We cannot have gotten here unless vargs was given and create_args\n         * was successfully allocated.\n         */\n        for (i = 0; i < PyTuple_GET_SIZE(vargs); i++)\n            free(create_args[i]);\n        free(create_args);\n    }\n\n    Py_INCREF(retval);\n    return retval;\n}"
  },
  {
    "function_name": "Container_console_getfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "863-878",
    "snippet": "static PyObject *\nContainer_console_getfd(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ttynum\", NULL};\n    int ttynum = -1, masterfd;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &ttynum))\n        return NULL;\n\n    if (self->container->console_getfd(self->container, &ttynum,\n                                       &masterfd) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to allocate tty\");\n        return NULL;\n    }\n    return PyLong_FromLong(masterfd);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "masterfd"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Unable to allocate tty\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->console_getfd",
          "args": [
            "self->container",
            "&ttynum",
            "&masterfd"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|i\"",
            "kwlist",
            "&ttynum"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_console_getfd(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ttynum\", NULL};\n    int ttynum = -1, masterfd;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &ttynum))\n        return NULL;\n\n    if (self->container->console_getfd(self->container, &ttynum,\n                                       &masterfd) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"Unable to allocate tty\");\n        return NULL;\n    }\n    return PyLong_FromLong(masterfd);\n}"
  },
  {
    "function_name": "Container_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "844-861",
    "snippet": "static PyObject *\nContainer_console(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ttynum\", \"stdinfd\", \"stdoutfd\", \"stderrfd\",\n                             \"escape\", NULL};\n    int ttynum = -1, stdinfd = 0, stdoutfd = 1, stderrfd = 2, escape = 1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|iiiii\", kwlist,\n                                      &ttynum, &stdinfd, &stdoutfd, &stderrfd,\n                                      &escape))\n        return NULL;\n\n    if (self->container->console(self->container, ttynum,\n            stdinfd, stdoutfd, stderrfd, escape) == 0) {\n        Py_RETURN_TRUE;\n    }\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->console",
          "args": [
            "self->container",
            "ttynum",
            "stdinfd",
            "stdoutfd",
            "stderrfd",
            "escape"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|iiiii\"",
            "kwlist",
            "&ttynum",
            "&stdinfd",
            "&stdoutfd",
            "&stderrfd",
            "&escape"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_console(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ttynum\", \"stdinfd\", \"stdoutfd\", \"stderrfd\",\n                             \"escape\", NULL};\n    int ttynum = -1, stdinfd = 0, stdoutfd = 1, stderrfd = 2, escape = 1;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|iiiii\", kwlist,\n                                      &ttynum, &stdinfd, &stdoutfd, &stderrfd,\n                                      &escape))\n        return NULL;\n\n    if (self->container->console(self->container, ttynum,\n            stdinfd, stdoutfd, stderrfd, escape) == 0) {\n        Py_RETURN_TRUE;\n    }\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "780-842",
    "snippet": "static PyObject *\nContainer_clone(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *newname = NULL;\n    char *config_path = NULL;\n    int flags = 0;\n    char *bdevtype = NULL;\n    char *bdevdata = NULL;\n    unsigned long newsize = 0;\n    char **hookargs = NULL;\n\n    PyObject *py_hookargs = NULL;\n    PyObject *py_config_path = NULL;\n    struct lxc_container *new_container = NULL;\n    int i = 0;\n\n    static char *kwlist[] = {\"newname\", \"config_path\", \"flags\", \"bdevtype\",\n                             \"bdevdata\", \"newsize\", \"hookargs\", NULL};\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|O&isskO\", kwlist,\n                                      &newname,\n                                      PyUnicode_FSConverter, &py_config_path,\n                                      &flags, &bdevtype, &bdevdata, &newsize,\n                                      &py_hookargs))\n        return NULL;\n\n    if (py_hookargs) {\n        if (PyTuple_Check(py_hookargs)) {\n            hookargs = convert_tuple_to_char_pointer_array(py_hookargs);\n            if (!hookargs) {\n                return NULL;\n            }\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError, \"hookargs needs to be a tuple\");\n            return NULL;\n        }\n    }\n\n    if (py_config_path != NULL) {\n        config_path = PyBytes_AS_STRING(py_config_path);\n        assert(config_path != NULL);\n    }\n\n    new_container = self->container->clone(self->container, newname,\n                                           config_path, flags, bdevtype,\n                                           bdevdata, newsize, hookargs);\n\n    Py_XDECREF(py_config_path);\n\n    if (hookargs) {\n        for (i = 0; i < PyTuple_GET_SIZE(py_hookargs); i++)\n            free(hookargs[i]);\n        free(hookargs);\n    }\n\n    if (new_container == NULL) {\n        Py_RETURN_FALSE;\n    }\n\n    lxc_container_put(new_container);\n\n    Py_RETURN_TRUE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "new_container"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hookargs"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_GET_SIZE",
          "args": [
            "py_hookargs"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_config_path"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->clone",
          "args": [
            "self->container",
            "newname",
            "config_path",
            "flags",
            "bdevtype",
            "bdevdata",
            "newsize",
            "hookargs"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "config_path != NULL"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_config_path"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"hookargs needs to be a tuple\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_tuple_to_char_pointer_array",
          "args": [
            "py_hookargs"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tuple_to_char_pointer_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "113-188",
          "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_Check",
          "args": [
            "py_hookargs"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|O&isskO\"",
            "kwlist",
            "&newname",
            "PyUnicode_FSConverter",
            "&py_config_path",
            "&flags",
            "&bdevtype",
            "&bdevdata",
            "&newsize",
            "&py_hookargs"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_clone(Container *self, PyObject *args, PyObject *kwds)\n{\n    char *newname = NULL;\n    char *config_path = NULL;\n    int flags = 0;\n    char *bdevtype = NULL;\n    char *bdevdata = NULL;\n    unsigned long newsize = 0;\n    char **hookargs = NULL;\n\n    PyObject *py_hookargs = NULL;\n    PyObject *py_config_path = NULL;\n    struct lxc_container *new_container = NULL;\n    int i = 0;\n\n    static char *kwlist[] = {\"newname\", \"config_path\", \"flags\", \"bdevtype\",\n                             \"bdevdata\", \"newsize\", \"hookargs\", NULL};\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|O&isskO\", kwlist,\n                                      &newname,\n                                      PyUnicode_FSConverter, &py_config_path,\n                                      &flags, &bdevtype, &bdevdata, &newsize,\n                                      &py_hookargs))\n        return NULL;\n\n    if (py_hookargs) {\n        if (PyTuple_Check(py_hookargs)) {\n            hookargs = convert_tuple_to_char_pointer_array(py_hookargs);\n            if (!hookargs) {\n                return NULL;\n            }\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError, \"hookargs needs to be a tuple\");\n            return NULL;\n        }\n    }\n\n    if (py_config_path != NULL) {\n        config_path = PyBytes_AS_STRING(py_config_path);\n        assert(config_path != NULL);\n    }\n\n    new_container = self->container->clone(self->container, newname,\n                                           config_path, flags, bdevtype,\n                                           bdevdata, newsize, hookargs);\n\n    Py_XDECREF(py_config_path);\n\n    if (hookargs) {\n        for (i = 0; i < PyTuple_GET_SIZE(py_hookargs); i++)\n            free(hookargs[i]);\n        free(hookargs);\n    }\n\n    if (new_container == NULL) {\n        Py_RETURN_FALSE;\n    }\n\n    lxc_container_put(new_container);\n\n    Py_RETURN_TRUE;\n}"
  },
  {
    "function_name": "Container_clear_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "763-778",
    "snippet": "static PyObject *\nContainer_clear_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char *key = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &key))\n        return NULL;\n\n    if (self->container->clear_config_item(self->container, key)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->clear_config_item",
          "args": [
            "self->container",
            "key"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s\"",
            "kwlist",
            "&key"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_clear_config_item(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char *key = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s\", kwlist,\n                                      &key))\n        return NULL;\n\n    if (self->container->clear_config_item(self->container, key)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_clear_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "755-761",
    "snippet": "static PyObject *\nContainer_clear_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    self->container->clear_config(self->container);\n\n    Py_RETURN_NONE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->clear_config",
          "args": [
            "self->container"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_clear_config(Container *self, PyObject *args, PyObject *kwds)\n{\n    self->container->clear_config(self->container);\n\n    Py_RETURN_NONE;\n}"
  },
  {
    "function_name": "Container_attach_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "749-753",
    "snippet": "static PyObject *\nContainer_attach_wait(Container *self, PyObject *args, PyObject *kwds)\n{\n    return Container_attach_and_possibly_wait(self, args, kwds, 1);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Container_attach_and_possibly_wait",
          "args": [
            "self",
            "args",
            "kwds",
            "1"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "Container_attach_and_possibly_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "702-741",
          "snippet": "static PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nstatic PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_attach_wait(Container *self, PyObject *args, PyObject *kwds)\n{\n    return Container_attach_and_possibly_wait(self, args, kwds, 1);\n}"
  },
  {
    "function_name": "Container_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "743-747",
    "snippet": "static PyObject *\nContainer_attach(Container *self, PyObject *args, PyObject *kwds)\n{\n    return Container_attach_and_possibly_wait(self, args, kwds, 0);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Container_attach_and_possibly_wait",
          "args": [
            "self",
            "args",
            "kwds",
            "0"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "Container_attach_and_possibly_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "702-741",
          "snippet": "static PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nstatic PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_attach(Container *self, PyObject *args, PyObject *kwds)\n{\n    return Container_attach_and_possibly_wait(self, args, kwds, 0);\n}"
  },
  {
    "function_name": "Container_attach_and_possibly_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "702-741",
    "snippet": "static PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_attach_free_options(lxc_attach_options_t *options);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "ret"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_free_options",
          "args": [
            "options"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_wait_for_pid_status",
          "args": [
            "pid"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "self->container->attach",
          "args": [
            "self->container",
            "lxc_attach_python_exec",
            "&payload",
            "options",
            "&pid"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_parse_options",
          "args": [
            "kwds"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "220-316",
          "snippet": "static lxc_attach_options_t *lxc_attach_parse_options(PyObject *kwds)\n{\n    static char *kwlist[] = {\"attach_flags\", \"namespaces\", \"personality\",\n                             \"initial_cwd\", \"uid\", \"gid\", \"env_policy\",\n                             \"extra_env_vars\", \"extra_keep_env\", \"stdin\",\n                             \"stdout\", \"stderr\", NULL};\n    long temp_uid, temp_gid;\n    int temp_env_policy;\n    PyObject *extra_env_vars_obj = NULL;\n    PyObject *extra_keep_env_obj = NULL;\n    PyObject *stdin_obj = NULL;\n    PyObject *stdout_obj = NULL;\n    PyObject *stderr_obj = NULL;\n    PyObject *initial_cwd_obj = NULL;\n    PyObject *dummy = NULL;\n    bool parse_result;\n\n    lxc_attach_options_t default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n    lxc_attach_options_t *options = malloc(sizeof(*options));\n\n    if (!options) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n    memcpy(options, &default_options, sizeof(*options));\n\n    /* we need some dummy variables because we can't be sure\n     * the data types match completely */\n    temp_uid = -1;\n    temp_gid = -1;\n    temp_env_policy = options->env_policy;\n\n    /* we need a dummy tuple */\n    dummy = PyTuple_New(0);\n\n    parse_result = PyArg_ParseTupleAndKeywords(dummy, kwds, \"|iilO&lliOOOOO\",\n                                               kwlist, &options->attach_flags,\n                                               &options->namespaces,\n                                               &options->personality,\n                                               PyUnicode_FSConverter,\n                                               &initial_cwd_obj, &temp_uid,\n                                               &temp_gid, &temp_env_policy,\n                                               &extra_env_vars_obj,\n                                               &extra_keep_env_obj,\n                                               &stdin_obj, &stdout_obj,\n                                               &stderr_obj);\n\n    /* immediately get rid of the dummy tuple */\n    Py_DECREF(dummy);\n\n    if (!parse_result) {\n        lxc_attach_free_options(options);\n        return NULL;\n    }\n\n    /* duplicate the string, so we don't depend on some random Python object */\n    if (initial_cwd_obj != NULL) {\n        options->initial_cwd = strndup(PyBytes_AsString(initial_cwd_obj),\n                                       PyBytes_Size(initial_cwd_obj));\n        Py_DECREF(initial_cwd_obj);\n    }\n\n    /* do the type conversion from the types that match the parse string */\n    if (temp_uid != -1) options->uid = (uid_t)temp_uid;\n    if (temp_gid != -1) options->gid = (gid_t)temp_gid;\n    options->env_policy = (lxc_attach_env_policy_t)temp_env_policy;\n\n    if (extra_env_vars_obj)\n        options->extra_env_vars =\n            convert_tuple_to_char_pointer_array(extra_env_vars_obj);\n    if (extra_keep_env_obj)\n        options->extra_keep_env =\n            convert_tuple_to_char_pointer_array(extra_keep_env_obj);\n    if (stdin_obj) {\n        options->stdin_fd = PyObject_AsFileDescriptor(stdin_obj);\n        if (options->stdin_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stdout_obj) {\n        options->stdout_fd = PyObject_AsFileDescriptor(stdout_obj);\n        if (options->stdout_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stderr_obj) {\n        options->stderr_fd = PyObject_AsFileDescriptor(stderr_obj);\n        if (options->stderr_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n\n    return options;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nstatic lxc_attach_options_t *lxc_attach_parse_options(PyObject *kwds)\n{\n    static char *kwlist[] = {\"attach_flags\", \"namespaces\", \"personality\",\n                             \"initial_cwd\", \"uid\", \"gid\", \"env_policy\",\n                             \"extra_env_vars\", \"extra_keep_env\", \"stdin\",\n                             \"stdout\", \"stderr\", NULL};\n    long temp_uid, temp_gid;\n    int temp_env_policy;\n    PyObject *extra_env_vars_obj = NULL;\n    PyObject *extra_keep_env_obj = NULL;\n    PyObject *stdin_obj = NULL;\n    PyObject *stdout_obj = NULL;\n    PyObject *stderr_obj = NULL;\n    PyObject *initial_cwd_obj = NULL;\n    PyObject *dummy = NULL;\n    bool parse_result;\n\n    lxc_attach_options_t default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n    lxc_attach_options_t *options = malloc(sizeof(*options));\n\n    if (!options) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n    memcpy(options, &default_options, sizeof(*options));\n\n    /* we need some dummy variables because we can't be sure\n     * the data types match completely */\n    temp_uid = -1;\n    temp_gid = -1;\n    temp_env_policy = options->env_policy;\n\n    /* we need a dummy tuple */\n    dummy = PyTuple_New(0);\n\n    parse_result = PyArg_ParseTupleAndKeywords(dummy, kwds, \"|iilO&lliOOOOO\",\n                                               kwlist, &options->attach_flags,\n                                               &options->namespaces,\n                                               &options->personality,\n                                               PyUnicode_FSConverter,\n                                               &initial_cwd_obj, &temp_uid,\n                                               &temp_gid, &temp_env_policy,\n                                               &extra_env_vars_obj,\n                                               &extra_keep_env_obj,\n                                               &stdin_obj, &stdout_obj,\n                                               &stderr_obj);\n\n    /* immediately get rid of the dummy tuple */\n    Py_DECREF(dummy);\n\n    if (!parse_result) {\n        lxc_attach_free_options(options);\n        return NULL;\n    }\n\n    /* duplicate the string, so we don't depend on some random Python object */\n    if (initial_cwd_obj != NULL) {\n        options->initial_cwd = strndup(PyBytes_AsString(initial_cwd_obj),\n                                       PyBytes_Size(initial_cwd_obj));\n        Py_DECREF(initial_cwd_obj);\n    }\n\n    /* do the type conversion from the types that match the parse string */\n    if (temp_uid != -1) options->uid = (uid_t)temp_uid;\n    if (temp_gid != -1) options->gid = (gid_t)temp_gid;\n    options->env_policy = (lxc_attach_env_policy_t)temp_env_policy;\n\n    if (extra_env_vars_obj)\n        options->extra_env_vars =\n            convert_tuple_to_char_pointer_array(extra_env_vars_obj);\n    if (extra_keep_env_obj)\n        options->extra_keep_env =\n            convert_tuple_to_char_pointer_array(extra_keep_env_obj);\n    if (stdin_obj) {\n        options->stdin_fd = PyObject_AsFileDescriptor(stdin_obj);\n        if (options->stdin_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stdout_obj) {\n        options->stdout_fd = PyObject_AsFileDescriptor(stdout_obj);\n        if (options->stdout_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stderr_obj) {\n        options->stderr_fd = PyObject_AsFileDescriptor(stderr_obj);\n        if (options->stderr_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n\n    return options;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyErr_Format",
          "args": [
            "PyExc_TypeError",
            "\"attach: object not callable\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyCallable_Check",
          "args": [
            "payload.fn"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTuple",
          "args": [
            "args",
            "\"O|O\"",
            "&payload.fn",
            "&payload.arg"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nstatic PyObject *\nContainer_attach_and_possibly_wait(Container *self, PyObject *args,\n                                   PyObject *kwds, int wait)\n{\n    struct lxc_attach_python_payload payload = { NULL, NULL };\n    lxc_attach_options_t *options = NULL;\n    long ret;\n    pid_t pid;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &payload.fn, &payload.arg))\n        return NULL;\n    if (!PyCallable_Check(payload.fn)) {\n        PyErr_Format(PyExc_TypeError, \"attach: object not callable\");\n        return NULL;\n    }\n\n    options = lxc_attach_parse_options(kwds);\n    if (!options)\n        return NULL;\n\n    ret = self->container->attach(self->container, lxc_attach_python_exec,\n                                  &payload, options, &pid);\n    if (ret < 0)\n        goto out;\n\n    if (wait) {\n        Py_BEGIN_ALLOW_THREADS\n        ret = lxc_wait_for_pid_status(pid);\n        Py_END_ALLOW_THREADS\n        /* handle case where attach fails */\n        if (WIFEXITED(ret) && WEXITSTATUS(ret) == 255)\n            ret = -1;\n    } else {\n        ret = (long)pid;\n    }\n\nout:\n    lxc_attach_free_options(options);\n    return PyLong_FromLong(ret);\n}"
  },
  {
    "function_name": "Container_add_device_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "666-700",
    "snippet": "static PyObject *\nContainer_add_device_node(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_path\", \"dest_path\", NULL};\n    char *src_path = NULL;\n    char *dst_path = NULL;\n    PyObject *py_src_path = NULL;\n    PyObject *py_dst_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_path,\n                                      PyUnicode_FSConverter, &py_dst_path))\n        return NULL;\n\n    if (py_src_path != NULL) {\n        src_path = PyBytes_AS_STRING(py_src_path);\n        assert(src_path != NULL);\n    }\n\n    if (py_dst_path != NULL) {\n        dst_path = PyBytes_AS_STRING(py_dst_path);\n        assert(dst_path != NULL);\n    }\n\n    if (self->container->add_device_node(self->container, src_path,\n                                         dst_path)) {\n        Py_XDECREF(py_src_path);\n        Py_XDECREF(py_dst_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_path);\n    Py_XDECREF(py_dst_path);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_path"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_path"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_path"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_path"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->add_device_node",
          "args": [
            "self->container",
            "src_path",
            "dst_path"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst_path != NULL"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_dst_path"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src_path != NULL"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_src_path"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"O&|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&py_src_path",
            "PyUnicode_FSConverter",
            "&py_dst_path"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_add_device_node(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_path\", \"dest_path\", NULL};\n    char *src_path = NULL;\n    char *dst_path = NULL;\n    PyObject *py_src_path = NULL;\n    PyObject *py_dst_path = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_path,\n                                      PyUnicode_FSConverter, &py_dst_path))\n        return NULL;\n\n    if (py_src_path != NULL) {\n        src_path = PyBytes_AS_STRING(py_src_path);\n        assert(src_path != NULL);\n    }\n\n    if (py_dst_path != NULL) {\n        dst_path = PyBytes_AS_STRING(py_dst_path);\n        assert(dst_path != NULL);\n    }\n\n    if (self->container->add_device_node(self->container, src_path,\n                                         dst_path)) {\n        Py_XDECREF(py_src_path);\n        Py_XDECREF(py_dst_path);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_path);\n    Py_XDECREF(py_dst_path);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_detach_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "641-664",
    "snippet": "static PyObject *\nContainer_detach_interface(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ifname\", NULL};\n    char *ifname = NULL;\n    PyObject *py_ifname = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_ifname))\n        return NULL;\n\n    if (py_ifname != NULL) {\n        ifname = PyBytes_AS_STRING(py_ifname);\n        assert(ifname != NULL);\n    }\n\n    if (self->container->detach_interface(self->container, ifname, NULL)) {\n        Py_XDECREF(py_ifname);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_ifname);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_ifname"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_ifname"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->detach_interface",
          "args": [
            "self->container",
            "ifname",
            "NULL"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ifname != NULL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_ifname"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&py_ifname"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_detach_interface(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"ifname\", NULL};\n    char *ifname = NULL;\n    PyObject *py_ifname = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_ifname))\n        return NULL;\n\n    if (py_ifname != NULL) {\n        ifname = PyBytes_AS_STRING(py_ifname);\n        assert(ifname != NULL);\n    }\n\n    if (self->container->detach_interface(self->container, ifname, NULL)) {\n        Py_XDECREF(py_ifname);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_ifname);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_attach_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "606-639",
    "snippet": "static PyObject *\nContainer_attach_interface(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_ifname\", \"dst_ifname\", NULL};\n    char *src_name = NULL;\n    char *dst_name = NULL;\n    PyObject *py_src_name = NULL;\n    PyObject *py_dst_name = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_name,\n                                      PyUnicode_FSConverter, &py_dst_name))\n        return NULL;\n\n    if (py_src_name != NULL) {\n        src_name = PyBytes_AS_STRING(py_src_name);\n        assert(src_name != NULL);\n    }\n\n    if (py_dst_name != NULL) {\n        dst_name = PyBytes_AS_STRING(py_dst_name);\n        assert(dst_name != NULL);\n    }\n\n    if (self->container->attach_interface(self->container, src_name, dst_name)) {\n        Py_XDECREF(py_src_name);\n        Py_XDECREF(py_dst_name);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_name);\n    Py_XDECREF(py_dst_name);\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_name"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_name"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_dst_name"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "py_src_name"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->attach_interface",
          "args": [
            "self->container",
            "src_name",
            "dst_name"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst_name != NULL"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_dst_name"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src_name != NULL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "py_src_name"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"O&|O&\"",
            "kwlist",
            "PyUnicode_FSConverter",
            "&py_src_name",
            "PyUnicode_FSConverter",
            "&py_dst_name"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_attach_interface(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"src_ifname\", \"dst_ifname\", NULL};\n    char *src_name = NULL;\n    char *dst_name = NULL;\n    PyObject *py_src_name = NULL;\n    PyObject *py_dst_name = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O&\", kwlist,\n                                      PyUnicode_FSConverter, &py_src_name,\n                                      PyUnicode_FSConverter, &py_dst_name))\n        return NULL;\n\n    if (py_src_name != NULL) {\n        src_name = PyBytes_AS_STRING(py_src_name);\n        assert(src_name != NULL);\n    }\n\n    if (py_dst_name != NULL) {\n        dst_name = PyBytes_AS_STRING(py_dst_name);\n        assert(dst_name != NULL);\n    }\n\n    if (self->container->attach_interface(self->container, src_name, dst_name)) {\n        Py_XDECREF(py_src_name);\n        Py_XDECREF(py_dst_name);\n        Py_RETURN_TRUE;\n    }\n\n    Py_XDECREF(py_src_name);\n    Py_XDECREF(py_dst_name);\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "599-603",
    "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "self->container->state(self->container)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->state",
          "args": [
            "self->container"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
  },
  {
    "function_name": "Container_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "589-597",
    "snippet": "static PyObject *\nContainer_running(Container *self, void *closure)\n{\n    if (self->container->is_running(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->is_running",
          "args": [
            "self->container"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_running(Container *self, void *closure)\n{\n    if (self->container->is_running(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "583-587",
    "snippet": "static PyObject *\nContainer_name(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->name);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "self->container->name"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_name(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->name);\n}"
  },
  {
    "function_name": "Container_init_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "577-581",
    "snippet": "static PyObject *\nContainer_init_pid(Container *self, void *closure)\n{\n    return PyLong_FromLong(self->container->init_pid(self->container));\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "self->container->init_pid(self->container)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->init_pid",
          "args": [
            "self->container"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_init_pid(Container *self, void *closure)\n{\n    return PyLong_FromLong(self->container->init_pid(self->container));\n}"
  },
  {
    "function_name": "Container_defined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "567-575",
    "snippet": "static PyObject *\nContainer_defined(Container *self, void *closure)\n{\n    if (self->container->is_defined(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->is_defined",
          "args": [
            "self->container"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_defined(Container *self, void *closure)\n{\n    if (self->container->is_defined(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_controllable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "557-565",
    "snippet": "static PyObject *\nContainer_controllable(Container *self, void *closure)\n{\n    if (self->container->may_control(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->container->may_control",
          "args": [
            "self->container"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_controllable(Container *self, void *closure)\n{\n    if (self->container->may_control(self->container)) {\n        Py_RETURN_TRUE;\n    }\n\n    Py_RETURN_FALSE;\n}"
  },
  {
    "function_name": "Container_config_file_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "550-555",
    "snippet": "static PyObject *\nContainer_config_file_name(Container *self, void *closure)\n{\n    return PyUnicode_FromString(\n                self->container->config_file_name(self->container));\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "self->container->config_file_name(self->container)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->container->config_file_name",
          "args": [
            "self->container"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_config_file_name(Container *self, void *closure)\n{\n    return PyUnicode_FromString(\n                self->container->config_file_name(self->container));\n}"
  },
  {
    "function_name": "Container_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "539-547",
    "snippet": "static PyObject *\nContainer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    Container *self;\n\n    self = (Container *)type->tp_alloc(type, 0);\n\n    return (PyObject *)self;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type->tp_alloc",
          "args": [
            "type",
            "0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    Container *self;\n\n    self = (Container *)type->tp_alloc(type, 0);\n\n    return (PyObject *)self;\n}"
  },
  {
    "function_name": "Container_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "508-537",
    "snippet": "static int\nContainer_init(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"name\", \"config_path\", NULL};\n    char *name = NULL;\n    PyObject *fs_config_path = NULL;\n    char *config_path = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"s|O&\", kwlist,\n                                      &name,\n                                      PyUnicode_FSConverter, &fs_config_path))\n        return -1;\n\n    if (fs_config_path != NULL) {\n        config_path = PyBytes_AS_STRING(fs_config_path);\n        assert(config_path != NULL);\n    }\n\n    self->container = lxc_container_new(name, config_path);\n    if (!self->container) {\n        Py_XDECREF(fs_config_path);\n\n        PyErr_Format(PyExc_RuntimeError, \"%s:%s:%d: error during init for container '%s'.\",\n\t\t\t__FUNCTION__, __FILE__, __LINE__, name);\n        return -1;\n    }\n\n    Py_XDECREF(fs_config_path);\n    return 0;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_config_path"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_Format",
          "args": [
            "PyExc_RuntimeError",
            "\"%s:%s:%d: error during init for container '%s'.\"",
            "__FUNCTION__",
            "__FILE__",
            "__LINE__",
            "name"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_XDECREF",
          "args": [
            "fs_config_path"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "config_path"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "config_path != NULL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AS_STRING",
          "args": [
            "fs_config_path"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|O&\"",
            "kwlist",
            "&name",
            "PyUnicode_FSConverter",
            "&fs_config_path"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int\nContainer_init(Container *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"name\", \"config_path\", NULL};\n    char *name = NULL;\n    PyObject *fs_config_path = NULL;\n    char *config_path = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"s|O&\", kwlist,\n                                      &name,\n                                      PyUnicode_FSConverter, &fs_config_path))\n        return -1;\n\n    if (fs_config_path != NULL) {\n        config_path = PyBytes_AS_STRING(fs_config_path);\n        assert(config_path != NULL);\n    }\n\n    self->container = lxc_container_new(name, config_path);\n    if (!self->container) {\n        Py_XDECREF(fs_config_path);\n\n        PyErr_Format(PyExc_RuntimeError, \"%s:%s:%d: error during init for container '%s'.\",\n\t\t\t__FUNCTION__, __FILE__, __LINE__, name);\n        return -1;\n    }\n\n    Py_XDECREF(fs_config_path);\n    return 0;\n}"
  },
  {
    "function_name": "Container_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "501-506",
    "snippet": "static void\nContainer_dealloc(Container* self)\n{\n    lxc_container_put(self->container);\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Py_TYPE",
          "args": [
            "(PyObject*)self"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_TYPE",
          "args": [
            "self"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "self->container"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void\nContainer_dealloc(Container* self)\n{\n    lxc_container_put(self->container);\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}"
  },
  {
    "function_name": "LXC_list_containers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "436-493",
    "snippet": "static PyObject *\nLXC_list_containers(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    char **names = NULL;\n    PyObject *list = NULL;\n    int list_count = 0;\n\n    int list_active = 1;\n    int list_defined = 1;\n\n    PyObject *py_list_active = NULL;\n    PyObject *py_list_defined = NULL;\n\n    char* config_path = NULL;\n\n    int i = 0;\n    PyObject *vargs = NULL;\n    static char *kwlist[] = {\"active\", \"defined\", \"config_path\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOs\", kwlist,\n                                      &py_list_active,\n                                      &py_list_defined,\n                                      &config_path, &vargs))\n        return NULL;\n\n    /* We default to listing everything */\n    if (py_list_active && py_list_active != Py_True) {\n        list_active = 0;\n    }\n\n    if (py_list_defined && py_list_defined != Py_True) {\n        list_defined = 0;\n    }\n\n    /* Call the right API function based on filters */\n    if (list_active == 1 && list_defined == 1)\n        list_count = list_all_containers(config_path, &names, NULL);\n    else if (list_active == 1)\n        list_count = list_active_containers(config_path, &names, NULL);\n    else if (list_defined == 1)\n        list_count = list_defined_containers(config_path, &names, NULL);\n\n    /* Handle failure */\n    if (list_count < 0) {\n        PyErr_SetString(PyExc_ValueError, \"failure to list containers\");\n        return NULL;\n    }\n\n    /* Generate the tuple */\n    list = PyTuple_New(list_count);\n    for (i = 0; i < list_count; i++) {\n        PyTuple_SET_ITEM(list, i, PyUnicode_FromString(names[i]));\n        free(names[i]);\n    }\n    free(names);\n\n    return list;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "names"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyTuple_SET_ITEM",
          "args": [
            "list",
            "i",
            "PyUnicode_FromString(names[i])"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "names[i]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "list_count"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"failure to list containers\""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_defined_containers",
          "args": [
            "config_path",
            "&names",
            "NULL"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "list_defined_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4234-4319",
          "snippet": "int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_active_containers",
          "args": [
            "config_path",
            "&names",
            "NULL"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "list_active_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4321-4444",
          "snippet": "int list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_all_containers",
          "args": [
            "config_path",
            "&names",
            "NULL"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "list_all_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4446-4526",
          "snippet": "int list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"|OOs\"",
            "kwlist",
            "&py_list_active",
            "&py_list_defined",
            "&config_path",
            "&vargs"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_list_containers(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    char **names = NULL;\n    PyObject *list = NULL;\n    int list_count = 0;\n\n    int list_active = 1;\n    int list_defined = 1;\n\n    PyObject *py_list_active = NULL;\n    PyObject *py_list_defined = NULL;\n\n    char* config_path = NULL;\n\n    int i = 0;\n    PyObject *vargs = NULL;\n    static char *kwlist[] = {\"active\", \"defined\", \"config_path\", NULL};\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOs\", kwlist,\n                                      &py_list_active,\n                                      &py_list_defined,\n                                      &config_path, &vargs))\n        return NULL;\n\n    /* We default to listing everything */\n    if (py_list_active && py_list_active != Py_True) {\n        list_active = 0;\n    }\n\n    if (py_list_defined && py_list_defined != Py_True) {\n        list_defined = 0;\n    }\n\n    /* Call the right API function based on filters */\n    if (list_active == 1 && list_defined == 1)\n        list_count = list_all_containers(config_path, &names, NULL);\n    else if (list_active == 1)\n        list_count = list_active_containers(config_path, &names, NULL);\n    else if (list_defined == 1)\n        list_count = list_defined_containers(config_path, &names, NULL);\n\n    /* Handle failure */\n    if (list_count < 0) {\n        PyErr_SetString(PyExc_ValueError, \"failure to list containers\");\n        return NULL;\n    }\n\n    /* Generate the tuple */\n    list = PyTuple_New(list_count);\n    for (i = 0; i < list_count; i++) {\n        PyTuple_SET_ITEM(list, i, PyUnicode_FromString(names[i]));\n        free(names[i]);\n    }\n    free(names);\n\n    return list;\n}"
  },
  {
    "function_name": "LXC_get_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "430-434",
    "snippet": "static PyObject *\nLXC_get_version(PyObject *self, PyObject *args)\n{\n    return PyUnicode_FromString(lxc_get_version());\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "lxc_get_version()"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_get_version",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_get_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2623-2626",
          "snippet": "const char *lxc_get_version(void)\n{\n\treturn LXC_VERSION;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nconst char *lxc_get_version(void)\n{\n\treturn LXC_VERSION;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_get_version(PyObject *self, PyObject *args)\n{\n    return PyUnicode_FromString(lxc_get_version());\n}"
  },
  {
    "function_name": "LXC_get_global_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "409-428",
    "snippet": "static PyObject *\nLXC_get_global_config_item(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    const char* value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    value = lxc_get_global_config_item(key);\n\n    if (!value) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    return PyUnicode_FromString(value);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyUnicode_FromString",
          "args": [
            "value"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Invalid configuration key\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_get_global_config_item",
          "args": [
            "key"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_get_global_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2618-2621",
          "snippet": "const char *lxc_get_global_config_item(const char *key)\n{\n\treturn lxc_global_config_value(key);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nconst char *lxc_get_global_config_item(const char *key)\n{\n\treturn lxc_global_config_value(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "args",
            "kwds",
            "\"s|\"",
            "kwlist",
            "&key"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_get_global_config_item(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"key\", NULL};\n    char* key = NULL;\n    const char* value = NULL;\n\n    if (! PyArg_ParseTupleAndKeywords(args, kwds, \"s|\", kwlist,\n                                      &key))\n        return NULL;\n\n    value = lxc_get_global_config_item(key);\n\n    if (!value) {\n        PyErr_SetString(PyExc_KeyError, \"Invalid configuration key\");\n        return NULL;\n    }\n\n    return PyUnicode_FromString(value);\n}"
  },
  {
    "function_name": "LXC_attach_run_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "399-407",
    "snippet": "static PyObject *\nLXC_attach_run_shell(PyObject *self, PyObject *arg)\n{\n    int rv;\n\n    rv = lxc_attach_run_shell(NULL);\n\n    return PyLong_FromLong(rv);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "rv"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_run_shell",
          "args": [
            "NULL"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_run_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "1350-1382",
          "snippet": "int lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_attach_run_shell(PyObject *self, PyObject *arg)\n{\n    int rv;\n\n    rv = lxc_attach_run_shell(NULL);\n\n    return PyLong_FromLong(rv);\n}"
  },
  {
    "function_name": "LXC_attach_run_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "367-397",
    "snippet": "static PyObject *\nLXC_attach_run_command(PyObject *self, PyObject *arg)\n{\n    PyObject *args_obj = NULL;\n    int i, rv;\n    lxc_attach_command_t cmd = {\n        NULL,         /* program */\n        NULL          /* argv[] */\n    };\n\n    if (!PyArg_ParseTuple(arg, \"sO\", (const char**)&cmd.program, &args_obj))\n        return NULL;\n    if (args_obj && PyList_Check(args_obj)) {\n        cmd.argv = convert_tuple_to_char_pointer_array(args_obj);\n    } else {\n        PyErr_Format(PyExc_TypeError, \"Second part of tuple passed to \"\n                                      \"attach_run_command must be a list.\");\n        return NULL;\n    }\n\n    if (!cmd.argv)\n        return NULL;\n\n    rv = lxc_attach_run_command(&cmd);\n\n    for (i = 0; cmd.argv[i]; i++)\n        free(cmd.argv[i]);\n    free(cmd.argv);\n\n    return PyLong_FromLong(rv);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "rv"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd.argv"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_attach_run_command",
          "args": [
            "&cmd"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "1341-1348",
          "snippet": "int lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyErr_Format",
          "args": [
            "PyExc_TypeError",
            "\"Second part of tuple passed to \"\n                                      \"attach_run_command must be a list.\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_tuple_to_char_pointer_array",
          "args": [
            "args_obj"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tuple_to_char_pointer_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "113-188",
          "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyList_Check",
          "args": [
            "args_obj"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTuple",
          "args": [
            "arg",
            "\"sO\"",
            "(const char**)&cmd.program",
            "&args_obj"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_attach_run_command(PyObject *self, PyObject *arg)\n{\n    PyObject *args_obj = NULL;\n    int i, rv;\n    lxc_attach_command_t cmd = {\n        NULL,         /* program */\n        NULL          /* argv[] */\n    };\n\n    if (!PyArg_ParseTuple(arg, \"sO\", (const char**)&cmd.program, &args_obj))\n        return NULL;\n    if (args_obj && PyList_Check(args_obj)) {\n        cmd.argv = convert_tuple_to_char_pointer_array(args_obj);\n    } else {\n        PyErr_Format(PyExc_TypeError, \"Second part of tuple passed to \"\n                                      \"attach_run_command must be a list.\");\n        return NULL;\n    }\n\n    if (!cmd.argv)\n        return NULL;\n\n    rv = lxc_attach_run_command(&cmd);\n\n    for (i = 0; cmd.argv[i]; i++)\n        free(cmd.argv[i]);\n    free(cmd.argv);\n\n    return PyLong_FromLong(rv);\n}"
  },
  {
    "function_name": "LXC_arch_to_personality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "338-365",
    "snippet": "static PyObject *\nLXC_arch_to_personality(PyObject *self, PyObject *arg)\n{\n    long rv = -1;\n    PyObject *pystr = NULL;\n    char *str;\n\n    if (!PyUnicode_Check(arg)) {\n        PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n        return NULL;\n    }\n\n    pystr = PyUnicode_AsUTF8String(arg);\n    if (!pystr)\n        return NULL;\n\n    str = PyBytes_AsString(pystr);\n    if (!str)\n        goto out;\n\n    rv = lxc_config_parse_arch(str);\n    if (rv == -1)\n        PyErr_SetString(PyExc_KeyError, \"Failed to lookup architecture.\");\n\nout:\n    Py_DECREF(pystr);\n    return rv == -1 ? NULL : PyLong_FromLong(rv);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_FromLong",
          "args": [
            "rv"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "pystr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_KeyError",
            "\"Failed to lookup architecture.\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_config_parse_arch",
          "args": [
            "str"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_config_parse_arch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "84-111",
          "snippet": "signed long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [
            "#define PER_LINUX32 0x0008",
            "#define PER_LINUX 0x0000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\n#define PER_LINUX32 0x0008\n#define PER_LINUX 0x0000\n\nsigned long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyBytes_AsString",
          "args": [
            "pystr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_AsUTF8String",
          "args": [
            "arg"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Expected a string\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_Check",
          "args": [
            "arg"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nLXC_arch_to_personality(PyObject *self, PyObject *arg)\n{\n    long rv = -1;\n    PyObject *pystr = NULL;\n    char *str;\n\n    if (!PyUnicode_Check(arg)) {\n        PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n        return NULL;\n    }\n\n    pystr = PyUnicode_AsUTF8String(arg);\n    if (!pystr)\n        return NULL;\n\n    str = PyBytes_AsString(pystr);\n    if (!str)\n        goto out;\n\n    rv = lxc_config_parse_arch(str);\n    if (rv == -1)\n        PyErr_SetString(PyExc_KeyError, \"Failed to lookup architecture.\");\n\nout:\n    Py_DECREF(pystr);\n    return rv == -1 ? NULL : PyLong_FromLong(rv);\n}"
  },
  {
    "function_name": "lxc_attach_free_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "318-335",
    "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_attach_free_options(lxc_attach_options_t *options);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
  },
  {
    "function_name": "lxc_attach_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "220-316",
    "snippet": "static lxc_attach_options_t *lxc_attach_parse_options(PyObject *kwds)\n{\n    static char *kwlist[] = {\"attach_flags\", \"namespaces\", \"personality\",\n                             \"initial_cwd\", \"uid\", \"gid\", \"env_policy\",\n                             \"extra_env_vars\", \"extra_keep_env\", \"stdin\",\n                             \"stdout\", \"stderr\", NULL};\n    long temp_uid, temp_gid;\n    int temp_env_policy;\n    PyObject *extra_env_vars_obj = NULL;\n    PyObject *extra_keep_env_obj = NULL;\n    PyObject *stdin_obj = NULL;\n    PyObject *stdout_obj = NULL;\n    PyObject *stderr_obj = NULL;\n    PyObject *initial_cwd_obj = NULL;\n    PyObject *dummy = NULL;\n    bool parse_result;\n\n    lxc_attach_options_t default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n    lxc_attach_options_t *options = malloc(sizeof(*options));\n\n    if (!options) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n    memcpy(options, &default_options, sizeof(*options));\n\n    /* we need some dummy variables because we can't be sure\n     * the data types match completely */\n    temp_uid = -1;\n    temp_gid = -1;\n    temp_env_policy = options->env_policy;\n\n    /* we need a dummy tuple */\n    dummy = PyTuple_New(0);\n\n    parse_result = PyArg_ParseTupleAndKeywords(dummy, kwds, \"|iilO&lliOOOOO\",\n                                               kwlist, &options->attach_flags,\n                                               &options->namespaces,\n                                               &options->personality,\n                                               PyUnicode_FSConverter,\n                                               &initial_cwd_obj, &temp_uid,\n                                               &temp_gid, &temp_env_policy,\n                                               &extra_env_vars_obj,\n                                               &extra_keep_env_obj,\n                                               &stdin_obj, &stdout_obj,\n                                               &stderr_obj);\n\n    /* immediately get rid of the dummy tuple */\n    Py_DECREF(dummy);\n\n    if (!parse_result) {\n        lxc_attach_free_options(options);\n        return NULL;\n    }\n\n    /* duplicate the string, so we don't depend on some random Python object */\n    if (initial_cwd_obj != NULL) {\n        options->initial_cwd = strndup(PyBytes_AsString(initial_cwd_obj),\n                                       PyBytes_Size(initial_cwd_obj));\n        Py_DECREF(initial_cwd_obj);\n    }\n\n    /* do the type conversion from the types that match the parse string */\n    if (temp_uid != -1) options->uid = (uid_t)temp_uid;\n    if (temp_gid != -1) options->gid = (gid_t)temp_gid;\n    options->env_policy = (lxc_attach_env_policy_t)temp_env_policy;\n\n    if (extra_env_vars_obj)\n        options->extra_env_vars =\n            convert_tuple_to_char_pointer_array(extra_env_vars_obj);\n    if (extra_keep_env_obj)\n        options->extra_keep_env =\n            convert_tuple_to_char_pointer_array(extra_keep_env_obj);\n    if (stdin_obj) {\n        options->stdin_fd = PyObject_AsFileDescriptor(stdin_obj);\n        if (options->stdin_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stdout_obj) {\n        options->stdout_fd = PyObject_AsFileDescriptor(stdout_obj);\n        if (options->stdout_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stderr_obj) {\n        options->stderr_fd = PyObject_AsFileDescriptor(stderr_obj);\n        if (options->stderr_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n\n    return options;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_attach_free_options(lxc_attach_options_t *options);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_attach_free_options",
          "args": [
            "options"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyObject_AsFileDescriptor",
          "args": [
            "stderr_obj"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyObject_AsFileDescriptor",
          "args": [
            "stdout_obj"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyObject_AsFileDescriptor",
          "args": [
            "stdin_obj"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_tuple_to_char_pointer_array",
          "args": [
            "extra_keep_env_obj"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tuple_to_char_pointer_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "113-188",
          "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "initial_cwd_obj"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup",
          "args": [
            "PyBytes_AsString(initial_cwd_obj)",
            "PyBytes_Size(initial_cwd_obj)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_Size",
          "args": [
            "initial_cwd_obj"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AsString",
          "args": [
            "initial_cwd_obj"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "dummy"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyArg_ParseTupleAndKeywords",
          "args": [
            "dummy",
            "kwds",
            "\"|iilO&lliOOOOO\"",
            "kwlist",
            "&options->attach_flags",
            "&options->namespaces",
            "&options->personality",
            "PyUnicode_FSConverter",
            "&initial_cwd_obj",
            "&temp_uid",
            "&temp_gid",
            "&temp_env_policy",
            "&extra_env_vars_obj",
            "&extra_keep_env_obj",
            "&stdin_obj",
            "&stdout_obj",
            "&stderr_obj"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_New",
          "args": [
            "0"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "options",
            "&default_options",
            "sizeof(*options)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetNone",
          "args": [
            "PyExc_MemoryError"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*options)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nstatic lxc_attach_options_t *lxc_attach_parse_options(PyObject *kwds)\n{\n    static char *kwlist[] = {\"attach_flags\", \"namespaces\", \"personality\",\n                             \"initial_cwd\", \"uid\", \"gid\", \"env_policy\",\n                             \"extra_env_vars\", \"extra_keep_env\", \"stdin\",\n                             \"stdout\", \"stderr\", NULL};\n    long temp_uid, temp_gid;\n    int temp_env_policy;\n    PyObject *extra_env_vars_obj = NULL;\n    PyObject *extra_keep_env_obj = NULL;\n    PyObject *stdin_obj = NULL;\n    PyObject *stdout_obj = NULL;\n    PyObject *stderr_obj = NULL;\n    PyObject *initial_cwd_obj = NULL;\n    PyObject *dummy = NULL;\n    bool parse_result;\n\n    lxc_attach_options_t default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n    lxc_attach_options_t *options = malloc(sizeof(*options));\n\n    if (!options) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n    memcpy(options, &default_options, sizeof(*options));\n\n    /* we need some dummy variables because we can't be sure\n     * the data types match completely */\n    temp_uid = -1;\n    temp_gid = -1;\n    temp_env_policy = options->env_policy;\n\n    /* we need a dummy tuple */\n    dummy = PyTuple_New(0);\n\n    parse_result = PyArg_ParseTupleAndKeywords(dummy, kwds, \"|iilO&lliOOOOO\",\n                                               kwlist, &options->attach_flags,\n                                               &options->namespaces,\n                                               &options->personality,\n                                               PyUnicode_FSConverter,\n                                               &initial_cwd_obj, &temp_uid,\n                                               &temp_gid, &temp_env_policy,\n                                               &extra_env_vars_obj,\n                                               &extra_keep_env_obj,\n                                               &stdin_obj, &stdout_obj,\n                                               &stderr_obj);\n\n    /* immediately get rid of the dummy tuple */\n    Py_DECREF(dummy);\n\n    if (!parse_result) {\n        lxc_attach_free_options(options);\n        return NULL;\n    }\n\n    /* duplicate the string, so we don't depend on some random Python object */\n    if (initial_cwd_obj != NULL) {\n        options->initial_cwd = strndup(PyBytes_AsString(initial_cwd_obj),\n                                       PyBytes_Size(initial_cwd_obj));\n        Py_DECREF(initial_cwd_obj);\n    }\n\n    /* do the type conversion from the types that match the parse string */\n    if (temp_uid != -1) options->uid = (uid_t)temp_uid;\n    if (temp_gid != -1) options->gid = (gid_t)temp_gid;\n    options->env_policy = (lxc_attach_env_policy_t)temp_env_policy;\n\n    if (extra_env_vars_obj)\n        options->extra_env_vars =\n            convert_tuple_to_char_pointer_array(extra_env_vars_obj);\n    if (extra_keep_env_obj)\n        options->extra_keep_env =\n            convert_tuple_to_char_pointer_array(extra_keep_env_obj);\n    if (stdin_obj) {\n        options->stdin_fd = PyObject_AsFileDescriptor(stdin_obj);\n        if (options->stdin_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stdout_obj) {\n        options->stdout_fd = PyObject_AsFileDescriptor(stdout_obj);\n        if (options->stdout_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n    if (stderr_obj) {\n        options->stderr_fd = PyObject_AsFileDescriptor(stderr_obj);\n        if (options->stderr_fd < 0) {\n            lxc_attach_free_options(options);\n            return NULL;\n        }\n    }\n\n    return options;\n}"
  },
  {
    "function_name": "lxc_attach_python_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "195-216",
    "snippet": "static int lxc_attach_python_exec(void* _payload)\n{\n    /* This function is the first one to be called after attaching to a\n     * container. As lxc_attach() calls fork() PyOS_AfterFork should be called\n     * in the new process if the Python interpreter will continue to be used.\n     */\n    PyOS_AfterFork();\n\n    struct lxc_attach_python_payload *payload =\n        (struct lxc_attach_python_payload *)_payload;\n    PyObject *result = PyObject_CallFunctionObjArgs(payload->fn,\n                                                    payload->arg, NULL);\n\n    if (!result) {\n        PyErr_Print();\n        return -1;\n    }\n    if (PyLong_Check(result))\n        return (int)PyLong_AsLong(result);\n    else\n        return -1;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PyLong_AsLong",
          "args": [
            "result"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyLong_Check",
          "args": [
            "result"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_Print",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyObject_CallFunctionObjArgs",
          "args": [
            "payload->fn",
            "payload->arg",
            "NULL"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyOS_AfterFork",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_attach_python_exec(void* _payload)\n{\n    /* This function is the first one to be called after attaching to a\n     * container. As lxc_attach() calls fork() PyOS_AfterFork should be called\n     * in the new process if the Python interpreter will continue to be used.\n     */\n    PyOS_AfterFork();\n\n    struct lxc_attach_python_payload *payload =\n        (struct lxc_attach_python_payload *)_payload;\n    PyObject *result = PyObject_CallFunctionObjArgs(payload->fn,\n                                                    payload->arg, NULL);\n\n    if (!result) {\n        PyErr_Print();\n        return -1;\n    }\n    if (PyLong_Check(result))\n        return (int)PyLong_AsLong(result);\n    else\n        return -1;\n}"
  },
  {
    "function_name": "convert_tuple_to_char_pointer_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "113-188",
    "snippet": "char**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_free_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "318-335",
          "snippet": "void lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_attach_free_options(lxc_attach_options_t *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic void lxc_attach_free_options(lxc_attach_options_t *options);\n\nvoid lxc_attach_free_options(lxc_attach_options_t *options)\n{\n    int i;\n    if (!options)\n        return;\n    free(options->initial_cwd);\n    if (options->extra_env_vars) {\n        for (i = 0; options->extra_env_vars[i]; i++)\n            free(options->extra_env_vars[i]);\n        free(options->extra_env_vars);\n    }\n    if (options->extra_keep_env) {\n        for (i = 0; options->extra_keep_env[i]; i++)\n            free(options->extra_keep_env[i]);\n        free(options->extra_keep_env);\n    }\n    free(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PyErr_SetNone",
          "args": [
            "PyExc_MemoryError"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "pystr"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Py_DECREF",
          "args": [
            "pystr"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyBytes_AsString",
          "args": [
            "pystr"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_AsUTF8String",
          "args": [
            "pyobj"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_ValueError",
            "\"Expected a string\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyUnicode_Check",
          "args": [
            "pyobj"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pyobj != NULL"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PySequence_Fast_GET_ITEM",
          "args": [
            "argv",
            "i"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetNone",
          "args": [
            "PyExc_MemoryError"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "argc + 1",
            "sizeof(char*)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PySequence_Fast_GET_SIZE",
          "args": [
            "argv"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyErr_SetString",
          "args": [
            "PyExc_TypeError",
            "\"Expected list or tuple.\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyTuple_Check",
          "args": [
            "argv"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PyList_Check",
          "args": [
            "argv"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nchar**\nconvert_tuple_to_char_pointer_array(PyObject *argv) {\n    int argc;\n    int i, j;\n    char **result;\n\n    /* not a list or tuple */\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected list or tuple.\");\n        return NULL;\n    }\n\n    argc = PySequence_Fast_GET_SIZE(argv);\n\n    result = (char**) calloc(argc + 1, sizeof(char*));\n\n    if (result == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    for (i = 0; i < argc; i++) {\n        char *str = NULL;\n        PyObject *pystr = NULL;\n        PyObject *pyobj = PySequence_Fast_GET_ITEM(argv, i);\n        assert(pyobj != NULL);\n\n        if (!PyUnicode_Check(pyobj)) {\n            PyErr_SetString(PyExc_ValueError, \"Expected a string\");\n            goto error;\n        }\n\n        pystr = PyUnicode_AsUTF8String(pyobj);\n        if (!pystr) {\n            /* Maybe it wasn't UTF-8 encoded.  An exception is already set. */\n            goto error;\n        }\n\n        str = PyBytes_AsString(pystr);\n        if (!str) {\n            /* Maybe pystr wasn't a valid object. An exception is already set.\n             */\n            Py_DECREF(pystr);\n            goto error;\n        }\n\n        /* We must make a copy of str, because it points into internal memory\n         * which we do not own.  Assume it's NULL terminated, otherwise we'd\n         * have to use PyUnicode_AsUTF8AndSize() and be explicit about copying\n         * the memory.\n         */\n        result[i] = strdup(str);\n\n        /* Do not decref pyobj since we stole a reference by using\n         * PyTuple_GET_ITEM().\n         */\n        Py_DECREF(pystr);\n        if (result[i] == NULL) {\n            PyErr_SetNone(PyExc_MemoryError);\n            goto error;\n        }\n    }\n\n    result[argc] = NULL;\n    return result;\n\nerror:\n    /* We can only iterate up to but not including i because malloc() does not\n     * initialize its memory.  Thus if we got here, i points to the index\n     * after the last strdup'd entry in result.\n     */\n    for (j = 0; j < i; j++)\n        free(result[j]);\n    free(result);\n    return NULL;\n}"
  },
  {
    "function_name": "lxc_config_parse_arch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "84-111",
    "snippet": "signed long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [
      "#define PER_LINUX32 0x0008",
      "#define PER_LINUX 0x0000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pername[i].name",
            "arch"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\n#define PER_LINUX32 0x0008\n#define PER_LINUX 0x0000\n\nsigned long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "lxc_wait_for_pid_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
    "lines": "67-81",
    "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
    "includes": [
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <stdio.h>",
      "#include <lxc/lxccontainer.h>",
      "#include \"structmember.h\"",
      "#include <Python.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
  }
]