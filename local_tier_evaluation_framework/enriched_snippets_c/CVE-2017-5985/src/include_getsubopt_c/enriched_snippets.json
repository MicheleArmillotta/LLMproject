[
  {
    "function_name": "getsubopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
    "lines": "48-89",
    "snippet": "int\ngetsubopt (char **optionp, char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n    && tokens[cnt][vstart - *optionp] == '\\0')\n      {\n    /* We found the current option in TOKENS.  */\n    *valuep = vstart != endp ? vstart + 1 : NULL;\n\n    if (*endp != '\\0')\n      *endp++ = '\\0';\n    *optionp = endp;\n\n    return cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*optionp",
            "tokens[cnt]",
            "vstart - *optionp"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "*optionp",
            "'='",
            "endp - *optionp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchrnul",
          "args": [
            "*optionp",
            "','"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nint\ngetsubopt (char **optionp, char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n    && tokens[cnt][vstart - *optionp] == '\\0')\n      {\n    /* We found the current option in TOKENS.  */\n    *valuep = vstart != endp ? vstart + 1 : NULL;\n\n    if (*endp != '\\0')\n      *endp++ = '\\0';\n    *optionp = endp;\n\n    return cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}"
  },
  {
    "function_name": "strchrnul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
    "lines": "28-40",
    "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "c"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
  }
]