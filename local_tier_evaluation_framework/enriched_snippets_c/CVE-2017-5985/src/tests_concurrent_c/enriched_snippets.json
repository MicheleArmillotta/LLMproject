[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
    "lines": "146-255",
    "snippet": "int main(int argc, char *argv[]) {\n    int i, j, iter, opt;\n    pthread_attr_t attr;\n    pthread_t *threads;\n    struct thread_args *args;\n\n    char *modes_default[] = {\"create\", \"start\", \"stop\", \"destroy\", NULL};\n    char **modes = modes_default;\n\n    pthread_attr_init(&attr);\n\n    while ((opt = getopt_long(argc, argv, \"j:i:t:d:m:qD\", options, NULL)) != -1) {\n        switch(opt) {\n        case 'j':\n            nthreads = atoi(optarg);\n            break;\n        case 'i':\n            iterations = atoi(optarg);\n            break;\n        case 't':\n            template = optarg;\n            break;\n        case 'd':\n            delay = atoi(optarg);\n            break;\n        case 'q':\n            quiet = 1;\n            break;\n        case 'D':\n            debug = 1;\n            break;\n        case 'm': {\n            char *mode_tok, *tok, *saveptr = NULL;\n\n            modes = NULL;\n            for (i = 0, mode_tok = optarg;\n                 (tok = strtok_r(mode_tok, \",\", &saveptr));\n                i++, mode_tok = NULL) {\n                modes = realloc(modes, sizeof(*modes) * (i+2));\n                if (!modes) {\n                    perror(\"realloc\");\n                    exit(EXIT_FAILURE);\n                }\n                modes[i] = tok;\n            }\n            modes[i] = NULL;\n            break;\n        }\n        default: /* '?' */\n            usage();\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    threads = malloc(sizeof(*threads) * nthreads);\n    args = malloc(sizeof(*args) * nthreads);\n    if (threads == NULL || args == NULL) {\n        fprintf(stderr, \"Unable malloc enough memory for %d threads\\n\", nthreads);\n        exit(EXIT_FAILURE);\n    }\n\n    for (iter = 1; iter <= iterations; iter++) {\n        int fd;\n        fd = open(\"/\", O_RDONLY);\n        if (fd < 0) {\n            fprintf(stderr, \"Failed to open /\\n\");\n            continue;\n        }\n\n        if (!quiet)\n            printf(\"\\nIteration %d/%d maxfd:%d\\n\", iter, iterations, fd);\n        close(fd);\n\n        for (i = 0; modes[i];i++) {\n            if (!quiet)\n                printf(\"Executing (%s) for %d containers...\\n\", modes[i], nthreads);\n            for (j = 0; j < nthreads; j++) {\n                args[j].thread_id = j;\n                args[j].mode = modes[i];\n\n                if (nthreads > 1) {\n                    if (pthread_create(&threads[j], &attr, concurrent, (void *) &args[j]) != 0) {\n                        perror(\"pthread_create() error\");\n                        exit(EXIT_FAILURE);\n                    }\n                } else {\n                    do_function(&args[j]);\n                }\n            }\n\n            for (j = 0; j < nthreads; j++) {\n                if (nthreads > 1) {\n                    if (pthread_join(threads[j], NULL) != 0) {\n                        perror(\"pthread_join() error\");\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                if (args[j].return_code) {\n                    fprintf(stderr, \"thread returned error %d\\n\", args[j].return_code);\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    free(args);\n    free(threads);\n    pthread_attr_destroy(&attr);\n    exit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include <lxc/lxccontainer.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nthreads = 5;",
      "static int iterations = 1;",
      "static int debug = 0;",
      "static int quiet = 0;",
      "static int delay = 0;",
      "static const char *template = \"busybox\";",
      "static const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "threads"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"thread returned error %d\\n\"",
            "args[j].return_code"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"pthread_join() error\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_join",
          "args": [
            "threads[j]",
            "NULL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_function",
          "args": [
            "&args[j]"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "do_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
          "lines": "72-136",
          "snippet": "static void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}",
          "includes": [
            "#include <lxc/lxccontainer.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <limits.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug = 0;",
            "static int delay = 0;",
            "static const char *template = \"busybox\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int debug = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\n\nstatic void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"pthread_create() error\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&threads[j]",
            "&attr",
            "concurrent",
            "(void *) &args[j]"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Executing (%s) for %d containers...\\n\"",
            "modes[i]",
            "nthreads"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nIteration %d/%d maxfd:%d\\n\"",
            "iter",
            "iterations",
            "fd"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open /\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/\"",
            "O_RDONLY"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "do_test_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
          "lines": "63-102",
          "snippet": "static int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}",
          "includes": [
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unable malloc enough memory for %d threads\\n\"",
            "nthreads"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*args) * nthreads"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*threads) * nthreads"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
          "lines": "49-64",
          "snippet": "static void usage(void) {\n    fprintf(stderr, \"Usage: lxc-test-concurrent [OPTION]...\\n\\n\"\n        \"Common options :\\n\"\n        \"  -j, --threads=N              Threads to run concurrently\\n\"\n        \"                               (default: 5, use 1 for no threading)\\n\"\n        \"  -i, --iterations=N           Number times to run the test (default: 1)\\n\"\n        \"  -t, --template=t             Template to use (default: busybox)\\n\"\n        \"  -d, --delay=N                Delay in seconds between start and stop\\n\"\n        \"  -m, --modes=<mode,mode,...>  Modes to run (create, start, stop, destroy)\\n\"\n        \"  -q, --quiet                  Don't produce any output\\n\"\n        \"  -D, --debug                  Create a debug log\\n\"\n        \"  -?, --help                   Give this help list\\n\"\n        \"\\n\"\n        \"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n        \"for any corresponding short options.\\n\\n\");\n}",
          "includes": [
            "#include <lxc/lxccontainer.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <limits.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int iterations = 1;",
            "static int debug = 0;",
            "static int quiet = 0;",
            "static int delay = 0;",
            "static const char *template = \"busybox\";",
            "static const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int iterations = 1;\nstatic int debug = 0;\nstatic int quiet = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\nstatic const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};\n\nstatic void usage(void) {\n    fprintf(stderr, \"Usage: lxc-test-concurrent [OPTION]...\\n\\n\"\n        \"Common options :\\n\"\n        \"  -j, --threads=N              Threads to run concurrently\\n\"\n        \"                               (default: 5, use 1 for no threading)\\n\"\n        \"  -i, --iterations=N           Number times to run the test (default: 1)\\n\"\n        \"  -t, --template=t             Template to use (default: busybox)\\n\"\n        \"  -d, --delay=N                Delay in seconds between start and stop\\n\"\n        \"  -m, --modes=<mode,mode,...>  Modes to run (create, start, stop, destroy)\\n\"\n        \"  -q, --quiet                  Don't produce any output\\n\"\n        \"  -D, --debug                  Create a debug log\\n\"\n        \"  -?, --help                   Give this help list\\n\"\n        \"\\n\"\n        \"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n        \"for any corresponding short options.\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"realloc\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "modes",
            "sizeof(*modes) * (i+2)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "mode_tok",
            "\",\"",
            "&saveptr"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "optarg"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "optarg"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "optarg"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"j:i:t:d:m:qD\"",
            "options",
            "NULL"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_attr_init",
          "args": [
            "&attr"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int nthreads = 5;\nstatic int iterations = 1;\nstatic int debug = 0;\nstatic int quiet = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\nstatic const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};\n\nint main(int argc, char *argv[]) {\n    int i, j, iter, opt;\n    pthread_attr_t attr;\n    pthread_t *threads;\n    struct thread_args *args;\n\n    char *modes_default[] = {\"create\", \"start\", \"stop\", \"destroy\", NULL};\n    char **modes = modes_default;\n\n    pthread_attr_init(&attr);\n\n    while ((opt = getopt_long(argc, argv, \"j:i:t:d:m:qD\", options, NULL)) != -1) {\n        switch(opt) {\n        case 'j':\n            nthreads = atoi(optarg);\n            break;\n        case 'i':\n            iterations = atoi(optarg);\n            break;\n        case 't':\n            template = optarg;\n            break;\n        case 'd':\n            delay = atoi(optarg);\n            break;\n        case 'q':\n            quiet = 1;\n            break;\n        case 'D':\n            debug = 1;\n            break;\n        case 'm': {\n            char *mode_tok, *tok, *saveptr = NULL;\n\n            modes = NULL;\n            for (i = 0, mode_tok = optarg;\n                 (tok = strtok_r(mode_tok, \",\", &saveptr));\n                i++, mode_tok = NULL) {\n                modes = realloc(modes, sizeof(*modes) * (i+2));\n                if (!modes) {\n                    perror(\"realloc\");\n                    exit(EXIT_FAILURE);\n                }\n                modes[i] = tok;\n            }\n            modes[i] = NULL;\n            break;\n        }\n        default: /* '?' */\n            usage();\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    threads = malloc(sizeof(*threads) * nthreads);\n    args = malloc(sizeof(*args) * nthreads);\n    if (threads == NULL || args == NULL) {\n        fprintf(stderr, \"Unable malloc enough memory for %d threads\\n\", nthreads);\n        exit(EXIT_FAILURE);\n    }\n\n    for (iter = 1; iter <= iterations; iter++) {\n        int fd;\n        fd = open(\"/\", O_RDONLY);\n        if (fd < 0) {\n            fprintf(stderr, \"Failed to open /\\n\");\n            continue;\n        }\n\n        if (!quiet)\n            printf(\"\\nIteration %d/%d maxfd:%d\\n\", iter, iterations, fd);\n        close(fd);\n\n        for (i = 0; modes[i];i++) {\n            if (!quiet)\n                printf(\"Executing (%s) for %d containers...\\n\", modes[i], nthreads);\n            for (j = 0; j < nthreads; j++) {\n                args[j].thread_id = j;\n                args[j].mode = modes[i];\n\n                if (nthreads > 1) {\n                    if (pthread_create(&threads[j], &attr, concurrent, (void *) &args[j]) != 0) {\n                        perror(\"pthread_create() error\");\n                        exit(EXIT_FAILURE);\n                    }\n                } else {\n                    do_function(&args[j]);\n                }\n            }\n\n            for (j = 0; j < nthreads; j++) {\n                if (nthreads > 1) {\n                    if (pthread_join(threads[j], NULL) != 0) {\n                        perror(\"pthread_join() error\");\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                if (args[j].return_code) {\n                    fprintf(stderr, \"thread returned error %d\\n\", args[j].return_code);\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    free(args);\n    free(threads);\n    pthread_attr_destroy(&attr);\n    exit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "concurrent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
    "lines": "138-144",
    "snippet": "static void *concurrent(void *arguments)\n{\n    do_function(arguments);\n    pthread_exit(NULL);\n\n    return NULL;\n}",
    "includes": [
      "#include <lxc/lxccontainer.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <limits.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_exit",
          "args": [
            "NULL"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_function",
          "args": [
            "arguments"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "do_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
          "lines": "72-136",
          "snippet": "static void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}",
          "includes": [
            "#include <lxc/lxccontainer.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <limits.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug = 0;",
            "static int delay = 0;",
            "static const char *template = \"busybox\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int debug = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\n\nstatic void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic void *concurrent(void *arguments)\n{\n    do_function(arguments);\n    pthread_exit(NULL);\n\n    return NULL;\n}"
  },
  {
    "function_name": "do_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
    "lines": "72-136",
    "snippet": "static void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}",
    "includes": [
      "#include <lxc/lxccontainer.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int debug = 0;",
      "static int delay = 0;",
      "static const char *template = \"busybox\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_log_close",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "449-460",
          "snippet": "extern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "static char *log_fname = NULL;",
            "static char *log_vmname = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\nstatic char *log_vmname = NULL;\n\nextern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Destroying the container (%s) failed...\\n\"",
            "name"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->destroy",
          "args": [
            "c"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->mode",
            "\"destroy\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Waiting the container (%s) to stop failed...\\n\"",
            "name"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->wait",
          "args": [
            "c",
            "\"STOPPED\"",
            "15"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Stopping the container (%s) failed...\\n\"",
            "name"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->mode",
            "\"stop\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "delay"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Waiting the container (%s) to start failed...\\n\"",
            "name"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->wait",
          "args": [
            "c",
            "\"RUNNING\"",
            "15"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Starting the container (%s) failed...\\n\"",
            "name"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->start",
          "args": [
            "c",
            "false",
            "NULL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->want_daemonize",
          "args": [
            "c",
            "true"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->mode",
            "\"start\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Creating the container (%s) failed...\\n\"",
            "name"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->create",
          "args": [
            "c",
            "template",
            "NULL",
            "NULL",
            "1",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->mode",
            "\"create\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.logfile\"",
            "name"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.loglevel\"",
            "\"DEBUG\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unable to instantiate container (%s)\\n\"",
            "name"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "NULL"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"lxc-test-concurrent-%d\"",
            "args->thread_id"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int debug = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\n\nstatic void do_function(void *arguments)\n{\n    char name[NAME_MAX+1];\n    struct thread_args *args = arguments;\n    struct lxc_container *c;\n\n    sprintf(name, \"lxc-test-concurrent-%d\", args->thread_id);\n\n    args->return_code = 1;\n    c = lxc_container_new(name, NULL);\n    if (!c) {\n        fprintf(stderr, \"Unable to instantiate container (%s)\\n\", name);\n        return;\n    }\n\n    if (debug) {\n        c->set_config_item(c, \"lxc.loglevel\", \"DEBUG\");\n        c->set_config_item(c, \"lxc.logfile\", name);\n    }\n\n    if (strcmp(args->mode, \"create\") == 0) {\n        if (!c->is_defined(c)) {\n            if (!c->create(c, template, NULL, NULL, 1, NULL)) {\n                fprintf(stderr, \"Creating the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"start\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            c->want_daemonize(c, true);\n            if (!c->start(c, false, NULL)) {\n                fprintf(stderr, \"Starting the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"RUNNING\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to start failed...\\n\", name);\n                goto out;\n            }\n            sleep(delay);\n        }\n    } else if(strcmp(args->mode, \"stop\") == 0) {\n        if (c->is_defined(c) && c->is_running(c)) {\n            if (!c->stop(c)) {\n                fprintf(stderr, \"Stopping the container (%s) failed...\\n\", name);\n                goto out;\n            }\n            if (!c->wait(c, \"STOPPED\", 15)) {\n                fprintf(stderr, \"Waiting the container (%s) to stop failed...\\n\", name);\n                goto out;\n            }\n        }\n    } else if(strcmp(args->mode, \"destroy\") == 0) {\n        if (c->is_defined(c) && !c->is_running(c)) {\n            if (!c->destroy(c)) {\n                fprintf(stderr, \"Destroying the container (%s) failed...\\n\", name);\n                goto out;\n            }\n        }\n    }\n    args->return_code = 0;\nout:\n    lxc_container_put(c);\n    if (debug)\n        lxc_log_close();\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/concurrent.c",
    "lines": "49-64",
    "snippet": "static void usage(void) {\n    fprintf(stderr, \"Usage: lxc-test-concurrent [OPTION]...\\n\\n\"\n        \"Common options :\\n\"\n        \"  -j, --threads=N              Threads to run concurrently\\n\"\n        \"                               (default: 5, use 1 for no threading)\\n\"\n        \"  -i, --iterations=N           Number times to run the test (default: 1)\\n\"\n        \"  -t, --template=t             Template to use (default: busybox)\\n\"\n        \"  -d, --delay=N                Delay in seconds between start and stop\\n\"\n        \"  -m, --modes=<mode,mode,...>  Modes to run (create, start, stop, destroy)\\n\"\n        \"  -q, --quiet                  Don't produce any output\\n\"\n        \"  -D, --debug                  Create a debug log\\n\"\n        \"  -?, --help                   Give this help list\\n\"\n        \"\\n\"\n        \"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n        \"for any corresponding short options.\\n\\n\");\n}",
    "includes": [
      "#include <lxc/lxccontainer.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int iterations = 1;",
      "static int debug = 0;",
      "static int quiet = 0;",
      "static int delay = 0;",
      "static const char *template = \"busybox\";",
      "static const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: lxc-test-concurrent [OPTION]...\\n\\n\"\n        \"Common options :\\n\"\n        \"  -j, --threads=N              Threads to run concurrently\\n\"\n        \"                               (default: 5, use 1 for no threading)\\n\"\n        \"  -i, --iterations=N           Number times to run the test (default: 1)\\n\"\n        \"  -t, --template=t             Template to use (default: busybox)\\n\"\n        \"  -d, --delay=N                Delay in seconds between start and stop\\n\"\n        \"  -m, --modes=<mode,mode,...>  Modes to run (create, start, stop, destroy)\\n\"\n        \"  -q, --quiet                  Don't produce any output\\n\"\n        \"  -D, --debug                  Create a debug log\\n\"\n        \"  -?, --help                   Give this help list\\n\"\n        \"\\n\"\n        \"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n        \"for any corresponding short options.\\n\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lxc/lxccontainer.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <limits.h>\n\nstatic int iterations = 1;\nstatic int debug = 0;\nstatic int quiet = 0;\nstatic int delay = 0;\nstatic const char *template = \"busybox\";\nstatic const struct option options[] = {\n    { \"threads\",     required_argument, NULL, 'j' },\n    { \"iterations\",  required_argument, NULL, 'i' },\n    { \"template\",    required_argument, NULL, 't' },\n    { \"delay\",       required_argument, NULL, 'd' },\n    { \"modes\",       required_argument, NULL, 'm' },\n    { \"quiet\",       no_argument,       NULL, 'q' },\n    { \"debug\",       no_argument,       NULL, 'D' },\n    { \"help\",        no_argument,       NULL, '?' },\n    { 0, 0, 0, 0 },\n};\n\nstatic void usage(void) {\n    fprintf(stderr, \"Usage: lxc-test-concurrent [OPTION]...\\n\\n\"\n        \"Common options :\\n\"\n        \"  -j, --threads=N              Threads to run concurrently\\n\"\n        \"                               (default: 5, use 1 for no threading)\\n\"\n        \"  -i, --iterations=N           Number times to run the test (default: 1)\\n\"\n        \"  -t, --template=t             Template to use (default: busybox)\\n\"\n        \"  -d, --delay=N                Delay in seconds between start and stop\\n\"\n        \"  -m, --modes=<mode,mode,...>  Modes to run (create, start, stop, destroy)\\n\"\n        \"  -q, --quiet                  Don't produce any output\\n\"\n        \"  -D, --debug                  Create a debug log\\n\"\n        \"  -?, --help                   Give this help list\\n\"\n        \"\\n\"\n        \"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n        \"for any corresponding short options.\\n\\n\");\n}"
  }
]