[
  {
    "function_name": "lxc_utmp_del_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "470-489",
    "snippet": "int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "utmp_data->timer_fd"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to del utmp timer from mainloop\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "descr",
            "utmp_data->timer_fd"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Clearing utmp shutdown timer\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "lxc_utmp_add_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "430-468",
    "snippet": "int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t       lxc_mainloop_callback_t callback, void *data)\n{\n\tint fd, result;\n\tstruct itimerspec timeout;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to create timer\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Setting up utmp shutdown timer\");\n\n\t/* set a one second timeout. Repeated. */\n\ttimeout.it_value.tv_sec = 1;\n\ttimeout.it_value.tv_nsec = 0;\n\n\ttimeout.it_interval.tv_sec = 1;\n\ttimeout.it_interval.tv_nsec = 0;\n\n\tresult = timerfd_settime(fd, 0, &timeout, NULL);\n\n\tif (result < 0) {\n\t\tSYSERROR(\"timerfd_settime:\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, fd, callback, utmp_data)) {\n\t\tSYSERROR(\"failed to add utmp timer to mainloop\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tutmp_data->timer_fd = fd;\n\n\treturn 0;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define TFD_CLOEXEC O_CLOEXEC",
      "#define TFD_NONBLOCK O_NONBLOCK"
    ],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
      "static int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to add utmp timer to mainloop\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "descr",
            "fd",
            "callback",
            "utmp_data"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"timerfd_settime:\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerfd_settime",
          "args": [
            "fd",
            "0",
            "&timeout",
            "NULL"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "timerfd_settime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "49-55",
          "snippet": "static int timerfd_settime (int __ufd, int __flags,\n\t\t\t    const struct itimerspec *__utmr,\n\t\t\t    struct itimerspec *__otmr) {\n\n\treturn syscall(__NR_timerfd_settime, __ufd, __flags,\n\t\t\t    __utmr, __otmr);\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int timerfd_settime (int __ufd, int __flags,\n\t\t\t    const struct itimerspec *__utmr,\n\t\t\t    struct itimerspec *__otmr) {\n\n\treturn syscall(__NR_timerfd_settime, __ufd, __flags,\n\t\t\t    __utmr, __otmr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Setting up utmp shutdown timer\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create timer\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerfd_create",
          "args": [
            "CLOCK_MONOTONIC",
            "TFD_NONBLOCK | TFD_CLOEXEC"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "timerfd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "45-47",
          "snippet": "static int timerfd_create (clockid_t __clock_id, int __flags) {\n\treturn syscall(__NR_timerfd_create, __clock_id, __flags);\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int timerfd_create (clockid_t __clock_id, int __flags) {\n\treturn syscall(__NR_timerfd_create, __clock_id, __flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define TFD_CLOEXEC O_CLOEXEC\n#define TFD_NONBLOCK O_NONBLOCK\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t       lxc_mainloop_callback_t callback, void *data)\n{\n\tint fd, result;\n\tstruct itimerspec timeout;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to create timer\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Setting up utmp shutdown timer\");\n\n\t/* set a one second timeout. Repeated. */\n\ttimeout.it_value.tv_sec = 1;\n\ttimeout.it_value.tv_nsec = 0;\n\n\ttimeout.it_interval.tv_sec = 1;\n\ttimeout.it_interval.tv_nsec = 0;\n\n\tresult = timerfd_settime(fd, 0, &timeout, NULL);\n\n\tif (result < 0) {\n\t\tSYSERROR(\"timerfd_settime:\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, fd, callback, utmp_data)) {\n\t\tSYSERROR(\"failed to add utmp timer to mainloop\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tutmp_data->timer_fd = fd;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "utmp_shutdown_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "393-428",
    "snippet": "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr)\n{\n\tint ntasks;\n\tssize_t nread;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\tstruct lxc_handler *handler = utmp_data->handler;\n\tstruct lxc_conf *conf = handler->conf;\n\tuint64_t expirations;\n\n\t/* read and clear notifications */\n\tnread = read(fd, &expirations, sizeof(expirations));\n\tif (nread < 0)\n\t\tSYSERROR(\"Failed to read timer notification\");\n\n\tntasks = utmp_get_ntasks(handler);\n\n\tif (ntasks == 1 && (utmp_data->container_state == CONTAINER_HALTING)) {\n\t\tINFO(\"container has shutdown\");\n\t\t/* shutdown timer */\n\t\tlxc_utmp_del_timer(descr, utmp_data);\n\n\t\tkill(handler->pid, SIGKILL);\n\t}\n\n\tif (ntasks == 1 && (utmp_data->container_state == CONTAINER_REBOOTING)) {\n\t\tINFO(\"container has rebooted\");\n\t\tconf->reboot = 1;\n\t\t/* shutdown timer */\n\t\tlxc_utmp_del_timer(descr, utmp_data);\n\t\t/* this seems a bit rough. */\n\t\tkill(handler->pid, SIGKILL);\n\t}\n\treturn 0;\n\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CONTAINER_HALTING   2",
      "#define CONTAINER_REBOOTING 1"
    ],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_get_ntasks(struct lxc_handler *handler);",
      "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
      "static int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "handler->pid",
            "SIGKILL"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_utmp_del_timer",
          "args": [
            "descr",
            "utmp_data"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_utmp_del_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "470-489",
          "snippet": "int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
            "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
            "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"container has rebooted\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "handler->pid",
            "SIGKILL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"container has shutdown\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utmp_get_ntasks",
          "args": [
            "handler"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "utmp_get_ntasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "290-304",
          "snippet": "static int utmp_get_ntasks(struct lxc_handler *handler)\n{\n\tint ntasks;\n\n\tntasks = cgroup_nrtasks(handler);\n\n\tif (ntasks < 0) {\n\t\tERROR(\"failed to get the number of tasks\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"there are %d tasks running\", ntasks);\n\n\treturn ntasks;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int utmp_get_ntasks(struct lxc_handler *handler);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\n\nstatic int utmp_get_ntasks(struct lxc_handler *handler)\n{\n\tint ntasks;\n\n\tntasks = cgroup_nrtasks(handler);\n\n\tif (ntasks < 0) {\n\t\tERROR(\"failed to get the number of tasks\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"there are %d tasks running\", ntasks);\n\n\treturn ntasks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to read timer notification\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&expirations",
            "sizeof(expirations)"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONTAINER_HALTING   2\n#define CONTAINER_REBOOTING 1\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr)\n{\n\tint ntasks;\n\tssize_t nread;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\tstruct lxc_handler *handler = utmp_data->handler;\n\tstruct lxc_conf *conf = handler->conf;\n\tuint64_t expirations;\n\n\t/* read and clear notifications */\n\tnread = read(fd, &expirations, sizeof(expirations));\n\tif (nread < 0)\n\t\tSYSERROR(\"Failed to read timer notification\");\n\n\tntasks = utmp_get_ntasks(handler);\n\n\tif (ntasks == 1 && (utmp_data->container_state == CONTAINER_HALTING)) {\n\t\tINFO(\"container has shutdown\");\n\t\t/* shutdown timer */\n\t\tlxc_utmp_del_timer(descr, utmp_data);\n\n\t\tkill(handler->pid, SIGKILL);\n\t}\n\n\tif (ntasks == 1 && (utmp_data->container_state == CONTAINER_REBOOTING)) {\n\t\tINFO(\"container has rebooted\");\n\t\tconf->reboot = 1;\n\t\t/* shutdown timer */\n\t\tlxc_utmp_del_timer(descr, utmp_data);\n\t\t/* this seems a bit rough. */\n\t\tkill(handler->pid, SIGKILL);\n\t}\n\treturn 0;\n\n}"
  },
  {
    "function_name": "lxc_utmp_mainloop_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "306-391",
    "snippet": "int lxc_utmp_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t  struct lxc_handler *handler)\n{\n\tchar path[MAXPATHLEN];\n\tchar path2[MAXPATHLEN];\n\tint fd, wd;\n\tstruct lxc_utmp *utmp_data;\n\n\t/* We set up a watch for the /var/run directory. We're only interested\n\t * in utmp at the moment, but want to watch for delete and create\n\t * events as well.\n\t */\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (snprintf(path2, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (!access(path2, F_OK))\n\t\tgoto run_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"'%s' not found\", path);\n\t\treturn 0;\n\t}\n\nrun_ok:\n\n\tutmp_data = (struct lxc_utmp *)malloc(sizeof(struct lxc_utmp));\n\n\tif (NULL == utmp_data) {\n\t\tSYSERROR(\"failed to malloc handler utmp_data\");\n\t\treturn -1;\n\t}\n\n\tmemset(utmp_data, 0, sizeof(struct lxc_utmp));\n\n\tfd = inotify_init();\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to inotify_init\");\n\t\tgoto out;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set inotify fd to close-on-exec\");\n\t\tgoto out_close;\n\n\t}\n\n\twd = inotify_add_watch(fd, path, IN_MODIFY | IN_CREATE);\n\tif (wd < 0) {\n\t\tSYSERROR(\"failed to add watch for '%s'\", path);\n\t\tgoto out_close;\n\t}\n\n\tutmp_data->handler = handler;\n\tutmp_data->container_state = CONTAINER_STARTING;\n\tutmp_data->timer_fd = -1;\n\tutmp_data->prev_runlevel = 'N';\n\tutmp_data->curr_runlevel = 'N';\n\n\tif (lxc_mainloop_add_handler\n\t    (descr, fd, utmp_handler, (void *)utmp_data)) {\n\t\tSYSERROR(\"failed to add mainloop\");\n\t\tgoto out_close;\n\t}\n\n\tDEBUG(\"Added '%s' to inotifywatch\", path);\n\n\treturn 0;\nout_close:\n\tclose(fd);\nout:\n\tfree(utmp_data);\n\treturn -1;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CONTAINER_STARTING  0"
    ],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_get_ntasks(struct lxc_handler *handler);",
      "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "utmp_data"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Added '%s' to inotifywatch\"",
            "path"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to add mainloop\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "descr",
            "fd",
            "utmp_handler",
            "(void *)utmp_data"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to add watch for '%s'\"",
            "path"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_add_watch",
          "args": [
            "fd",
            "path",
            "IN_MODIFY | IN_CREATE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set inotify fd to close-on-exec\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to inotify_init\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_init",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utmp_data",
            "0",
            "sizeof(struct lxc_utmp)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to malloc handler utmp_data\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct lxc_utmp)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"'%s' not found\"",
            "path"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path is too long\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/%d/root/var/run\"",
            "handler->pid"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path2",
            "F_OK"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path is too long\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path2",
            "MAXPATHLEN",
            "\"/proc/%d/root/run/utmp\"",
            "handler->pid"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path is too long\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/%d/root/run\"",
            "handler->pid"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONTAINER_STARTING  0\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t  struct lxc_handler *handler)\n{\n\tchar path[MAXPATHLEN];\n\tchar path2[MAXPATHLEN];\n\tint fd, wd;\n\tstruct lxc_utmp *utmp_data;\n\n\t/* We set up a watch for the /var/run directory. We're only interested\n\t * in utmp at the moment, but want to watch for delete and create\n\t * events as well.\n\t */\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (snprintf(path2, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (!access(path2, F_OK))\n\t\tgoto run_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"'%s' not found\", path);\n\t\treturn 0;\n\t}\n\nrun_ok:\n\n\tutmp_data = (struct lxc_utmp *)malloc(sizeof(struct lxc_utmp));\n\n\tif (NULL == utmp_data) {\n\t\tSYSERROR(\"failed to malloc handler utmp_data\");\n\t\treturn -1;\n\t}\n\n\tmemset(utmp_data, 0, sizeof(struct lxc_utmp));\n\n\tfd = inotify_init();\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to inotify_init\");\n\t\tgoto out;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set inotify fd to close-on-exec\");\n\t\tgoto out_close;\n\n\t}\n\n\twd = inotify_add_watch(fd, path, IN_MODIFY | IN_CREATE);\n\tif (wd < 0) {\n\t\tSYSERROR(\"failed to add watch for '%s'\", path);\n\t\tgoto out_close;\n\t}\n\n\tutmp_data->handler = handler;\n\tutmp_data->container_state = CONTAINER_STARTING;\n\tutmp_data->timer_fd = -1;\n\tutmp_data->prev_runlevel = 'N';\n\tutmp_data->curr_runlevel = 'N';\n\n\tif (lxc_mainloop_add_handler\n\t    (descr, fd, utmp_handler, (void *)utmp_data)) {\n\t\tSYSERROR(\"failed to add mainloop\");\n\t\tgoto out_close;\n\t}\n\n\tDEBUG(\"Added '%s' to inotifywatch\", path);\n\n\treturn 0;\nout_close:\n\tclose(fd);\nout:\n\tfree(utmp_data);\n\treturn -1;\n}"
  },
  {
    "function_name": "utmp_get_ntasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "290-304",
    "snippet": "static int utmp_get_ntasks(struct lxc_handler *handler)\n{\n\tint ntasks;\n\n\tntasks = cgroup_nrtasks(handler);\n\n\tif (ntasks < 0) {\n\t\tERROR(\"failed to get the number of tasks\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"there are %d tasks running\", ntasks);\n\n\treturn ntasks;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int utmp_get_ntasks(struct lxc_handler *handler);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"there are %d tasks running\"",
            "ntasks"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to get the number of tasks\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_nrtasks",
          "args": [
            "handler"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_nrtasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "168-177",
          "snippet": "int cgroup_nrtasks(struct lxc_handler *handler)\n{\n\tif (ops) {\n\t\tif (ops->nrtasks)\n\t\t\treturn ops->nrtasks(handler->cgroup_data);\n\t\telse\n\t\t\tWARN(\"CGROUP driver %s doesn't implement nrtasks\", ops->name);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nint cgroup_nrtasks(struct lxc_handler *handler)\n{\n\tif (ops) {\n\t\tif (ops->nrtasks)\n\t\t\treturn ops->nrtasks(handler->cgroup_data);\n\t\telse\n\t\t\tWARN(\"CGROUP driver %s doesn't implement nrtasks\", ops->name);\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\n\nstatic int utmp_get_ntasks(struct lxc_handler *handler)\n{\n\tint ntasks;\n\n\tntasks = cgroup_nrtasks(handler);\n\n\tif (ntasks < 0) {\n\t\tERROR(\"failed to get the number of tasks\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"there are %d tasks running\", ntasks);\n\n\treturn ntasks;\n}"
  },
  {
    "function_name": "utmp_get_runlevel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "240-288",
    "snippet": "static int utmp_get_runlevel(struct lxc_utmp *utmp_data)\n{\n\t#if HAVE_UTMPX_H\n\tstruct utmpx *utmpx;\n\t#else\n\tstruct utmp *utmpx;\n\t#endif\n\tchar path[MAXPATHLEN];\n\tstruct lxc_handler *handler = utmp_data->handler;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (!access(path, F_OK) && !utmpxname(path))\n\t\tgoto utmp_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (utmpxname(path)) {\n\t\tSYSERROR(\"failed to 'utmpxname'\");\n\t\treturn -1;\n\t}\n\nutmp_ok:\n\n\tsetutxent();\n\n\twhile ((utmpx = getutxent())) {\n\n\t\tif (utmpx->ut_type == RUN_LVL) {\n\t\t\tutmp_data->prev_runlevel = utmpx->ut_pid / 256;\n\t\t\tutmp_data->curr_runlevel = utmpx->ut_pid % 256;\n\t\t\tDEBUG(\"utmp handler - run level is %c/%c\",\n\t\t\t      utmp_data->prev_runlevel,\n\t\t\t      utmp_data->curr_runlevel);\n\t\t}\n\t}\n\n\tendutxent();\n\n\treturn 0;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define RUN_LVL 1"
    ],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_get_ntasks(struct lxc_handler *handler);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "endutxent",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "endutxent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "90-97",
          "snippet": "static void endutxent (void) {\n#ifdef IS_BIONIC\n\t/* bionic isn't exporting endutend */\n\treturn;\n#else\n\treturn endutent();\n#endif\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void endutxent (void) {\n#ifdef IS_BIONIC\n\t/* bionic isn't exporting endutend */\n\treturn;\n#else\n\treturn endutent();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"utmp handler - run level is %c/%c\"",
            "utmp_data->prev_runlevel",
            "utmp_data->curr_runlevel"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getutxent",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "getutxent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "86-88",
          "snippet": "static struct utmp * getutxent (void) {\n\treturn (struct utmp *) getutent();\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct utmp * getutxent (void) {\n\treturn (struct utmp *) getutent();\n}"
        }
      },
      {
        "call_info": {
          "callee": "setutxent",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "setutxent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "82-84",
          "snippet": "static void setutxent(void) {\n\treturn setutent();\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void setutxent(void) {\n\treturn setutent();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to 'utmpxname'\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utmpxname",
          "args": [
            "path"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "utmpxname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "101-111",
          "snippet": "static int utmpxname(const char *file) {\n\tint result;\n\tresult = utmpname(file);\n\n#ifdef IS_BIONIC\n\t/* Yeah bionic is that weird */\n\tresult = result - 1;\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmpxname(const char *file) {\n\tint result;\n\tresult = utmpname(file);\n\n#ifdef IS_BIONIC\n\t/* Yeah bionic is that weird */\n\tresult = result - 1;\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path is too long\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/%d/root/var/run/utmp\"",
            "handler->pid"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path is too long\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/proc/%d/root/run/utmp\"",
            "handler->pid"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define RUN_LVL 1\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data)\n{\n\t#if HAVE_UTMPX_H\n\tstruct utmpx *utmpx;\n\t#else\n\tstruct utmp *utmpx;\n\t#endif\n\tchar path[MAXPATHLEN];\n\tstruct lxc_handler *handler = utmp_data->handler;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (!access(path, F_OK) && !utmpxname(path))\n\t\tgoto utmp_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (utmpxname(path)) {\n\t\tSYSERROR(\"failed to 'utmpxname'\");\n\t\treturn -1;\n\t}\n\nutmp_ok:\n\n\tsetutxent();\n\n\twhile ((utmpx = getutxent())) {\n\n\t\tif (utmpx->ut_type == RUN_LVL) {\n\t\t\tutmp_data->prev_runlevel = utmpx->ut_pid / 256;\n\t\t\tutmp_data->curr_runlevel = utmpx->ut_pid % 256;\n\t\t\tDEBUG(\"utmp handler - run level is %c/%c\",\n\t\t\t      utmp_data->prev_runlevel,\n\t\t\t      utmp_data->curr_runlevel);\n\t\t}\n\t}\n\n\tendutxent();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "utmp_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "150-238",
    "snippet": "static int utmp_handler(int fd, uint32_t events, void *data,\n\t\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct inotify_event *ie;\n\tint size, ret, length;\n\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\t/*\n\t * we're monitoring a directory. ie->name is not included in\n\t * sizeof(struct inotify_event) if we don't read it all at once,\n\t * read gives us EINVAL, so we read and cast to struct ie\n\t */\n\tchar buffer[MAXPATHLEN];\n\n\tif (ioctl(fd, FIONREAD, &size) < 0) {\n\t\tSYSERROR(\"cannot determine the size of this notification\");\n\t\treturn -1;\n\t}\n\n\tif (read(fd, buffer, size) < size) {\n\t\tSYSERROR(\"failed to read notification\");\n\t\treturn -1;\n\t}\n\n\tie = (struct inotify_event *)buffer;\n\n\tif (ie->len <= 0) {\n\n\t\tif (ie->mask & IN_UNMOUNT) {\n\t\t\tDEBUG(\"watched directory removed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tSYSERROR(\"inotify event with no name (mask %d)\", ie->mask);\n\t\treturn -1;\n\t}\n\n\tret = 0;\n\n\tDEBUG(\"got inotify event %d for %s\", ie->mask, ie->name);\n\n\tlength = (4 < ie->len) ? 4 : ie->len;\n\n\t/* only care about utmp */\n\n\tif (strncmp(ie->name, \"utmp\", length))\n\t\treturn 0;\n\n\tif (ie->mask & (IN_MODIFY | IN_CREATE))\n\t\tret = utmp_get_runlevel(utmp_data);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* container halting, from running or starting state */\n\tif (utmp_data->curr_runlevel == '0'\n\t    && ((utmp_data->container_state == CONTAINER_RUNNING)\n\t\t|| (utmp_data->container_state == CONTAINER_STARTING))) {\n\t\tutmp_data->container_state = CONTAINER_HALTING;\n\t\tif (utmp_data->timer_fd == -1)\n\t\t\tlxc_utmp_add_timer(descr, utmp_shutdown_handler, data);\n\t\tDEBUG(\"Container halting\");\n\t\tgoto out;\n\t}\n\n\t/* container rebooting, from running or starting state */\n\tif (utmp_data->curr_runlevel == '6'\n\t    && ((utmp_data->container_state == CONTAINER_RUNNING)\n\t\t|| (utmp_data->container_state == CONTAINER_STARTING))) {\n\t\tutmp_data->container_state = CONTAINER_REBOOTING;\n\t\tif (utmp_data->timer_fd == -1)\n\t\t\tlxc_utmp_add_timer(descr, utmp_shutdown_handler, data);\n\t\tDEBUG(\"Container rebooting\");\n\t\tgoto out;\n\t}\n\n\t/* normal operation, running, from starting state. */\n\tif (utmp_data->curr_runlevel > '0' && utmp_data->curr_runlevel < '6') {\n\t\tutmp_data->container_state = CONTAINER_RUNNING;\n\t\tif (utmp_data->timer_fd > 0)\n\t\t\tlxc_utmp_del_timer(descr, utmp_data);\n\t\tDEBUG(\"Container running\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn 0;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CONTAINER_RUNNING   4",
      "#define CONTAINER_HALTING   2",
      "#define CONTAINER_REBOOTING 1",
      "#define CONTAINER_STARTING  0"
    ],
    "globals_used": [
      "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
      "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
      "static int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);",
      "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container running\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_utmp_del_timer",
          "args": [
            "descr",
            "utmp_data"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_utmp_del_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "470-489",
          "snippet": "int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
            "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
            "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t       struct lxc_utmp *utmp_data)\n{\n\tint result;\n\n\tDEBUG(\"Clearing utmp shutdown timer\");\n\n\tresult = lxc_mainloop_del_handler(descr, utmp_data->timer_fd);\n\tif (result < 0)\n\t\tSYSERROR(\"failed to del utmp timer from mainloop\");\n\n\t/* shutdown timer_fd */\n\tclose(utmp_data->timer_fd);\n\tutmp_data->timer_fd = -1;\n\n\tif (result < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container rebooting\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_utmp_add_timer",
          "args": [
            "descr",
            "utmp_shutdown_handler",
            "data"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_utmp_add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "430-468",
          "snippet": "int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t       lxc_mainloop_callback_t callback, void *data)\n{\n\tint fd, result;\n\tstruct itimerspec timeout;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to create timer\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Setting up utmp shutdown timer\");\n\n\t/* set a one second timeout. Repeated. */\n\ttimeout.it_value.tv_sec = 1;\n\ttimeout.it_value.tv_nsec = 0;\n\n\ttimeout.it_interval.tv_sec = 1;\n\ttimeout.it_interval.tv_nsec = 0;\n\n\tresult = timerfd_settime(fd, 0, &timeout, NULL);\n\n\tif (result < 0) {\n\t\tSYSERROR(\"timerfd_settime:\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, fd, callback, utmp_data)) {\n\t\tSYSERROR(\"failed to add utmp timer to mainloop\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tutmp_data->timer_fd = fd;\n\n\treturn 0;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TFD_CLOEXEC O_CLOEXEC",
            "#define TFD_NONBLOCK O_NONBLOCK"
          ],
          "globals_used": [
            "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
            "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
            "static int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);",
            "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define TFD_CLOEXEC O_CLOEXEC\n#define TFD_NONBLOCK O_NONBLOCK\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t       lxc_mainloop_callback_t callback, void *data)\n{\n\tint fd, result;\n\tstruct itimerspec timeout;\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to create timer\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Setting up utmp shutdown timer\");\n\n\t/* set a one second timeout. Repeated. */\n\ttimeout.it_value.tv_sec = 1;\n\ttimeout.it_value.tv_nsec = 0;\n\n\ttimeout.it_interval.tv_sec = 1;\n\ttimeout.it_interval.tv_nsec = 0;\n\n\tresult = timerfd_settime(fd, 0, &timeout, NULL);\n\n\tif (result < 0) {\n\t\tSYSERROR(\"timerfd_settime:\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, fd, callback, utmp_data)) {\n\t\tSYSERROR(\"failed to add utmp timer to mainloop\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tutmp_data->timer_fd = fd;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container halting\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utmp_get_runlevel",
          "args": [
            "utmp_data"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "utmp_get_runlevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "240-288",
          "snippet": "static int utmp_get_runlevel(struct lxc_utmp *utmp_data)\n{\n\t#if HAVE_UTMPX_H\n\tstruct utmpx *utmpx;\n\t#else\n\tstruct utmp *utmpx;\n\t#endif\n\tchar path[MAXPATHLEN];\n\tstruct lxc_handler *handler = utmp_data->handler;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (!access(path, F_OK) && !utmpxname(path))\n\t\tgoto utmp_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (utmpxname(path)) {\n\t\tSYSERROR(\"failed to 'utmpxname'\");\n\t\treturn -1;\n\t}\n\nutmp_ok:\n\n\tsetutxent();\n\n\twhile ((utmpx = getutxent())) {\n\n\t\tif (utmpx->ut_type == RUN_LVL) {\n\t\t\tutmp_data->prev_runlevel = utmpx->ut_pid / 256;\n\t\t\tutmp_data->curr_runlevel = utmpx->ut_pid % 256;\n\t\t\tDEBUG(\"utmp handler - run level is %c/%c\",\n\t\t\t      utmp_data->prev_runlevel,\n\t\t\t      utmp_data->curr_runlevel);\n\t\t}\n\t}\n\n\tendutxent();\n\n\treturn 0;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define RUN_LVL 1"
          ],
          "globals_used": [
            "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
            "static int utmp_get_ntasks(struct lxc_handler *handler);",
            "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define RUN_LVL 1\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data)\n{\n\t#if HAVE_UTMPX_H\n\tstruct utmpx *utmpx;\n\t#else\n\tstruct utmp *utmpx;\n\t#endif\n\tchar path[MAXPATHLEN];\n\tstruct lxc_handler *handler = utmp_data->handler;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (!access(path, F_OK) && !utmpxname(path))\n\t\tgoto utmp_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (utmpxname(path)) {\n\t\tSYSERROR(\"failed to 'utmpxname'\");\n\t\treturn -1;\n\t}\n\nutmp_ok:\n\n\tsetutxent();\n\n\twhile ((utmpx = getutxent())) {\n\n\t\tif (utmpx->ut_type == RUN_LVL) {\n\t\t\tutmp_data->prev_runlevel = utmpx->ut_pid / 256;\n\t\t\tutmp_data->curr_runlevel = utmpx->ut_pid % 256;\n\t\t\tDEBUG(\"utmp handler - run level is %c/%c\",\n\t\t\t      utmp_data->prev_runlevel,\n\t\t\t      utmp_data->curr_runlevel);\n\t\t}\n\t}\n\n\tendutxent();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ie->name",
            "\"utmp\"",
            "length"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"got inotify event %d for %s\"",
            "ie->mask",
            "ie->name"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"inotify event with no name (mask %d)\"",
            "ie->mask"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"watched directory removed\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to read notification\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "size"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"cannot determine the size of this notification\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "FIONREAD",
            "&size"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONTAINER_RUNNING   4\n#define CONTAINER_HALTING   2\n#define CONTAINER_REBOOTING 1\n#define CONTAINER_STARTING  0\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_add_timer(struct lxc_epoll_descr *descr,\n\t\t\t      lxc_mainloop_callback_t callback, void *data);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nstatic int utmp_handler(int fd, uint32_t events, void *data,\n\t\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct inotify_event *ie;\n\tint size, ret, length;\n\n\tstruct lxc_utmp *utmp_data = (struct lxc_utmp *)data;\n\n\t/*\n\t * we're monitoring a directory. ie->name is not included in\n\t * sizeof(struct inotify_event) if we don't read it all at once,\n\t * read gives us EINVAL, so we read and cast to struct ie\n\t */\n\tchar buffer[MAXPATHLEN];\n\n\tif (ioctl(fd, FIONREAD, &size) < 0) {\n\t\tSYSERROR(\"cannot determine the size of this notification\");\n\t\treturn -1;\n\t}\n\n\tif (read(fd, buffer, size) < size) {\n\t\tSYSERROR(\"failed to read notification\");\n\t\treturn -1;\n\t}\n\n\tie = (struct inotify_event *)buffer;\n\n\tif (ie->len <= 0) {\n\n\t\tif (ie->mask & IN_UNMOUNT) {\n\t\t\tDEBUG(\"watched directory removed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tSYSERROR(\"inotify event with no name (mask %d)\", ie->mask);\n\t\treturn -1;\n\t}\n\n\tret = 0;\n\n\tDEBUG(\"got inotify event %d for %s\", ie->mask, ie->name);\n\n\tlength = (4 < ie->len) ? 4 : ie->len;\n\n\t/* only care about utmp */\n\n\tif (strncmp(ie->name, \"utmp\", length))\n\t\treturn 0;\n\n\tif (ie->mask & (IN_MODIFY | IN_CREATE))\n\t\tret = utmp_get_runlevel(utmp_data);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* container halting, from running or starting state */\n\tif (utmp_data->curr_runlevel == '0'\n\t    && ((utmp_data->container_state == CONTAINER_RUNNING)\n\t\t|| (utmp_data->container_state == CONTAINER_STARTING))) {\n\t\tutmp_data->container_state = CONTAINER_HALTING;\n\t\tif (utmp_data->timer_fd == -1)\n\t\t\tlxc_utmp_add_timer(descr, utmp_shutdown_handler, data);\n\t\tDEBUG(\"Container halting\");\n\t\tgoto out;\n\t}\n\n\t/* container rebooting, from running or starting state */\n\tif (utmp_data->curr_runlevel == '6'\n\t    && ((utmp_data->container_state == CONTAINER_RUNNING)\n\t\t|| (utmp_data->container_state == CONTAINER_STARTING))) {\n\t\tutmp_data->container_state = CONTAINER_REBOOTING;\n\t\tif (utmp_data->timer_fd == -1)\n\t\t\tlxc_utmp_add_timer(descr, utmp_shutdown_handler, data);\n\t\tDEBUG(\"Container rebooting\");\n\t\tgoto out;\n\t}\n\n\t/* normal operation, running, from starting state. */\n\tif (utmp_data->curr_runlevel > '0' && utmp_data->curr_runlevel < '6') {\n\t\tutmp_data->container_state = CONTAINER_RUNNING;\n\t\tif (utmp_data->timer_fd > 0)\n\t\t\tlxc_utmp_del_timer(descr, utmp_data);\n\t\tDEBUG(\"Container running\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "utmpxname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "101-111",
    "snippet": "static int utmpxname(const char *file) {\n\tint result;\n\tresult = utmpname(file);\n\n#ifdef IS_BIONIC\n\t/* Yeah bionic is that weird */\n\tresult = result - 1;\n#endif\n\n\treturn result;\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "utmpname",
          "args": [
            "file"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int utmpxname(const char *file) {\n\tint result;\n\tresult = utmpname(file);\n\n#ifdef IS_BIONIC\n\t/* Yeah bionic is that weird */\n\tresult = result - 1;\n#endif\n\n\treturn result;\n}"
  },
  {
    "function_name": "endutxent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "90-97",
    "snippet": "static void endutxent (void) {\n#ifdef IS_BIONIC\n\t/* bionic isn't exporting endutend */\n\treturn;\n#else\n\treturn endutent();\n#endif\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "endutent",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void endutxent (void) {\n#ifdef IS_BIONIC\n\t/* bionic isn't exporting endutend */\n\treturn;\n#else\n\treturn endutent();\n#endif\n}"
  },
  {
    "function_name": "getutxent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "86-88",
    "snippet": "static struct utmp * getutxent (void) {\n\treturn (struct utmp *) getutent();\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getutent",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct utmp * getutxent (void) {\n\treturn (struct utmp *) getutent();\n}"
  },
  {
    "function_name": "setutxent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "82-84",
    "snippet": "static void setutxent(void) {\n\treturn setutent();\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setutent",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void setutxent(void) {\n\treturn setutent();\n}"
  },
  {
    "function_name": "timerfd_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "49-55",
    "snippet": "static int timerfd_settime (int __ufd, int __flags,\n\t\t\t    const struct itimerspec *__utmr,\n\t\t\t    struct itimerspec *__otmr) {\n\n\treturn syscall(__NR_timerfd_settime, __ufd, __flags,\n\t\t\t    __utmr, __otmr);\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_timerfd_settime",
            "__ufd",
            "__flags",
            "__utmr",
            "__otmr"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int timerfd_settime (int __ufd, int __flags,\n\t\t\t    const struct itimerspec *__utmr,\n\t\t\t    struct itimerspec *__otmr) {\n\n\treturn syscall(__NR_timerfd_settime, __ufd, __flags,\n\t\t\t    __utmr, __otmr);\n}"
  },
  {
    "function_name": "timerfd_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
    "lines": "45-47",
    "snippet": "static int timerfd_create (clockid_t __clock_id, int __flags) {\n\treturn syscall(__NR_timerfd_create, __clock_id, __flags);\n}",
    "includes": [
      "#include <utmp.h>",
      "#include <utmp.h>",
      "#include <utmpx.h>",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include \"mainloop.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"conf.h\"",
      "#include <sys/syscall.h>",
      "#include <sys/timerfd.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/inotify.h>",
      "#include <fcntl.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_timerfd_create",
            "__clock_id",
            "__flags"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int timerfd_create (clockid_t __clock_id, int __flags) {\n\treturn syscall(__NR_timerfd_create, __clock_id, __flags);\n}"
  }
]