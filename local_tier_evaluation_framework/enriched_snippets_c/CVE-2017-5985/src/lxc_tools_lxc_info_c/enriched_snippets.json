[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "394-413",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(ret);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(ret);\n\tlxc_log_options_no_override();\n\n\tif (print_info(my_args.name, my_args.lxcpath[0]) == 0)\n\t\tret = EXIT_SUCCESS;\n\n\texit(ret);\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_info",
          "args": [
            "my_args.name",
            "my_args.lxcpath[0]"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "print_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "287-392",
          "snippet": "static int print_info(const char *name, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_container *c;\n\n\tc = lxc_container_new(name, lxcpath);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failure to retrieve information on %s:%s\\n\", lxcpath ? lxcpath : \"null\",\n\t\t\t\tname ? name : \"null\");\n\t\treturn -1;\n\t}\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!c->is_running(c) && !c->is_defined(c)) {\n\t\tfprintf(stderr, \"%s doesn't exist\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!state && !pid && !ips && !stats && keys <= 0) {\n\t\tstate = pid = ips = stats = true;\n\t\tprint_info_msg_str(\"Name:\", c->name);\n\t}\n\n\tif (state) {\n\t\tprint_info_msg_str(\"State:\", c->state(c));\n\t}\n\n\tif (c->is_running(c)) {\n\t\tif (pid) {\n\t\t\tpid_t initpid;\n\n\t\t\tinitpid = c->init_pid(c);\n\t\t\tif (initpid >= 0)\n\t\t\t\tprint_info_msg_int(\"PID:\", initpid);\n\t\t}\n\n\t\tif (ips) {\n\t\t\tfflush(stdout);\n\t\t\tchar **addresses = c->get_ips(c, NULL, NULL, 0);\n\t\t\tif (addresses) {\n\t\t\t\tchar *address;\n\t\t\t\ti = 0;\n\t\t\t\twhile (addresses[i]) {\n\t\t\t\t\taddress = addresses[i];\n\t\t\t\t\tprint_info_msg_str(\"IP:\", address);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stats) {\n\t\tprint_stats(c);\n\t\tprint_net_stats(c);\n\t}\n\n\tfor(i = 0; i < keys; i++) {\n\t\tint len = c->get_config_item(c, key[i], NULL, 0);\n\n\t\tif (len > 0) {\n\t\t\tchar *val = (char*) malloc(sizeof(char)*len + 1);\n\n\t\t\tif (c->get_config_item(c, key[i], val, len + 1) != len) {\n\t\t\t\tfprintf(stderr, \"unable to read %s from configuration\\n\", key[i]);\n\t\t\t} else {\n\t\t\t\tif (!humanize && keys == 1)\n\t\t\t\t\tprintf(\"%s\\n\", val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s = %s\\n\", key[i], val);\n\t\t\t}\n\t\t\tfree(val);\n\t\t} else if (len == 0) {\n\t\t\tif (!humanize && keys == 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s =\\n\", key[i]);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s invalid\\n\", key[i]);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tlxc_container_put(c);\n\treturn 0;\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ips;",
            "static bool state;",
            "static bool pid;",
            "static bool stats;",
            "static bool humanize = true;",
            "static char **key = NULL;",
            "static int keys = 0;",
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool ips;\nstatic bool state;\nstatic bool pid;\nstatic bool stats;\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int keys = 0;\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nstatic int print_info(const char *name, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_container *c;\n\n\tc = lxc_container_new(name, lxcpath);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failure to retrieve information on %s:%s\\n\", lxcpath ? lxcpath : \"null\",\n\t\t\t\tname ? name : \"null\");\n\t\treturn -1;\n\t}\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!c->is_running(c) && !c->is_defined(c)) {\n\t\tfprintf(stderr, \"%s doesn't exist\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!state && !pid && !ips && !stats && keys <= 0) {\n\t\tstate = pid = ips = stats = true;\n\t\tprint_info_msg_str(\"Name:\", c->name);\n\t}\n\n\tif (state) {\n\t\tprint_info_msg_str(\"State:\", c->state(c));\n\t}\n\n\tif (c->is_running(c)) {\n\t\tif (pid) {\n\t\t\tpid_t initpid;\n\n\t\t\tinitpid = c->init_pid(c);\n\t\t\tif (initpid >= 0)\n\t\t\t\tprint_info_msg_int(\"PID:\", initpid);\n\t\t}\n\n\t\tif (ips) {\n\t\t\tfflush(stdout);\n\t\t\tchar **addresses = c->get_ips(c, NULL, NULL, 0);\n\t\t\tif (addresses) {\n\t\t\t\tchar *address;\n\t\t\t\ti = 0;\n\t\t\t\twhile (addresses[i]) {\n\t\t\t\t\taddress = addresses[i];\n\t\t\t\t\tprint_info_msg_str(\"IP:\", address);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stats) {\n\t\tprint_stats(c);\n\t\tprint_net_stats(c);\n\t}\n\n\tfor(i = 0; i < keys; i++) {\n\t\tint len = c->get_config_item(c, key[i], NULL, 0);\n\n\t\tif (len > 0) {\n\t\t\tchar *val = (char*) malloc(sizeof(char)*len + 1);\n\n\t\t\tif (c->get_config_item(c, key[i], val, len + 1) != len) {\n\t\t\t\tfprintf(stderr, \"unable to read %s from configuration\\n\", key[i]);\n\t\t\t} else {\n\t\t\t\tif (!humanize && keys == 1)\n\t\t\t\t\tprintf(\"%s\\n\", val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s = %s\\n\", key[i], val);\n\t\t\t}\n\t\t\tfree(val);\n\t\t} else if (len == 0) {\n\t\t\tif (!humanize && keys == 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s =\\n\", key[i]);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s invalid\\n\", key[i]);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tlxc_container_put(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nint main(int argc, char *argv[])\n{\n\tint ret = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(ret);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(ret);\n\tlxc_log_options_no_override();\n\n\tif (print_info(my_args.name, my_args.lxcpath[0]) == 0)\n\t\tret = EXIT_SUCCESS;\n\n\texit(ret);\n}"
  },
  {
    "function_name": "print_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "287-392",
    "snippet": "static int print_info(const char *name, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_container *c;\n\n\tc = lxc_container_new(name, lxcpath);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failure to retrieve information on %s:%s\\n\", lxcpath ? lxcpath : \"null\",\n\t\t\t\tname ? name : \"null\");\n\t\treturn -1;\n\t}\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!c->is_running(c) && !c->is_defined(c)) {\n\t\tfprintf(stderr, \"%s doesn't exist\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!state && !pid && !ips && !stats && keys <= 0) {\n\t\tstate = pid = ips = stats = true;\n\t\tprint_info_msg_str(\"Name:\", c->name);\n\t}\n\n\tif (state) {\n\t\tprint_info_msg_str(\"State:\", c->state(c));\n\t}\n\n\tif (c->is_running(c)) {\n\t\tif (pid) {\n\t\t\tpid_t initpid;\n\n\t\t\tinitpid = c->init_pid(c);\n\t\t\tif (initpid >= 0)\n\t\t\t\tprint_info_msg_int(\"PID:\", initpid);\n\t\t}\n\n\t\tif (ips) {\n\t\t\tfflush(stdout);\n\t\t\tchar **addresses = c->get_ips(c, NULL, NULL, 0);\n\t\t\tif (addresses) {\n\t\t\t\tchar *address;\n\t\t\t\ti = 0;\n\t\t\t\twhile (addresses[i]) {\n\t\t\t\t\taddress = addresses[i];\n\t\t\t\t\tprint_info_msg_str(\"IP:\", address);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stats) {\n\t\tprint_stats(c);\n\t\tprint_net_stats(c);\n\t}\n\n\tfor(i = 0; i < keys; i++) {\n\t\tint len = c->get_config_item(c, key[i], NULL, 0);\n\n\t\tif (len > 0) {\n\t\t\tchar *val = (char*) malloc(sizeof(char)*len + 1);\n\n\t\t\tif (c->get_config_item(c, key[i], val, len + 1) != len) {\n\t\t\t\tfprintf(stderr, \"unable to read %s from configuration\\n\", key[i]);\n\t\t\t} else {\n\t\t\t\tif (!humanize && keys == 1)\n\t\t\t\t\tprintf(\"%s\\n\", val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s = %s\\n\", key[i], val);\n\t\t\t}\n\t\t\tfree(val);\n\t\t} else if (len == 0) {\n\t\t\tif (!humanize && keys == 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s =\\n\", key[i]);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s invalid\\n\", key[i]);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tlxc_container_put(c);\n\treturn 0;\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ips;",
      "static bool state;",
      "static bool pid;",
      "static bool stats;",
      "static bool humanize = true;",
      "static char **key = NULL;",
      "static int keys = 0;",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s invalid\\n\"",
            "key[i]"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s =\\n\"",
            "key[i]"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s = %s\\n\"",
            "key[i]",
            "val"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "val"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unable to read %s from configuration\\n\"",
            "key[i]"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key[i]",
            "val",
            "len + 1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key[i]",
            "NULL",
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_net_stats",
          "args": [
            "c"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "print_net_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "149-202",
          "snippet": "static void print_net_stats(struct lxc_container *c)\n{\n\tint rc,netnr;\n\tunsigned long long rx_bytes = 0, tx_bytes = 0;\n\tchar *ifname, *type;\n\tchar path[PATH_MAX];\n\tchar buf[256];\n\n\tfor(netnr = 0; ;netnr++) {\n\t\tsprintf(buf, \"lxc.network.%d.type\", netnr);\n\t\ttype = c->get_running_config_item(c, buf);\n\t\tif (!type)\n\t\t\tbreak;\n\n\t\tif (!strcmp(type, \"veth\")) {\n\t\t\tsprintf(buf, \"lxc.network.%d.veth.pair\", netnr);\n\t\t} else {\n\t\t\tsprintf(buf, \"lxc.network.%d.link\", netnr);\n\t\t}\n\t\tfree(type);\n\t\tifname = c->get_running_config_item(c, buf);\n\t\tif (!ifname)\n\t\t\treturn;\n\t\tprintf(\"%-15s %s\\n\", \"Link:\", ifname);\n\t\tfflush(stdout);\n\n\t\t/* XXX: tx and rx are reversed from the host vs container\n\t\t * perspective, print them from the container perspective\n\t\t */\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/rx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\trx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" TX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/tx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\ttx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" RX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsprintf(buf, \"%llu\", rx_bytes + tx_bytes);\n\t\tstr_size_humanize(buf, sizeof(buf));\n\t\tprintf(\"%-15s %s\\n\", \" Total bytes:\", buf);\n\t\tfflush(stdout);\n\t\tfree(ifname);\n\t}\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void print_net_stats(struct lxc_container *c)\n{\n\tint rc,netnr;\n\tunsigned long long rx_bytes = 0, tx_bytes = 0;\n\tchar *ifname, *type;\n\tchar path[PATH_MAX];\n\tchar buf[256];\n\n\tfor(netnr = 0; ;netnr++) {\n\t\tsprintf(buf, \"lxc.network.%d.type\", netnr);\n\t\ttype = c->get_running_config_item(c, buf);\n\t\tif (!type)\n\t\t\tbreak;\n\n\t\tif (!strcmp(type, \"veth\")) {\n\t\t\tsprintf(buf, \"lxc.network.%d.veth.pair\", netnr);\n\t\t} else {\n\t\t\tsprintf(buf, \"lxc.network.%d.link\", netnr);\n\t\t}\n\t\tfree(type);\n\t\tifname = c->get_running_config_item(c, buf);\n\t\tif (!ifname)\n\t\t\treturn;\n\t\tprintf(\"%-15s %s\\n\", \"Link:\", ifname);\n\t\tfflush(stdout);\n\n\t\t/* XXX: tx and rx are reversed from the host vs container\n\t\t * perspective, print them from the container perspective\n\t\t */\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/rx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\trx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" TX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/tx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\ttx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" RX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsprintf(buf, \"%llu\", rx_bytes + tx_bytes);\n\t\tstr_size_humanize(buf, sizeof(buf));\n\t\tprintf(\"%-15s %s\\n\", \" Total bytes:\", buf);\n\t\tfflush(stdout);\n\t\tfree(ifname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_stats",
          "args": [
            "c"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "print_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "204-259",
          "snippet": "static void print_stats(struct lxc_container *c)\n{\n\tint i, ret;\n\tchar buf[256];\n\n\tret = c->get_cgroup_item(c, \"cpuacct.usage\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tstr_chomp(buf);\n\t\tif (humanize) {\n\t\t\tfloat seconds = strtof(buf, NULL) / 1000000000.0;\n\t\t\tprintf(\"%-15s %.2f seconds\\n\", \"CPU use:\", seconds);\n\t\t} else {\n\t\t\tprintf(\"%-15s %s\\n\", \"CPU use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tret = c->get_cgroup_item(c, \"blkio.throttle.io_service_bytes\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tchar *ch;\n\n\t\t/* put ch on last \"Total\" line */\n\t\tstr_chomp(buf);\n\t\tfor(ch = &buf[strlen(buf)-1]; ch > buf && *ch != '\\n'; ch--)\n\t\t\t;\n\t\tif (*ch == '\\n')\n\t\t\tch++;\n\n\t\tif (strncmp(ch, \"Total\", 5) == 0) {\n\t\t\tch += 6;\n\t\t\tmemmove(buf, ch, strlen(ch)+1);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \"BlkIO use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tconst char *file;\n\t} lxstat[] = {\n\t\t{ \"Memory use:\", \"memory.usage_in_bytes\" },\n\t\t{ \"KMem use:\",   \"memory.kmem.usage_in_bytes\" },\n\t\t{ NULL, NULL },\n\t};\n\n\tfor (i = 0; lxstat[i].name; i++) {\n\t\tret = c->get_cgroup_item(c, lxstat[i].file, buf, sizeof(buf));\n\t\tif (ret > 0 && ret < sizeof(buf)) {\n\t\t\tstr_chomp(buf);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", lxstat[i].name, buf);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool humanize = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\n\nstatic void print_stats(struct lxc_container *c)\n{\n\tint i, ret;\n\tchar buf[256];\n\n\tret = c->get_cgroup_item(c, \"cpuacct.usage\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tstr_chomp(buf);\n\t\tif (humanize) {\n\t\t\tfloat seconds = strtof(buf, NULL) / 1000000000.0;\n\t\t\tprintf(\"%-15s %.2f seconds\\n\", \"CPU use:\", seconds);\n\t\t} else {\n\t\t\tprintf(\"%-15s %s\\n\", \"CPU use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tret = c->get_cgroup_item(c, \"blkio.throttle.io_service_bytes\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tchar *ch;\n\n\t\t/* put ch on last \"Total\" line */\n\t\tstr_chomp(buf);\n\t\tfor(ch = &buf[strlen(buf)-1]; ch > buf && *ch != '\\n'; ch--)\n\t\t\t;\n\t\tif (*ch == '\\n')\n\t\t\tch++;\n\n\t\tif (strncmp(ch, \"Total\", 5) == 0) {\n\t\t\tch += 6;\n\t\t\tmemmove(buf, ch, strlen(ch)+1);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \"BlkIO use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tconst char *file;\n\t} lxstat[] = {\n\t\t{ \"Memory use:\", \"memory.usage_in_bytes\" },\n\t\t{ \"KMem use:\",   \"memory.kmem.usage_in_bytes\" },\n\t\t{ NULL, NULL },\n\t};\n\n\tfor (i = 0; lxstat[i].name; i++) {\n\t\tret = c->get_cgroup_item(c, lxstat[i].file, buf, sizeof(buf));\n\t\tif (ret > 0 && ret < sizeof(buf)) {\n\t\t\tstr_chomp(buf);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", lxstat[i].name, buf);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_info_msg_str",
          "args": [
            "\"IP:\"",
            "address"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "print_info_msg_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "274-285",
          "snippet": "static void print_info_msg_str(const char *key, const char *value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %s\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%s\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %s\\n\", key, value);\n\t}\n\tfflush(stdout);\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool humanize = true;",
            "static char **key = NULL;",
            "static int filter_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int filter_count = 0;\n\nstatic void print_info_msg_str(const char *key, const char *value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %s\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%s\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %s\\n\", key, value);\n\t}\n\tfflush(stdout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_ips",
          "args": [
            "c",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_info_msg_int",
          "args": [
            "\"PID:\"",
            "initpid"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "print_info_msg_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "261-272",
          "snippet": "static void print_info_msg_int(const char *key, int value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %d\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%d\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %d\\n\", key, value);\n\t}\n\tfflush(stdout);\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool humanize = true;",
            "static char **key = NULL;",
            "static int filter_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int filter_count = 0;\n\nstatic void print_info_msg_int(const char *key, int value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %d\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%d\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %d\\n\", key, value);\n\t}\n\tfflush(stdout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->init_pid",
          "args": [
            "c"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->state",
          "args": [
            "c"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s doesn't exist\\n\"",
            "c->name"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Insufficent privileges to control %s\\n\"",
            "c->name"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->may_control",
          "args": [
            "c"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory setting new config filename\\n\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "my_args.rcfile"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to load rcfile\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "my_args.rcfile"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clear_config",
          "args": [
            "c"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failure to retrieve information on %s:%s\\n\"",
            "lxcpath ? lxcpath : \"null\"",
            "name ? name : \"null\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool ips;\nstatic bool state;\nstatic bool pid;\nstatic bool stats;\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int keys = 0;\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-info\",\n\t.help     = \"\\\n--name=NAME\\n\\\n\\n\\\nlxc-info display some information about a container with the identifier NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME       NAME of the container\\n\\\n  -c, --config=KEY      show configuration variable KEY from running container\\n\\\n  -i, --ips             shows the IP addresses\\n\\\n  -p, --pid             shows the process id of the init container\\n\\\n  -S, --stats           shows usage stats\\n\\\n  -H, --no-humanize     shows stats as raw numbers, not humanized\\n\\\n  -s, --state           shows the state of the container\\n\\\n  --rcfile=FILE         Load configuration file FILE\\n\",\n\t.name     = NULL,\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nstatic int print_info(const char *name, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_container *c;\n\n\tc = lxc_container_new(name, lxcpath);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failure to retrieve information on %s:%s\\n\", lxcpath ? lxcpath : \"null\",\n\t\t\t\tname ? name : \"null\");\n\t\treturn -1;\n\t}\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tlxc_container_put(c);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!c->is_running(c) && !c->is_defined(c)) {\n\t\tfprintf(stderr, \"%s doesn't exist\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\treturn -1;\n\t}\n\n\tif (!state && !pid && !ips && !stats && keys <= 0) {\n\t\tstate = pid = ips = stats = true;\n\t\tprint_info_msg_str(\"Name:\", c->name);\n\t}\n\n\tif (state) {\n\t\tprint_info_msg_str(\"State:\", c->state(c));\n\t}\n\n\tif (c->is_running(c)) {\n\t\tif (pid) {\n\t\t\tpid_t initpid;\n\n\t\t\tinitpid = c->init_pid(c);\n\t\t\tif (initpid >= 0)\n\t\t\t\tprint_info_msg_int(\"PID:\", initpid);\n\t\t}\n\n\t\tif (ips) {\n\t\t\tfflush(stdout);\n\t\t\tchar **addresses = c->get_ips(c, NULL, NULL, 0);\n\t\t\tif (addresses) {\n\t\t\t\tchar *address;\n\t\t\t\ti = 0;\n\t\t\t\twhile (addresses[i]) {\n\t\t\t\t\taddress = addresses[i];\n\t\t\t\t\tprint_info_msg_str(\"IP:\", address);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stats) {\n\t\tprint_stats(c);\n\t\tprint_net_stats(c);\n\t}\n\n\tfor(i = 0; i < keys; i++) {\n\t\tint len = c->get_config_item(c, key[i], NULL, 0);\n\n\t\tif (len > 0) {\n\t\t\tchar *val = (char*) malloc(sizeof(char)*len + 1);\n\n\t\t\tif (c->get_config_item(c, key[i], val, len + 1) != len) {\n\t\t\t\tfprintf(stderr, \"unable to read %s from configuration\\n\", key[i]);\n\t\t\t} else {\n\t\t\t\tif (!humanize && keys == 1)\n\t\t\t\t\tprintf(\"%s\\n\", val);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s = %s\\n\", key[i], val);\n\t\t\t}\n\t\t\tfree(val);\n\t\t} else if (len == 0) {\n\t\t\tif (!humanize && keys == 1)\n\t\t\t\tprintf(\"\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s =\\n\", key[i]);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s invalid\\n\", key[i]);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tlxc_container_put(c);\n\treturn 0;\n}"
  },
  {
    "function_name": "print_info_msg_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "274-285",
    "snippet": "static void print_info_msg_str(const char *key, const char *value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %s\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%s\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %s\\n\", key, value);\n\t}\n\tfflush(stdout);\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool humanize = true;",
      "static char **key = NULL;",
      "static int filter_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "key",
            "value"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "value"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "key",
            "value"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int filter_count = 0;\n\nstatic void print_info_msg_str(const char *key, const char *value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %s\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%s\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %s\\n\", key, value);\n\t}\n\tfflush(stdout);\n}"
  },
  {
    "function_name": "print_info_msg_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "261-272",
    "snippet": "static void print_info_msg_int(const char *key, int value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %d\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%d\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %d\\n\", key, value);\n\t}\n\tfflush(stdout);\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool humanize = true;",
      "static char **key = NULL;",
      "static int filter_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %d\\n\"",
            "key",
            "value"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d\\n\"",
            "value"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %d\\n\"",
            "key",
            "value"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int filter_count = 0;\n\nstatic void print_info_msg_int(const char *key, int value)\n{\n\tif (humanize)\n\t\tprintf(\"%-15s %d\\n\", key, value);\n\telse {\n\t\tif (filter_count == 1)\n\t\t\tprintf(\"%d\\n\", value);\n\t\telse\n\t\t\tprintf(\"%-15s %d\\n\", key, value);\n\t}\n\tfflush(stdout);\n}"
  },
  {
    "function_name": "print_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "204-259",
    "snippet": "static void print_stats(struct lxc_container *c)\n{\n\tint i, ret;\n\tchar buf[256];\n\n\tret = c->get_cgroup_item(c, \"cpuacct.usage\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tstr_chomp(buf);\n\t\tif (humanize) {\n\t\t\tfloat seconds = strtof(buf, NULL) / 1000000000.0;\n\t\t\tprintf(\"%-15s %.2f seconds\\n\", \"CPU use:\", seconds);\n\t\t} else {\n\t\t\tprintf(\"%-15s %s\\n\", \"CPU use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tret = c->get_cgroup_item(c, \"blkio.throttle.io_service_bytes\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tchar *ch;\n\n\t\t/* put ch on last \"Total\" line */\n\t\tstr_chomp(buf);\n\t\tfor(ch = &buf[strlen(buf)-1]; ch > buf && *ch != '\\n'; ch--)\n\t\t\t;\n\t\tif (*ch == '\\n')\n\t\t\tch++;\n\n\t\tif (strncmp(ch, \"Total\", 5) == 0) {\n\t\t\tch += 6;\n\t\t\tmemmove(buf, ch, strlen(ch)+1);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \"BlkIO use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tconst char *file;\n\t} lxstat[] = {\n\t\t{ \"Memory use:\", \"memory.usage_in_bytes\" },\n\t\t{ \"KMem use:\",   \"memory.kmem.usage_in_bytes\" },\n\t\t{ NULL, NULL },\n\t};\n\n\tfor (i = 0; lxstat[i].name; i++) {\n\t\tret = c->get_cgroup_item(c, lxstat[i].file, buf, sizeof(buf));\n\t\tif (ret > 0 && ret < sizeof(buf)) {\n\t\t\tstr_chomp(buf);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", lxstat[i].name, buf);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool humanize = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "lxstat[i].name",
            "buf"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_size_humanize",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "str_size_humanize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "134-147",
          "snippet": "static unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool humanize = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\n\nstatic unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_chomp",
          "args": [
            "buf"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "str_chomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "104-113",
          "snippet": "static void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "lxstat[i].file",
            "buf",
            "sizeof(buf)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\"BlkIO use:\"",
            "buf"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf",
            "ch",
            "strlen(ch)+1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ch"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ch",
            "\"Total\"",
            "5"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"blkio.throttle.io_service_bytes\"",
            "buf",
            "sizeof(buf)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\"CPU use:\"",
            "buf"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %.2f seconds\\n\"",
            "\"CPU use:\"",
            "seconds"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtof",
          "args": [
            "buf",
            "NULL"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"cpuacct.usage\"",
            "buf",
            "sizeof(buf)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\n\nstatic void print_stats(struct lxc_container *c)\n{\n\tint i, ret;\n\tchar buf[256];\n\n\tret = c->get_cgroup_item(c, \"cpuacct.usage\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tstr_chomp(buf);\n\t\tif (humanize) {\n\t\t\tfloat seconds = strtof(buf, NULL) / 1000000000.0;\n\t\t\tprintf(\"%-15s %.2f seconds\\n\", \"CPU use:\", seconds);\n\t\t} else {\n\t\t\tprintf(\"%-15s %s\\n\", \"CPU use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tret = c->get_cgroup_item(c, \"blkio.throttle.io_service_bytes\", buf, sizeof(buf));\n\tif (ret > 0 && ret < sizeof(buf)) {\n\t\tchar *ch;\n\n\t\t/* put ch on last \"Total\" line */\n\t\tstr_chomp(buf);\n\t\tfor(ch = &buf[strlen(buf)-1]; ch > buf && *ch != '\\n'; ch--)\n\t\t\t;\n\t\tif (*ch == '\\n')\n\t\t\tch++;\n\n\t\tif (strncmp(ch, \"Total\", 5) == 0) {\n\t\t\tch += 6;\n\t\t\tmemmove(buf, ch, strlen(ch)+1);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \"BlkIO use:\", buf);\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tconst char *file;\n\t} lxstat[] = {\n\t\t{ \"Memory use:\", \"memory.usage_in_bytes\" },\n\t\t{ \"KMem use:\",   \"memory.kmem.usage_in_bytes\" },\n\t\t{ NULL, NULL },\n\t};\n\n\tfor (i = 0; lxstat[i].name; i++) {\n\t\tret = c->get_cgroup_item(c, lxstat[i].file, buf, sizeof(buf));\n\t\tif (ret > 0 && ret < sizeof(buf)) {\n\t\t\tstr_chomp(buf);\n\t\t\tstr_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", lxstat[i].name, buf);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_net_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "149-202",
    "snippet": "static void print_net_stats(struct lxc_container *c)\n{\n\tint rc,netnr;\n\tunsigned long long rx_bytes = 0, tx_bytes = 0;\n\tchar *ifname, *type;\n\tchar path[PATH_MAX];\n\tchar buf[256];\n\n\tfor(netnr = 0; ;netnr++) {\n\t\tsprintf(buf, \"lxc.network.%d.type\", netnr);\n\t\ttype = c->get_running_config_item(c, buf);\n\t\tif (!type)\n\t\t\tbreak;\n\n\t\tif (!strcmp(type, \"veth\")) {\n\t\t\tsprintf(buf, \"lxc.network.%d.veth.pair\", netnr);\n\t\t} else {\n\t\t\tsprintf(buf, \"lxc.network.%d.link\", netnr);\n\t\t}\n\t\tfree(type);\n\t\tifname = c->get_running_config_item(c, buf);\n\t\tif (!ifname)\n\t\t\treturn;\n\t\tprintf(\"%-15s %s\\n\", \"Link:\", ifname);\n\t\tfflush(stdout);\n\n\t\t/* XXX: tx and rx are reversed from the host vs container\n\t\t * perspective, print them from the container perspective\n\t\t */\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/rx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\trx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" TX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/tx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\ttx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" RX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsprintf(buf, \"%llu\", rx_bytes + tx_bytes);\n\t\tstr_size_humanize(buf, sizeof(buf));\n\t\tprintf(\"%-15s %s\\n\", \" Total bytes:\", buf);\n\t\tfflush(stdout);\n\t\tfree(ifname);\n\t}\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifname"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\" Total bytes:\"",
            "buf"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_size_humanize",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "str_size_humanize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "134-147",
          "snippet": "static unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool humanize = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\n\nstatic unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\"",
            "rx_bytes + tx_bytes"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\" RX bytes:\"",
            "buf"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_chomp",
          "args": [
            "buf"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "str_chomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "104-113",
          "snippet": "static void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "path",
            "buf",
            "sizeof(buf)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"/sys/class/net/%s/statistics/tx_bytes\"",
            "ifname"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\" TX bytes:\"",
            "buf"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"/sys/class/net/%s/statistics/rx_bytes\"",
            "ifname"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-15s %s\\n\"",
            "\"Link:\"",
            "ifname"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "buf"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"lxc.network.%d.link\"",
            "netnr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"lxc.network.%d.veth.pair\"",
            "netnr"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"veth\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "buf"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"lxc.network.%d.type\"",
            "netnr"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void print_net_stats(struct lxc_container *c)\n{\n\tint rc,netnr;\n\tunsigned long long rx_bytes = 0, tx_bytes = 0;\n\tchar *ifname, *type;\n\tchar path[PATH_MAX];\n\tchar buf[256];\n\n\tfor(netnr = 0; ;netnr++) {\n\t\tsprintf(buf, \"lxc.network.%d.type\", netnr);\n\t\ttype = c->get_running_config_item(c, buf);\n\t\tif (!type)\n\t\t\tbreak;\n\n\t\tif (!strcmp(type, \"veth\")) {\n\t\t\tsprintf(buf, \"lxc.network.%d.veth.pair\", netnr);\n\t\t} else {\n\t\t\tsprintf(buf, \"lxc.network.%d.link\", netnr);\n\t\t}\n\t\tfree(type);\n\t\tifname = c->get_running_config_item(c, buf);\n\t\tif (!ifname)\n\t\t\treturn;\n\t\tprintf(\"%-15s %s\\n\", \"Link:\", ifname);\n\t\tfflush(stdout);\n\n\t\t/* XXX: tx and rx are reversed from the host vs container\n\t\t * perspective, print them from the container perspective\n\t\t */\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/rx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\trx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" TX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsnprintf(path, sizeof(path), \"/sys/class/net/%s/statistics/tx_bytes\", ifname);\n\t\trc = lxc_read_from_file(path, buf, sizeof(buf));\n\t\tif (rc > 0) {\n\t\t\tstr_chomp(buf);\n\t\t\ttx_bytes = str_size_humanize(buf, sizeof(buf));\n\t\t\tprintf(\"%-15s %s\\n\", \" RX bytes:\", buf);\n\t\t\tfflush(stdout);\n\t\t}\n\n\t\tsprintf(buf, \"%llu\", rx_bytes + tx_bytes);\n\t\tstr_size_humanize(buf, sizeof(buf));\n\t\tprintf(\"%-15s %s\\n\", \" Total bytes:\", buf);\n\t\tfflush(stdout);\n\t\tfree(ifname);\n\t}\n}"
  },
  {
    "function_name": "str_size_humanize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "134-147",
    "snippet": "static unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool humanize = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_humanize",
          "args": [
            "val",
            "iobuf",
            "iobufsz"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "size_humanize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
          "lines": "115-132",
          "snippet": "static void size_humanize(unsigned long long val, char *buf, size_t bufsz)\n{\n\tif (val > 1 << 30) {\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u GiB\",\n\t\t\t    (int)(val >> 30),\n\t\t\t    (int)(val & ((1 << 30) - 1)) / 10737419);\n\t} else if (val > 1 << 20) {\n\t\tint x = val + 5243;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u MiB\",\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (val > 1 << 10) {\n\t\tint x = val + 5;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u KiB\",\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tsnprintf(buf, bufsz, \"%u bytes\", (int)val);\n\t}\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <libgen.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void size_humanize(unsigned long long val, char *buf, size_t bufsz)\n{\n\tif (val > 1 << 30) {\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u GiB\",\n\t\t\t    (int)(val >> 30),\n\t\t\t    (int)(val & ((1 << 30) - 1)) / 10737419);\n\t} else if (val > 1 << 20) {\n\t\tint x = val + 5243;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u MiB\",\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (val > 1 << 10) {\n\t\tint x = val + 5;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u KiB\",\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tsnprintf(buf, bufsz, \"%u bytes\", (int)val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "iobuf",
            "&end",
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool humanize = true;\n\nstatic unsigned long long str_size_humanize(char *iobuf, size_t iobufsz)\n{\n\tunsigned long long val;\n\tchar *end = NULL;\n\n\tval = strtoull(iobuf, &end, 0);\n\tif (humanize) {\n\t\tif (*end == '\\0' || *end == '\\n')\n\t\t\tsize_humanize(val, iobuf, iobufsz);\n\t\telse\n\t\t\t*iobuf = '\\0';\n\t}\n\treturn val;\n}"
  },
  {
    "function_name": "size_humanize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "115-132",
    "snippet": "static void size_humanize(unsigned long long val, char *buf, size_t bufsz)\n{\n\tif (val > 1 << 30) {\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u GiB\",\n\t\t\t    (int)(val >> 30),\n\t\t\t    (int)(val & ((1 << 30) - 1)) / 10737419);\n\t} else if (val > 1 << 20) {\n\t\tint x = val + 5243;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u MiB\",\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (val > 1 << 10) {\n\t\tint x = val + 5;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u KiB\",\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tsnprintf(buf, bufsz, \"%u bytes\", (int)val);\n\t}\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsz",
            "\"%u bytes\"",
            "(int)val"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsz",
            "\"%u.%2.2u KiB\"",
            "x >> 10",
            "((x & ((1 << 10) - 1)) * 100) >> 10"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsz",
            "\"%u.%2.2u MiB\"",
            "x >> 20",
            "((x & ((1 << 20) - 1)) * 100) >> 20"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsz",
            "\"%u.%2.2u GiB\"",
            "(int)(val >> 30)",
            "(int)(val & ((1 << 30) - 1)) / 10737419"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void size_humanize(unsigned long long val, char *buf, size_t bufsz)\n{\n\tif (val > 1 << 30) {\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u GiB\",\n\t\t\t    (int)(val >> 30),\n\t\t\t    (int)(val & ((1 << 30) - 1)) / 10737419);\n\t} else if (val > 1 << 20) {\n\t\tint x = val + 5243;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u MiB\",\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (val > 1 << 10) {\n\t\tint x = val + 5;  /* for rounding */\n\t\tsnprintf(buf, bufsz, \"%u.%2.2u KiB\",\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tsnprintf(buf, bufsz, \"%u bytes\", (int)val);\n\t}\n}"
  },
  {
    "function_name": "str_chomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "104-113",
    "snippet": "static void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic void str_chomp(char *buf)\n{\n\tchar *ch;\n\n\t/* remove trailing whitespace from buf */\n\tfor(ch = &buf[strlen(buf)-1];\n\t    ch >= buf && (*ch == '\\t' || *ch == '\\n' || *ch == ' ');\n\t    ch--)\n\t\t*ch = '\\0';\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_info.c",
    "lines": "51-70",
    "snippet": "static int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tchar **newk;\n\tswitch (c) {\n\tcase 'c':\n\t\tnewk = realloc(key, (keys + 1) * sizeof(key[0]));\n\t\tif (!newk)\n\t\t\treturn -1;\n\t\tkey = newk;\n\t\tkey[keys] = arg;\n\t\tkeys++;\n\t\tbreak;\n\tcase 'i': ips = true; filter_count += 1; break;\n\tcase 's': state = true; filter_count += 1; break;\n\tcase 'p': pid = true; filter_count += 1; break;\n\tcase 'S': stats = true; filter_count += 5; break;\n\tcase 'H': humanize = false; break;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <libgen.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ips;",
      "static bool state;",
      "static bool pid;",
      "static bool stats;",
      "static bool humanize = true;",
      "static char **key = NULL;",
      "static int keys = 0;",
      "static int filter_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "key",
            "(keys + 1) * sizeof(key[0])"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nstatic bool ips;\nstatic bool state;\nstatic bool pid;\nstatic bool stats;\nstatic bool humanize = true;\nstatic char **key = NULL;\nstatic int keys = 0;\nstatic int filter_count = 0;\n\nstatic int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tchar **newk;\n\tswitch (c) {\n\tcase 'c':\n\t\tnewk = realloc(key, (keys + 1) * sizeof(key[0]));\n\t\tif (!newk)\n\t\t\treturn -1;\n\t\tkey = newk;\n\t\tkey[keys] = arg;\n\t\tkeys++;\n\t\tbreak;\n\tcase 'i': ips = true; filter_count += 1; break;\n\tcase 's': state = true; filter_count += 1; break;\n\tcase 'p': pid = true; filter_count += 1; break;\n\tcase 'S': stats = true; filter_count += 5; break;\n\tcase 'H': humanize = false; break;\n\t}\n\treturn 0;\n}"
  }
]