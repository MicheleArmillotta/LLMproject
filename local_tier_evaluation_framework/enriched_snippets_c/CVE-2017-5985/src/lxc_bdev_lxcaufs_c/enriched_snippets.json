[
  {
    "function_name": "aufs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "352-419",
    "snippet": "int aufs_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t\tconst char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *upperdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"br=\") && (strlen(opts[i]) > (len = strlen(\"br=\"))))\n\t\t\ttmp = opts[i] + len;\n\t}\n\tif (!tmp)\n\t\tgoto err;\n\n\tupperdir = strtok_r(tmp, \":=\", &scratch);\n\tif (!upperdir)\n\t\tgoto err;\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = aufs_get_rootfs(rootfs->path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (!rootfs_path)\n\t\tret = mkdir_p(upperdir, 0755);\n\telse if ((strncmp(upperdir, lxcpath, strlen(lxcpath)) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\tret = mkdir_p(upperdir, 0755);\n\tif (ret < 0)\n\t\tWARN(\"Failed to create upperdir\");\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)opts",
            "free"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rootfsdir"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create upperdir\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "upperdir",
            "0755"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upperdir",
            "rootfsdir",
            "rootfslen"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upperdir",
            "lxcpath",
            "strlen(lxcpath)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aufs_get_rootfs",
          "args": [
            "rootfs->path",
            "&rootfslen"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "aufs_get_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
          "lines": "317-350",
          "snippet": "char *aufs_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nchar *aufs_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "lxc_path",
            "lxc_name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\":=\"",
            "&scratch"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"br=\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts[i]"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "opts[i]",
            "\"br=\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)opts"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "mntent->mnt_opts",
            "','"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);\n\nint aufs_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t\tconst char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *upperdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"br=\") && (strlen(opts[i]) > (len = strlen(\"br=\"))))\n\t\t\ttmp = opts[i] + len;\n\t}\n\tif (!tmp)\n\t\tgoto err;\n\n\tupperdir = strtok_r(tmp, \":=\", &scratch);\n\tif (!upperdir)\n\t\tgoto err;\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = aufs_get_rootfs(rootfs->path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (!rootfs_path)\n\t\tret = mkdir_p(upperdir, 0755);\n\telse if ((strncmp(upperdir, lxcpath, strlen(lxcpath)) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\tret = mkdir_p(upperdir, 0755);\n\tif (ret < 0)\n\t\tWARN(\"Failed to create upperdir\");\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}"
  },
  {
    "function_name": "aufs_get_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "317-350",
    "snippet": "char *aufs_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootfsdir"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s1"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s2"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s2",
            "\":/\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s1",
            "\":/\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rootfs_path"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nchar *aufs_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}"
  },
  {
    "function_name": "aufs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "308-315",
    "snippet": "int aufs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"aufs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "aufs_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
          "lines": "308-315",
          "snippet": "int aufs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"aufs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"aufs\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nint aufs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"aufs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
  },
  {
    "function_name": "aufs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "236-306",
    "snippet": "int aufs_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tint len;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\n\tif (strcmp(bdev->type, \"aufs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\t//  separately mount it first\n\t//  mount -t aufs -obr=${upper}=rw:${lower}=ro lower dest\n\tdup = alloca(strlen(bdev->src)+1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t// TODO We should check whether bdev->src is a blockdev, and if so\n\t// but for now, only support aufs of a basic directory\n\n\t// AUFS does not work on top of certain filesystems like (XFS or Btrfs)\n\t// so add xino=/dev/shm/aufs.xino parameter to mount options.\n\t// The same xino option can be specified to multiple aufs mounts, and\n\t// a xino file is not shared among multiple aufs mounts.\n\t//\n\t// see http://www.mail-archive.com/aufs-users@lists.sourceforge.net/msg02587.html\n\t//     http://www.mail-archive.com/aufs-users@lists.sourceforge.net/msg05126.html\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(xinopath) + strlen(\"br==rw:=ro,,xino=\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"br=%s=rw:%s=ro,%s,xino=%s\", upper, lower, mntdata, xinopath);\n\t}\n\telse {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(xinopath) + strlen(\"br==rw:=ro,xino=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"br=%s=rw:%s=ro,xino=%s\", upper, lower, xinopath);\n\t}\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount(lower, bdev->dest, \"aufs\", MS_MGC_VAL | mntflags, options);\n\tif (ret < 0)\n\t\tSYSERROR(\"aufs: error mounting %s onto %s options %s\",\n\t\t\tlower, bdev->dest, options);\n\telse\n\t\tINFO(\"aufs: mounted %s onto %s options %s\",\n\t\t\tlower, bdev->dest, options);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"aufs: mounted %s onto %s options %s\"",
            "lower",
            "bdev->dest",
            "options"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"aufs: error mounting %s onto %s options %s\"",
            "lower",
            "bdev->dest",
            "options"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "lower",
            "bdev->dest",
            "\"aufs\"",
            "MS_MGC_VAL | mntflags",
            "options"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options",
            "len",
            "\"br=%s=rw:%s=ro,xino=%s\"",
            "upper",
            "lower",
            "xinopath"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"br==rw:=ro,xino=\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xinopath"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options",
            "len",
            "\"br=%s=rw:%s=ro,%s,xino=%s\"",
            "upper",
            "lower",
            "mntdata",
            "xinopath"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mntdata"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"br==rw:=ro,,xino=\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xinopath"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "bdev->mntopts",
            "&mntflags",
            "&mntdata"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "++upper",
            "\":/\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dup",
            "\":/\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dup",
            "bdev->src"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(bdev->src)+1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bdev->src"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"aufs\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nint aufs_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tint len;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\n\tif (strcmp(bdev->type, \"aufs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\t//  separately mount it first\n\t//  mount -t aufs -obr=${upper}=rw:${lower}=ro lower dest\n\tdup = alloca(strlen(bdev->src)+1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t// TODO We should check whether bdev->src is a blockdev, and if so\n\t// but for now, only support aufs of a basic directory\n\n\t// AUFS does not work on top of certain filesystems like (XFS or Btrfs)\n\t// so add xino=/dev/shm/aufs.xino parameter to mount options.\n\t// The same xino option can be specified to multiple aufs mounts, and\n\t// a xino file is not shared among multiple aufs mounts.\n\t//\n\t// see http://www.mail-archive.com/aufs-users@lists.sourceforge.net/msg02587.html\n\t//     http://www.mail-archive.com/aufs-users@lists.sourceforge.net/msg05126.html\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(xinopath) + strlen(\"br==rw:=ro,,xino=\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"br=%s=rw:%s=ro,%s,xino=%s\", upper, lower, mntdata, xinopath);\n\t}\n\telse {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(xinopath) + strlen(\"br==rw:=ro,xino=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"br=%s=rw:%s=ro,xino=%s\", upper, lower, xinopath);\n\t}\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount(lower, bdev->dest, \"aufs\", MS_MGC_VAL | mntflags, options);\n\tif (ret < 0)\n\t\tSYSERROR(\"aufs: error mounting %s onto %s options %s\",\n\t\t\tlower, bdev->dest, options);\n\telse\n\t\tINFO(\"aufs: mounted %s onto %s options %s\",\n\t\t\tlower, bdev->dest, options);\n\treturn ret;\n}"
  },
  {
    "function_name": "aufs_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "229-234",
    "snippet": "int aufs_detect(const char *path)\n{\n\tif (strncmp(path, \"aufs:\", 5) == 0)\n\t\treturn 1; // take their word for it\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"aufs:\"",
            "5"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nint aufs_detect(const char *path)\n{\n\tif (strncmp(path, \"aufs:\", 5) == 0)\n\t\treturn 1; // take their word for it\n\treturn 0;\n}"
  },
  {
    "function_name": "aufs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "216-227",
    "snippet": "int aufs_destroy(struct bdev *orig)\n{\n\tchar *upper;\n\n\tif (strncmp(orig->src, \"aufs:\", 5) != 0)\n\t\treturn -22;\n\tupper = strchr(orig->src + 5, ':');\n\tif (!upper)\n\t\treturn -22;\n\tupper++;\n\treturn lxc_rmdir_onedev(upper, NULL);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "upper",
            "NULL"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig->src + 5",
            "':'"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "orig->src",
            "\"aufs:\"",
            "5"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nint aufs_destroy(struct bdev *orig)\n{\n\tchar *upper;\n\n\tif (strncmp(orig->src, \"aufs:\", 5) != 0)\n\t\treturn -22;\n\tupper = strchr(orig->src + 5, ':');\n\tif (!upper)\n\t\treturn -22;\n\tupper++;\n\treturn lxc_rmdir_onedev(upper, NULL);\n}"
  },
  {
    "function_name": "aufs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "174-214",
    "snippet": "int aufs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tchar *delta;\n\tint ret, len = strlen(dest), newlen;\n\n\tif (len < 8 || strcmp(dest+len-7, \"/rootfs\") != 0)\n\t\treturn -1;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdelta = alloca(strlen(dest)+1);\n\tstrcpy(delta, dest);\n\tstrcpy(delta+len-6, \"delta0\");\n\n\tif (mkdir_p(delta, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", delta);\n\t\treturn -1;\n\t}\n\n\t/* aufs:lower:upper */\n\tnewlen = (2 * len) + strlen(\"aufs:\") + 2;\n\tbdev->src = malloc(newlen);\n\tif (!bdev->src) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tret = snprintf(bdev->src, newlen, \"aufs:%s:%s\", dest, delta);\n\tif (ret < 0 || ret >= newlen)\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "bdev->dest"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "bdev->dest",
            "0755"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "bdev->src",
            "newlen",
            "\"aufs:%s:%s\"",
            "dest",
            "delta"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "newlen"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"aufs:\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "delta"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta+len-6",
            "\"delta0\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta",
            "dest"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(dest)+1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dest+len-7",
            "\"/rootfs\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nint aufs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tchar *delta;\n\tint ret, len = strlen(dest), newlen;\n\n\tif (len < 8 || strcmp(dest+len-7, \"/rootfs\") != 0)\n\t\treturn -1;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdelta = alloca(strlen(dest)+1);\n\tstrcpy(delta, dest);\n\tstrcpy(delta+len-6, \"delta0\");\n\n\tif (mkdir_p(delta, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", delta);\n\t\treturn -1;\n\t}\n\n\t/* aufs:lower:upper */\n\tnewlen = (2 * len) + strlen(\"aufs:\") + 2;\n\tbdev->src = malloc(newlen);\n\tif (!bdev->src) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tret = snprintf(bdev->src, newlen, \"aufs:%s:%s\", dest, delta);\n\tif (ret < 0 || ret >= newlen)\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aufs_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
    "lines": "43-166",
    "snippet": "int aufs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tif (!snap) {\n\t\tERROR(\"aufs is only for snapshot clones\");\n\t\treturn -22;\n\t}\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tnew->dest = dir_new_path(orig->dest, oldname, cname, oldpath, lxcpath);\n\tif (!new->dest)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (am_unpriv() && chown_mapped_root(new->dest, conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (strcmp(orig->type, \"dir\") == 0) {\n\t\tchar *delta, *lastslash;\n\t\tint ret, len, lastslashidx;\n\n\t\t// if we have /var/lib/lxc/c2/rootfs, then delta will be\n\t\t//            /var/lib/lxc/c2/delta0\n\t\tlastslash = strrchr(new->dest, '/');\n\t\tif (!lastslash)\n\t\t\treturn -22;\n\t\tif (strlen(lastslash) < 7)\n\t\t\treturn -22;\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - new->dest;\n\n\t\tdelta = malloc(lastslashidx + 7);\n\t\tif (!delta)\n\t\t\treturn -1;\n\t\tstrncpy(delta, new->dest, lastslashidx+1);\n\t\tstrcpy(delta+lastslashidx, \"delta0\");\n\t\tif ((ret = mkdir(delta, 0755)) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", delta);\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(delta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", delta);\n\n\t\t// the src will be 'aufs:lowerdir:upperdir'\n\t\tlen = strlen(delta) + strlen(orig->src) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(delta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"aufs:%s:%s\", orig->src, delta);\n\t\tfree(delta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else if (strcmp(orig->type, \"aufs\") == 0) {\n\t\t// What exactly do we want to do here?\n\t\t// I think we want to use the original lowerdir, with a\n\t\t// private delta which is originally rsynced from the\n\t\t// original delta\n\t\tchar *osrc, *odelta, *nsrc, *ndelta;\n\t\tint len, ret;\n\t\tif (!(osrc = strdup(orig->src)))\n\t\t\treturn -22;\n\t\tnsrc = strchr(osrc, ':') + 1;\n\t\tif (nsrc != osrc + 5 || (odelta = strchr(nsrc, ':')) == NULL) {\n\t\t\tfree(osrc);\n\t\t\treturn -22;\n\t\t}\n\t\t*odelta = '\\0';\n\t\todelta++;\n\t\tndelta = dir_new_path(odelta, oldname, cname, oldpath, lxcpath);\n\t\tif (!ndelta) {\n\t\t\tfree(osrc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif ((ret = mkdir(ndelta, 0755)) < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", ndelta);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(ndelta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", ndelta);\n\n\t\tstruct rsync_data_char rdata;\n\t\trdata.src = odelta;\n\t\trdata.dest = ndelta;\n\t\tif (am_unpriv())\n\t\t\tret = userns_exec_1(conf, rsync_delta_wrapper, &rdata);\n\t\telse\n\t\t\tret = rsync_delta(&rdata);\n\t\tif (ret) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\tERROR(\"copying aufs delta\");\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(nsrc) + strlen(ndelta) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"aufs:%s:%s\", nsrc, ndelta);\n\t\tfree(osrc);\n\t\tfree(ndelta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tERROR(\"aufs clone of %s container is not yet supported\",\n\t\t\torig->type);\n\t\t// Note, supporting this will require aufs_mount supporting\n\t\t// mounting of the underlay.  No big deal, just needs to be done.\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"aufs clone of %s container is not yet supported\"",
            "orig->type"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ndelta"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"aufs:%s:%s\"",
            "nsrc",
            "ndelta"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ndelta"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsrc"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"copying aufs delta\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsync_delta",
          "args": [
            "&rdata"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "rsync_delta_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrsync.c",
          "lines": "88-92",
          "snippet": "int rsync_delta_wrapper(void *data)\n{\n\tstruct rsync_data_char *arg = data;\n\treturn rsync_delta(arg);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <grp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <grp.h>\n\nint rsync_delta_wrapper(void *data)\n{\n\tstruct rsync_data_char *arg = data;\n\treturn rsync_delta(arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "rsync_delta_wrapper",
            "&rdata"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "ndelta"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "ndelta",
            "conf"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "ndelta"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "ndelta",
            "0755"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_new_path",
          "args": [
            "odelta",
            "oldname",
            "cname",
            "oldpath",
            "lxcpath"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dir_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "214-253",
          "snippet": "char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nchar *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nsrc",
            "':'"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "orig->src"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"aufs\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"aufs:%s:%s\"",
            "orig->src",
            "delta"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig->src"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "delta"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "delta"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "delta"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta+lastslashidx",
            "\"delta0\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "delta",
            "new->dest",
            "lastslashidx+1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "lastslashidx + 7"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lastslash"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "new->dest",
            "'/'"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"dir\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "new->dest"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"aufs is only for snapshot clones\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);\n\nint aufs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tif (!snap) {\n\t\tERROR(\"aufs is only for snapshot clones\");\n\t\treturn -22;\n\t}\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tnew->dest = dir_new_path(orig->dest, oldname, cname, oldpath, lxcpath);\n\tif (!new->dest)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (am_unpriv() && chown_mapped_root(new->dest, conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (strcmp(orig->type, \"dir\") == 0) {\n\t\tchar *delta, *lastslash;\n\t\tint ret, len, lastslashidx;\n\n\t\t// if we have /var/lib/lxc/c2/rootfs, then delta will be\n\t\t//            /var/lib/lxc/c2/delta0\n\t\tlastslash = strrchr(new->dest, '/');\n\t\tif (!lastslash)\n\t\t\treturn -22;\n\t\tif (strlen(lastslash) < 7)\n\t\t\treturn -22;\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - new->dest;\n\n\t\tdelta = malloc(lastslashidx + 7);\n\t\tif (!delta)\n\t\t\treturn -1;\n\t\tstrncpy(delta, new->dest, lastslashidx+1);\n\t\tstrcpy(delta+lastslashidx, \"delta0\");\n\t\tif ((ret = mkdir(delta, 0755)) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", delta);\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(delta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", delta);\n\n\t\t// the src will be 'aufs:lowerdir:upperdir'\n\t\tlen = strlen(delta) + strlen(orig->src) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(delta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"aufs:%s:%s\", orig->src, delta);\n\t\tfree(delta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else if (strcmp(orig->type, \"aufs\") == 0) {\n\t\t// What exactly do we want to do here?\n\t\t// I think we want to use the original lowerdir, with a\n\t\t// private delta which is originally rsynced from the\n\t\t// original delta\n\t\tchar *osrc, *odelta, *nsrc, *ndelta;\n\t\tint len, ret;\n\t\tif (!(osrc = strdup(orig->src)))\n\t\t\treturn -22;\n\t\tnsrc = strchr(osrc, ':') + 1;\n\t\tif (nsrc != osrc + 5 || (odelta = strchr(nsrc, ':')) == NULL) {\n\t\t\tfree(osrc);\n\t\t\treturn -22;\n\t\t}\n\t\t*odelta = '\\0';\n\t\todelta++;\n\t\tndelta = dir_new_path(odelta, oldname, cname, oldpath, lxcpath);\n\t\tif (!ndelta) {\n\t\t\tfree(osrc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif ((ret = mkdir(ndelta, 0755)) < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", ndelta);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(ndelta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", ndelta);\n\n\t\tstruct rsync_data_char rdata;\n\t\trdata.src = odelta;\n\t\trdata.dest = ndelta;\n\t\tif (am_unpriv())\n\t\t\tret = userns_exec_1(conf, rsync_delta_wrapper, &rdata);\n\t\telse\n\t\t\tret = rsync_delta(&rdata);\n\t\tif (ret) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\tERROR(\"copying aufs delta\");\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(nsrc) + strlen(ndelta) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"aufs:%s:%s\", nsrc, ndelta);\n\t\tfree(osrc);\n\t\tfree(ndelta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tERROR(\"aufs clone of %s container is not yet supported\",\n\t\t\torig->type);\n\t\t// Note, supporting this will require aufs_mount supporting\n\t\t// mounting of the underlay.  No big deal, just needs to be done.\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  }
]