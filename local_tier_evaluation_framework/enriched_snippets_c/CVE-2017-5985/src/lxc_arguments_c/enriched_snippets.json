[
  {
    "function_name": "lxc_arguments_str_to_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "254-272",
    "snippet": "int lxc_arguments_str_to_int(struct lxc_arguments *args, const char *str)\n{\n\tlong val;\n\tchar *endptr;\n\n\terrno = 0;\n\tval = strtol(str, &endptr, 10);\n\tif (errno) {\n\t\tlxc_error(args, \"invalid statefd '%s' : %m\", str);\n\t\treturn -1;\n\t}\n\n\tif (*endptr) {\n\t\tlxc_error(args, \"invalid digit for statefd '%s'\", str);\n\t\treturn -1;\n\t}\n\n\treturn (int)val;\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"invalid digit for statefd '%s'\"",
            "str"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"invalid statefd '%s' : %m\"",
            "str"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&endptr",
            "10"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_arguments_str_to_int(struct lxc_arguments *args, const char *str)\n{\n\tlong val;\n\tchar *endptr;\n\n\terrno = 0;\n\tval = strtol(str, &endptr, 10);\n\tif (errno) {\n\t\tlxc_error(args, \"invalid statefd '%s' : %m\", str);\n\t\treturn -1;\n\t}\n\n\tif (*endptr) {\n\t\tlxc_error(args, \"invalid digit for statefd '%s'\", str);\n\t\treturn -1;\n\t}\n\n\treturn (int)val;\n}"
  },
  {
    "function_name": "lxc_arguments_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "182-252",
    "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"could not parse command line\""
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->checker",
          "args": [
            "args"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->progname",
            "\"lxc-autostart\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_lxcpath_add",
          "args": [
            "args",
            "lxc_global_config_value(\"lxc.lxcpath\")"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_lxcpath_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "162-180",
          "snippet": "static int lxc_arguments_lxcpath_add(struct lxc_arguments *args,\n\t\t\t\t     const char *lxcpath)\n{\n\tif (args->lxcpath_additional != -1 &&\n\t    args->lxcpath_cnt > args->lxcpath_additional) {\n\t\tfprintf(stderr, \"This command only accepts %d -P,--lxcpath arguments\\n\",\n\t\t\targs->lxcpath_additional + 1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs->lxcpath = realloc(args->lxcpath, (args->lxcpath_cnt + 1) *\n\t\t\t\t sizeof(args->lxcpath[0]));\n\tif (args->lxcpath == NULL) {\n\t\tlxc_error(args, \"no memory\");\n\t\treturn -ENOMEM;\n\t}\n\targs->lxcpath[args->lxcpath_cnt++] = lxcpath;\n\treturn 0;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int lxc_arguments_lxcpath_add(struct lxc_arguments *args,\n\t\t\t\t     const char *lxcpath)\n{\n\tif (args->lxcpath_additional != -1 &&\n\t    args->lxcpath_cnt > args->lxcpath_additional) {\n\t\tfprintf(stderr, \"This command only accepts %d -P,--lxcpath arguments\\n\",\n\t\t\targs->lxcpath_additional + 1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs->lxcpath = realloc(args->lxcpath, (args->lxcpath_cnt + 1) *\n\t\t\t\t sizeof(args->lxcpath[0]));\n\tif (args->lxcpath == NULL) {\n\t\tlxc_error(args, \"no memory\");\n\t\treturn -ENOMEM;\n\t}\n\targs->lxcpath[args->lxcpath_cnt++] = lxcpath;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->parser",
          "args": [
            "args",
            "c",
            "optarg"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_help",
          "args": [
            "args",
            "0"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "137-160",
          "snippet": "static void print_help(const struct lxc_arguments *args, int code)\n{\n\tfprintf(stderr, \"\\\nUsage: %s %s\\\n\\n\\\nCommon options :\\n\\\n  -o, --logfile=FILE               Output log to FILE instead of stderr\\n\\\n  -l, --logpriority=LEVEL          Set log priority to LEVEL\\n\\\n  -q, --quiet                      Don't produce any output\\n\\\n  -P, --lxcpath=PATH               Use specified container path\\n\\\n  -?, --help                       Give this help list\\n\\\n      --usage                      Give a short usage message\\n\\\n      --version                    Print the version number\\n\\\n\\n\\\nMandatory or optional arguments to long options are also mandatory or optional\\n\\\nfor any corresponding short options.\\n\\\n\\n\\\nSee the %s man page for further information.\\n\\n\",\n\targs->progname, args->help, args->progname);\n\n\tif (args->helpfn)\n\t\targs->helpfn(args);\n\texit(code);\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_help(const struct lxc_arguments *args, int code)\n{\n\tfprintf(stderr, \"\\\nUsage: %s %s\\\n\\n\\\nCommon options :\\n\\\n  -o, --logfile=FILE               Output log to FILE instead of stderr\\n\\\n  -l, --logpriority=LEVEL          Set log priority to LEVEL\\n\\\n  -q, --quiet                      Don't produce any output\\n\\\n  -P, --lxcpath=PATH               Use specified container path\\n\\\n  -?, --help                       Give this help list\\n\\\n      --usage                      Give a short usage message\\n\\\n      --version                    Print the version number\\n\\\n\\n\\\nMandatory or optional arguments to long options are also mandatory or optional\\n\\\nfor any corresponding short options.\\n\\\n\\n\\\nSee the %s man page for further information.\\n\\n\",\n\targs->progname, args->help, args->progname);\n\n\tif (args->helpfn)\n\t\targs->helpfn(args);\n\texit(code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_version",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "print_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "132-135",
          "snippet": "static void print_version() {\n\tprintf(\"%s\\n\", LXC_VERSION);\n\texit(0);\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_version() {\n\tprintf(\"%s\\n\", LXC_VERSION);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "args->options",
            "args"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "88-130",
          "snippet": "static void print_usage(const struct option longopts[],\n\t\t\tconst struct lxc_arguments *a_args)\n\n{\n\tint i;\n\tconst struct option *opt;\n\n\tfprintf(stderr, \"Usage: %s \", a_args->progname);\n\n\tfor (opt = longopts, i = 1; opt->name; opt++, i++) {\n\t\tint j;\n\t\tchar *uppername = strdup(opt->name);\n\n\t\tif (!uppername)\n\t\t\texit(-ENOMEM);\n\n\t\tfor (j = 0; uppername[j]; j++)\n\t\t\tuppername[j] = toupper(uppername[j]);\n\n\t\tfprintf(stderr, \"[\");\n\n\t\tif (isprint(opt->val))\n\t\t\tfprintf(stderr, \"-%c|\", opt->val);\n\n\t\tfprintf(stderr, \"--%s\", opt->name);\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tfprintf(stderr, \"=%s\", uppername);\n\n\t\tif (opt->has_arg == optional_argument)\n\t\t\tfprintf(stderr, \"[=%s]\", uppername);\n\n\t\tfprintf(stderr, \"] \");\n\n\t\tif (!(i % 4))\n\t\t\tfprintf(stderr, \"\\n\\t\");\n\n\t\tfree(uppername);\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\texit(0);\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_usage(const struct option longopts[],\n\t\t\tconst struct lxc_arguments *a_args)\n\n{\n\tint i;\n\tconst struct option *opt;\n\n\tfprintf(stderr, \"Usage: %s \", a_args->progname);\n\n\tfor (opt = longopts, i = 1; opt->name; opt++, i++) {\n\t\tint j;\n\t\tchar *uppername = strdup(opt->name);\n\n\t\tif (!uppername)\n\t\t\texit(-ENOMEM);\n\n\t\tfor (j = 0; uppername[j]; j++)\n\t\t\tuppername[j] = toupper(uppername[j]);\n\n\t\tfprintf(stderr, \"[\");\n\n\t\tif (isprint(opt->val))\n\t\t\tfprintf(stderr, \"-%c|\", opt->val);\n\n\t\tfprintf(stderr, \"--%s\", opt->name);\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tfprintf(stderr, \"=%s\", uppername);\n\n\t\tif (opt->has_arg == optional_argument)\n\t\t\tfprintf(stderr, \"[=%s]\", uppername);\n\n\t\tfprintf(stderr, \"] \");\n\n\t\tif (!(i % 4))\n\t\t\tfprintf(stderr, \"\\n\\t\");\n\n\t\tfree(uppername);\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_trailing_slashes",
          "args": [
            "optarg"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "249-254",
          "snippet": "extern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "shortopts",
            "args->options",
            "&index"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"build_shortopts() failed : %s\"",
            "strerror(errno)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_shortopts",
          "args": [
            "args->options",
            "shortopts",
            "sizeof(shortopts)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "build_shortopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "39-85",
          "snippet": "static int build_shortopts(const struct option *a_options,\n\t\t\t   char *a_shortopts, size_t a_size)\n{\n\tconst struct option *opt;\n\tsize_t i = 0;\n\n\tif (!a_options || !a_shortopts || !a_size)\n\t\treturn -1;\n\n\tfor (opt = a_options; opt->name; opt++) {\n\n\t\tif (!isascii(opt->val))\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = opt->val;\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == no_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\t}\n\n\tif (i < a_size)\n\t\ta_shortopts[i] = '\\0';\n\telse\n\t\tgoto is2big;\n\n\treturn 0;\n\n      is2big:\n\terrno = E2BIG;\n\treturn -1;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int build_shortopts(const struct option *a_options,\n\t\t\t   char *a_shortopts, size_t a_size)\n{\n\tconst struct option *opt;\n\tsize_t i = 0;\n\n\tif (!a_options || !a_shortopts || !a_size)\n\t\treturn -1;\n\n\tfor (opt = a_options; opt->name; opt++) {\n\n\t\tif (!isascii(opt->val))\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = opt->val;\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == no_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\t}\n\n\tif (i < a_size)\n\t\ta_shortopts[i] = '\\0';\n\telse\n\t\tgoto is2big;\n\n\treturn 0;\n\n      is2big:\n\terrno = E2BIG;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_arguments_lxcpath_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "162-180",
    "snippet": "static int lxc_arguments_lxcpath_add(struct lxc_arguments *args,\n\t\t\t\t     const char *lxcpath)\n{\n\tif (args->lxcpath_additional != -1 &&\n\t    args->lxcpath_cnt > args->lxcpath_additional) {\n\t\tfprintf(stderr, \"This command only accepts %d -P,--lxcpath arguments\\n\",\n\t\t\targs->lxcpath_additional + 1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs->lxcpath = realloc(args->lxcpath, (args->lxcpath_cnt + 1) *\n\t\t\t\t sizeof(args->lxcpath[0]));\n\tif (args->lxcpath == NULL) {\n\t\tlxc_error(args, \"no memory\");\n\t\treturn -ENOMEM;\n\t}\n\targs->lxcpath[args->lxcpath_cnt++] = lxcpath;\n\treturn 0;\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"no memory\""
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "args->lxcpath",
            "(args->lxcpath_cnt + 1) *\n\t\t\t\t sizeof(args->lxcpath[0])"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This command only accepts %d -P,--lxcpath arguments\\n\"",
            "args->lxcpath_additional + 1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int lxc_arguments_lxcpath_add(struct lxc_arguments *args,\n\t\t\t\t     const char *lxcpath)\n{\n\tif (args->lxcpath_additional != -1 &&\n\t    args->lxcpath_cnt > args->lxcpath_additional) {\n\t\tfprintf(stderr, \"This command only accepts %d -P,--lxcpath arguments\\n\",\n\t\t\targs->lxcpath_additional + 1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs->lxcpath = realloc(args->lxcpath, (args->lxcpath_cnt + 1) *\n\t\t\t\t sizeof(args->lxcpath[0]));\n\tif (args->lxcpath == NULL) {\n\t\tlxc_error(args, \"no memory\");\n\t\treturn -ENOMEM;\n\t}\n\targs->lxcpath[args->lxcpath_cnt++] = lxcpath;\n\treturn 0;\n}"
  },
  {
    "function_name": "print_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "137-160",
    "snippet": "static void print_help(const struct lxc_arguments *args, int code)\n{\n\tfprintf(stderr, \"\\\nUsage: %s %s\\\n\\n\\\nCommon options :\\n\\\n  -o, --logfile=FILE               Output log to FILE instead of stderr\\n\\\n  -l, --logpriority=LEVEL          Set log priority to LEVEL\\n\\\n  -q, --quiet                      Don't produce any output\\n\\\n  -P, --lxcpath=PATH               Use specified container path\\n\\\n  -?, --help                       Give this help list\\n\\\n      --usage                      Give a short usage message\\n\\\n      --version                    Print the version number\\n\\\n\\n\\\nMandatory or optional arguments to long options are also mandatory or optional\\n\\\nfor any corresponding short options.\\n\\\n\\n\\\nSee the %s man page for further information.\\n\\n\",\n\targs->progname, args->help, args->progname);\n\n\tif (args->helpfn)\n\t\targs->helpfn(args);\n\texit(code);\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "code"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->helpfn",
          "args": [
            "args"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\\nUsage: %s %s\\\n\\n\\\nCommon options :\\n\\\n  -o, --logfile=FILE               Output log to FILE instead of stderr\\n\\\n  -l, --logpriority=LEVEL          Set log priority to LEVEL\\n\\\n  -q, --quiet                      Don't produce any output\\n\\\n  -P, --lxcpath=PATH               Use specified container path\\n\\\n  -?, --help                       Give this help list\\n\\\n      --usage                      Give a short usage message\\n\\\n      --version                    Print the version number\\n\\\n\\n\\\nMandatory or optional arguments to long options are also mandatory or optional\\n\\\nfor any corresponding short options.\\n\\\n\\n\\\nSee the %s man page for further information.\\n\\n\"",
            "args->progname",
            "args->help",
            "args->progname"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_help(const struct lxc_arguments *args, int code)\n{\n\tfprintf(stderr, \"\\\nUsage: %s %s\\\n\\n\\\nCommon options :\\n\\\n  -o, --logfile=FILE               Output log to FILE instead of stderr\\n\\\n  -l, --logpriority=LEVEL          Set log priority to LEVEL\\n\\\n  -q, --quiet                      Don't produce any output\\n\\\n  -P, --lxcpath=PATH               Use specified container path\\n\\\n  -?, --help                       Give this help list\\n\\\n      --usage                      Give a short usage message\\n\\\n      --version                    Print the version number\\n\\\n\\n\\\nMandatory or optional arguments to long options are also mandatory or optional\\n\\\nfor any corresponding short options.\\n\\\n\\n\\\nSee the %s man page for further information.\\n\\n\",\n\targs->progname, args->help, args->progname);\n\n\tif (args->helpfn)\n\t\targs->helpfn(args);\n\texit(code);\n}"
  },
  {
    "function_name": "print_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "132-135",
    "snippet": "static void print_version() {\n\tprintf(\"%s\\n\", LXC_VERSION);\n\texit(0);\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "LXC_VERSION"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_version() {\n\tprintf(\"%s\\n\", LXC_VERSION);\n\texit(0);\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "88-130",
    "snippet": "static void print_usage(const struct option longopts[],\n\t\t\tconst struct lxc_arguments *a_args)\n\n{\n\tint i;\n\tconst struct option *opt;\n\n\tfprintf(stderr, \"Usage: %s \", a_args->progname);\n\n\tfor (opt = longopts, i = 1; opt->name; opt++, i++) {\n\t\tint j;\n\t\tchar *uppername = strdup(opt->name);\n\n\t\tif (!uppername)\n\t\t\texit(-ENOMEM);\n\n\t\tfor (j = 0; uppername[j]; j++)\n\t\t\tuppername[j] = toupper(uppername[j]);\n\n\t\tfprintf(stderr, \"[\");\n\n\t\tif (isprint(opt->val))\n\t\t\tfprintf(stderr, \"-%c|\", opt->val);\n\n\t\tfprintf(stderr, \"--%s\", opt->name);\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tfprintf(stderr, \"=%s\", uppername);\n\n\t\tif (opt->has_arg == optional_argument)\n\t\t\tfprintf(stderr, \"[=%s]\", uppername);\n\n\t\tfprintf(stderr, \"] \");\n\n\t\tif (!(i % 4))\n\t\t\tfprintf(stderr, \"\\n\\t\");\n\n\t\tfree(uppername);\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\texit(0);\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uppername"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\\t\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"] \""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"[=%s]\"",
            "uppername"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"=%s\"",
            "uppername"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--%s\"",
            "opt->name"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-%c|\"",
            "opt->val"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "opt->val"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"[\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "uppername[j]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-ENOMEM"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "opt->name"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: %s \"",
            "a_args->progname"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void print_usage(const struct option longopts[],\n\t\t\tconst struct lxc_arguments *a_args)\n\n{\n\tint i;\n\tconst struct option *opt;\n\n\tfprintf(stderr, \"Usage: %s \", a_args->progname);\n\n\tfor (opt = longopts, i = 1; opt->name; opt++, i++) {\n\t\tint j;\n\t\tchar *uppername = strdup(opt->name);\n\n\t\tif (!uppername)\n\t\t\texit(-ENOMEM);\n\n\t\tfor (j = 0; uppername[j]; j++)\n\t\t\tuppername[j] = toupper(uppername[j]);\n\n\t\tfprintf(stderr, \"[\");\n\n\t\tif (isprint(opt->val))\n\t\t\tfprintf(stderr, \"-%c|\", opt->val);\n\n\t\tfprintf(stderr, \"--%s\", opt->name);\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tfprintf(stderr, \"=%s\", uppername);\n\n\t\tif (opt->has_arg == optional_argument)\n\t\t\tfprintf(stderr, \"[=%s]\", uppername);\n\n\t\tfprintf(stderr, \"] \");\n\n\t\tif (!(i % 4))\n\t\t\tfprintf(stderr, \"\\n\\t\");\n\n\t\tfree(uppername);\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\texit(0);\n}"
  },
  {
    "function_name": "build_shortopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
    "lines": "39-85",
    "snippet": "static int build_shortopts(const struct option *a_options,\n\t\t\t   char *a_shortopts, size_t a_size)\n{\n\tconst struct option *opt;\n\tsize_t i = 0;\n\n\tif (!a_options || !a_shortopts || !a_size)\n\t\treturn -1;\n\n\tfor (opt = a_options; opt->name; opt++) {\n\n\t\tif (!isascii(opt->val))\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = opt->val;\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == no_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\t}\n\n\tif (i < a_size)\n\t\ta_shortopts[i] = '\\0';\n\telse\n\t\tgoto is2big;\n\n\treturn 0;\n\n      is2big:\n\terrno = E2BIG;\n\treturn -1;\n}",
    "includes": [
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"arguments.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <ctype.h>\t\t/* for isprint() */",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "opt->val"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int build_shortopts(const struct option *a_options,\n\t\t\t   char *a_shortopts, size_t a_size)\n{\n\tconst struct option *opt;\n\tsize_t i = 0;\n\n\tif (!a_options || !a_shortopts || !a_size)\n\t\treturn -1;\n\n\tfor (opt = a_options; opt->name; opt++) {\n\n\t\tif (!isascii(opt->val))\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = opt->val;\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == no_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\n\t\tif (opt->has_arg == required_argument)\n\t\t\tcontinue;\n\n\t\tif (i < a_size)\n\t\t\ta_shortopts[i++] = ':';\n\t\telse\n\t\t\tgoto is2big;\n\t}\n\n\tif (i < a_size)\n\t\ta_shortopts[i] = '\\0';\n\telse\n\t\tgoto is2big;\n\n\treturn 0;\n\n      is2big:\n\terrno = E2BIG;\n\treturn -1;\n}"
  }
]