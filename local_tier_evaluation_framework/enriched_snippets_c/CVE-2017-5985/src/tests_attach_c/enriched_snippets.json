[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "392-408",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret;\n\n\ttest_lsm_detect();\n\tret = test_attach(NULL, TSTNAME, \"busybox\");\n\tif (ret < 0)\n\t\treturn EXIT_FAILURE;\n\n\tTSTOUT(\"\\n\");\n\tret = test_attach(LXCPATH \"/alternate-path-test\", TSTNAME, \"busybox\");\n\tif (ret < 0)\n\t\treturn EXIT_FAILURE;\n\n\tTSTOUT(\"All tests passed\\n\");\n\treturn EXIT_SUCCESS;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define TSTNAME    \"lxc-attach-test\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"All tests passed\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach",
          "args": [
            "LXCPATH \"/alternate-path-test\"",
            "TSTNAME",
            "\"busybox\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "349-390",
          "snippet": "static int test_attach(const char *lxcpath, const char *name, const char *template)\n{\n\tint ret = -1;\n\tstruct lxc_container *ct;\n\n\tTSTOUT(\"Testing attach with on lxcpath:%s\\n\", lxcpath ? lxcpath : \"<default>\");\n\tct = test_ct_create(lxcpath, NULL, name, template);\n\tif (!ct)\n\t\tgoto err1;\n\n\tret = test_attach_cmd(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach cmd test failed\");\n\t\tgoto err2;\n\t}\n\n\tret = test_attach_func(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach func test failed\");\n\t\tgoto err2;\n\t}\n\n\tif (lsm_enabled()) {\n\t\tret = test_attach_lsm_cmd(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm cmd test failed\");\n\t\t\tgoto err2;\n\t\t}\n\n\t\tret = test_attach_lsm_func(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm func test failed\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\tret = 0;\n\nerr2:\n\ttest_ct_destroy(ct);\nerr1:\n\treturn ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach(const char *lxcpath, const char *name, const char *template)\n{\n\tint ret = -1;\n\tstruct lxc_container *ct;\n\n\tTSTOUT(\"Testing attach with on lxcpath:%s\\n\", lxcpath ? lxcpath : \"<default>\");\n\tct = test_ct_create(lxcpath, NULL, name, template);\n\tif (!ct)\n\t\tgoto err1;\n\n\tret = test_attach_cmd(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach cmd test failed\");\n\t\tgoto err2;\n\t}\n\n\tret = test_attach_func(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach func test failed\");\n\t\tgoto err2;\n\t}\n\n\tif (lsm_enabled()) {\n\t\tret = test_attach_lsm_cmd(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm cmd test failed\");\n\t\t\tgoto err2;\n\t\t}\n\n\t\tret = test_attach_lsm_func(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm func test failed\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\tret = 0;\n\nerr2:\n\ttest_ct_destroy(ct);\nerr1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"\\n\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_lsm_detect",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "test_lsm_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "50-69",
          "snippet": "static void test_lsm_detect(void)\n{\n\tif (lsm_enabled()) {\n\t\tif (!strcmp(lsm_name(), \"SELinux\")) {\n\t\t\tlsm_config_key = \"lxc.se_context\";\n\t\t\tlsm_label      = \"unconfined_u:unconfined_r:lxc_t:s0-s0:c0.c1023\";\n\t\t}\n\t\telse if (!strcmp(lsm_name(), \"AppArmor\")) {\n\t\t\tlsm_config_key = \"lxc.aa_profile\";\n\t\t\tif (file_exists(\"/proc/self/ns/cgroup\"))\n\t\t\t\tlsm_label      = \"lxc-container-default-cgns\";\n\t\t\telse\n\t\t\t\tlsm_label      = \"lxc-container-default\";\n\t\t}\n\t\telse {\n\t\t\tTSTERR(\"unknown lsm %s enabled, add test code here\", lsm_name());\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *lsm_config_key = NULL;",
            "static const char *lsm_label = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic const char *lsm_config_key = NULL;\nstatic const char *lsm_label = NULL;\n\nstatic void test_lsm_detect(void)\n{\n\tif (lsm_enabled()) {\n\t\tif (!strcmp(lsm_name(), \"SELinux\")) {\n\t\t\tlsm_config_key = \"lxc.se_context\";\n\t\t\tlsm_label      = \"unconfined_u:unconfined_r:lxc_t:s0-s0:c0.c1023\";\n\t\t}\n\t\telse if (!strcmp(lsm_name(), \"AppArmor\")) {\n\t\t\tlsm_config_key = \"lxc.aa_profile\";\n\t\t\tif (file_exists(\"/proc/self/ns/cgroup\"))\n\t\t\t\tlsm_label      = \"lxc-container-default-cgns\";\n\t\t\telse\n\t\t\t\tlsm_label      = \"lxc-container-default\";\n\t\t}\n\t\telse {\n\t\t\tTSTERR(\"unknown lsm %s enabled, add test code here\", lsm_name());\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\n#define TSTNAME    \"lxc-attach-test\"\n\nint main(int argc, char *argv[])\n{\n\tint ret;\n\n\ttest_lsm_detect();\n\tret = test_attach(NULL, TSTNAME, \"busybox\");\n\tif (ret < 0)\n\t\treturn EXIT_FAILURE;\n\n\tTSTOUT(\"\\n\");\n\tret = test_attach(LXCPATH \"/alternate-path-test\", TSTNAME, \"busybox\");\n\tif (ret < 0)\n\t\treturn EXIT_FAILURE;\n\n\tTSTOUT(\"All tests passed\\n\");\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "function_name": "test_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "349-390",
    "snippet": "static int test_attach(const char *lxcpath, const char *name, const char *template)\n{\n\tint ret = -1;\n\tstruct lxc_container *ct;\n\n\tTSTOUT(\"Testing attach with on lxcpath:%s\\n\", lxcpath ? lxcpath : \"<default>\");\n\tct = test_ct_create(lxcpath, NULL, name, template);\n\tif (!ct)\n\t\tgoto err1;\n\n\tret = test_attach_cmd(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach cmd test failed\");\n\t\tgoto err2;\n\t}\n\n\tret = test_attach_func(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach func test failed\");\n\t\tgoto err2;\n\t}\n\n\tif (lsm_enabled()) {\n\t\tret = test_attach_lsm_cmd(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm cmd test failed\");\n\t\t\tgoto err2;\n\t\t}\n\n\t\tret = test_attach_lsm_func(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm func test failed\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\tret = 0;\n\nerr2:\n\ttest_ct_destroy(ct);\nerr1:\n\treturn ret;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ct_destroy",
          "args": [
            "ct"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "test_ct_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "288-293",
          "snippet": "static void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach lsm func test failed\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach_lsm_func",
          "args": [
            "ct"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach_lsm_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "186-186",
          "snippet": "static int  test_attach_lsm_func(struct lxc_container *ct) { return 0; }",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int  test_attach_lsm_func(struct lxc_container *ct) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach lsm cmd test failed\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach_lsm_cmd",
          "args": [
            "ct"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach_lsm_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "187-187",
          "snippet": "static int  test_attach_lsm_cmd(struct lxc_container *ct) { return 0; }",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int  test_attach_lsm_cmd(struct lxc_container *ct) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "lsm_enabled",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "49-49",
          "snippet": "static inline int         lsm_enabled(void) { return 0; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline int         lsm_enabled(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach func test failed\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach_func",
          "args": [
            "ct"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "196-245",
          "snippet": "static int test_attach_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid,nspid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with func...\\n\");\n\n\t/* XXX: We can't just use &nspid and have test_attach_func_func fill\n\t * it in because the function doesn't run in our process context but\n\t * in a fork()ed from us context. We read the result through a pipe.\n\t */\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, test_attach_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\n\t/* There is a small chance the pid is reused inside the NS, so we\n\t * just print it and don't actually do this check\n\t *\n\t * if (pid == nspid) TSTERR(...)\n\t */\n\tnspid = atoi(result);\n\tTSTOUT(\"Pid:%d in NS:%d\\n\", pid, nspid);\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid,nspid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with func...\\n\");\n\n\t/* XXX: We can't just use &nspid and have test_attach_func_func fill\n\t * it in because the function doesn't run in our process context but\n\t * in a fork()ed from us context. We read the result through a pipe.\n\t */\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, test_attach_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\n\t/* There is a small chance the pid is reused inside the NS, so we\n\t * just print it and don't actually do this check\n\t *\n\t * if (pid == nspid) TSTERR(...)\n\t */\n\tnspid = atoi(result);\n\tTSTOUT(\"Pid:%d in NS:%d\\n\", pid, nspid);\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach cmd test failed\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach_cmd",
          "args": [
            "ct"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "247-282",
          "snippet": "static int test_attach_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *argv[] = {\"cmp\", \"-s\", \"/sbin/init\", \"/bin/busybox\", NULL};\n\tlxc_attach_command_t command = {\"cmp\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with success command...\\n\");\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach success command got bad return %d\", ret);\n\t\treturn ret;\n\t}\n\n\tTSTOUT(\"Testing attach with failure command...\\n\");\n\targv[2] = \"/etc/fstab\";\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret == 0) {\n\t\tTSTERR(\"attach failure command got bad return %d\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *argv[] = {\"cmp\", \"-s\", \"/sbin/init\", \"/bin/busybox\", NULL};\n\tlxc_attach_command_t command = {\"cmp\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with success command...\\n\");\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach success command got bad return %d\", ret);\n\t\treturn ret;\n\t}\n\n\tTSTOUT(\"Testing attach with failure command...\\n\");\n\targv[2] = \"/etc/fstab\";\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret == 0) {\n\t\tTSTERR(\"attach failure command got bad return %d\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_ct_create",
          "args": [
            "lxcpath",
            "NULL",
            "name",
            "template"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "test_ct_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "302-346",
          "snippet": "static struct lxc_container *test_ct_create(const char *lxcpath,\n\t\t\t\tconst char *group, const char *name,\n\t\t\t\tconst char *template)\n{\n\tint ret;\n\tstruct lxc_container *ct = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((ct = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (ct->is_defined(ct)) {\n\t\tct->stop(ct);\n\t\tct->destroy(ct);\n\t\tct = lxc_container_new(name, lxcpath);\n\t}\n\tif (!ct->createl(ct, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\n\tif (lsm_enabled())\n\t\ttest_attach_lsm_set_config(ct);\n\n\tct->want_daemonize(ct, true);\n\tif (!ct->startl(ct, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out2;\n\t}\n\treturn ct;\n\nout2:\n\ttest_ct_destroy(ct);\n\tct = NULL;\nout1:\n\treturn ct;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic struct lxc_container *test_ct_create(const char *lxcpath,\n\t\t\t\tconst char *group, const char *name,\n\t\t\t\tconst char *template)\n{\n\tint ret;\n\tstruct lxc_container *ct = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((ct = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (ct->is_defined(ct)) {\n\t\tct->stop(ct);\n\t\tct->destroy(ct);\n\t\tct = lxc_container_new(name, lxcpath);\n\t}\n\tif (!ct->createl(ct, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\n\tif (lsm_enabled())\n\t\ttest_attach_lsm_set_config(ct);\n\n\tct->want_daemonize(ct, true);\n\tif (!ct->startl(ct, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out2;\n\t}\n\treturn ct;\n\nout2:\n\ttest_ct_destroy(ct);\n\tct = NULL;\nout1:\n\treturn ct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach with on lxcpath:%s\\n\"",
            "lxcpath ? lxcpath : \"<default>\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach(const char *lxcpath, const char *name, const char *template)\n{\n\tint ret = -1;\n\tstruct lxc_container *ct;\n\n\tTSTOUT(\"Testing attach with on lxcpath:%s\\n\", lxcpath ? lxcpath : \"<default>\");\n\tct = test_ct_create(lxcpath, NULL, name, template);\n\tif (!ct)\n\t\tgoto err1;\n\n\tret = test_attach_cmd(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach cmd test failed\");\n\t\tgoto err2;\n\t}\n\n\tret = test_attach_func(ct);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach func test failed\");\n\t\tgoto err2;\n\t}\n\n\tif (lsm_enabled()) {\n\t\tret = test_attach_lsm_cmd(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm cmd test failed\");\n\t\t\tgoto err2;\n\t\t}\n\n\t\tret = test_attach_lsm_func(ct);\n\t\tif (ret < 0) {\n\t\t\tTSTERR(\"attach lsm func test failed\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\tret = 0;\n\nerr2:\n\ttest_ct_destroy(ct);\nerr1:\n\treturn ret;\n}"
  },
  {
    "function_name": "test_ct_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "302-346",
    "snippet": "static struct lxc_container *test_ct_create(const char *lxcpath,\n\t\t\t\tconst char *group, const char *name,\n\t\t\t\tconst char *template)\n{\n\tint ret;\n\tstruct lxc_container *ct = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((ct = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (ct->is_defined(ct)) {\n\t\tct->stop(ct);\n\t\tct->destroy(ct);\n\t\tct = lxc_container_new(name, lxcpath);\n\t}\n\tif (!ct->createl(ct, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\n\tif (lsm_enabled())\n\t\ttest_attach_lsm_set_config(ct);\n\n\tct->want_daemonize(ct, true);\n\tif (!ct->startl(ct, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out2;\n\t}\n\treturn ct;\n\nout2:\n\ttest_ct_destroy(ct);\n\tct = NULL;\nout1:\n\treturn ct;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ct_destroy",
          "args": [
            "ct"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "test_ct_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "288-293",
          "snippet": "static void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"starting container %s\"",
            "name"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->startl",
          "args": [
            "ct",
            "0",
            "NULL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->want_daemonize",
          "args": [
            "ct",
            "true"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_attach_lsm_set_config",
          "args": [
            "ct"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "test_attach_lsm_set_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "185-185",
          "snippet": "static void test_attach_lsm_set_config(struct lxc_container *ct) {}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic void test_attach_lsm_set_config(struct lxc_container *ct) {}"
        }
      },
      {
        "call_info": {
          "callee": "lsm_enabled",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "49-49",
          "snippet": "static inline int         lsm_enabled(void) { return 0; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline int         lsm_enabled(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"creating container %s\"",
            "name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->createl",
          "args": [
            "ct",
            "template",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct->destroy",
          "args": [
            "ct"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->stop",
          "args": [
            "ct"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->is_defined",
          "args": [
            "ct"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"instantiating container %s\"",
            "name"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"failed to mkdir %s %s\"",
            "lxcpath",
            "strerror(errno)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "lxcpath",
            "0755"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic struct lxc_container *test_ct_create(const char *lxcpath,\n\t\t\t\tconst char *group, const char *name,\n\t\t\t\tconst char *template)\n{\n\tint ret;\n\tstruct lxc_container *ct = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((ct = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (ct->is_defined(ct)) {\n\t\tct->stop(ct);\n\t\tct->destroy(ct);\n\t\tct = lxc_container_new(name, lxcpath);\n\t}\n\tif (!ct->createl(ct, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\n\tif (lsm_enabled())\n\t\ttest_attach_lsm_set_config(ct);\n\n\tct->want_daemonize(ct, true);\n\tif (!ct->startl(ct, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out2;\n\t}\n\treturn ct;\n\nout2:\n\ttest_ct_destroy(ct);\n\tct = NULL;\nout1:\n\treturn ct;\n}"
  },
  {
    "function_name": "test_ct_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "288-293",
    "snippet": "static void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "ct"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ct->destroy",
          "args": [
            "ct"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->stop",
          "args": [
            "ct"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic void test_ct_destroy(struct lxc_container *ct)\n{\n\tct->stop(ct);\n\tct->destroy(ct);\n\tlxc_container_put(ct);\n}"
  },
  {
    "function_name": "test_attach_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "247-282",
    "snippet": "static int test_attach_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *argv[] = {\"cmp\", \"-s\", \"/sbin/init\", \"/bin/busybox\", NULL};\n\tlxc_attach_command_t command = {\"cmp\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with success command...\\n\");\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach success command got bad return %d\", ret);\n\t\treturn ret;\n\t}\n\n\tTSTOUT(\"Testing attach with failure command...\\n\");\n\targv[2] = \"/etc/fstab\";\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret == 0) {\n\t\tTSTERR(\"attach failure command got bad return %d\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failure command got bad return %d\"",
            "ret"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failed\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->attach",
          "args": [
            "ct",
            "lxc_attach_run_command",
            "&command",
            "&attach_options",
            "&pid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach with failure command...\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach success command got bad return %d\"",
            "ret"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failed\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->attach",
          "args": [
            "ct",
            "lxc_attach_run_command",
            "&command",
            "&attach_options",
            "&pid"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach with success command...\\n\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *argv[] = {\"cmp\", \"-s\", \"/sbin/init\", \"/bin/busybox\", NULL};\n\tlxc_attach_command_t command = {\"cmp\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with success command...\\n\");\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach success command got bad return %d\", ret);\n\t\treturn ret;\n\t}\n\n\tTSTOUT(\"Testing attach with failure command...\\n\");\n\targv[2] = \"/etc/fstab\";\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret == 0) {\n\t\tTSTERR(\"attach failure command got bad return %d\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "test_attach_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "196-245",
    "snippet": "static int test_attach_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid,nspid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with func...\\n\");\n\n\t/* XXX: We can't just use &nspid and have test_attach_func_func fill\n\t * it in because the function doesn't run in our process context but\n\t * in a fork()ed from us context. We read the result through a pipe.\n\t */\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, test_attach_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\n\t/* There is a small chance the pid is reused inside the NS, so we\n\t * just print it and don't actually do this check\n\t *\n\t * if (pid == nspid) TSTERR(...)\n\t */\n\tnspid = atoi(result);\n\tTSTOUT(\"Pid:%d in NS:%d\\n\", pid, nspid);\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[1]"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Pid:%d in NS:%d\\n\"",
            "pid",
            "nspid"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "result"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"read failed %d\"",
            "ret"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "result",
            "sizeof(result)-1"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failed\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->attach",
          "args": [
            "ct",
            "test_attach_func_func",
            "NULL",
            "&attach_options",
            "&pid"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"pipe failed %d\"",
            "ret"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach with func...\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid,nspid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach with func...\\n\");\n\n\t/* XXX: We can't just use &nspid and have test_attach_func_func fill\n\t * it in because the function doesn't run in our process context but\n\t * in a fork()ed from us context. We read the result through a pipe.\n\t */\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, test_attach_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\n\t/* There is a small chance the pid is reused inside the NS, so we\n\t * just print it and don't actually do this check\n\t *\n\t * if (pid == nspid) TSTERR(...)\n\t */\n\tnspid = atoi(result);\n\tTSTOUT(\"Pid:%d in NS:%d\\n\", pid, nspid);\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_attach_func_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "190-194",
    "snippet": "static int test_attach_func_func(void* payload)\n{\n\tTSTOUT(\"%d\", getpid());\n\treturn 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"%d\"",
            "getpid()"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_func_func(void* payload)\n{\n\tTSTOUT(\"%d\", getpid());\n\treturn 0;\n}"
  },
  {
    "function_name": "test_attach_lsm_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "187-187",
    "snippet": "static int  test_attach_lsm_cmd(struct lxc_container *ct) { return 0; }",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int  test_attach_lsm_cmd(struct lxc_container *ct) { return 0; }"
  },
  {
    "function_name": "test_attach_lsm_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "186-186",
    "snippet": "static int  test_attach_lsm_func(struct lxc_container *ct) { return 0; }",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int  test_attach_lsm_func(struct lxc_container *ct) { return 0; }"
  },
  {
    "function_name": "test_attach_lsm_set_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "185-185",
    "snippet": "static void test_attach_lsm_set_config(struct lxc_container *ct) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic void test_attach_lsm_set_config(struct lxc_container *ct) {}"
  },
  {
    "function_name": "test_attach_lsm_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "131-183",
    "snippet": "static int test_attach_lsm_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tchar *space;\n\tchar *argv[] = {\"cat\", \"/proc/self/attr/current\", NULL};\n\tlxc_attach_command_t command = {\"cat\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach lsm label with cmd...\\n\");\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\tspace = strchr(result, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(result, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\n\tret = -1;\n\tif (strcmp(lsm_label, result)) {\n\t\tTSTERR(\"LSM label mismatch expected:%s got:%s\", lsm_label, result);\n\t\tgoto err2;\n\t}\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *lsm_label = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[1]"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"LSM label mismatch expected:%s got:%s\"",
            "lsm_label",
            "result"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lsm_label",
            "result"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "result",
            "' '"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"read failed %d\"",
            "ret"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "result",
            "sizeof(result)-1"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failed\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->attach",
          "args": [
            "ct",
            "lxc_attach_run_command",
            "&command",
            "&attach_options",
            "&pid"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"pipe failed %d\"",
            "ret"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach lsm label with cmd...\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic const char *lsm_label = NULL;\n\nstatic int test_attach_lsm_cmd(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tchar *space;\n\tchar *argv[] = {\"cat\", \"/proc/self/attr/current\", NULL};\n\tlxc_attach_command_t command = {\"cat\", argv};\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach lsm label with cmd...\\n\");\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\n\tret = ct->attach(ct, lxc_attach_run_command, &command, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\tresult[ret] = '\\0';\n\tspace = strchr(result, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(result, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\n\tret = -1;\n\tif (strcmp(lsm_label, result)) {\n\t\tTSTERR(\"LSM label mismatch expected:%s got:%s\", lsm_label, result);\n\t\tgoto err2;\n\t}\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_attach_lsm_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "85-129",
    "snippet": "static int test_attach_lsm_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach lsm label with func...\\n\");\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = ct->attach(ct, test_attach_lsm_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\n\tresult[ret] = '\\0';\n\tif (strcmp(lsm_label, result)) {\n\t\tTSTERR(\"LSM label mismatch expected:%s got:%s\", lsm_label, result);\n\t\tret = -1;\n\t\tgoto err2;\n\t}\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *lsm_label = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[1]"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"LSM label mismatch expected:%s got:%s\"",
            "lsm_label",
            "result"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lsm_label",
            "result"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"read failed %d\"",
            "ret"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "result",
            "sizeof(result)-1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"attach failed\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->attach",
          "args": [
            "ct",
            "test_attach_lsm_func_func",
            "NULL",
            "&attach_options",
            "&pid"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"pipe failed %d\"",
            "ret"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"Testing attach lsm label with func...\\n\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic const char *lsm_label = NULL;\n\nstatic int test_attach_lsm_func(struct lxc_container *ct)\n{\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tTSTOUT(\"Testing attach lsm label with func...\\n\");\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tTSTERR(\"pipe failed %d\", ret);\n\t\treturn ret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = ct->attach(ct, test_attach_lsm_func_func, NULL, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tTSTERR(\"attach failed\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tTSTERR(\"read failed %d\", ret);\n\t\tgoto err2;\n\t}\n\n\tresult[ret] = '\\0';\n\tif (strcmp(lsm_label, result)) {\n\t\tTSTERR(\"LSM label mismatch expected:%s got:%s\", lsm_label, result);\n\t\tret = -1;\n\t\tgoto err2;\n\t}\n\tret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_attach_lsm_func_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "79-83",
    "snippet": "static int test_attach_lsm_func_func(void* payload)\n{\n\tTSTOUT(\"%s\", lsm_process_label_get(getpid()));\n\treturn 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TSTOUT",
          "args": [
            "\"%s\"",
            "lsm_process_label_get(getpid())"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_process_label_get",
          "args": [
            "getpid()"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_process_label_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "51-51",
          "snippet": "static inline char       *lsm_process_label_get(pid_t pid) { return NULL; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline char       *lsm_process_label_get(pid_t pid) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_lsm_func_func(void* payload)\n{\n\tTSTOUT(\"%s\", lsm_process_label_get(getpid()));\n\treturn 0;\n}"
  },
  {
    "function_name": "test_attach_lsm_set_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "72-77",
    "snippet": "static void test_attach_lsm_set_config(struct lxc_container *ct)\n{\n\tct->load_config(ct, NULL);\n\tct->set_config_item(ct, lsm_config_key, lsm_label);\n\tct->save_config(ct, NULL);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *lsm_config_key = NULL;",
      "static const char *lsm_label = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ct->save_config",
          "args": [
            "ct",
            "NULL"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->set_config_item",
          "args": [
            "ct",
            "lsm_config_key",
            "lsm_label"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct->load_config",
          "args": [
            "ct",
            "NULL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic const char *lsm_config_key = NULL;\nstatic const char *lsm_label = NULL;\n\nstatic void test_attach_lsm_set_config(struct lxc_container *ct)\n{\n\tct->load_config(ct, NULL);\n\tct->set_config_item(ct, lsm_config_key, lsm_label);\n\tct->save_config(ct, NULL);\n}"
  },
  {
    "function_name": "test_lsm_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "50-69",
    "snippet": "static void test_lsm_detect(void)\n{\n\tif (lsm_enabled()) {\n\t\tif (!strcmp(lsm_name(), \"SELinux\")) {\n\t\t\tlsm_config_key = \"lxc.se_context\";\n\t\t\tlsm_label      = \"unconfined_u:unconfined_r:lxc_t:s0-s0:c0.c1023\";\n\t\t}\n\t\telse if (!strcmp(lsm_name(), \"AppArmor\")) {\n\t\t\tlsm_config_key = \"lxc.aa_profile\";\n\t\t\tif (file_exists(\"/proc/self/ns/cgroup\"))\n\t\t\t\tlsm_label      = \"lxc-container-default-cgns\";\n\t\t\telse\n\t\t\t\tlsm_label      = \"lxc-container-default\";\n\t\t}\n\t\telse {\n\t\t\tTSTERR(\"unknown lsm %s enabled, add test code here\", lsm_name());\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *lsm_config_key = NULL;",
      "static const char *lsm_label = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"unknown lsm %s enabled, add test code here\"",
            "lsm_name()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_name",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "50-50",
          "snippet": "static inline const char *lsm_name(void) { return \"none\"; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline const char *lsm_name(void) { return \"none\"; }"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "\"/proc/self/ns/cgroup\""
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
          "lines": "43-48",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"lxc/lsm/lsm.h\"",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lsm_name()",
            "\"AppArmor\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lsm_name()",
            "\"SELinux\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_enabled",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "49-49",
          "snippet": "static inline int         lsm_enabled(void) { return 0; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline int         lsm_enabled(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic const char *lsm_config_key = NULL;\nstatic const char *lsm_label = NULL;\n\nstatic void test_lsm_detect(void)\n{\n\tif (lsm_enabled()) {\n\t\tif (!strcmp(lsm_name(), \"SELinux\")) {\n\t\t\tlsm_config_key = \"lxc.se_context\";\n\t\t\tlsm_label      = \"unconfined_u:unconfined_r:lxc_t:s0-s0:c0.c1023\";\n\t\t}\n\t\telse if (!strcmp(lsm_name(), \"AppArmor\")) {\n\t\t\tlsm_config_key = \"lxc.aa_profile\";\n\t\t\tif (file_exists(\"/proc/self/ns/cgroup\"))\n\t\t\t\tlsm_label      = \"lxc-container-default-cgns\";\n\t\t\telse\n\t\t\t\tlsm_label      = \"lxc-container-default\";\n\t\t}\n\t\telse {\n\t\t\tTSTERR(\"unknown lsm %s enabled, add test code here\", lsm_name());\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "file_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/attach.c",
    "lines": "43-48",
    "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"lxc/lsm/lsm.h\"",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "f",
            "&statbuf"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"lxc/lsm/lsm.h\"\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
  }
]