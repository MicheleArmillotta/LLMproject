[
  {
    "function_name": "lxc_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "642-739",
    "snippet": "int lxc_console(struct lxc_container *c, int ttynum,\n\t\tint stdinfd, int stdoutfd, int stderrfd,\n\t\tint escape)\n{\n\tint ret, ttyfd, masterfd;\n\tstruct lxc_epoll_descr descr;\n\tstruct termios oldtios;\n\tstruct lxc_tty_state *ts;\n\n\tif (!isatty(stdinfd)) {\n\t\tERROR(\"stdin is not a tty\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_setup_tios(stdinfd, &oldtios);\n\tif (ret) {\n\t\tERROR(\"failed to setup tios\");\n\t\treturn -1;\n\t}\n\n\tttyfd = lxc_cmd_console(c->name, &ttynum, &masterfd, c->config_path);\n\tif (ttyfd < 0) {\n\t\tret = ttyfd;\n\t\tgoto err1;\n\t}\n\n\tfprintf(stderr, \"\\n\"\n\t\t\t\"Connected to tty %1$d\\n\"\n\t\t\t\"Type <Ctrl+%2$c q> to exit the console, \"\n\t\t\t\"<Ctrl+%2$c Ctrl+%2$c> to enter Ctrl+%2$c itself\\n\",\n\t\t\tttynum, 'a' + escape - 1);\n\n\tret = setsid();\n\tif (ret)\n\t\tINFO(\"already group leader\");\n\n\tts = lxc_console_sigwinch_init(stdinfd, masterfd);\n\tif (!ts) {\n\t\tret = -1;\n\t\tgoto err2;\n\t}\n\tts->escape = escape;\n\tts->winch_proxy = c->name;\n\tts->winch_proxy_lxcpath = c->config_path;\n\n\tlxc_console_winsz(stdinfd, masterfd);\n\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err3;\n\t}\n\n\tif (ts->sigfd != -1) {\n\t\tret = lxc_mainloop_add_handler(&descr, ts->sigfd,\n\t\t\t\tlxc_console_cb_sigwinch_fd, ts);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to add handler for SIGWINCH fd\");\n\t\t\tgoto err4;\n\t\t}\n\t}\n\n\tret = lxc_mainloop_add_handler(&descr, ts->stdinfd,\n\t\t\t\t       lxc_console_cb_tty_stdin, ts);\n\tif (ret) {\n\t\tERROR(\"failed to add handler for stdinfd\");\n\t\tgoto err4;\n\t}\n\n\tret = lxc_mainloop_add_handler(&descr, ts->masterfd,\n\t\t\t\t       lxc_console_cb_tty_master, ts);\n\tif (ret) {\n\t\tERROR(\"failed to add handler for masterfd\");\n\t\tgoto err4;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err4;\n\t}\n\n\tret = 0;\n\nerr4:\n\tlxc_mainloop_close(&descr);\nerr3:\n\tif (ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr2:\n\tclose(masterfd);\n\tclose(ttyfd);\nerr1:\n\ttcsetattr(stdinfd, TCSAFLUSH, &oldtios);\n\n\treturn ret;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "stdinfd",
            "TCSAFLUSH",
            "&oldtios"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ttyfd"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_fini",
          "args": [
            "ts"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "148-156",
          "snippet": "void lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_close",
          "args": [
            "&descr"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "148-163",
          "snippet": "int lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"mainloop returned an error\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop",
          "args": [
            "&descr",
            "-1"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add handler for masterfd\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "&descr",
            "ts->masterfd",
            "lxc_console_cb_tty_master",
            "ts"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add handler for stdinfd\""
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add handler for SIGWINCH fd\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create mainloop\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_open",
          "args": [
            "&descr"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "132-146",
          "snippet": "int lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_console_winch",
          "args": [
            "ts->winch_proxy",
            "ts->winch_proxy_lxcpath"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_console_winch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "661-673",
          "snippet": "int lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_winsz",
          "args": [
            "stdinfd",
            "masterfd"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_winsz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "66-74",
          "snippet": "void lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_init",
          "args": [
            "stdinfd",
            "masterfd"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "110-146",
          "snippet": "struct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list lxc_ttys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\nstruct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"already group leader\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\"\n\t\t\t\"Connected to tty %1$d\\n\"\n\t\t\t\"Type <Ctrl+%2$c q> to exit the console, \"\n\t\t\t\"<Ctrl+%2$c Ctrl+%2$c> to enter Ctrl+%2$c itself\\n\"",
            "ttynum",
            "'a' + escape - 1"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_console",
          "args": [
            "c->name",
            "&ttynum",
            "&masterfd",
            "c->config_path"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "695-732",
          "snippet": "int lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup tios\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_setup_tios",
          "args": [
            "stdinfd",
            "&oldtios"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup_tios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "245-291",
          "snippet": "int lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"stdin is not a tty\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "stdinfd"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console(struct lxc_container *c, int ttynum,\n\t\tint stdinfd, int stdoutfd, int stderrfd,\n\t\tint escape)\n{\n\tint ret, ttyfd, masterfd;\n\tstruct lxc_epoll_descr descr;\n\tstruct termios oldtios;\n\tstruct lxc_tty_state *ts;\n\n\tif (!isatty(stdinfd)) {\n\t\tERROR(\"stdin is not a tty\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_setup_tios(stdinfd, &oldtios);\n\tif (ret) {\n\t\tERROR(\"failed to setup tios\");\n\t\treturn -1;\n\t}\n\n\tttyfd = lxc_cmd_console(c->name, &ttynum, &masterfd, c->config_path);\n\tif (ttyfd < 0) {\n\t\tret = ttyfd;\n\t\tgoto err1;\n\t}\n\n\tfprintf(stderr, \"\\n\"\n\t\t\t\"Connected to tty %1$d\\n\"\n\t\t\t\"Type <Ctrl+%2$c q> to exit the console, \"\n\t\t\t\"<Ctrl+%2$c Ctrl+%2$c> to enter Ctrl+%2$c itself\\n\",\n\t\t\tttynum, 'a' + escape - 1);\n\n\tret = setsid();\n\tif (ret)\n\t\tINFO(\"already group leader\");\n\n\tts = lxc_console_sigwinch_init(stdinfd, masterfd);\n\tif (!ts) {\n\t\tret = -1;\n\t\tgoto err2;\n\t}\n\tts->escape = escape;\n\tts->winch_proxy = c->name;\n\tts->winch_proxy_lxcpath = c->config_path;\n\n\tlxc_console_winsz(stdinfd, masterfd);\n\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err3;\n\t}\n\n\tif (ts->sigfd != -1) {\n\t\tret = lxc_mainloop_add_handler(&descr, ts->sigfd,\n\t\t\t\tlxc_console_cb_sigwinch_fd, ts);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to add handler for SIGWINCH fd\");\n\t\t\tgoto err4;\n\t\t}\n\t}\n\n\tret = lxc_mainloop_add_handler(&descr, ts->stdinfd,\n\t\t\t\t       lxc_console_cb_tty_stdin, ts);\n\tif (ret) {\n\t\tERROR(\"failed to add handler for stdinfd\");\n\t\tgoto err4;\n\t}\n\n\tret = lxc_mainloop_add_handler(&descr, ts->masterfd,\n\t\t\t\t       lxc_console_cb_tty_master, ts);\n\tif (ret) {\n\t\tERROR(\"failed to add handler for masterfd\");\n\t\tgoto err4;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err4;\n\t}\n\n\tret = 0;\n\nerr4:\n\tlxc_mainloop_close(&descr);\nerr3:\n\tif (ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr2:\n\tclose(masterfd);\n\tclose(ttyfd);\nerr1:\n\ttcsetattr(stdinfd, TCSAFLUSH, &oldtios);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_console_getfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "637-640",
    "snippet": "int lxc_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\treturn lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_console",
          "args": [
            "c->name",
            "ttynum",
            "masterfd",
            "c->config_path"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "695-732",
          "snippet": "int lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\treturn lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);\n}"
  },
  {
    "function_name": "lxc_console_cb_tty_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "612-635",
    "snippet": "int lxc_console_cb_tty_master(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct lxc_tty_state *ts = cbdata;\n\tchar buf[1024];\n\tint r, w;\n\n\tif (fd != ts->masterfd)\n\t\treturn 1;\n\n\tr = lxc_read_nointr(fd, buf, sizeof(buf));\n\tif (r <= 0)\n\t\treturn 1;\n\n\tw = lxc_write_nointr(ts->stdoutfd, buf, r);\n\tif (w <= 0) {\n\t\treturn 1;\n\t} else if (w != r) {\n\t\tSYSERROR(\"failed to write\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to write\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "ts->stdoutfd",
            "buf",
            "r"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_cb_tty_master(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct lxc_tty_state *ts = cbdata;\n\tchar buf[1024];\n\tint r, w;\n\n\tif (fd != ts->masterfd)\n\t\treturn 1;\n\n\tr = lxc_read_nointr(fd, buf, sizeof(buf));\n\tif (r <= 0)\n\t\treturn 1;\n\n\tw = lxc_write_nointr(ts->stdoutfd, buf, r);\n\tif (w <= 0) {\n\t\treturn 1;\n\t} else if (w != r) {\n\t\tSYSERROR(\"failed to write\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_cb_tty_stdin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "581-610",
    "snippet": "int lxc_console_cb_tty_stdin(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct lxc_tty_state *ts = cbdata;\n\tchar c;\n\n\tif (fd != ts->stdinfd)\n\t\treturn 1;\n\n\tif (lxc_read_nointr(ts->stdinfd, &c, 1) <= 0)\n\t\treturn 1;\n\n\tif (ts->escape != -1) {\n\t\t/* we want to exit the console with Ctrl+a q */\n\t\tif (c == ts->escape && !ts->saw_escape) {\n\t\t\tts->saw_escape = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'q' && ts->saw_escape)\n\t\t\treturn 1;\n\n\t\tts->saw_escape = 0;\n\t}\n\n\tif (lxc_write_nointr(ts->masterfd, &c, 1) <= 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "ts->masterfd",
            "&c",
            "1"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "ts->stdinfd",
            "&c",
            "1"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_cb_tty_stdin(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct lxc_tty_state *ts = cbdata;\n\tchar c;\n\n\tif (fd != ts->stdinfd)\n\t\treturn 1;\n\n\tif (lxc_read_nointr(ts->stdinfd, &c, 1) <= 0)\n\t\treturn 1;\n\n\tif (ts->escape != -1) {\n\t\t/* we want to exit the console with Ctrl+a q */\n\t\tif (c == ts->escape && !ts->saw_escape) {\n\t\t\tts->saw_escape = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'q' && ts->saw_escape)\n\t\t\treturn 1;\n\n\t\tts->saw_escape = 0;\n\t}\n\n\tif (lxc_write_nointr(ts->masterfd, &c, 1) <= 0)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_set_stdfds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "555-579",
    "snippet": "int lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to duplicate stderr.\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDERR_FILENO"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to duplicate stdout.\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to duplicate stdin.\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDIN_FILENO"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "500-553",
    "snippet": "int lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_delete",
          "args": [
            "console"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "480-498",
          "snippet": "void lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"using '%s' as console log\"",
            "console->log_path"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open '%s'\"",
            "console->log_path"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_unpriv",
          "args": [
            "open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "console->log_path",
            "O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND",
            "0600"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_peer_default",
          "args": [
            "console"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "418-478",
          "snippet": "static void lxc_console_peer_default(struct lxc_console *console)\n{\n\tstruct lxc_tty_state *ts;\n\tconst char *path = console->path;\n\n\t/* if no console was given, try current controlling terminal, there\n\t * won't be one if we were started as a daemon (-d)\n\t */\n\tif (!path && !access(\"/dev/tty\", F_OK)) {\n\t\tint fd;\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t\tpath = \"/dev/tty\";\n\t\t}\n\t}\n\n\tif (!path)\n\t\tgoto out;\n\n\tDEBUG(\"opening %s for console peer\", path);\n\tconsole->peer = lxc_unpriv(open(path, O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND, 0600));\n\tif (console->peer < 0)\n\t\tgoto out;\n\n\tDEBUG(\"using '%s' as console\", path);\n\n\tif (!isatty(console->peer))\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peer, console->master);\n\tconsole->tty_state = ts;\n\tif (!ts) {\n\t\tWARN(\"Unable to install SIGWINCH\");\n\t\tgoto err1;\n\t}\n\n\tlxc_console_winsz(console->peer, console->master);\n\n\tconsole->tios = malloc(sizeof(*console->tios));\n\tif (!console->tios) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tgoto err1;\n\t}\n\n\tif (lxc_setup_tios(console->peer, console->tios) < 0)\n\t\tgoto err2;\n\n\treturn;\n\nerr2:\n\tfree(console->tios);\n\tconsole->tios = NULL;\nerr1:\n\tclose(console->peer);\n\tconsole->peer = -1;\nout:\n\tDEBUG(\"no console peer\");\n\treturn;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_default(struct lxc_console *console)\n{\n\tstruct lxc_tty_state *ts;\n\tconst char *path = console->path;\n\n\t/* if no console was given, try current controlling terminal, there\n\t * won't be one if we were started as a daemon (-d)\n\t */\n\tif (!path && !access(\"/dev/tty\", F_OK)) {\n\t\tint fd;\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t\tpath = \"/dev/tty\";\n\t\t}\n\t}\n\n\tif (!path)\n\t\tgoto out;\n\n\tDEBUG(\"opening %s for console peer\", path);\n\tconsole->peer = lxc_unpriv(open(path, O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND, 0600));\n\tif (console->peer < 0)\n\t\tgoto out;\n\n\tDEBUG(\"using '%s' as console\", path);\n\n\tif (!isatty(console->peer))\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peer, console->master);\n\tconsole->tty_state = ts;\n\tif (!ts) {\n\t\tWARN(\"Unable to install SIGWINCH\");\n\t\tgoto err1;\n\t}\n\n\tlxc_console_winsz(console->peer, console->master);\n\n\tconsole->tios = malloc(sizeof(*console->tios));\n\tif (!console->tios) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tgoto err1;\n\t}\n\n\tif (lxc_setup_tios(console->peer, console->tios) < 0)\n\t\tgoto err2;\n\n\treturn;\n\nerr2:\n\tfree(console->tios);\n\tconsole->tios = NULL;\nerr1:\n\tclose(console->peer);\n\tconsole->peer = -1;\nout:\n\tDEBUG(\"no console peer\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set console slave to close-on-exec\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "console->slave",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set console master to close-on-exec\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "console->master",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to allocate a pty\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_unlock",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "process_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "320-323",
          "snippet": "void process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openpty",
          "args": [
            "&console->master",
            "&console->slave",
            "console->name",
            "NULL",
            "NULL"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "openpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/openpty.c",
          "lines": "37-76",
          "snippet": "int openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define _PATH_DEVPTMX \"/dev/ptmx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define _PATH_DEVPTMX \"/dev/ptmx\"\n\nint openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lock",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "console->path",
            "\"none\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no console for lxc-execute.\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_console_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "480-498",
    "snippet": "void lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "console->log_fd"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "console->tios"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "293-306",
          "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to set old terminal settings\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "console->peer",
            "TCSAFLUSH",
            "console->tios"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}"
  },
  {
    "function_name": "lxc_console_peer_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "418-478",
    "snippet": "static void lxc_console_peer_default(struct lxc_console *console)\n{\n\tstruct lxc_tty_state *ts;\n\tconst char *path = console->path;\n\n\t/* if no console was given, try current controlling terminal, there\n\t * won't be one if we were started as a daemon (-d)\n\t */\n\tif (!path && !access(\"/dev/tty\", F_OK)) {\n\t\tint fd;\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t\tpath = \"/dev/tty\";\n\t\t}\n\t}\n\n\tif (!path)\n\t\tgoto out;\n\n\tDEBUG(\"opening %s for console peer\", path);\n\tconsole->peer = lxc_unpriv(open(path, O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND, 0600));\n\tif (console->peer < 0)\n\t\tgoto out;\n\n\tDEBUG(\"using '%s' as console\", path);\n\n\tif (!isatty(console->peer))\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peer, console->master);\n\tconsole->tty_state = ts;\n\tif (!ts) {\n\t\tWARN(\"Unable to install SIGWINCH\");\n\t\tgoto err1;\n\t}\n\n\tlxc_console_winsz(console->peer, console->master);\n\n\tconsole->tios = malloc(sizeof(*console->tios));\n\tif (!console->tios) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tgoto err1;\n\t}\n\n\tif (lxc_setup_tios(console->peer, console->tios) < 0)\n\t\tgoto err2;\n\n\treturn;\n\nerr2:\n\tfree(console->tios);\n\tconsole->tios = NULL;\nerr1:\n\tclose(console->peer);\n\tconsole->peer = -1;\nout:\n\tDEBUG(\"no console peer\");\n\treturn;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"no console peer\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "console->peer"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "console->tios"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "293-306",
          "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_setup_tios",
          "args": [
            "console->peer",
            "console->tios"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup_tios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "245-291",
          "snippet": "int lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to allocate memory\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*console->tios)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_winsz",
          "args": [
            "console->peer",
            "console->master"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_winsz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "66-74",
          "snippet": "void lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Unable to install SIGWINCH\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_init",
          "args": [
            "console->peer",
            "console->master"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "110-146",
          "snippet": "struct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list lxc_ttys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\nstruct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "console->peer"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"using '%s' as console\"",
            "path"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_unpriv",
          "args": [
            "open(path, O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND, 0600)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND",
            "0600"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"opening %s for console peer\"",
            "path"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/tty\"",
            "O_RDWR"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/dev/tty\"",
            "F_OK"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_default(struct lxc_console *console)\n{\n\tstruct lxc_tty_state *ts;\n\tconst char *path = console->path;\n\n\t/* if no console was given, try current controlling terminal, there\n\t * won't be one if we were started as a daemon (-d)\n\t */\n\tif (!path && !access(\"/dev/tty\", F_OK)) {\n\t\tint fd;\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t\tpath = \"/dev/tty\";\n\t\t}\n\t}\n\n\tif (!path)\n\t\tgoto out;\n\n\tDEBUG(\"opening %s for console peer\", path);\n\tconsole->peer = lxc_unpriv(open(path, O_CLOEXEC | O_RDWR | O_CREAT |\n\t\t\t\t\tO_APPEND, 0600));\n\tif (console->peer < 0)\n\t\tgoto out;\n\n\tDEBUG(\"using '%s' as console\", path);\n\n\tif (!isatty(console->peer))\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peer, console->master);\n\tconsole->tty_state = ts;\n\tif (!ts) {\n\t\tWARN(\"Unable to install SIGWINCH\");\n\t\tgoto err1;\n\t}\n\n\tlxc_console_winsz(console->peer, console->master);\n\n\tconsole->tios = malloc(sizeof(*console->tios));\n\tif (!console->tios) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tgoto err1;\n\t}\n\n\tif (lxc_setup_tios(console->peer, console->tios) < 0)\n\t\tgoto err2;\n\n\treturn;\n\nerr2:\n\tfree(console->tios);\n\tconsole->tios = NULL;\nerr1:\n\tclose(console->peer);\n\tconsole->peer = -1;\nout:\n\tDEBUG(\"no console peer\");\n\treturn;\n}"
  },
  {
    "function_name": "lxc_console_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "401-416",
    "snippet": "void lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_peer_proxy_free",
          "args": [
            "console"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "293-306",
          "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "console->descr",
            "console->peerpty.slave"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}"
  },
  {
    "function_name": "lxc_console_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "359-399",
    "snippet": "int lxc_console_allocate(struct lxc_conf *conf, int sockfd, int *ttyreq)\n{\n\tint masterfd = -1, ttynum;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tif (*ttyreq == 0) {\n\t\tif (lxc_console_peer_proxy_alloc(console, sockfd) < 0)\n\t\t\tgoto out;\n\t\tmasterfd = console->peerpty.master;\n\t\tgoto out;\n\t}\n\n\tif (*ttyreq > 0) {\n\t\tif (*ttyreq > tty_info->nbtty)\n\t\t\tgoto out;\n\n\t\tif (tty_info->pty_info[*ttyreq - 1].busy)\n\t\t\tgoto out;\n\n\t\t/* the requested tty is available */\n\t\tttynum = *ttyreq;\n\t\tgoto out_tty;\n\t}\n\n\t/* search for next available tty, fixup index tty1 => [0] */\n\tfor (ttynum = 1; ttynum <= tty_info->nbtty && tty_info->pty_info[ttynum - 1].busy; ttynum++)\n\t\t;\n\n\t/* we didn't find any available slot for tty */\n\tif (ttynum > tty_info->nbtty)\n\t\tgoto out;\n\n\t*ttyreq = ttynum;\n\nout_tty:\n\ttty_info->pty_info[ttynum - 1].busy = sockfd;\n\tmasterfd = tty_info->pty_info[ttynum - 1].master;\nout:\n\treturn masterfd;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_peer_proxy_alloc",
          "args": [
            "console",
            "sockfd"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "308-357",
          "snippet": "static int lxc_console_peer_proxy_alloc(struct lxc_console *console, int sockfd)\n{\n\tstruct termios oldtermio;\n\tstruct lxc_tty_state *ts;\n\tint ret;\n\n\tif (console->master < 0) {\n\t\tERROR(\"console not set up\");\n\t\treturn -1;\n\t}\n\tif (console->peerpty.busy != -1 || console->peer != -1) {\n\t\tNOTICE(\"console already in use\");\n\t\treturn -1;\n\t}\n\tif (console->tty_state) {\n\t\tERROR(\"console already has tty_state\");\n\t\treturn -1;\n\t}\n\n\t/* this is the proxy pty that will be given to the client, and that\n\t * the real pty master will send to / recv from\n\t */\n\tprocess_lock();\n\tret = openpty(&console->peerpty.master, &console->peerpty.slave,\n\t\t    console->peerpty.name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to create proxy pty\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_setup_tios(console->peerpty.slave, &oldtermio) < 0)\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peerpty.master, console->master);\n\tif (!ts)\n\t\tgoto err1;\n\n\tconsole->tty_state = ts;\n\tconsole->peer = console->peerpty.slave;\n\tconsole->peerpty.busy = sockfd;\n\tlxc_console_mainloop_add_peer(console);\n\n\tDEBUG(\"%d %s peermaster:%d sockfd:%d\", getpid(), __FUNCTION__, console->peerpty.master, sockfd);\n\treturn 0;\n\nerr1:\n\tlxc_console_peer_proxy_free(console);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int lxc_console_peer_proxy_alloc(struct lxc_console *console, int sockfd)\n{\n\tstruct termios oldtermio;\n\tstruct lxc_tty_state *ts;\n\tint ret;\n\n\tif (console->master < 0) {\n\t\tERROR(\"console not set up\");\n\t\treturn -1;\n\t}\n\tif (console->peerpty.busy != -1 || console->peer != -1) {\n\t\tNOTICE(\"console already in use\");\n\t\treturn -1;\n\t}\n\tif (console->tty_state) {\n\t\tERROR(\"console already has tty_state\");\n\t\treturn -1;\n\t}\n\n\t/* this is the proxy pty that will be given to the client, and that\n\t * the real pty master will send to / recv from\n\t */\n\tprocess_lock();\n\tret = openpty(&console->peerpty.master, &console->peerpty.slave,\n\t\t    console->peerpty.name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to create proxy pty\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_setup_tios(console->peerpty.slave, &oldtermio) < 0)\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peerpty.master, console->master);\n\tif (!ts)\n\t\tgoto err1;\n\n\tconsole->tty_state = ts;\n\tconsole->peer = console->peerpty.slave;\n\tconsole->peerpty.busy = sockfd;\n\tlxc_console_mainloop_add_peer(console);\n\n\tDEBUG(\"%d %s peermaster:%d sockfd:%d\", getpid(), __FUNCTION__, console->peerpty.master, sockfd);\n\treturn 0;\n\nerr1:\n\tlxc_console_peer_proxy_free(console);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_allocate(struct lxc_conf *conf, int sockfd, int *ttyreq)\n{\n\tint masterfd = -1, ttynum;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tif (*ttyreq == 0) {\n\t\tif (lxc_console_peer_proxy_alloc(console, sockfd) < 0)\n\t\t\tgoto out;\n\t\tmasterfd = console->peerpty.master;\n\t\tgoto out;\n\t}\n\n\tif (*ttyreq > 0) {\n\t\tif (*ttyreq > tty_info->nbtty)\n\t\t\tgoto out;\n\n\t\tif (tty_info->pty_info[*ttyreq - 1].busy)\n\t\t\tgoto out;\n\n\t\t/* the requested tty is available */\n\t\tttynum = *ttyreq;\n\t\tgoto out_tty;\n\t}\n\n\t/* search for next available tty, fixup index tty1 => [0] */\n\tfor (ttynum = 1; ttynum <= tty_info->nbtty && tty_info->pty_info[ttynum - 1].busy; ttynum++)\n\t\t;\n\n\t/* we didn't find any available slot for tty */\n\tif (ttynum > tty_info->nbtty)\n\t\tgoto out;\n\n\t*ttyreq = ttynum;\n\nout_tty:\n\ttty_info->pty_info[ttynum - 1].busy = sockfd;\n\tmasterfd = tty_info->pty_info[ttynum - 1].master;\nout:\n\treturn masterfd;\n}"
  },
  {
    "function_name": "lxc_console_peer_proxy_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "308-357",
    "snippet": "static int lxc_console_peer_proxy_alloc(struct lxc_console *console, int sockfd)\n{\n\tstruct termios oldtermio;\n\tstruct lxc_tty_state *ts;\n\tint ret;\n\n\tif (console->master < 0) {\n\t\tERROR(\"console not set up\");\n\t\treturn -1;\n\t}\n\tif (console->peerpty.busy != -1 || console->peer != -1) {\n\t\tNOTICE(\"console already in use\");\n\t\treturn -1;\n\t}\n\tif (console->tty_state) {\n\t\tERROR(\"console already has tty_state\");\n\t\treturn -1;\n\t}\n\n\t/* this is the proxy pty that will be given to the client, and that\n\t * the real pty master will send to / recv from\n\t */\n\tprocess_lock();\n\tret = openpty(&console->peerpty.master, &console->peerpty.slave,\n\t\t    console->peerpty.name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to create proxy pty\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_setup_tios(console->peerpty.slave, &oldtermio) < 0)\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peerpty.master, console->master);\n\tif (!ts)\n\t\tgoto err1;\n\n\tconsole->tty_state = ts;\n\tconsole->peer = console->peerpty.slave;\n\tconsole->peerpty.busy = sockfd;\n\tlxc_console_mainloop_add_peer(console);\n\n\tDEBUG(\"%d %s peermaster:%d sockfd:%d\", getpid(), __FUNCTION__, console->peerpty.master, sockfd);\n\treturn 0;\n\nerr1:\n\tlxc_console_peer_proxy_free(console);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_peer_proxy_free",
          "args": [
            "console"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "293-306",
          "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"%d %s peermaster:%d sockfd:%d\"",
            "getpid()",
            "__FUNCTION__",
            "console->peerpty.master",
            "sockfd"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_mainloop_add_peer",
          "args": [
            "console"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_mainloop_add_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "190-207",
          "snippet": "static void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_init",
          "args": [
            "console->peerpty.master",
            "console->master"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "110-146",
          "snippet": "struct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list lxc_ttys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\nstruct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_setup_tios",
          "args": [
            "console->peerpty.slave",
            "&oldtermio"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup_tios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "245-291",
          "snippet": "int lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create proxy pty\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_unlock",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "process_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "320-323",
          "snippet": "void process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openpty",
          "args": [
            "&console->peerpty.master",
            "&console->peerpty.slave",
            "console->peerpty.name",
            "NULL",
            "NULL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "openpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/openpty.c",
          "lines": "37-76",
          "snippet": "int openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define _PATH_DEVPTMX \"/dev/ptmx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define _PATH_DEVPTMX \"/dev/ptmx\"\n\nint openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lock",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"console already has tty_state\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"console already in use\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"console not set up\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int lxc_console_peer_proxy_alloc(struct lxc_console *console, int sockfd)\n{\n\tstruct termios oldtermio;\n\tstruct lxc_tty_state *ts;\n\tint ret;\n\n\tif (console->master < 0) {\n\t\tERROR(\"console not set up\");\n\t\treturn -1;\n\t}\n\tif (console->peerpty.busy != -1 || console->peer != -1) {\n\t\tNOTICE(\"console already in use\");\n\t\treturn -1;\n\t}\n\tif (console->tty_state) {\n\t\tERROR(\"console already has tty_state\");\n\t\treturn -1;\n\t}\n\n\t/* this is the proxy pty that will be given to the client, and that\n\t * the real pty master will send to / recv from\n\t */\n\tprocess_lock();\n\tret = openpty(&console->peerpty.master, &console->peerpty.slave,\n\t\t    console->peerpty.name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to create proxy pty\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_setup_tios(console->peerpty.slave, &oldtermio) < 0)\n\t\tgoto err1;\n\n\tts = lxc_console_sigwinch_init(console->peerpty.master, console->master);\n\tif (!ts)\n\t\tgoto err1;\n\n\tconsole->tty_state = ts;\n\tconsole->peer = console->peerpty.slave;\n\tconsole->peerpty.busy = sockfd;\n\tlxc_console_mainloop_add_peer(console);\n\n\tDEBUG(\"%d %s peermaster:%d sockfd:%d\", getpid(), __FUNCTION__, console->peerpty.master, sockfd);\n\treturn 0;\n\nerr1:\n\tlxc_console_peer_proxy_free(console);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_console_peer_proxy_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "293-306",
    "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "console->peerpty.slave"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_fini",
          "args": [
            "console->tty_state"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "148-156",
          "snippet": "void lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
  },
  {
    "function_name": "lxc_setup_tios",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "245-291",
    "snippet": "int lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set new terminal settings\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fd",
            "TCSAFLUSH",
            "&newtios"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTTOU",
            "SIG_IGN"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "task_blocking_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1893-1925",
          "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get current terminal settings\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "fd",
            "oldtios"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"'%d' is not a tty\"",
            "fd"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fd"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_setup_tios(int fd, struct termios *oldtios)\n{\n\tstruct termios newtios;\n\n\tif (!isatty(fd)) {\n\t\tERROR(\"'%d' is not a tty\", fd);\n\t\treturn -1;\n\t}\n\n\t/* Get current termios */\n\tif (tcgetattr(fd, oldtios)) {\n\t\tSYSERROR(\"failed to get current terminal settings\");\n\t\treturn -1;\n\t}\n\n\t/* ensure we don't end up in an endless loop:\n\t * The kernel might fire SIGTTOU while an\n\t * ioctl() in tcsetattr() is executed. When the ioctl()\n\t * is resumed and retries, the signal handler interrupts it again.\n\t */\n\tsignal (SIGTTIN, SIG_IGN);\n\tsignal (SIGTTOU, SIG_IGN);\n\n\tnewtios = *oldtios;\n\n\t/* We use the same settings that ssh does. */\n\tnewtios.c_iflag |= IGNPAR;\n\tnewtios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\tnewtios.c_iflag &= ~IUCLC;\n#endif\n\tnewtios.c_lflag &= ~(TOSTOP | ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\tnewtios.c_lflag &= ~IEXTEN;\n#endif\n\tnewtios.c_oflag &= ~OPOST;\n\tnewtios.c_cc[VMIN] = 1;\n\tnewtios.c_cc[VTIME] = 0;\n\n\t/* Set new attributes. */\n\tif (tcsetattr(fd, TCSAFLUSH, &newtios)) {\n\t\tERROR(\"failed to set new terminal settings\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_mainloop_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "209-243",
    "snippet": "extern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_mainloop_add_peer",
          "args": [
            "console"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_mainloop_add_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "190-207",
          "snippet": "static void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add to mainloop console handler for '%d'\"",
            "console->master"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "descr",
            "console->master",
            "lxc_console_cb_con",
            "console"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no console\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no rootfs, no console.\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no console for lxc-execute.\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_mainloop_add_peer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "190-207",
    "snippet": "static void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to add to mainloop SIGWINCH handler for '%d'\"",
            "console->tty_state->sigfd"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "console->descr",
            "console->tty_state->sigfd",
            "lxc_console_cb_sigwinch_fd",
            "console->tty_state"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"console peer not added to mainloop\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_mainloop_add_peer(struct lxc_console *console)\n{\n\tif (console->peer >= 0) {\n\t\tif (lxc_mainloop_add_handler(console->descr, console->peer,\n\t\t\t\t\t     lxc_console_cb_con, console))\n\t\t\tWARN(\"console peer not added to mainloop\");\n\t}\n\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tif (lxc_mainloop_add_handler(console->descr,\n\t\t\t\t\t     console->tty_state->sigfd,\n\t\t\t\t\t     lxc_console_cb_sigwinch_fd,\n\t\t\t\t\t     console->tty_state)) {\n\t\t\tWARN(\"failed to add to mainloop SIGWINCH handler for '%d'\",\n\t\t\t     console->tty_state->sigfd);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "lxc_console_cb_con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "158-188",
    "snippet": "static int lxc_console_cb_con(int fd, uint32_t events, void *data,\n\t\t\t      struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_console *console = (struct lxc_console *)data;\n\tchar buf[1024];\n\tint r, w;\n\n\tw = r = lxc_read_nointr(fd, buf, sizeof(buf));\n\tif (r <= 0) {\n\t\tINFO(\"console client on fd %d has exited\", fd);\n\t\tlxc_mainloop_del_handler(descr, fd);\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\n\tif (fd == console->peer)\n\t\tw = lxc_write_nointr(console->master, buf, r);\n\n\tif (fd == console->master) {\n\t\tif (console->log_fd >= 0)\n\t\t\tw = lxc_write_nointr(console->log_fd, buf, r);\n\n\t\tif (console->peer >= 0)\n\t\t\tw = lxc_write_nointr(console->peer, buf, r);\n\t}\n\n\tif (w != r)\n\t\tWARN(\"console short write r:%d w:%d\", r, w);\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"console short write r:%d w:%d\"",
            "r",
            "w"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "console->peer",
            "buf",
            "r"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "descr",
            "fd"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"console client on fd %d has exited\"",
            "fd"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int lxc_console_cb_con(int fd, uint32_t events, void *data,\n\t\t\t      struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_console *console = (struct lxc_console *)data;\n\tchar buf[1024];\n\tint r, w;\n\n\tw = r = lxc_read_nointr(fd, buf, sizeof(buf));\n\tif (r <= 0) {\n\t\tINFO(\"console client on fd %d has exited\", fd);\n\t\tlxc_mainloop_del_handler(descr, fd);\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\n\tif (fd == console->peer)\n\t\tw = lxc_write_nointr(console->master, buf, r);\n\n\tif (fd == console->master) {\n\t\tif (console->log_fd >= 0)\n\t\t\tw = lxc_write_nointr(console->log_fd, buf, r);\n\n\t\tif (console->peer >= 0)\n\t\t\tw = lxc_write_nointr(console->peer, buf, r);\n\t}\n\n\tif (w != r)\n\t\tWARN(\"console short write r:%d w:%d\", r, w);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_sigwinch_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "148-156",
    "snippet": "void lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ts"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_peer_proxy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "293-306",
          "snippet": "static void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_peer_proxy_free(struct lxc_console *console)\n{\n\tif (console->tty_state && console->tty_state->sigfd != -1) {\n\t\tlxc_console_sigwinch_fini(console->tty_state);\n\t\tconsole->tty_state = NULL;\n\t}\n\tclose(console->peerpty.master);\n\tclose(console->peerpty.slave);\n\tconsole->peerpty.master = -1;\n\tconsole->peerpty.slave = -1;\n\tconsole->peerpty.busy = -1;\n\tconsole->peerpty.name[0] = '\\0';\n\tconsole->peer = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&ts->oldmask",
            "NULL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "&ts->node"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ts->sigfd"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}"
  },
  {
    "function_name": "lxc_console_sigwinch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "110-146",
    "snippet": "struct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list lxc_ttys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"%d got SIGWINCH fd %d\"",
            "getpid()",
            "ts->sigfd"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&ts->oldmask",
            "NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get signalfd.\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd",
          "args": [
            "-1",
            "&mask",
            "0"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "155-163",
          "snippet": "static inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to block SIGWINCH.\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "&ts->oldmask"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "SIGWINCH"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "&lxc_ttys",
            "&ts->node"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_add_elem",
          "args": [
            "&ts->node",
            "ts"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "76-79",
          "snippet": "static inline void lxc_list_add_elem(struct lxc_list *list, void *elem)\n{\n\tlist->elem = elem;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_elem(struct lxc_list *list, void *elem)\n{\n\tlist->elem = elem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ts",
            "0",
            "sizeof(*ts)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*ts)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\nstruct lxc_tty_state *lxc_console_sigwinch_init(int srcfd, int dstfd)\n{\n\tsigset_t mask;\n\tstruct lxc_tty_state *ts;\n\n\tts = malloc(sizeof(*ts));\n\tif (!ts)\n\t\treturn NULL;\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->stdinfd = srcfd;\n\tts->masterfd = dstfd;\n\tts->sigfd = -1;\n\n\t/* add tty to list to be scanned at SIGWINCH time */\n\tlxc_list_add_elem(&ts->node, ts);\n\tlxc_list_add_tail(&lxc_ttys, &ts->node);\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGWINCH);\n\tif (sigprocmask(SIG_BLOCK, &mask, &ts->oldmask)) {\n\t\tSYSERROR(\"failed to block SIGWINCH.\");\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tts->sigfd = signalfd(-1, &mask, 0);\n\tif (ts->sigfd < 0) {\n\t\tSYSERROR(\"failed to get signalfd.\");\n\t\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\t\tts->sigfd = -1;\n\t\treturn ts;\n\t}\n\n\tDEBUG(\"%d got SIGWINCH fd %d\", getpid(), ts->sigfd);\n\treturn ts;\n}"
  },
  {
    "function_name": "lxc_console_cb_sigwinch_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "94-108",
    "snippet": "int lxc_console_cb_sigwinch_fd(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct signalfd_siginfo siginfo;\n\tstruct lxc_tty_state *ts = cbdata;\n\n\tssize_t ret = read(fd, &siginfo, sizeof(siginfo));\n\tif (ret < 0 || (size_t)ret < sizeof(siginfo)) {\n\t\tERROR(\"failed to read signal info\");\n\t\treturn -1;\n\t}\n\n\tlxc_console_winch(ts);\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_winch",
          "args": [
            "ts"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_winch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "76-81",
          "snippet": "static void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to read signal info\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&siginfo",
            "sizeof(siginfo)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_cb_sigwinch_fd(int fd, uint32_t events, void *cbdata,\n\t\tstruct lxc_epoll_descr *descr)\n{\n\tstruct signalfd_siginfo siginfo;\n\tstruct lxc_tty_state *ts = cbdata;\n\n\tssize_t ret = read(fd, &siginfo, sizeof(siginfo));\n\tif (ret < 0 || (size_t)ret < sizeof(siginfo)) {\n\t\tERROR(\"failed to read signal info\");\n\t\treturn -1;\n\t}\n\n\tlxc_console_winch(ts);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_console_sigwinch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "83-92",
    "snippet": "void lxc_console_sigwinch(int sig)\n{\n\tstruct lxc_list *it;\n\tstruct lxc_tty_state *ts;\n\n\tlxc_list_for_each(it, &lxc_ttys) {\n\t\tts = it->elem;\n\t\tlxc_console_winch(ts);\n\t}\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list lxc_ttys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_winch",
          "args": [
            "ts"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_winch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "76-81",
          "snippet": "static void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&lxc_ttys"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\nvoid lxc_console_sigwinch(int sig)\n{\n\tstruct lxc_list *it;\n\tstruct lxc_tty_state *ts;\n\n\tlxc_list_for_each(it, &lxc_ttys) {\n\t\tts = it->elem;\n\t\tlxc_console_winch(ts);\n\t}\n}"
  },
  {
    "function_name": "lxc_console_winch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "76-81",
    "snippet": "static void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_console_winch",
          "args": [
            "ts->winch_proxy",
            "ts->winch_proxy_lxcpath"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_console_winch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "661-673",
          "snippet": "int lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_winsz",
          "args": [
            "ts->stdinfd",
            "ts->masterfd"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_winsz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "66-74",
          "snippet": "void lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_console_winch(struct lxc_tty_state *ts)\n{\n\tlxc_console_winsz(ts->stdinfd, ts->masterfd);\n\tif (ts->winch_proxy)\n\t\tlxc_cmd_console_winch(ts->winch_proxy, ts->winch_proxy_lxcpath);\n}"
  },
  {
    "function_name": "lxc_console_winsz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "66-74",
    "snippet": "void lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "dstfd",
            "TIOCSWINSZ",
            "&wsz"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"set winsz dstfd:%d cols:%d rows:%d\"",
            "dstfd",
            "wsz.ws_col",
            "wsz.ws_row"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "srcfd",
            "TIOCGWINSZ",
            "&wsz"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "srcfd"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_winsz(int srcfd, int dstfd)\n{\n\tstruct winsize wsz;\n\tif (isatty(srcfd) && ioctl(srcfd, TIOCGWINSZ, &wsz) == 0) {\n\t\tDEBUG(\"set winsz dstfd:%d cols:%d rows:%d\", dstfd,\n\t\t      wsz.ws_col, wsz.ws_row);\n\t\tioctl(dstfd, TIOCSWINSZ, &wsz);\n\t}\n}"
  },
  {
    "function_name": "lxc_console_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
    "lines": "60-64",
    "snippet": "__attribute__((constructor))\nvoid lxc_console_init(void)\n{\n\tlxc_list_init(&lxc_ttys);\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"start.h\" \t/* for struct lxc_handler */",
      "#include \"mainloop.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"caps.h\"",
      "#include \"af_unix.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list lxc_ttys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "&lxc_ttys"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_list lxc_ttys;\n\n__attribute__((constructor))\nvoid lxc_console_init(void)\n{\n\tlxc_list_init(&lxc_ttys);\n}"
  }
]